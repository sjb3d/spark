//! Generated from vk.xml version 1.4.326

#![allow(clippy::wrong_self_convention, clippy::unnecessary_cast)]

use super::vk;
use std::{
    ffi::CStr,
    marker::PhantomData,
    ops::Deref,
    os::raw::{c_char, c_int, c_void},
    ptr,
};

pub trait Builder<'a> {
    type Type;
    fn builder() -> Self::Type;
}

unsafe fn insert_next(head: *mut vk::BaseOutStructure, other: *mut vk::BaseOutStructure) {
    assert!((*other).p_next.is_null());
    (*other).p_next = (*head).p_next;
    (*head).p_next = other as *mut _;
}

#[repr(transparent)]
#[derive(Default)]
pub struct Offset2DBuilder {
    inner: vk::Offset2D,
}
impl Builder<'_> for vk::Offset2D {
    type Type = Offset2DBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl Offset2DBuilder {
    pub fn get_mut(&mut self) -> &mut vk::Offset2D {
        &mut self.inner
    }
    pub fn x(mut self, x: i32) -> Self {
        self.inner.x = x;
        self
    }
    pub fn y(mut self, y: i32) -> Self {
        self.inner.y = y;
        self
    }
}
impl Deref for Offset2DBuilder {
    type Target = vk::Offset2D;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct Offset3DBuilder {
    inner: vk::Offset3D,
}
impl Builder<'_> for vk::Offset3D {
    type Type = Offset3DBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl Offset3DBuilder {
    pub fn get_mut(&mut self) -> &mut vk::Offset3D {
        &mut self.inner
    }
    pub fn x(mut self, x: i32) -> Self {
        self.inner.x = x;
        self
    }
    pub fn y(mut self, y: i32) -> Self {
        self.inner.y = y;
        self
    }
    pub fn z(mut self, z: i32) -> Self {
        self.inner.z = z;
        self
    }
}
impl Deref for Offset3DBuilder {
    type Target = vk::Offset3D;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct Extent2DBuilder {
    inner: vk::Extent2D,
}
impl Builder<'_> for vk::Extent2D {
    type Type = Extent2DBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl Extent2DBuilder {
    pub fn get_mut(&mut self) -> &mut vk::Extent2D {
        &mut self.inner
    }
    pub fn width(mut self, width: u32) -> Self {
        self.inner.width = width;
        self
    }
    pub fn height(mut self, height: u32) -> Self {
        self.inner.height = height;
        self
    }
}
impl Deref for Extent2DBuilder {
    type Target = vk::Extent2D;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct Extent3DBuilder {
    inner: vk::Extent3D,
}
impl Builder<'_> for vk::Extent3D {
    type Type = Extent3DBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl Extent3DBuilder {
    pub fn get_mut(&mut self) -> &mut vk::Extent3D {
        &mut self.inner
    }
    pub fn width(mut self, width: u32) -> Self {
        self.inner.width = width;
        self
    }
    pub fn height(mut self, height: u32) -> Self {
        self.inner.height = height;
        self
    }
    pub fn depth(mut self, depth: u32) -> Self {
        self.inner.depth = depth;
        self
    }
}
impl Deref for Extent3DBuilder {
    type Target = vk::Extent3D;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ViewportBuilder {
    inner: vk::Viewport,
}
impl Builder<'_> for vk::Viewport {
    type Type = ViewportBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ViewportBuilder {
    pub fn get_mut(&mut self) -> &mut vk::Viewport {
        &mut self.inner
    }
    pub fn x(mut self, x: f32) -> Self {
        self.inner.x = x;
        self
    }
    pub fn y(mut self, y: f32) -> Self {
        self.inner.y = y;
        self
    }
    pub fn width(mut self, width: f32) -> Self {
        self.inner.width = width;
        self
    }
    pub fn height(mut self, height: f32) -> Self {
        self.inner.height = height;
        self
    }
    pub fn min_depth(mut self, min_depth: f32) -> Self {
        self.inner.min_depth = min_depth;
        self
    }
    pub fn max_depth(mut self, max_depth: f32) -> Self {
        self.inner.max_depth = max_depth;
        self
    }
}
impl Deref for ViewportBuilder {
    type Target = vk::Viewport;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct Rect2DBuilder {
    inner: vk::Rect2D,
}
impl Builder<'_> for vk::Rect2D {
    type Type = Rect2DBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl Rect2DBuilder {
    pub fn get_mut(&mut self) -> &mut vk::Rect2D {
        &mut self.inner
    }
    pub fn offset(mut self, offset: vk::Offset2D) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn extent(mut self, extent: vk::Extent2D) -> Self {
        self.inner.extent = extent;
        self
    }
}
impl Deref for Rect2DBuilder {
    type Target = vk::Rect2D;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ClearRectBuilder {
    inner: vk::ClearRect,
}
impl Builder<'_> for vk::ClearRect {
    type Type = ClearRectBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClearRectBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClearRect {
        &mut self.inner
    }
    pub fn rect(mut self, rect: vk::Rect2D) -> Self {
        self.inner.rect = rect;
        self
    }
    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
        self.inner.base_array_layer = base_array_layer;
        self
    }
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.inner.layer_count = layer_count;
        self
    }
}
impl Deref for ClearRectBuilder {
    type Target = vk::ClearRect;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ComponentMappingBuilder {
    inner: vk::ComponentMapping,
}
impl Builder<'_> for vk::ComponentMapping {
    type Type = ComponentMappingBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ComponentMappingBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ComponentMapping {
        &mut self.inner
    }
    pub fn r(mut self, r: vk::ComponentSwizzle) -> Self {
        self.inner.r = r;
        self
    }
    pub fn g(mut self, g: vk::ComponentSwizzle) -> Self {
        self.inner.g = g;
        self
    }
    pub fn b(mut self, b: vk::ComponentSwizzle) -> Self {
        self.inner.b = b;
        self
    }
    pub fn a(mut self, a: vk::ComponentSwizzle) -> Self {
        self.inner.a = a;
        self
    }
}
impl Deref for ComponentMappingBuilder {
    type Target = vk::ComponentMapping;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ApplicationInfoBuilder<'a> {
    inner: vk::ApplicationInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ApplicationInfo {
    type Type = ApplicationInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ApplicationInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ApplicationInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_application_name(mut self, p_application_name: Option<&'a CStr>) -> Self {
        self.inner.p_application_name = p_application_name.map_or(ptr::null(), |r| r.as_ptr());
        self
    }
    pub fn application_version(mut self, application_version: u32) -> Self {
        self.inner.application_version = application_version;
        self
    }
    pub fn p_engine_name(mut self, p_engine_name: Option<&'a CStr>) -> Self {
        self.inner.p_engine_name = p_engine_name.map_or(ptr::null(), |r| r.as_ptr());
        self
    }
    pub fn engine_version(mut self, engine_version: u32) -> Self {
        self.inner.engine_version = engine_version;
        self
    }
    pub fn api_version(mut self, api_version: vk::Version) -> Self {
        self.inner.api_version = api_version;
        self
    }
}
impl<'a> Deref for ApplicationInfoBuilder<'a> {
    type Target = vk::ApplicationInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AllocationCallbacksBuilder<'a> {
    inner: vk::AllocationCallbacks,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AllocationCallbacks {
    type Type = AllocationCallbacksBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> AllocationCallbacksBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::AllocationCallbacks {
        &mut self.inner
    }
    pub fn p_user_data(mut self, p_user_data: *mut c_void) -> Self {
        self.inner.p_user_data = p_user_data;
        self
    }
    pub fn pfn_allocation(mut self, pfn_allocation: vk::FnAllocationFunction) -> Self {
        self.inner.pfn_allocation = Some(pfn_allocation);
        self
    }
    pub fn pfn_reallocation(mut self, pfn_reallocation: vk::FnReallocationFunction) -> Self {
        self.inner.pfn_reallocation = Some(pfn_reallocation);
        self
    }
    pub fn pfn_free(mut self, pfn_free: vk::FnFreeFunction) -> Self {
        self.inner.pfn_free = Some(pfn_free);
        self
    }
    pub fn pfn_internal_allocation(
        mut self,
        pfn_internal_allocation: Option<vk::FnInternalAllocationNotification>,
    ) -> Self {
        self.inner.pfn_internal_allocation = pfn_internal_allocation;
        self
    }
    pub fn pfn_internal_free(mut self, pfn_internal_free: Option<vk::FnInternalFreeNotification>) -> Self {
        self.inner.pfn_internal_free = pfn_internal_free;
        self
    }
}
impl<'a> Deref for AllocationCallbacksBuilder<'a> {
    type Target = vk::AllocationCallbacks;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceQueueCreateInfoBuilder<'a> {
    inner: vk::DeviceQueueCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DeviceQueueCreateInfo {
    type Type = DeviceQueueCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DeviceQueueCreateInfoNext {}
impl<'a> DeviceQueueCreateInfoBuilder<'a> {
    pub fn insert_next<T: DeviceQueueCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DeviceQueueCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DeviceQueueCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.inner.queue_family_index = queue_family_index;
        self
    }
    pub fn p_queue_priorities(mut self, p_queue_priorities: &'a [f32]) -> Self {
        self.inner.queue_count = p_queue_priorities.len() as u32;
        self.inner.p_queue_priorities = p_queue_priorities.as_ptr();
        self
    }
}
impl<'a> Deref for DeviceQueueCreateInfoBuilder<'a> {
    type Target = vk::DeviceQueueCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceCreateInfoBuilder<'a> {
    inner: vk::DeviceCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DeviceCreateInfo {
    type Type = DeviceCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DeviceCreateInfoNext {}
impl<'a> DeviceCreateInfoBuilder<'a> {
    pub fn insert_next<T: DeviceCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DeviceCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DeviceCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_queue_create_infos(mut self, p_queue_create_infos: &'a [vk::DeviceQueueCreateInfo]) -> Self {
        self.inner.queue_create_info_count = p_queue_create_infos.len() as u32;
        self.inner.p_queue_create_infos = p_queue_create_infos.as_ptr();
        self
    }
    pub fn pp_enabled_layer_names(mut self, pp_enabled_layer_names: &'a [*const c_char]) -> Self {
        self.inner.enabled_layer_count = pp_enabled_layer_names.len() as u32;
        self.inner.pp_enabled_layer_names = pp_enabled_layer_names.as_ptr();
        self
    }
    pub fn pp_enabled_extension_names(mut self, pp_enabled_extension_names: &'a [*const c_char]) -> Self {
        self.inner.enabled_extension_count = pp_enabled_extension_names.len() as u32;
        self.inner.pp_enabled_extension_names = pp_enabled_extension_names.as_ptr();
        self
    }
    pub fn p_enabled_features(mut self, p_enabled_features: Option<&'a vk::PhysicalDeviceFeatures>) -> Self {
        self.inner.p_enabled_features = p_enabled_features.map_or(ptr::null(), |r| r);
        self
    }
}
impl<'a> Deref for DeviceCreateInfoBuilder<'a> {
    type Target = vk::DeviceCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct InstanceCreateInfoBuilder<'a> {
    inner: vk::InstanceCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::InstanceCreateInfo {
    type Type = InstanceCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait InstanceCreateInfoNext {}
impl<'a> InstanceCreateInfoBuilder<'a> {
    pub fn insert_next<T: InstanceCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::InstanceCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::InstanceCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_application_info(mut self, p_application_info: Option<&'a vk::ApplicationInfo>) -> Self {
        self.inner.p_application_info = p_application_info.map_or(ptr::null(), |r| r);
        self
    }
    pub fn pp_enabled_layer_names(mut self, pp_enabled_layer_names: &'a [*const c_char]) -> Self {
        self.inner.enabled_layer_count = pp_enabled_layer_names.len() as u32;
        self.inner.pp_enabled_layer_names = pp_enabled_layer_names.as_ptr();
        self
    }
    pub fn pp_enabled_extension_names(mut self, pp_enabled_extension_names: &'a [*const c_char]) -> Self {
        self.inner.enabled_extension_count = pp_enabled_extension_names.len() as u32;
        self.inner.pp_enabled_extension_names = pp_enabled_extension_names.as_ptr();
        self
    }
}
impl<'a> Deref for InstanceCreateInfoBuilder<'a> {
    type Target = vk::InstanceCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryAllocateInfoBuilder<'a> {
    inner: vk::MemoryAllocateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::MemoryAllocateInfo {
    type Type = MemoryAllocateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait MemoryAllocateInfoNext {}
impl<'a> MemoryAllocateInfoBuilder<'a> {
    pub fn insert_next<T: MemoryAllocateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::MemoryAllocateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn allocation_size(mut self, allocation_size: vk::DeviceSize) -> Self {
        self.inner.allocation_size = allocation_size;
        self
    }
    pub fn memory_type_index(mut self, memory_type_index: u32) -> Self {
        self.inner.memory_type_index = memory_type_index;
        self
    }
}
impl<'a> Deref for MemoryAllocateInfoBuilder<'a> {
    type Target = vk::MemoryAllocateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MappedMemoryRangeBuilder {
    inner: vk::MappedMemoryRange,
}
impl Builder<'_> for vk::MappedMemoryRange {
    type Type = MappedMemoryRangeBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MappedMemoryRangeBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MappedMemoryRange {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn offset(mut self, offset: vk::DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
}
impl Deref for MappedMemoryRangeBuilder {
    type Target = vk::MappedMemoryRange;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorBufferInfoBuilder {
    inner: vk::DescriptorBufferInfo,
}
impl Builder<'_> for vk::DescriptorBufferInfo {
    type Type = DescriptorBufferInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DescriptorBufferInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DescriptorBufferInfo {
        &mut self.inner
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    pub fn offset(mut self, offset: vk::DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn range(mut self, range: vk::DeviceSize) -> Self {
        self.inner.range = range;
        self
    }
}
impl Deref for DescriptorBufferInfoBuilder {
    type Target = vk::DescriptorBufferInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorImageInfoBuilder {
    inner: vk::DescriptorImageInfo,
}
impl Builder<'_> for vk::DescriptorImageInfo {
    type Type = DescriptorImageInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DescriptorImageInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DescriptorImageInfo {
        &mut self.inner
    }
    pub fn sampler(mut self, sampler: vk::Sampler) -> Self {
        self.inner.sampler = sampler;
        self
    }
    pub fn image_view(mut self, image_view: vk::ImageView) -> Self {
        self.inner.image_view = image_view;
        self
    }
    pub fn image_layout(mut self, image_layout: vk::ImageLayout) -> Self {
        self.inner.image_layout = image_layout;
        self
    }
}
impl Deref for DescriptorImageInfoBuilder {
    type Target = vk::DescriptorImageInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct WriteDescriptorSetBuilder<'a> {
    inner: vk::WriteDescriptorSet,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::WriteDescriptorSet {
    type Type = WriteDescriptorSetBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait WriteDescriptorSetNext {}
impl<'a> WriteDescriptorSetBuilder<'a> {
    pub fn insert_next<T: WriteDescriptorSetNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::WriteDescriptorSet {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn dst_set(mut self, dst_set: vk::DescriptorSet) -> Self {
        self.inner.dst_set = dst_set;
        self
    }
    pub fn dst_binding(mut self, dst_binding: u32) -> Self {
        self.inner.dst_binding = dst_binding;
        self
    }
    pub fn dst_array_element(mut self, dst_array_element: u32) -> Self {
        self.inner.dst_array_element = dst_array_element;
        self
    }
    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.inner.descriptor_count = descriptor_count;
        self
    }
    pub fn p_image_info(mut self, p_image_info: &'a [vk::DescriptorImageInfo]) -> Self {
        self.inner.descriptor_count = p_image_info.len() as u32;
        self.inner.p_image_info = p_image_info.as_ptr();
        self
    }
    pub fn p_buffer_info(mut self, p_buffer_info: &'a [vk::DescriptorBufferInfo]) -> Self {
        self.inner.descriptor_count = p_buffer_info.len() as u32;
        self.inner.p_buffer_info = p_buffer_info.as_ptr();
        self
    }
    pub fn p_texel_buffer_view(mut self, p_texel_buffer_view: &'a [vk::BufferView]) -> Self {
        self.inner.descriptor_count = p_texel_buffer_view.len() as u32;
        self.inner.p_texel_buffer_view = p_texel_buffer_view.as_ptr();
        self
    }
    pub fn descriptor_type(mut self, descriptor_type: vk::DescriptorType) -> Self {
        self.inner.descriptor_type = descriptor_type;
        self
    }
}
impl<'a> Deref for WriteDescriptorSetBuilder<'a> {
    type Target = vk::WriteDescriptorSet;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyDescriptorSetBuilder {
    inner: vk::CopyDescriptorSet,
}
impl Builder<'_> for vk::CopyDescriptorSet {
    type Type = CopyDescriptorSetBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CopyDescriptorSetBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CopyDescriptorSet {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_set(mut self, src_set: vk::DescriptorSet) -> Self {
        self.inner.src_set = src_set;
        self
    }
    pub fn src_binding(mut self, src_binding: u32) -> Self {
        self.inner.src_binding = src_binding;
        self
    }
    pub fn src_array_element(mut self, src_array_element: u32) -> Self {
        self.inner.src_array_element = src_array_element;
        self
    }
    pub fn dst_set(mut self, dst_set: vk::DescriptorSet) -> Self {
        self.inner.dst_set = dst_set;
        self
    }
    pub fn dst_binding(mut self, dst_binding: u32) -> Self {
        self.inner.dst_binding = dst_binding;
        self
    }
    pub fn dst_array_element(mut self, dst_array_element: u32) -> Self {
        self.inner.dst_array_element = dst_array_element;
        self
    }
    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.inner.descriptor_count = descriptor_count;
        self
    }
}
impl Deref for CopyDescriptorSetBuilder {
    type Target = vk::CopyDescriptorSet;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferUsageFlags2CreateInfoBuilder {
    inner: vk::BufferUsageFlags2CreateInfo,
}
impl Builder<'_> for vk::BufferUsageFlags2CreateInfo {
    type Type = BufferUsageFlags2CreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BufferUsageFlags2CreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BufferUsageFlags2CreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn usage(mut self, usage: vk::BufferUsageFlags2) -> Self {
        self.inner.usage = usage;
        self
    }
}
impl Deref for BufferUsageFlags2CreateInfoBuilder {
    type Target = vk::BufferUsageFlags2CreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BufferViewCreateInfoNext for vk::BufferUsageFlags2CreateInfo {}
impl BufferViewCreateInfoNext for BufferUsageFlags2CreateInfoBuilder {}
impl BufferCreateInfoNext for vk::BufferUsageFlags2CreateInfo {}
impl BufferCreateInfoNext for BufferUsageFlags2CreateInfoBuilder {}
impl PhysicalDeviceExternalBufferInfoNext for vk::BufferUsageFlags2CreateInfo {}
impl PhysicalDeviceExternalBufferInfoNext for BufferUsageFlags2CreateInfoBuilder {}
impl DescriptorBufferBindingInfoEXTNext for vk::BufferUsageFlags2CreateInfo {}
impl DescriptorBufferBindingInfoEXTNext for BufferUsageFlags2CreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferCreateInfoBuilder<'a> {
    inner: vk::BufferCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BufferCreateInfo {
    type Type = BufferCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait BufferCreateInfoNext {}
impl<'a> BufferCreateInfoBuilder<'a> {
    pub fn insert_next<T: BufferCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::BufferCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::BufferCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    pub fn usage(mut self, usage: vk::BufferUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
    pub fn sharing_mode(mut self, sharing_mode: vk::SharingMode) -> Self {
        self.inner.sharing_mode = sharing_mode;
        self
    }
    pub fn queue_family_index_count(mut self, queue_family_index_count: u32) -> Self {
        self.inner.queue_family_index_count = queue_family_index_count;
        self
    }
    pub fn p_queue_family_indices(mut self, p_queue_family_indices: &'a [u32]) -> Self {
        self.inner.queue_family_index_count = p_queue_family_indices.len() as u32;
        self.inner.p_queue_family_indices = p_queue_family_indices.as_ptr();
        self
    }
}
impl<'a> Deref for BufferCreateInfoBuilder<'a> {
    type Target = vk::BufferCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferViewCreateInfoBuilder<'a> {
    inner: vk::BufferViewCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BufferViewCreateInfo {
    type Type = BufferViewCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait BufferViewCreateInfoNext {}
impl<'a> BufferViewCreateInfoBuilder<'a> {
    pub fn insert_next<T: BufferViewCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::BufferViewCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::BufferViewCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    pub fn format(mut self, format: vk::Format) -> Self {
        self.inner.format = format;
        self
    }
    pub fn offset(mut self, offset: vk::DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn range(mut self, range: vk::DeviceSize) -> Self {
        self.inner.range = range;
        self
    }
}
impl<'a> Deref for BufferViewCreateInfoBuilder<'a> {
    type Target = vk::BufferViewCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageSubresourceBuilder {
    inner: vk::ImageSubresource,
}
impl Builder<'_> for vk::ImageSubresource {
    type Type = ImageSubresourceBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageSubresourceBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageSubresource {
        &mut self.inner
    }
    pub fn aspect_mask(mut self, aspect_mask: vk::ImageAspectFlags) -> Self {
        self.inner.aspect_mask = aspect_mask;
        self
    }
    pub fn mip_level(mut self, mip_level: u32) -> Self {
        self.inner.mip_level = mip_level;
        self
    }
    pub fn array_layer(mut self, array_layer: u32) -> Self {
        self.inner.array_layer = array_layer;
        self
    }
}
impl Deref for ImageSubresourceBuilder {
    type Target = vk::ImageSubresource;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageSubresourceLayersBuilder {
    inner: vk::ImageSubresourceLayers,
}
impl Builder<'_> for vk::ImageSubresourceLayers {
    type Type = ImageSubresourceLayersBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageSubresourceLayersBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageSubresourceLayers {
        &mut self.inner
    }
    pub fn aspect_mask(mut self, aspect_mask: vk::ImageAspectFlags) -> Self {
        self.inner.aspect_mask = aspect_mask;
        self
    }
    pub fn mip_level(mut self, mip_level: u32) -> Self {
        self.inner.mip_level = mip_level;
        self
    }
    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
        self.inner.base_array_layer = base_array_layer;
        self
    }
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.inner.layer_count = layer_count;
        self
    }
}
impl Deref for ImageSubresourceLayersBuilder {
    type Target = vk::ImageSubresourceLayers;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageSubresourceRangeBuilder {
    inner: vk::ImageSubresourceRange,
}
impl Builder<'_> for vk::ImageSubresourceRange {
    type Type = ImageSubresourceRangeBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageSubresourceRangeBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageSubresourceRange {
        &mut self.inner
    }
    pub fn aspect_mask(mut self, aspect_mask: vk::ImageAspectFlags) -> Self {
        self.inner.aspect_mask = aspect_mask;
        self
    }
    pub fn base_mip_level(mut self, base_mip_level: u32) -> Self {
        self.inner.base_mip_level = base_mip_level;
        self
    }
    pub fn level_count(mut self, level_count: u32) -> Self {
        self.inner.level_count = level_count;
        self
    }
    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
        self.inner.base_array_layer = base_array_layer;
        self
    }
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.inner.layer_count = layer_count;
        self
    }
}
impl Deref for ImageSubresourceRangeBuilder {
    type Target = vk::ImageSubresourceRange;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryBarrierBuilder {
    inner: vk::MemoryBarrier,
}
impl Builder<'_> for vk::MemoryBarrier {
    type Type = MemoryBarrierBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryBarrierBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryBarrier {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_access_mask(mut self, src_access_mask: vk::AccessFlags) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    pub fn dst_access_mask(mut self, dst_access_mask: vk::AccessFlags) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
}
impl Deref for MemoryBarrierBuilder {
    type Target = vk::MemoryBarrier;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferMemoryBarrierBuilder<'a> {
    inner: vk::BufferMemoryBarrier,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BufferMemoryBarrier {
    type Type = BufferMemoryBarrierBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait BufferMemoryBarrierNext {}
impl<'a> BufferMemoryBarrierBuilder<'a> {
    pub fn insert_next<T: BufferMemoryBarrierNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::BufferMemoryBarrier {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_access_mask(mut self, src_access_mask: vk::AccessFlags) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    pub fn dst_access_mask(mut self, dst_access_mask: vk::AccessFlags) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.inner.src_queue_family_index = src_queue_family_index;
        self
    }
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.inner.dst_queue_family_index = dst_queue_family_index;
        self
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    pub fn offset(mut self, offset: vk::DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
}
impl<'a> Deref for BufferMemoryBarrierBuilder<'a> {
    type Target = vk::BufferMemoryBarrier;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageMemoryBarrierBuilder<'a> {
    inner: vk::ImageMemoryBarrier,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImageMemoryBarrier {
    type Type = ImageMemoryBarrierBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait ImageMemoryBarrierNext {}
impl<'a> ImageMemoryBarrierBuilder<'a> {
    pub fn insert_next<T: ImageMemoryBarrierNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::ImageMemoryBarrier {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_access_mask(mut self, src_access_mask: vk::AccessFlags) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    pub fn dst_access_mask(mut self, dst_access_mask: vk::AccessFlags) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    pub fn old_layout(mut self, old_layout: vk::ImageLayout) -> Self {
        self.inner.old_layout = old_layout;
        self
    }
    pub fn new_layout(mut self, new_layout: vk::ImageLayout) -> Self {
        self.inner.new_layout = new_layout;
        self
    }
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.inner.src_queue_family_index = src_queue_family_index;
        self
    }
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.inner.dst_queue_family_index = dst_queue_family_index;
        self
    }
    pub fn image(mut self, image: vk::Image) -> Self {
        self.inner.image = image;
        self
    }
    pub fn subresource_range(mut self, subresource_range: vk::ImageSubresourceRange) -> Self {
        self.inner.subresource_range = subresource_range;
        self
    }
}
impl<'a> Deref for ImageMemoryBarrierBuilder<'a> {
    type Target = vk::ImageMemoryBarrier;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageCreateInfoBuilder<'a> {
    inner: vk::ImageCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImageCreateInfo {
    type Type = ImageCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait ImageCreateInfoNext {}
impl<'a> ImageCreateInfoBuilder<'a> {
    pub fn insert_next<T: ImageCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::ImageCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::ImageCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn image_type(mut self, image_type: vk::ImageType) -> Self {
        self.inner.image_type = image_type;
        self
    }
    pub fn format(mut self, format: vk::Format) -> Self {
        self.inner.format = format;
        self
    }
    pub fn extent(mut self, extent: vk::Extent3D) -> Self {
        self.inner.extent = extent;
        self
    }
    pub fn mip_levels(mut self, mip_levels: u32) -> Self {
        self.inner.mip_levels = mip_levels;
        self
    }
    pub fn array_layers(mut self, array_layers: u32) -> Self {
        self.inner.array_layers = array_layers;
        self
    }
    pub fn samples(mut self, samples: vk::SampleCountFlags) -> Self {
        self.inner.samples = samples;
        self
    }
    pub fn tiling(mut self, tiling: vk::ImageTiling) -> Self {
        self.inner.tiling = tiling;
        self
    }
    pub fn usage(mut self, usage: vk::ImageUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
    pub fn sharing_mode(mut self, sharing_mode: vk::SharingMode) -> Self {
        self.inner.sharing_mode = sharing_mode;
        self
    }
    pub fn queue_family_index_count(mut self, queue_family_index_count: u32) -> Self {
        self.inner.queue_family_index_count = queue_family_index_count;
        self
    }
    pub fn p_queue_family_indices(mut self, p_queue_family_indices: &'a [u32]) -> Self {
        self.inner.queue_family_index_count = p_queue_family_indices.len() as u32;
        self.inner.p_queue_family_indices = p_queue_family_indices.as_ptr();
        self
    }
    pub fn initial_layout(mut self, initial_layout: vk::ImageLayout) -> Self {
        self.inner.initial_layout = initial_layout;
        self
    }
}
impl<'a> Deref for ImageCreateInfoBuilder<'a> {
    type Target = vk::ImageCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SubresourceLayoutBuilder {
    inner: vk::SubresourceLayout,
}
impl Builder<'_> for vk::SubresourceLayout {
    type Type = SubresourceLayoutBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SubresourceLayoutBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SubresourceLayout {
        &mut self.inner
    }
    pub fn offset(mut self, offset: vk::DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    pub fn row_pitch(mut self, row_pitch: vk::DeviceSize) -> Self {
        self.inner.row_pitch = row_pitch;
        self
    }
    pub fn array_pitch(mut self, array_pitch: vk::DeviceSize) -> Self {
        self.inner.array_pitch = array_pitch;
        self
    }
    pub fn depth_pitch(mut self, depth_pitch: vk::DeviceSize) -> Self {
        self.inner.depth_pitch = depth_pitch;
        self
    }
}
impl Deref for SubresourceLayoutBuilder {
    type Target = vk::SubresourceLayout;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageViewCreateInfoBuilder<'a> {
    inner: vk::ImageViewCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImageViewCreateInfo {
    type Type = ImageViewCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait ImageViewCreateInfoNext {}
impl<'a> ImageViewCreateInfoBuilder<'a> {
    pub fn insert_next<T: ImageViewCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::ImageViewCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::ImageViewCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn image(mut self, image: vk::Image) -> Self {
        self.inner.image = image;
        self
    }
    pub fn view_type(mut self, view_type: vk::ImageViewType) -> Self {
        self.inner.view_type = view_type;
        self
    }
    pub fn format(mut self, format: vk::Format) -> Self {
        self.inner.format = format;
        self
    }
    pub fn components(mut self, components: vk::ComponentMapping) -> Self {
        self.inner.components = components;
        self
    }
    pub fn subresource_range(mut self, subresource_range: vk::ImageSubresourceRange) -> Self {
        self.inner.subresource_range = subresource_range;
        self
    }
}
impl<'a> Deref for ImageViewCreateInfoBuilder<'a> {
    type Target = vk::ImageViewCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferCopyBuilder {
    inner: vk::BufferCopy,
}
impl Builder<'_> for vk::BufferCopy {
    type Type = BufferCopyBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BufferCopyBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BufferCopy {
        &mut self.inner
    }
    pub fn src_offset(mut self, src_offset: vk::DeviceSize) -> Self {
        self.inner.src_offset = src_offset;
        self
    }
    pub fn dst_offset(mut self, dst_offset: vk::DeviceSize) -> Self {
        self.inner.dst_offset = dst_offset;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
}
impl Deref for BufferCopyBuilder {
    type Target = vk::BufferCopy;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SparseMemoryBindBuilder {
    inner: vk::SparseMemoryBind,
}
impl Builder<'_> for vk::SparseMemoryBind {
    type Type = SparseMemoryBindBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SparseMemoryBindBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SparseMemoryBind {
        &mut self.inner
    }
    pub fn resource_offset(mut self, resource_offset: vk::DeviceSize) -> Self {
        self.inner.resource_offset = resource_offset;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn memory_offset(mut self, memory_offset: vk::DeviceSize) -> Self {
        self.inner.memory_offset = memory_offset;
        self
    }
    pub fn flags(mut self, flags: vk::SparseMemoryBindFlags) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl Deref for SparseMemoryBindBuilder {
    type Target = vk::SparseMemoryBind;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SparseImageMemoryBindBuilder {
    inner: vk::SparseImageMemoryBind,
}
impl Builder<'_> for vk::SparseImageMemoryBind {
    type Type = SparseImageMemoryBindBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SparseImageMemoryBindBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SparseImageMemoryBind {
        &mut self.inner
    }
    pub fn subresource(mut self, subresource: vk::ImageSubresource) -> Self {
        self.inner.subresource = subresource;
        self
    }
    pub fn offset(mut self, offset: vk::Offset3D) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn extent(mut self, extent: vk::Extent3D) -> Self {
        self.inner.extent = extent;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn memory_offset(mut self, memory_offset: vk::DeviceSize) -> Self {
        self.inner.memory_offset = memory_offset;
        self
    }
    pub fn flags(mut self, flags: vk::SparseMemoryBindFlags) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl Deref for SparseImageMemoryBindBuilder {
    type Target = vk::SparseImageMemoryBind;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SparseBufferMemoryBindInfoBuilder<'a> {
    inner: vk::SparseBufferMemoryBindInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SparseBufferMemoryBindInfo {
    type Type = SparseBufferMemoryBindInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> SparseBufferMemoryBindInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::SparseBufferMemoryBindInfo {
        &mut self.inner
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    pub fn p_binds(mut self, p_binds: &'a [vk::SparseMemoryBind]) -> Self {
        self.inner.bind_count = p_binds.len() as u32;
        self.inner.p_binds = p_binds.as_ptr();
        self
    }
}
impl<'a> Deref for SparseBufferMemoryBindInfoBuilder<'a> {
    type Target = vk::SparseBufferMemoryBindInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SparseImageOpaqueMemoryBindInfoBuilder<'a> {
    inner: vk::SparseImageOpaqueMemoryBindInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SparseImageOpaqueMemoryBindInfo {
    type Type = SparseImageOpaqueMemoryBindInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> SparseImageOpaqueMemoryBindInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::SparseImageOpaqueMemoryBindInfo {
        &mut self.inner
    }
    pub fn image(mut self, image: vk::Image) -> Self {
        self.inner.image = image;
        self
    }
    pub fn p_binds(mut self, p_binds: &'a [vk::SparseMemoryBind]) -> Self {
        self.inner.bind_count = p_binds.len() as u32;
        self.inner.p_binds = p_binds.as_ptr();
        self
    }
}
impl<'a> Deref for SparseImageOpaqueMemoryBindInfoBuilder<'a> {
    type Target = vk::SparseImageOpaqueMemoryBindInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SparseImageMemoryBindInfoBuilder<'a> {
    inner: vk::SparseImageMemoryBindInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SparseImageMemoryBindInfo {
    type Type = SparseImageMemoryBindInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> SparseImageMemoryBindInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::SparseImageMemoryBindInfo {
        &mut self.inner
    }
    pub fn image(mut self, image: vk::Image) -> Self {
        self.inner.image = image;
        self
    }
    pub fn p_binds(mut self, p_binds: &'a [vk::SparseImageMemoryBind]) -> Self {
        self.inner.bind_count = p_binds.len() as u32;
        self.inner.p_binds = p_binds.as_ptr();
        self
    }
}
impl<'a> Deref for SparseImageMemoryBindInfoBuilder<'a> {
    type Target = vk::SparseImageMemoryBindInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BindSparseInfoBuilder<'a> {
    inner: vk::BindSparseInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BindSparseInfo {
    type Type = BindSparseInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait BindSparseInfoNext {}
impl<'a> BindSparseInfoBuilder<'a> {
    pub fn insert_next<T: BindSparseInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::BindSparseInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_wait_semaphores(mut self, p_wait_semaphores: &'a [vk::Semaphore]) -> Self {
        self.inner.wait_semaphore_count = p_wait_semaphores.len() as u32;
        self.inner.p_wait_semaphores = p_wait_semaphores.as_ptr();
        self
    }
    pub fn p_buffer_binds(mut self, p_buffer_binds: &'a [vk::SparseBufferMemoryBindInfo]) -> Self {
        self.inner.buffer_bind_count = p_buffer_binds.len() as u32;
        self.inner.p_buffer_binds = p_buffer_binds.as_ptr();
        self
    }
    pub fn p_image_opaque_binds(mut self, p_image_opaque_binds: &'a [vk::SparseImageOpaqueMemoryBindInfo]) -> Self {
        self.inner.image_opaque_bind_count = p_image_opaque_binds.len() as u32;
        self.inner.p_image_opaque_binds = p_image_opaque_binds.as_ptr();
        self
    }
    pub fn p_image_binds(mut self, p_image_binds: &'a [vk::SparseImageMemoryBindInfo]) -> Self {
        self.inner.image_bind_count = p_image_binds.len() as u32;
        self.inner.p_image_binds = p_image_binds.as_ptr();
        self
    }
    pub fn p_signal_semaphores(mut self, p_signal_semaphores: &'a [vk::Semaphore]) -> Self {
        self.inner.signal_semaphore_count = p_signal_semaphores.len() as u32;
        self.inner.p_signal_semaphores = p_signal_semaphores.as_ptr();
        self
    }
}
impl<'a> Deref for BindSparseInfoBuilder<'a> {
    type Target = vk::BindSparseInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageCopyBuilder {
    inner: vk::ImageCopy,
}
impl Builder<'_> for vk::ImageCopy {
    type Type = ImageCopyBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageCopyBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageCopy {
        &mut self.inner
    }
    pub fn src_subresource(mut self, src_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.src_subresource = src_subresource;
        self
    }
    pub fn src_offset(mut self, src_offset: vk::Offset3D) -> Self {
        self.inner.src_offset = src_offset;
        self
    }
    pub fn dst_subresource(mut self, dst_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.dst_subresource = dst_subresource;
        self
    }
    pub fn dst_offset(mut self, dst_offset: vk::Offset3D) -> Self {
        self.inner.dst_offset = dst_offset;
        self
    }
    pub fn extent(mut self, extent: vk::Extent3D) -> Self {
        self.inner.extent = extent;
        self
    }
}
impl Deref for ImageCopyBuilder {
    type Target = vk::ImageCopy;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageBlitBuilder {
    inner: vk::ImageBlit,
}
impl Builder<'_> for vk::ImageBlit {
    type Type = ImageBlitBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageBlitBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageBlit {
        &mut self.inner
    }
    pub fn src_subresource(mut self, src_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.src_subresource = src_subresource;
        self
    }
    pub fn src_offsets(mut self, src_offsets: [vk::Offset3D; 2]) -> Self {
        self.inner.src_offsets = src_offsets;
        self
    }
    pub fn dst_subresource(mut self, dst_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.dst_subresource = dst_subresource;
        self
    }
    pub fn dst_offsets(mut self, dst_offsets: [vk::Offset3D; 2]) -> Self {
        self.inner.dst_offsets = dst_offsets;
        self
    }
}
impl Deref for ImageBlitBuilder {
    type Target = vk::ImageBlit;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferImageCopyBuilder {
    inner: vk::BufferImageCopy,
}
impl Builder<'_> for vk::BufferImageCopy {
    type Type = BufferImageCopyBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BufferImageCopyBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BufferImageCopy {
        &mut self.inner
    }
    pub fn buffer_offset(mut self, buffer_offset: vk::DeviceSize) -> Self {
        self.inner.buffer_offset = buffer_offset;
        self
    }
    pub fn buffer_row_length(mut self, buffer_row_length: u32) -> Self {
        self.inner.buffer_row_length = buffer_row_length;
        self
    }
    pub fn buffer_image_height(mut self, buffer_image_height: u32) -> Self {
        self.inner.buffer_image_height = buffer_image_height;
        self
    }
    pub fn image_subresource(mut self, image_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.image_subresource = image_subresource;
        self
    }
    pub fn image_offset(mut self, image_offset: vk::Offset3D) -> Self {
        self.inner.image_offset = image_offset;
        self
    }
    pub fn image_extent(mut self, image_extent: vk::Extent3D) -> Self {
        self.inner.image_extent = image_extent;
        self
    }
}
impl Deref for BufferImageCopyBuilder {
    type Target = vk::BufferImageCopy;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyMemoryIndirectCommandNVBuilder {
    inner: vk::CopyMemoryIndirectCommandNV,
}
impl Builder<'_> for vk::CopyMemoryIndirectCommandNV {
    type Type = CopyMemoryIndirectCommandNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CopyMemoryIndirectCommandNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CopyMemoryIndirectCommandNV {
        &mut self.inner
    }
    pub fn src_address(mut self, src_address: vk::DeviceAddress) -> Self {
        self.inner.src_address = src_address;
        self
    }
    pub fn dst_address(mut self, dst_address: vk::DeviceAddress) -> Self {
        self.inner.dst_address = dst_address;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
}
impl Deref for CopyMemoryIndirectCommandNVBuilder {
    type Target = vk::CopyMemoryIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyMemoryToImageIndirectCommandNVBuilder {
    inner: vk::CopyMemoryToImageIndirectCommandNV,
}
impl Builder<'_> for vk::CopyMemoryToImageIndirectCommandNV {
    type Type = CopyMemoryToImageIndirectCommandNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CopyMemoryToImageIndirectCommandNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CopyMemoryToImageIndirectCommandNV {
        &mut self.inner
    }
    pub fn src_address(mut self, src_address: vk::DeviceAddress) -> Self {
        self.inner.src_address = src_address;
        self
    }
    pub fn buffer_row_length(mut self, buffer_row_length: u32) -> Self {
        self.inner.buffer_row_length = buffer_row_length;
        self
    }
    pub fn buffer_image_height(mut self, buffer_image_height: u32) -> Self {
        self.inner.buffer_image_height = buffer_image_height;
        self
    }
    pub fn image_subresource(mut self, image_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.image_subresource = image_subresource;
        self
    }
    pub fn image_offset(mut self, image_offset: vk::Offset3D) -> Self {
        self.inner.image_offset = image_offset;
        self
    }
    pub fn image_extent(mut self, image_extent: vk::Extent3D) -> Self {
        self.inner.image_extent = image_extent;
        self
    }
}
impl Deref for CopyMemoryToImageIndirectCommandNVBuilder {
    type Target = vk::CopyMemoryToImageIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageResolveBuilder {
    inner: vk::ImageResolve,
}
impl Builder<'_> for vk::ImageResolve {
    type Type = ImageResolveBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageResolveBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageResolve {
        &mut self.inner
    }
    pub fn src_subresource(mut self, src_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.src_subresource = src_subresource;
        self
    }
    pub fn src_offset(mut self, src_offset: vk::Offset3D) -> Self {
        self.inner.src_offset = src_offset;
        self
    }
    pub fn dst_subresource(mut self, dst_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.dst_subresource = dst_subresource;
        self
    }
    pub fn dst_offset(mut self, dst_offset: vk::Offset3D) -> Self {
        self.inner.dst_offset = dst_offset;
        self
    }
    pub fn extent(mut self, extent: vk::Extent3D) -> Self {
        self.inner.extent = extent;
        self
    }
}
impl Deref for ImageResolveBuilder {
    type Target = vk::ImageResolve;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ShaderModuleCreateInfoBuilder<'a> {
    inner: vk::ShaderModuleCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ShaderModuleCreateInfo {
    type Type = ShaderModuleCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait ShaderModuleCreateInfoNext {}
impl<'a> ShaderModuleCreateInfoBuilder<'a> {
    pub fn insert_next<T: ShaderModuleCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::ShaderModuleCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::ShaderModuleCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn code_size(mut self, code_size: usize) -> Self {
        self.inner.code_size = code_size;
        self
    }
    pub fn p_code(mut self, p_code: *const u32) -> Self {
        self.inner.p_code = p_code;
        self
    }
}
impl<'a> Deref for ShaderModuleCreateInfoBuilder<'a> {
    type Target = vk::ShaderModuleCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineShaderStageCreateInfoNext for vk::ShaderModuleCreateInfo {}
impl PipelineShaderStageCreateInfoNext for ShaderModuleCreateInfoBuilder<'_> {}
impl DataGraphPipelineCreateInfoARMNext for vk::ShaderModuleCreateInfo {}
impl DataGraphPipelineCreateInfoARMNext for ShaderModuleCreateInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorSetLayoutBindingBuilder<'a> {
    inner: vk::DescriptorSetLayoutBinding,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DescriptorSetLayoutBinding {
    type Type = DescriptorSetLayoutBindingBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DescriptorSetLayoutBindingBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DescriptorSetLayoutBinding {
        &mut self.inner
    }
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
    pub fn descriptor_type(mut self, descriptor_type: vk::DescriptorType) -> Self {
        self.inner.descriptor_type = descriptor_type;
        self
    }
    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.inner.descriptor_count = descriptor_count;
        self
    }
    pub fn p_immutable_samplers(mut self, p_immutable_samplers: &'a [vk::Sampler]) -> Self {
        self.inner.descriptor_count = p_immutable_samplers.len() as u32;
        self.inner.p_immutable_samplers = p_immutable_samplers.as_ptr();
        self
    }
    pub fn stage_flags(mut self, stage_flags: vk::ShaderStageFlags) -> Self {
        self.inner.stage_flags = stage_flags;
        self
    }
}
impl<'a> Deref for DescriptorSetLayoutBindingBuilder<'a> {
    type Target = vk::DescriptorSetLayoutBinding;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorSetLayoutCreateInfoBuilder<'a> {
    inner: vk::DescriptorSetLayoutCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DescriptorSetLayoutCreateInfo {
    type Type = DescriptorSetLayoutCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DescriptorSetLayoutCreateInfoNext {}
impl<'a> DescriptorSetLayoutCreateInfoBuilder<'a> {
    pub fn insert_next<T: DescriptorSetLayoutCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DescriptorSetLayoutCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DescriptorSetLayoutCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_bindings(mut self, p_bindings: &'a [vk::DescriptorSetLayoutBinding]) -> Self {
        self.inner.binding_count = p_bindings.len() as u32;
        self.inner.p_bindings = p_bindings.as_ptr();
        self
    }
}
impl<'a> Deref for DescriptorSetLayoutCreateInfoBuilder<'a> {
    type Target = vk::DescriptorSetLayoutCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorPoolSizeBuilder {
    inner: vk::DescriptorPoolSize,
}
impl Builder<'_> for vk::DescriptorPoolSize {
    type Type = DescriptorPoolSizeBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DescriptorPoolSizeBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DescriptorPoolSize {
        &mut self.inner
    }
    pub fn ty(mut self, ty: vk::DescriptorType) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.inner.descriptor_count = descriptor_count;
        self
    }
}
impl Deref for DescriptorPoolSizeBuilder {
    type Target = vk::DescriptorPoolSize;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorPoolCreateInfoBuilder<'a> {
    inner: vk::DescriptorPoolCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DescriptorPoolCreateInfo {
    type Type = DescriptorPoolCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DescriptorPoolCreateInfoNext {}
impl<'a> DescriptorPoolCreateInfoBuilder<'a> {
    pub fn insert_next<T: DescriptorPoolCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DescriptorPoolCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DescriptorPoolCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn max_sets(mut self, max_sets: u32) -> Self {
        self.inner.max_sets = max_sets;
        self
    }
    pub fn p_pool_sizes(mut self, p_pool_sizes: &'a [vk::DescriptorPoolSize]) -> Self {
        self.inner.pool_size_count = p_pool_sizes.len() as u32;
        self.inner.p_pool_sizes = p_pool_sizes.as_ptr();
        self
    }
}
impl<'a> Deref for DescriptorPoolCreateInfoBuilder<'a> {
    type Target = vk::DescriptorPoolCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorSetAllocateInfoBuilder<'a> {
    inner: vk::DescriptorSetAllocateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DescriptorSetAllocateInfo {
    type Type = DescriptorSetAllocateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DescriptorSetAllocateInfoNext {}
impl<'a> DescriptorSetAllocateInfoBuilder<'a> {
    pub fn insert_next<T: DescriptorSetAllocateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DescriptorSetAllocateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn descriptor_pool(mut self, descriptor_pool: vk::DescriptorPool) -> Self {
        self.inner.descriptor_pool = descriptor_pool;
        self
    }
    pub fn p_set_layouts(mut self, p_set_layouts: &'a [vk::DescriptorSetLayout]) -> Self {
        self.inner.descriptor_set_count = p_set_layouts.len() as u32;
        self.inner.p_set_layouts = p_set_layouts.as_ptr();
        self
    }
}
impl<'a> Deref for DescriptorSetAllocateInfoBuilder<'a> {
    type Target = vk::DescriptorSetAllocateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SpecializationMapEntryBuilder {
    inner: vk::SpecializationMapEntry,
}
impl Builder<'_> for vk::SpecializationMapEntry {
    type Type = SpecializationMapEntryBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SpecializationMapEntryBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SpecializationMapEntry {
        &mut self.inner
    }
    pub fn constant_id(mut self, constant_id: u32) -> Self {
        self.inner.constant_id = constant_id;
        self
    }
    pub fn offset(mut self, offset: u32) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn size(mut self, size: usize) -> Self {
        self.inner.size = size;
        self
    }
}
impl Deref for SpecializationMapEntryBuilder {
    type Target = vk::SpecializationMapEntry;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SpecializationInfoBuilder<'a> {
    inner: vk::SpecializationInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SpecializationInfo {
    type Type = SpecializationInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> SpecializationInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::SpecializationInfo {
        &mut self.inner
    }
    pub fn p_map_entries(mut self, p_map_entries: &'a [vk::SpecializationMapEntry]) -> Self {
        self.inner.map_entry_count = p_map_entries.len() as u32;
        self.inner.p_map_entries = p_map_entries.as_ptr();
        self
    }
    pub fn p_data(mut self, p_data: &'a [u8]) -> Self {
        self.inner.data_size = p_data.len();
        self.inner.p_data = p_data.as_ptr() as *const _;
        self
    }
}
impl<'a> Deref for SpecializationInfoBuilder<'a> {
    type Target = vk::SpecializationInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineShaderStageCreateInfoBuilder<'a> {
    inner: vk::PipelineShaderStageCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineShaderStageCreateInfo {
    type Type = PipelineShaderStageCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PipelineShaderStageCreateInfoNext {}
impl<'a> PipelineShaderStageCreateInfoBuilder<'a> {
    pub fn insert_next<T: PipelineShaderStageCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PipelineShaderStageCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineShaderStageCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn stage(mut self, stage: vk::ShaderStageFlags) -> Self {
        self.inner.stage = stage;
        self
    }
    pub fn module(mut self, module: vk::ShaderModule) -> Self {
        self.inner.module = module;
        self
    }
    pub fn p_name(mut self, p_name: &'a CStr) -> Self {
        self.inner.p_name = p_name.as_ptr();
        self
    }
    pub fn p_specialization_info(mut self, p_specialization_info: Option<&'a vk::SpecializationInfo>) -> Self {
        self.inner.p_specialization_info = p_specialization_info.map_or(ptr::null(), |r| r);
        self
    }
}
impl<'a> Deref for PipelineShaderStageCreateInfoBuilder<'a> {
    type Target = vk::PipelineShaderStageCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ComputePipelineCreateInfoBuilder<'a> {
    inner: vk::ComputePipelineCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ComputePipelineCreateInfo {
    type Type = ComputePipelineCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait ComputePipelineCreateInfoNext {}
impl<'a> ComputePipelineCreateInfoBuilder<'a> {
    pub fn insert_next<T: ComputePipelineCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::ComputePipelineCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn stage(mut self, stage: vk::PipelineShaderStageCreateInfo) -> Self {
        self.inner.stage = stage;
        self
    }
    pub fn layout(mut self, layout: vk::PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    pub fn base_pipeline_handle(mut self, base_pipeline_handle: vk::Pipeline) -> Self {
        self.inner.base_pipeline_handle = base_pipeline_handle;
        self
    }
    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.inner.base_pipeline_index = base_pipeline_index;
        self
    }
}
impl<'a> Deref for ComputePipelineCreateInfoBuilder<'a> {
    type Target = vk::ComputePipelineCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ComputePipelineIndirectBufferInfoNVBuilder {
    inner: vk::ComputePipelineIndirectBufferInfoNV,
}
impl Builder<'_> for vk::ComputePipelineIndirectBufferInfoNV {
    type Type = ComputePipelineIndirectBufferInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ComputePipelineIndirectBufferInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ComputePipelineIndirectBufferInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn device_address(mut self, device_address: vk::DeviceAddress) -> Self {
        self.inner.device_address = device_address;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    pub fn pipeline_device_address_capture_replay(
        mut self,
        pipeline_device_address_capture_replay: vk::DeviceAddress,
    ) -> Self {
        self.inner.pipeline_device_address_capture_replay = pipeline_device_address_capture_replay;
        self
    }
}
impl Deref for ComputePipelineIndirectBufferInfoNVBuilder {
    type Target = vk::ComputePipelineIndirectBufferInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ComputePipelineCreateInfoNext for vk::ComputePipelineIndirectBufferInfoNV {}
impl ComputePipelineCreateInfoNext for ComputePipelineIndirectBufferInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineCreateFlags2CreateInfoBuilder {
    inner: vk::PipelineCreateFlags2CreateInfo,
}
impl Builder<'_> for vk::PipelineCreateFlags2CreateInfo {
    type Type = PipelineCreateFlags2CreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineCreateFlags2CreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineCreateFlags2CreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineCreateFlags2) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl Deref for PipelineCreateFlags2CreateInfoBuilder {
    type Target = vk::PipelineCreateFlags2CreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ComputePipelineCreateInfoNext for vk::PipelineCreateFlags2CreateInfo {}
impl ComputePipelineCreateInfoNext for PipelineCreateFlags2CreateInfoBuilder {}
impl GraphicsPipelineCreateInfoNext for vk::PipelineCreateFlags2CreateInfo {}
impl GraphicsPipelineCreateInfoNext for PipelineCreateFlags2CreateInfoBuilder {}
impl RayTracingPipelineCreateInfoNVNext for vk::PipelineCreateFlags2CreateInfo {}
impl RayTracingPipelineCreateInfoNVNext for PipelineCreateFlags2CreateInfoBuilder {}
impl RayTracingPipelineCreateInfoKHRNext for vk::PipelineCreateFlags2CreateInfo {}
impl RayTracingPipelineCreateInfoKHRNext for PipelineCreateFlags2CreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct VertexInputBindingDescriptionBuilder {
    inner: vk::VertexInputBindingDescription,
}
impl Builder<'_> for vk::VertexInputBindingDescription {
    type Type = VertexInputBindingDescriptionBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl VertexInputBindingDescriptionBuilder {
    pub fn get_mut(&mut self) -> &mut vk::VertexInputBindingDescription {
        &mut self.inner
    }
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
    pub fn stride(mut self, stride: u32) -> Self {
        self.inner.stride = stride;
        self
    }
    pub fn input_rate(mut self, input_rate: vk::VertexInputRate) -> Self {
        self.inner.input_rate = input_rate;
        self
    }
}
impl Deref for VertexInputBindingDescriptionBuilder {
    type Target = vk::VertexInputBindingDescription;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct VertexInputAttributeDescriptionBuilder {
    inner: vk::VertexInputAttributeDescription,
}
impl Builder<'_> for vk::VertexInputAttributeDescription {
    type Type = VertexInputAttributeDescriptionBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl VertexInputAttributeDescriptionBuilder {
    pub fn get_mut(&mut self) -> &mut vk::VertexInputAttributeDescription {
        &mut self.inner
    }
    pub fn location(mut self, location: u32) -> Self {
        self.inner.location = location;
        self
    }
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
    pub fn format(mut self, format: vk::Format) -> Self {
        self.inner.format = format;
        self
    }
    pub fn offset(mut self, offset: u32) -> Self {
        self.inner.offset = offset;
        self
    }
}
impl Deref for VertexInputAttributeDescriptionBuilder {
    type Target = vk::VertexInputAttributeDescription;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineVertexInputStateCreateInfoBuilder<'a> {
    inner: vk::PipelineVertexInputStateCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineVertexInputStateCreateInfo {
    type Type = PipelineVertexInputStateCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PipelineVertexInputStateCreateInfoNext {}
impl<'a> PipelineVertexInputStateCreateInfoBuilder<'a> {
    pub fn insert_next<T: PipelineVertexInputStateCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PipelineVertexInputStateCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineVertexInputStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_vertex_binding_descriptions(
        mut self,
        p_vertex_binding_descriptions: &'a [vk::VertexInputBindingDescription],
    ) -> Self {
        self.inner.vertex_binding_description_count = p_vertex_binding_descriptions.len() as u32;
        self.inner.p_vertex_binding_descriptions = p_vertex_binding_descriptions.as_ptr();
        self
    }
    pub fn p_vertex_attribute_descriptions(
        mut self,
        p_vertex_attribute_descriptions: &'a [vk::VertexInputAttributeDescription],
    ) -> Self {
        self.inner.vertex_attribute_description_count = p_vertex_attribute_descriptions.len() as u32;
        self.inner.p_vertex_attribute_descriptions = p_vertex_attribute_descriptions.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineVertexInputStateCreateInfoBuilder<'a> {
    type Target = vk::PipelineVertexInputStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineInputAssemblyStateCreateInfoBuilder {
    inner: vk::PipelineInputAssemblyStateCreateInfo,
}
impl Builder<'_> for vk::PipelineInputAssemblyStateCreateInfo {
    type Type = PipelineInputAssemblyStateCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineInputAssemblyStateCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineInputAssemblyStateCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineInputAssemblyStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn topology(mut self, topology: vk::PrimitiveTopology) -> Self {
        self.inner.topology = topology;
        self
    }
    pub fn primitive_restart_enable(mut self, primitive_restart_enable: bool) -> Self {
        self.inner.primitive_restart_enable = if primitive_restart_enable { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PipelineInputAssemblyStateCreateInfoBuilder {
    type Target = vk::PipelineInputAssemblyStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineTessellationStateCreateInfoBuilder<'a> {
    inner: vk::PipelineTessellationStateCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineTessellationStateCreateInfo {
    type Type = PipelineTessellationStateCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PipelineTessellationStateCreateInfoNext {}
impl<'a> PipelineTessellationStateCreateInfoBuilder<'a> {
    pub fn insert_next<T: PipelineTessellationStateCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PipelineTessellationStateCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineTessellationStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn patch_control_points(mut self, patch_control_points: u32) -> Self {
        self.inner.patch_control_points = patch_control_points;
        self
    }
}
impl<'a> Deref for PipelineTessellationStateCreateInfoBuilder<'a> {
    type Target = vk::PipelineTessellationStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineViewportStateCreateInfoBuilder<'a> {
    inner: vk::PipelineViewportStateCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineViewportStateCreateInfo {
    type Type = PipelineViewportStateCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PipelineViewportStateCreateInfoNext {}
impl<'a> PipelineViewportStateCreateInfoBuilder<'a> {
    pub fn insert_next<T: PipelineViewportStateCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PipelineViewportStateCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineViewportStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn viewport_count(mut self, viewport_count: u32) -> Self {
        self.inner.viewport_count = viewport_count;
        self
    }
    pub fn p_viewports(mut self, p_viewports: &'a [vk::Viewport]) -> Self {
        self.inner.viewport_count = p_viewports.len() as u32;
        self.inner.p_viewports = p_viewports.as_ptr();
        self
    }
    pub fn scissor_count(mut self, scissor_count: u32) -> Self {
        self.inner.scissor_count = scissor_count;
        self
    }
    pub fn p_scissors(mut self, p_scissors: &'a [vk::Rect2D]) -> Self {
        self.inner.scissor_count = p_scissors.len() as u32;
        self.inner.p_scissors = p_scissors.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineViewportStateCreateInfoBuilder<'a> {
    type Target = vk::PipelineViewportStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineRasterizationStateCreateInfoBuilder<'a> {
    inner: vk::PipelineRasterizationStateCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineRasterizationStateCreateInfo {
    type Type = PipelineRasterizationStateCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PipelineRasterizationStateCreateInfoNext {}
impl<'a> PipelineRasterizationStateCreateInfoBuilder<'a> {
    pub fn insert_next<T: PipelineRasterizationStateCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PipelineRasterizationStateCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineRasterizationStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn depth_clamp_enable(mut self, depth_clamp_enable: bool) -> Self {
        self.inner.depth_clamp_enable = if depth_clamp_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn rasterizer_discard_enable(mut self, rasterizer_discard_enable: bool) -> Self {
        self.inner.rasterizer_discard_enable = if rasterizer_discard_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn polygon_mode(mut self, polygon_mode: vk::PolygonMode) -> Self {
        self.inner.polygon_mode = polygon_mode;
        self
    }
    pub fn cull_mode(mut self, cull_mode: vk::CullModeFlags) -> Self {
        self.inner.cull_mode = cull_mode;
        self
    }
    pub fn front_face(mut self, front_face: vk::FrontFace) -> Self {
        self.inner.front_face = front_face;
        self
    }
    pub fn depth_bias_enable(mut self, depth_bias_enable: bool) -> Self {
        self.inner.depth_bias_enable = if depth_bias_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn depth_bias_constant_factor(mut self, depth_bias_constant_factor: f32) -> Self {
        self.inner.depth_bias_constant_factor = depth_bias_constant_factor;
        self
    }
    pub fn depth_bias_clamp(mut self, depth_bias_clamp: f32) -> Self {
        self.inner.depth_bias_clamp = depth_bias_clamp;
        self
    }
    pub fn depth_bias_slope_factor(mut self, depth_bias_slope_factor: f32) -> Self {
        self.inner.depth_bias_slope_factor = depth_bias_slope_factor;
        self
    }
    pub fn line_width(mut self, line_width: f32) -> Self {
        self.inner.line_width = line_width;
        self
    }
}
impl<'a> Deref for PipelineRasterizationStateCreateInfoBuilder<'a> {
    type Target = vk::PipelineRasterizationStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineMultisampleStateCreateInfoBuilder<'a> {
    inner: vk::PipelineMultisampleStateCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineMultisampleStateCreateInfo {
    type Type = PipelineMultisampleStateCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PipelineMultisampleStateCreateInfoNext {}
impl<'a> PipelineMultisampleStateCreateInfoBuilder<'a> {
    pub fn insert_next<T: PipelineMultisampleStateCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PipelineMultisampleStateCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineMultisampleStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn rasterization_samples(mut self, rasterization_samples: vk::SampleCountFlags) -> Self {
        self.inner.rasterization_samples = rasterization_samples;
        self
    }
    pub fn sample_shading_enable(mut self, sample_shading_enable: bool) -> Self {
        self.inner.sample_shading_enable = if sample_shading_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn min_sample_shading(mut self, min_sample_shading: f32) -> Self {
        self.inner.min_sample_shading = min_sample_shading;
        self
    }
    pub fn p_sample_mask(mut self, p_sample_mask: *const vk::SampleMask) -> Self {
        self.inner.p_sample_mask = p_sample_mask;
        self
    }
    pub fn alpha_to_coverage_enable(mut self, alpha_to_coverage_enable: bool) -> Self {
        self.inner.alpha_to_coverage_enable = if alpha_to_coverage_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn alpha_to_one_enable(mut self, alpha_to_one_enable: bool) -> Self {
        self.inner.alpha_to_one_enable = if alpha_to_one_enable { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl<'a> Deref for PipelineMultisampleStateCreateInfoBuilder<'a> {
    type Target = vk::PipelineMultisampleStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineColorBlendAttachmentStateBuilder {
    inner: vk::PipelineColorBlendAttachmentState,
}
impl Builder<'_> for vk::PipelineColorBlendAttachmentState {
    type Type = PipelineColorBlendAttachmentStateBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineColorBlendAttachmentStateBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineColorBlendAttachmentState {
        &mut self.inner
    }
    pub fn blend_enable(mut self, blend_enable: bool) -> Self {
        self.inner.blend_enable = if blend_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn src_color_blend_factor(mut self, src_color_blend_factor: vk::BlendFactor) -> Self {
        self.inner.src_color_blend_factor = src_color_blend_factor;
        self
    }
    pub fn dst_color_blend_factor(mut self, dst_color_blend_factor: vk::BlendFactor) -> Self {
        self.inner.dst_color_blend_factor = dst_color_blend_factor;
        self
    }
    pub fn color_blend_op(mut self, color_blend_op: vk::BlendOp) -> Self {
        self.inner.color_blend_op = color_blend_op;
        self
    }
    pub fn src_alpha_blend_factor(mut self, src_alpha_blend_factor: vk::BlendFactor) -> Self {
        self.inner.src_alpha_blend_factor = src_alpha_blend_factor;
        self
    }
    pub fn dst_alpha_blend_factor(mut self, dst_alpha_blend_factor: vk::BlendFactor) -> Self {
        self.inner.dst_alpha_blend_factor = dst_alpha_blend_factor;
        self
    }
    pub fn alpha_blend_op(mut self, alpha_blend_op: vk::BlendOp) -> Self {
        self.inner.alpha_blend_op = alpha_blend_op;
        self
    }
    pub fn color_write_mask(mut self, color_write_mask: vk::ColorComponentFlags) -> Self {
        self.inner.color_write_mask = color_write_mask;
        self
    }
}
impl Deref for PipelineColorBlendAttachmentStateBuilder {
    type Target = vk::PipelineColorBlendAttachmentState;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineColorBlendStateCreateInfoBuilder<'a> {
    inner: vk::PipelineColorBlendStateCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineColorBlendStateCreateInfo {
    type Type = PipelineColorBlendStateCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PipelineColorBlendStateCreateInfoNext {}
impl<'a> PipelineColorBlendStateCreateInfoBuilder<'a> {
    pub fn insert_next<T: PipelineColorBlendStateCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PipelineColorBlendStateCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineColorBlendStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn logic_op_enable(mut self, logic_op_enable: bool) -> Self {
        self.inner.logic_op_enable = if logic_op_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn logic_op(mut self, logic_op: vk::LogicOp) -> Self {
        self.inner.logic_op = logic_op;
        self
    }
    pub fn p_attachments(mut self, p_attachments: &'a [vk::PipelineColorBlendAttachmentState]) -> Self {
        self.inner.attachment_count = p_attachments.len() as u32;
        self.inner.p_attachments = p_attachments.as_ptr();
        self
    }
    pub fn blend_constants(mut self, blend_constants: [f32; 4]) -> Self {
        self.inner.blend_constants = blend_constants;
        self
    }
}
impl<'a> Deref for PipelineColorBlendStateCreateInfoBuilder<'a> {
    type Target = vk::PipelineColorBlendStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineDynamicStateCreateInfoBuilder<'a> {
    inner: vk::PipelineDynamicStateCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineDynamicStateCreateInfo {
    type Type = PipelineDynamicStateCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineDynamicStateCreateInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineDynamicStateCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineDynamicStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_dynamic_states(mut self, p_dynamic_states: &'a [vk::DynamicState]) -> Self {
        self.inner.dynamic_state_count = p_dynamic_states.len() as u32;
        self.inner.p_dynamic_states = p_dynamic_states.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineDynamicStateCreateInfoBuilder<'a> {
    type Target = vk::PipelineDynamicStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct StencilOpStateBuilder {
    inner: vk::StencilOpState,
}
impl Builder<'_> for vk::StencilOpState {
    type Type = StencilOpStateBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl StencilOpStateBuilder {
    pub fn get_mut(&mut self) -> &mut vk::StencilOpState {
        &mut self.inner
    }
    pub fn fail_op(mut self, fail_op: vk::StencilOp) -> Self {
        self.inner.fail_op = fail_op;
        self
    }
    pub fn pass_op(mut self, pass_op: vk::StencilOp) -> Self {
        self.inner.pass_op = pass_op;
        self
    }
    pub fn depth_fail_op(mut self, depth_fail_op: vk::StencilOp) -> Self {
        self.inner.depth_fail_op = depth_fail_op;
        self
    }
    pub fn compare_op(mut self, compare_op: vk::CompareOp) -> Self {
        self.inner.compare_op = compare_op;
        self
    }
    pub fn compare_mask(mut self, compare_mask: u32) -> Self {
        self.inner.compare_mask = compare_mask;
        self
    }
    pub fn write_mask(mut self, write_mask: u32) -> Self {
        self.inner.write_mask = write_mask;
        self
    }
    pub fn reference(mut self, reference: u32) -> Self {
        self.inner.reference = reference;
        self
    }
}
impl Deref for StencilOpStateBuilder {
    type Target = vk::StencilOpState;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineDepthStencilStateCreateInfoBuilder {
    inner: vk::PipelineDepthStencilStateCreateInfo,
}
impl Builder<'_> for vk::PipelineDepthStencilStateCreateInfo {
    type Type = PipelineDepthStencilStateCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineDepthStencilStateCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineDepthStencilStateCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineDepthStencilStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn depth_test_enable(mut self, depth_test_enable: bool) -> Self {
        self.inner.depth_test_enable = if depth_test_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn depth_write_enable(mut self, depth_write_enable: bool) -> Self {
        self.inner.depth_write_enable = if depth_write_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn depth_compare_op(mut self, depth_compare_op: vk::CompareOp) -> Self {
        self.inner.depth_compare_op = depth_compare_op;
        self
    }
    pub fn depth_bounds_test_enable(mut self, depth_bounds_test_enable: bool) -> Self {
        self.inner.depth_bounds_test_enable = if depth_bounds_test_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn stencil_test_enable(mut self, stencil_test_enable: bool) -> Self {
        self.inner.stencil_test_enable = if stencil_test_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn front(mut self, front: vk::StencilOpState) -> Self {
        self.inner.front = front;
        self
    }
    pub fn back(mut self, back: vk::StencilOpState) -> Self {
        self.inner.back = back;
        self
    }
    pub fn min_depth_bounds(mut self, min_depth_bounds: f32) -> Self {
        self.inner.min_depth_bounds = min_depth_bounds;
        self
    }
    pub fn max_depth_bounds(mut self, max_depth_bounds: f32) -> Self {
        self.inner.max_depth_bounds = max_depth_bounds;
        self
    }
}
impl Deref for PipelineDepthStencilStateCreateInfoBuilder {
    type Target = vk::PipelineDepthStencilStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct GraphicsPipelineCreateInfoBuilder<'a> {
    inner: vk::GraphicsPipelineCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::GraphicsPipelineCreateInfo {
    type Type = GraphicsPipelineCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait GraphicsPipelineCreateInfoNext {}
impl<'a> GraphicsPipelineCreateInfoBuilder<'a> {
    pub fn insert_next<T: GraphicsPipelineCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::GraphicsPipelineCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn stage_count(mut self, stage_count: u32) -> Self {
        self.inner.stage_count = stage_count;
        self
    }
    pub fn p_stages(mut self, p_stages: &'a [vk::PipelineShaderStageCreateInfo]) -> Self {
        self.inner.stage_count = p_stages.len() as u32;
        self.inner.p_stages = p_stages.as_ptr();
        self
    }
    pub fn p_vertex_input_state(
        mut self,
        p_vertex_input_state: Option<&'a vk::PipelineVertexInputStateCreateInfo>,
    ) -> Self {
        self.inner.p_vertex_input_state = p_vertex_input_state.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_input_assembly_state(
        mut self,
        p_input_assembly_state: Option<&'a vk::PipelineInputAssemblyStateCreateInfo>,
    ) -> Self {
        self.inner.p_input_assembly_state = p_input_assembly_state.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_tessellation_state(
        mut self,
        p_tessellation_state: Option<&'a vk::PipelineTessellationStateCreateInfo>,
    ) -> Self {
        self.inner.p_tessellation_state = p_tessellation_state.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_viewport_state(mut self, p_viewport_state: Option<&'a vk::PipelineViewportStateCreateInfo>) -> Self {
        self.inner.p_viewport_state = p_viewport_state.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_rasterization_state(
        mut self,
        p_rasterization_state: Option<&'a vk::PipelineRasterizationStateCreateInfo>,
    ) -> Self {
        self.inner.p_rasterization_state = p_rasterization_state.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_multisample_state(
        mut self,
        p_multisample_state: Option<&'a vk::PipelineMultisampleStateCreateInfo>,
    ) -> Self {
        self.inner.p_multisample_state = p_multisample_state.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_depth_stencil_state(
        mut self,
        p_depth_stencil_state: Option<&'a vk::PipelineDepthStencilStateCreateInfo>,
    ) -> Self {
        self.inner.p_depth_stencil_state = p_depth_stencil_state.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_color_blend_state(
        mut self,
        p_color_blend_state: Option<&'a vk::PipelineColorBlendStateCreateInfo>,
    ) -> Self {
        self.inner.p_color_blend_state = p_color_blend_state.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_dynamic_state(mut self, p_dynamic_state: Option<&'a vk::PipelineDynamicStateCreateInfo>) -> Self {
        self.inner.p_dynamic_state = p_dynamic_state.map_or(ptr::null(), |r| r);
        self
    }
    pub fn layout(mut self, layout: vk::PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    pub fn render_pass(mut self, render_pass: vk::RenderPass) -> Self {
        self.inner.render_pass = render_pass;
        self
    }
    pub fn subpass(mut self, subpass: u32) -> Self {
        self.inner.subpass = subpass;
        self
    }
    pub fn base_pipeline_handle(mut self, base_pipeline_handle: vk::Pipeline) -> Self {
        self.inner.base_pipeline_handle = base_pipeline_handle;
        self
    }
    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.inner.base_pipeline_index = base_pipeline_index;
        self
    }
}
impl<'a> Deref for GraphicsPipelineCreateInfoBuilder<'a> {
    type Target = vk::GraphicsPipelineCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineCacheCreateInfoBuilder<'a> {
    inner: vk::PipelineCacheCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineCacheCreateInfo {
    type Type = PipelineCacheCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineCacheCreateInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineCacheCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineCacheCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_initial_data(mut self, p_initial_data: &'a [u8]) -> Self {
        self.inner.initial_data_size = p_initial_data.len();
        self.inner.p_initial_data = p_initial_data.as_ptr() as *const _;
        self
    }
}
impl<'a> Deref for PipelineCacheCreateInfoBuilder<'a> {
    type Target = vk::PipelineCacheCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineCacheHeaderVersionOneBuilder {
    inner: vk::PipelineCacheHeaderVersionOne,
}
impl Builder<'_> for vk::PipelineCacheHeaderVersionOne {
    type Type = PipelineCacheHeaderVersionOneBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineCacheHeaderVersionOneBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineCacheHeaderVersionOne {
        &mut self.inner
    }
    pub fn header_size(mut self, header_size: u32) -> Self {
        self.inner.header_size = header_size;
        self
    }
    pub fn header_version(mut self, header_version: vk::PipelineCacheHeaderVersion) -> Self {
        self.inner.header_version = header_version;
        self
    }
    pub fn vendor_id(mut self, vendor_id: u32) -> Self {
        self.inner.vendor_id = vendor_id;
        self
    }
    pub fn device_id(mut self, device_id: u32) -> Self {
        self.inner.device_id = device_id;
        self
    }
    pub fn pipeline_cache_uuid(mut self, pipeline_cache_uuid: [u8; vk::UUID_SIZE]) -> Self {
        self.inner.pipeline_cache_uuid = pipeline_cache_uuid;
        self
    }
}
impl Deref for PipelineCacheHeaderVersionOneBuilder {
    type Target = vk::PipelineCacheHeaderVersionOne;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PushConstantRangeBuilder {
    inner: vk::PushConstantRange,
}
impl Builder<'_> for vk::PushConstantRange {
    type Type = PushConstantRangeBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PushConstantRangeBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PushConstantRange {
        &mut self.inner
    }
    pub fn stage_flags(mut self, stage_flags: vk::ShaderStageFlags) -> Self {
        self.inner.stage_flags = stage_flags;
        self
    }
    pub fn offset(mut self, offset: u32) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn size(mut self, size: u32) -> Self {
        self.inner.size = size;
        self
    }
}
impl Deref for PushConstantRangeBuilder {
    type Target = vk::PushConstantRange;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineBinaryCreateInfoKHRBuilder<'a> {
    inner: vk::PipelineBinaryCreateInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineBinaryCreateInfoKHR {
    type Type = PipelineBinaryCreateInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineBinaryCreateInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineBinaryCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_keys_and_data_info(mut self, p_keys_and_data_info: Option<&'a vk::PipelineBinaryKeysAndDataKHR>) -> Self {
        self.inner.p_keys_and_data_info = p_keys_and_data_info.map_or(ptr::null(), |r| r);
        self
    }
    pub fn pipeline(mut self, pipeline: vk::Pipeline) -> Self {
        self.inner.pipeline = pipeline;
        self
    }
    pub fn p_pipeline_create_info(mut self, p_pipeline_create_info: Option<&'a vk::PipelineCreateInfoKHR>) -> Self {
        self.inner.p_pipeline_create_info = p_pipeline_create_info.map_or(ptr::null(), |r| r);
        self
    }
}
impl<'a> Deref for PipelineBinaryCreateInfoKHRBuilder<'a> {
    type Target = vk::PipelineBinaryCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineBinaryHandlesInfoKHRBuilder<'a> {
    inner: vk::PipelineBinaryHandlesInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineBinaryHandlesInfoKHR {
    type Type = PipelineBinaryHandlesInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineBinaryHandlesInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineBinaryHandlesInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_pipeline_binaries(mut self, p_pipeline_binaries: &'a mut [vk::PipelineBinaryKHR]) -> Self {
        self.inner.pipeline_binary_count = p_pipeline_binaries.len() as u32;
        self.inner.p_pipeline_binaries = p_pipeline_binaries.as_mut_ptr();
        self
    }
}
impl<'a> Deref for PipelineBinaryHandlesInfoKHRBuilder<'a> {
    type Target = vk::PipelineBinaryHandlesInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineBinaryDataKHRBuilder<'a> {
    inner: vk::PipelineBinaryDataKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineBinaryDataKHR {
    type Type = PipelineBinaryDataKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineBinaryDataKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineBinaryDataKHR {
        &mut self.inner
    }
    pub fn p_data(mut self, p_data: &'a mut [u8]) -> Self {
        self.inner.data_size = p_data.len();
        self.inner.p_data = p_data.as_mut_ptr() as *mut _;
        self
    }
}
impl<'a> Deref for PipelineBinaryDataKHRBuilder<'a> {
    type Target = vk::PipelineBinaryDataKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineBinaryKeysAndDataKHRBuilder<'a> {
    inner: vk::PipelineBinaryKeysAndDataKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineBinaryKeysAndDataKHR {
    type Type = PipelineBinaryKeysAndDataKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineBinaryKeysAndDataKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineBinaryKeysAndDataKHR {
        &mut self.inner
    }
    pub fn p_pipeline_binary_keys(
        mut self,
        p_pipeline_binary_keys: &'a [vk::PipelineBinaryKeyKHR],
        p_pipeline_binary_data: &'a [vk::PipelineBinaryDataKHR],
    ) -> Self {
        self.inner.binary_count = p_pipeline_binary_keys.len() as u32;
        assert_eq!(self.inner.binary_count, p_pipeline_binary_data.len() as u32);
        self.inner.p_pipeline_binary_keys = p_pipeline_binary_keys.as_ptr();
        self.inner.p_pipeline_binary_data = p_pipeline_binary_data.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineBinaryKeysAndDataKHRBuilder<'a> {
    type Target = vk::PipelineBinaryKeysAndDataKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineBinaryKeyKHRBuilder {
    inner: vk::PipelineBinaryKeyKHR,
}
impl Builder<'_> for vk::PipelineBinaryKeyKHR {
    type Type = PipelineBinaryKeyKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineBinaryKeyKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineBinaryKeyKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn key_size(mut self, key_size: u32) -> Self {
        self.inner.key_size = key_size;
        self
    }
    pub fn key(mut self, key: [u8; vk::MAX_PIPELINE_BINARY_KEY_SIZE_KHR]) -> Self {
        self.inner.key = key;
        self
    }
}
impl Deref for PipelineBinaryKeyKHRBuilder {
    type Target = vk::PipelineBinaryKeyKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineBinaryInfoKHRBuilder<'a> {
    inner: vk::PipelineBinaryInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineBinaryInfoKHR {
    type Type = PipelineBinaryInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineBinaryInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineBinaryInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_pipeline_binaries(mut self, p_pipeline_binaries: &'a [vk::PipelineBinaryKHR]) -> Self {
        self.inner.binary_count = p_pipeline_binaries.len() as u32;
        self.inner.p_pipeline_binaries = p_pipeline_binaries.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineBinaryInfoKHRBuilder<'a> {
    type Target = vk::PipelineBinaryInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::PipelineBinaryInfoKHR {}
impl GraphicsPipelineCreateInfoNext for PipelineBinaryInfoKHRBuilder<'_> {}
impl ComputePipelineCreateInfoNext for vk::PipelineBinaryInfoKHR {}
impl ComputePipelineCreateInfoNext for PipelineBinaryInfoKHRBuilder<'_> {}
impl RayTracingPipelineCreateInfoKHRNext for vk::PipelineBinaryInfoKHR {}
impl RayTracingPipelineCreateInfoKHRNext for PipelineBinaryInfoKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ReleaseCapturedPipelineDataInfoKHRBuilder {
    inner: vk::ReleaseCapturedPipelineDataInfoKHR,
}
impl Builder<'_> for vk::ReleaseCapturedPipelineDataInfoKHR {
    type Type = ReleaseCapturedPipelineDataInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ReleaseCapturedPipelineDataInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ReleaseCapturedPipelineDataInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline(mut self, pipeline: vk::Pipeline) -> Self {
        self.inner.pipeline = pipeline;
        self
    }
}
impl Deref for ReleaseCapturedPipelineDataInfoKHRBuilder {
    type Target = vk::ReleaseCapturedPipelineDataInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineBinaryDataInfoKHRBuilder {
    inner: vk::PipelineBinaryDataInfoKHR,
}
impl Builder<'_> for vk::PipelineBinaryDataInfoKHR {
    type Type = PipelineBinaryDataInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineBinaryDataInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineBinaryDataInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline_binary(mut self, pipeline_binary: vk::PipelineBinaryKHR) -> Self {
        self.inner.pipeline_binary = pipeline_binary;
        self
    }
}
impl Deref for PipelineBinaryDataInfoKHRBuilder {
    type Target = vk::PipelineBinaryDataInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineCreateInfoKHRBuilder {
    inner: vk::PipelineCreateInfoKHR,
}
impl Builder<'_> for vk::PipelineCreateInfoKHR {
    type Type = PipelineCreateInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineCreateInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
}
impl Deref for PipelineCreateInfoKHRBuilder {
    type Target = vk::PipelineCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineLayoutCreateInfoBuilder<'a> {
    inner: vk::PipelineLayoutCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineLayoutCreateInfo {
    type Type = PipelineLayoutCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineLayoutCreateInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineLayoutCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineLayoutCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_set_layouts(mut self, p_set_layouts: &'a [vk::DescriptorSetLayout]) -> Self {
        self.inner.set_layout_count = p_set_layouts.len() as u32;
        self.inner.p_set_layouts = p_set_layouts.as_ptr();
        self
    }
    pub fn p_push_constant_ranges(mut self, p_push_constant_ranges: &'a [vk::PushConstantRange]) -> Self {
        self.inner.push_constant_range_count = p_push_constant_ranges.len() as u32;
        self.inner.p_push_constant_ranges = p_push_constant_ranges.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineLayoutCreateInfoBuilder<'a> {
    type Target = vk::PipelineLayoutCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BindDescriptorSetsInfoNext for vk::PipelineLayoutCreateInfo {}
impl BindDescriptorSetsInfoNext for PipelineLayoutCreateInfoBuilder<'_> {}
impl PushConstantsInfoNext for vk::PipelineLayoutCreateInfo {}
impl PushConstantsInfoNext for PipelineLayoutCreateInfoBuilder<'_> {}
impl PushDescriptorSetInfoNext for vk::PipelineLayoutCreateInfo {}
impl PushDescriptorSetInfoNext for PipelineLayoutCreateInfoBuilder<'_> {}
impl PushDescriptorSetWithTemplateInfoNext for vk::PipelineLayoutCreateInfo {}
impl PushDescriptorSetWithTemplateInfoNext for PipelineLayoutCreateInfoBuilder<'_> {}
impl SetDescriptorBufferOffsetsInfoEXTNext for vk::PipelineLayoutCreateInfo {}
impl SetDescriptorBufferOffsetsInfoEXTNext for PipelineLayoutCreateInfoBuilder<'_> {}
impl BindDescriptorBufferEmbeddedSamplersInfoEXTNext for vk::PipelineLayoutCreateInfo {}
impl BindDescriptorBufferEmbeddedSamplersInfoEXTNext for PipelineLayoutCreateInfoBuilder<'_> {}
impl IndirectCommandsLayoutCreateInfoEXTNext for vk::PipelineLayoutCreateInfo {}
impl IndirectCommandsLayoutCreateInfoEXTNext for PipelineLayoutCreateInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct SamplerCreateInfoBuilder<'a> {
    inner: vk::SamplerCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SamplerCreateInfo {
    type Type = SamplerCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait SamplerCreateInfoNext {}
impl<'a> SamplerCreateInfoBuilder<'a> {
    pub fn insert_next<T: SamplerCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::SamplerCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::SamplerCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn mag_filter(mut self, mag_filter: vk::Filter) -> Self {
        self.inner.mag_filter = mag_filter;
        self
    }
    pub fn min_filter(mut self, min_filter: vk::Filter) -> Self {
        self.inner.min_filter = min_filter;
        self
    }
    pub fn mipmap_mode(mut self, mipmap_mode: vk::SamplerMipmapMode) -> Self {
        self.inner.mipmap_mode = mipmap_mode;
        self
    }
    pub fn address_mode_u(mut self, address_mode_u: vk::SamplerAddressMode) -> Self {
        self.inner.address_mode_u = address_mode_u;
        self
    }
    pub fn address_mode_v(mut self, address_mode_v: vk::SamplerAddressMode) -> Self {
        self.inner.address_mode_v = address_mode_v;
        self
    }
    pub fn address_mode_w(mut self, address_mode_w: vk::SamplerAddressMode) -> Self {
        self.inner.address_mode_w = address_mode_w;
        self
    }
    pub fn mip_lod_bias(mut self, mip_lod_bias: f32) -> Self {
        self.inner.mip_lod_bias = mip_lod_bias;
        self
    }
    pub fn anisotropy_enable(mut self, anisotropy_enable: bool) -> Self {
        self.inner.anisotropy_enable = if anisotropy_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn max_anisotropy(mut self, max_anisotropy: f32) -> Self {
        self.inner.max_anisotropy = max_anisotropy;
        self
    }
    pub fn compare_enable(mut self, compare_enable: bool) -> Self {
        self.inner.compare_enable = if compare_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn compare_op(mut self, compare_op: vk::CompareOp) -> Self {
        self.inner.compare_op = compare_op;
        self
    }
    pub fn min_lod(mut self, min_lod: f32) -> Self {
        self.inner.min_lod = min_lod;
        self
    }
    pub fn max_lod(mut self, max_lod: f32) -> Self {
        self.inner.max_lod = max_lod;
        self
    }
    pub fn border_color(mut self, border_color: vk::BorderColor) -> Self {
        self.inner.border_color = border_color;
        self
    }
    pub fn unnormalized_coordinates(mut self, unnormalized_coordinates: bool) -> Self {
        self.inner.unnormalized_coordinates = if unnormalized_coordinates { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl<'a> Deref for SamplerCreateInfoBuilder<'a> {
    type Target = vk::SamplerCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CommandPoolCreateInfoBuilder<'a> {
    inner: vk::CommandPoolCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CommandPoolCreateInfo {
    type Type = CommandPoolCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait CommandPoolCreateInfoNext {}
impl<'a> CommandPoolCreateInfoBuilder<'a> {
    pub fn insert_next<T: CommandPoolCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::CommandPoolCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::CommandPoolCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.inner.queue_family_index = queue_family_index;
        self
    }
}
impl<'a> Deref for CommandPoolCreateInfoBuilder<'a> {
    type Target = vk::CommandPoolCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CommandBufferAllocateInfoBuilder {
    inner: vk::CommandBufferAllocateInfo,
}
impl Builder<'_> for vk::CommandBufferAllocateInfo {
    type Type = CommandBufferAllocateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CommandBufferAllocateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CommandBufferAllocateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn command_pool(mut self, command_pool: vk::CommandPool) -> Self {
        self.inner.command_pool = command_pool;
        self
    }
    pub fn level(mut self, level: vk::CommandBufferLevel) -> Self {
        self.inner.level = level;
        self
    }
    pub fn command_buffer_count(mut self, command_buffer_count: u32) -> Self {
        self.inner.command_buffer_count = command_buffer_count;
        self
    }
}
impl Deref for CommandBufferAllocateInfoBuilder {
    type Target = vk::CommandBufferAllocateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CommandBufferInheritanceInfoBuilder<'a> {
    inner: vk::CommandBufferInheritanceInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CommandBufferInheritanceInfo {
    type Type = CommandBufferInheritanceInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait CommandBufferInheritanceInfoNext {}
impl<'a> CommandBufferInheritanceInfoBuilder<'a> {
    pub fn insert_next<T: CommandBufferInheritanceInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::CommandBufferInheritanceInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn render_pass(mut self, render_pass: vk::RenderPass) -> Self {
        self.inner.render_pass = render_pass;
        self
    }
    pub fn subpass(mut self, subpass: u32) -> Self {
        self.inner.subpass = subpass;
        self
    }
    pub fn framebuffer(mut self, framebuffer: vk::Framebuffer) -> Self {
        self.inner.framebuffer = framebuffer;
        self
    }
    pub fn occlusion_query_enable(mut self, occlusion_query_enable: bool) -> Self {
        self.inner.occlusion_query_enable = if occlusion_query_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn query_flags(mut self, query_flags: vk::QueryControlFlags) -> Self {
        self.inner.query_flags = query_flags;
        self
    }
    pub fn pipeline_statistics(mut self, pipeline_statistics: vk::QueryPipelineStatisticFlags) -> Self {
        self.inner.pipeline_statistics = pipeline_statistics;
        self
    }
}
impl<'a> Deref for CommandBufferInheritanceInfoBuilder<'a> {
    type Target = vk::CommandBufferInheritanceInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CommandBufferBeginInfoBuilder<'a> {
    inner: vk::CommandBufferBeginInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CommandBufferBeginInfo {
    type Type = CommandBufferBeginInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait CommandBufferBeginInfoNext {}
impl<'a> CommandBufferBeginInfoBuilder<'a> {
    pub fn insert_next<T: CommandBufferBeginInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::CommandBufferBeginInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::CommandBufferUsageFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_inheritance_info(mut self, p_inheritance_info: Option<&'a vk::CommandBufferInheritanceInfo>) -> Self {
        self.inner.p_inheritance_info = p_inheritance_info.map_or(ptr::null(), |r| r);
        self
    }
}
impl<'a> Deref for CommandBufferBeginInfoBuilder<'a> {
    type Target = vk::CommandBufferBeginInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassBeginInfoBuilder<'a> {
    inner: vk::RenderPassBeginInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderPassBeginInfo {
    type Type = RenderPassBeginInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait RenderPassBeginInfoNext {}
impl<'a> RenderPassBeginInfoBuilder<'a> {
    pub fn insert_next<T: RenderPassBeginInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::RenderPassBeginInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn render_pass(mut self, render_pass: vk::RenderPass) -> Self {
        self.inner.render_pass = render_pass;
        self
    }
    pub fn framebuffer(mut self, framebuffer: vk::Framebuffer) -> Self {
        self.inner.framebuffer = framebuffer;
        self
    }
    pub fn render_area(mut self, render_area: vk::Rect2D) -> Self {
        self.inner.render_area = render_area;
        self
    }
    pub fn clear_value_count(mut self, clear_value_count: u32) -> Self {
        self.inner.clear_value_count = clear_value_count;
        self
    }
    pub fn p_clear_values(mut self, p_clear_values: &'a [vk::ClearValue]) -> Self {
        self.inner.clear_value_count = p_clear_values.len() as u32;
        self.inner.p_clear_values = p_clear_values.as_ptr();
        self
    }
}
impl<'a> Deref for RenderPassBeginInfoBuilder<'a> {
    type Target = vk::RenderPassBeginInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ClearDepthStencilValueBuilder {
    inner: vk::ClearDepthStencilValue,
}
impl Builder<'_> for vk::ClearDepthStencilValue {
    type Type = ClearDepthStencilValueBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClearDepthStencilValueBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClearDepthStencilValue {
        &mut self.inner
    }
    pub fn depth(mut self, depth: f32) -> Self {
        self.inner.depth = depth;
        self
    }
    pub fn stencil(mut self, stencil: u32) -> Self {
        self.inner.stencil = stencil;
        self
    }
}
impl Deref for ClearDepthStencilValueBuilder {
    type Target = vk::ClearDepthStencilValue;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ClearAttachmentBuilder {
    inner: vk::ClearAttachment,
}
impl Builder<'_> for vk::ClearAttachment {
    type Type = ClearAttachmentBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClearAttachmentBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClearAttachment {
        &mut self.inner
    }
    pub fn aspect_mask(mut self, aspect_mask: vk::ImageAspectFlags) -> Self {
        self.inner.aspect_mask = aspect_mask;
        self
    }
    pub fn color_attachment(mut self, color_attachment: u32) -> Self {
        self.inner.color_attachment = color_attachment;
        self
    }
    pub fn clear_value(mut self, clear_value: vk::ClearValue) -> Self {
        self.inner.clear_value = clear_value;
        self
    }
}
impl Deref for ClearAttachmentBuilder {
    type Target = vk::ClearAttachment;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AttachmentDescriptionBuilder {
    inner: vk::AttachmentDescription,
}
impl Builder<'_> for vk::AttachmentDescription {
    type Type = AttachmentDescriptionBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AttachmentDescriptionBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AttachmentDescription {
        &mut self.inner
    }
    pub fn flags(mut self, flags: vk::AttachmentDescriptionFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn format(mut self, format: vk::Format) -> Self {
        self.inner.format = format;
        self
    }
    pub fn samples(mut self, samples: vk::SampleCountFlags) -> Self {
        self.inner.samples = samples;
        self
    }
    pub fn load_op(mut self, load_op: vk::AttachmentLoadOp) -> Self {
        self.inner.load_op = load_op;
        self
    }
    pub fn store_op(mut self, store_op: vk::AttachmentStoreOp) -> Self {
        self.inner.store_op = store_op;
        self
    }
    pub fn stencil_load_op(mut self, stencil_load_op: vk::AttachmentLoadOp) -> Self {
        self.inner.stencil_load_op = stencil_load_op;
        self
    }
    pub fn stencil_store_op(mut self, stencil_store_op: vk::AttachmentStoreOp) -> Self {
        self.inner.stencil_store_op = stencil_store_op;
        self
    }
    pub fn initial_layout(mut self, initial_layout: vk::ImageLayout) -> Self {
        self.inner.initial_layout = initial_layout;
        self
    }
    pub fn final_layout(mut self, final_layout: vk::ImageLayout) -> Self {
        self.inner.final_layout = final_layout;
        self
    }
}
impl Deref for AttachmentDescriptionBuilder {
    type Target = vk::AttachmentDescription;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AttachmentReferenceBuilder {
    inner: vk::AttachmentReference,
}
impl Builder<'_> for vk::AttachmentReference {
    type Type = AttachmentReferenceBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AttachmentReferenceBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AttachmentReference {
        &mut self.inner
    }
    pub fn attachment(mut self, attachment: u32) -> Self {
        self.inner.attachment = attachment;
        self
    }
    pub fn layout(mut self, layout: vk::ImageLayout) -> Self {
        self.inner.layout = layout;
        self
    }
}
impl Deref for AttachmentReferenceBuilder {
    type Target = vk::AttachmentReference;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SubpassDescriptionBuilder<'a> {
    inner: vk::SubpassDescription,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SubpassDescription {
    type Type = SubpassDescriptionBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> SubpassDescriptionBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::SubpassDescription {
        &mut self.inner
    }
    pub fn flags(mut self, flags: vk::SubpassDescriptionFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: vk::PipelineBindPoint) -> Self {
        self.inner.pipeline_bind_point = pipeline_bind_point;
        self
    }
    pub fn p_input_attachments(mut self, p_input_attachments: &'a [vk::AttachmentReference]) -> Self {
        self.inner.input_attachment_count = p_input_attachments.len() as u32;
        self.inner.p_input_attachments = p_input_attachments.as_ptr();
        self
    }
    pub fn p_color_attachments(
        mut self,
        p_color_attachments: &'a [vk::AttachmentReference],
        p_resolve_attachments: Option<&'a [vk::AttachmentReference]>,
    ) -> Self {
        self.inner.color_attachment_count = p_color_attachments.len() as u32;
        self.inner.p_color_attachments = p_color_attachments.as_ptr();
        self.inner.p_resolve_attachments = p_resolve_attachments.map_or(ptr::null(), |s| s.as_ptr());
        self
    }
    pub fn p_depth_stencil_attachment(
        mut self,
        p_depth_stencil_attachment: Option<&'a vk::AttachmentReference>,
    ) -> Self {
        self.inner.p_depth_stencil_attachment = p_depth_stencil_attachment.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_preserve_attachments(mut self, p_preserve_attachments: &'a [u32]) -> Self {
        self.inner.preserve_attachment_count = p_preserve_attachments.len() as u32;
        self.inner.p_preserve_attachments = p_preserve_attachments.as_ptr();
        self
    }
}
impl<'a> Deref for SubpassDescriptionBuilder<'a> {
    type Target = vk::SubpassDescription;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SubpassDependencyBuilder {
    inner: vk::SubpassDependency,
}
impl Builder<'_> for vk::SubpassDependency {
    type Type = SubpassDependencyBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SubpassDependencyBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SubpassDependency {
        &mut self.inner
    }
    pub fn src_subpass(mut self, src_subpass: u32) -> Self {
        self.inner.src_subpass = src_subpass;
        self
    }
    pub fn dst_subpass(mut self, dst_subpass: u32) -> Self {
        self.inner.dst_subpass = dst_subpass;
        self
    }
    pub fn src_stage_mask(mut self, src_stage_mask: vk::PipelineStageFlags) -> Self {
        self.inner.src_stage_mask = src_stage_mask;
        self
    }
    pub fn dst_stage_mask(mut self, dst_stage_mask: vk::PipelineStageFlags) -> Self {
        self.inner.dst_stage_mask = dst_stage_mask;
        self
    }
    pub fn src_access_mask(mut self, src_access_mask: vk::AccessFlags) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    pub fn dst_access_mask(mut self, dst_access_mask: vk::AccessFlags) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    pub fn dependency_flags(mut self, dependency_flags: vk::DependencyFlags) -> Self {
        self.inner.dependency_flags = dependency_flags;
        self
    }
}
impl Deref for SubpassDependencyBuilder {
    type Target = vk::SubpassDependency;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassCreateInfoBuilder<'a> {
    inner: vk::RenderPassCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderPassCreateInfo {
    type Type = RenderPassCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait RenderPassCreateInfoNext {}
impl<'a> RenderPassCreateInfoBuilder<'a> {
    pub fn insert_next<T: RenderPassCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::RenderPassCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::RenderPassCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_attachments(mut self, p_attachments: &'a [vk::AttachmentDescription]) -> Self {
        self.inner.attachment_count = p_attachments.len() as u32;
        self.inner.p_attachments = p_attachments.as_ptr();
        self
    }
    pub fn p_subpasses(mut self, p_subpasses: &'a [vk::SubpassDescription]) -> Self {
        self.inner.subpass_count = p_subpasses.len() as u32;
        self.inner.p_subpasses = p_subpasses.as_ptr();
        self
    }
    pub fn p_dependencies(mut self, p_dependencies: &'a [vk::SubpassDependency]) -> Self {
        self.inner.dependency_count = p_dependencies.len() as u32;
        self.inner.p_dependencies = p_dependencies.as_ptr();
        self
    }
}
impl<'a> Deref for RenderPassCreateInfoBuilder<'a> {
    type Target = vk::RenderPassCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct EventCreateInfoBuilder<'a> {
    inner: vk::EventCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::EventCreateInfo {
    type Type = EventCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait EventCreateInfoNext {}
impl<'a> EventCreateInfoBuilder<'a> {
    pub fn insert_next<T: EventCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::EventCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::EventCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl<'a> Deref for EventCreateInfoBuilder<'a> {
    type Target = vk::EventCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct FenceCreateInfoBuilder<'a> {
    inner: vk::FenceCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::FenceCreateInfo {
    type Type = FenceCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait FenceCreateInfoNext {}
impl<'a> FenceCreateInfoBuilder<'a> {
    pub fn insert_next<T: FenceCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::FenceCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::FenceCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl<'a> Deref for FenceCreateInfoBuilder<'a> {
    type Target = vk::FenceCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceFeaturesBuilder {
    inner: vk::PhysicalDeviceFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceFeatures {
    type Type = PhysicalDeviceFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceFeatures {
        &mut self.inner
    }
    pub fn robust_buffer_access(mut self, robust_buffer_access: bool) -> Self {
        self.inner.robust_buffer_access = if robust_buffer_access { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn full_draw_index_uint32(mut self, full_draw_index_uint32: bool) -> Self {
        self.inner.full_draw_index_uint32 = if full_draw_index_uint32 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn image_cube_array(mut self, image_cube_array: bool) -> Self {
        self.inner.image_cube_array = if image_cube_array { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn independent_blend(mut self, independent_blend: bool) -> Self {
        self.inner.independent_blend = if independent_blend { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn geometry_shader(mut self, geometry_shader: bool) -> Self {
        self.inner.geometry_shader = if geometry_shader { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn tessellation_shader(mut self, tessellation_shader: bool) -> Self {
        self.inner.tessellation_shader = if tessellation_shader { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sample_rate_shading(mut self, sample_rate_shading: bool) -> Self {
        self.inner.sample_rate_shading = if sample_rate_shading { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn dual_src_blend(mut self, dual_src_blend: bool) -> Self {
        self.inner.dual_src_blend = if dual_src_blend { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn logic_op(mut self, logic_op: bool) -> Self {
        self.inner.logic_op = if logic_op { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn multi_draw_indirect(mut self, multi_draw_indirect: bool) -> Self {
        self.inner.multi_draw_indirect = if multi_draw_indirect { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn draw_indirect_first_instance(mut self, draw_indirect_first_instance: bool) -> Self {
        self.inner.draw_indirect_first_instance = if draw_indirect_first_instance {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn depth_clamp(mut self, depth_clamp: bool) -> Self {
        self.inner.depth_clamp = if depth_clamp { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn depth_bias_clamp(mut self, depth_bias_clamp: bool) -> Self {
        self.inner.depth_bias_clamp = if depth_bias_clamp { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn fill_mode_non_solid(mut self, fill_mode_non_solid: bool) -> Self {
        self.inner.fill_mode_non_solid = if fill_mode_non_solid { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn depth_bounds(mut self, depth_bounds: bool) -> Self {
        self.inner.depth_bounds = if depth_bounds { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn wide_lines(mut self, wide_lines: bool) -> Self {
        self.inner.wide_lines = if wide_lines { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn large_points(mut self, large_points: bool) -> Self {
        self.inner.large_points = if large_points { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn alpha_to_one(mut self, alpha_to_one: bool) -> Self {
        self.inner.alpha_to_one = if alpha_to_one { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn multi_viewport(mut self, multi_viewport: bool) -> Self {
        self.inner.multi_viewport = if multi_viewport { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sampler_anisotropy(mut self, sampler_anisotropy: bool) -> Self {
        self.inner.sampler_anisotropy = if sampler_anisotropy { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn texture_compression_etc2(mut self, texture_compression_etc2: bool) -> Self {
        self.inner.texture_compression_etc2 = if texture_compression_etc2 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn texture_compression_astc_ldr(mut self, texture_compression_astc_ldr: bool) -> Self {
        self.inner.texture_compression_astc_ldr = if texture_compression_astc_ldr {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn texture_compression_bc(mut self, texture_compression_bc: bool) -> Self {
        self.inner.texture_compression_bc = if texture_compression_bc { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn occlusion_query_precise(mut self, occlusion_query_precise: bool) -> Self {
        self.inner.occlusion_query_precise = if occlusion_query_precise { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn pipeline_statistics_query(mut self, pipeline_statistics_query: bool) -> Self {
        self.inner.pipeline_statistics_query = if pipeline_statistics_query { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn vertex_pipeline_stores_and_atomics(mut self, vertex_pipeline_stores_and_atomics: bool) -> Self {
        self.inner.vertex_pipeline_stores_and_atomics = if vertex_pipeline_stores_and_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn fragment_stores_and_atomics(mut self, fragment_stores_and_atomics: bool) -> Self {
        self.inner.fragment_stores_and_atomics = if fragment_stores_and_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_tessellation_and_geometry_point_size(
        mut self,
        shader_tessellation_and_geometry_point_size: bool,
    ) -> Self {
        self.inner.shader_tessellation_and_geometry_point_size = if shader_tessellation_and_geometry_point_size {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_image_gather_extended(mut self, shader_image_gather_extended: bool) -> Self {
        self.inner.shader_image_gather_extended = if shader_image_gather_extended {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_storage_image_extended_formats(mut self, shader_storage_image_extended_formats: bool) -> Self {
        self.inner.shader_storage_image_extended_formats = if shader_storage_image_extended_formats {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_storage_image_multisample(mut self, shader_storage_image_multisample: bool) -> Self {
        self.inner.shader_storage_image_multisample = if shader_storage_image_multisample {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_storage_image_read_without_format(mut self, shader_storage_image_read_without_format: bool) -> Self {
        self.inner.shader_storage_image_read_without_format = if shader_storage_image_read_without_format {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_storage_image_write_without_format(
        mut self,
        shader_storage_image_write_without_format: bool,
    ) -> Self {
        self.inner.shader_storage_image_write_without_format = if shader_storage_image_write_without_format {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_uniform_buffer_array_dynamic_indexing(
        mut self,
        shader_uniform_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_uniform_buffer_array_dynamic_indexing = if shader_uniform_buffer_array_dynamic_indexing {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_sampled_image_array_dynamic_indexing(
        mut self,
        shader_sampled_image_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_sampled_image_array_dynamic_indexing = if shader_sampled_image_array_dynamic_indexing {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_storage_buffer_array_dynamic_indexing(
        mut self,
        shader_storage_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_buffer_array_dynamic_indexing = if shader_storage_buffer_array_dynamic_indexing {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_storage_image_array_dynamic_indexing(
        mut self,
        shader_storage_image_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_image_array_dynamic_indexing = if shader_storage_image_array_dynamic_indexing {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_clip_distance(mut self, shader_clip_distance: bool) -> Self {
        self.inner.shader_clip_distance = if shader_clip_distance { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_cull_distance(mut self, shader_cull_distance: bool) -> Self {
        self.inner.shader_cull_distance = if shader_cull_distance { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_float64(mut self, shader_float64: bool) -> Self {
        self.inner.shader_float64 = if shader_float64 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_int64(mut self, shader_int64: bool) -> Self {
        self.inner.shader_int64 = if shader_int64 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_int16(mut self, shader_int16: bool) -> Self {
        self.inner.shader_int16 = if shader_int16 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_resource_residency(mut self, shader_resource_residency: bool) -> Self {
        self.inner.shader_resource_residency = if shader_resource_residency { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_resource_min_lod(mut self, shader_resource_min_lod: bool) -> Self {
        self.inner.shader_resource_min_lod = if shader_resource_min_lod { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sparse_binding(mut self, sparse_binding: bool) -> Self {
        self.inner.sparse_binding = if sparse_binding { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sparse_residency_buffer(mut self, sparse_residency_buffer: bool) -> Self {
        self.inner.sparse_residency_buffer = if sparse_residency_buffer { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sparse_residency_image_2d(mut self, sparse_residency_image_2d: bool) -> Self {
        self.inner.sparse_residency_image_2d = if sparse_residency_image_2d { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sparse_residency_image_3d(mut self, sparse_residency_image_3d: bool) -> Self {
        self.inner.sparse_residency_image_3d = if sparse_residency_image_3d { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sparse_residency2_samples(mut self, sparse_residency2_samples: bool) -> Self {
        self.inner.sparse_residency2_samples = if sparse_residency2_samples { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sparse_residency4_samples(mut self, sparse_residency4_samples: bool) -> Self {
        self.inner.sparse_residency4_samples = if sparse_residency4_samples { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sparse_residency8_samples(mut self, sparse_residency8_samples: bool) -> Self {
        self.inner.sparse_residency8_samples = if sparse_residency8_samples { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sparse_residency16_samples(mut self, sparse_residency16_samples: bool) -> Self {
        self.inner.sparse_residency16_samples = if sparse_residency16_samples {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn sparse_residency_aliased(mut self, sparse_residency_aliased: bool) -> Self {
        self.inner.sparse_residency_aliased = if sparse_residency_aliased { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn variable_multisample_rate(mut self, variable_multisample_rate: bool) -> Self {
        self.inner.variable_multisample_rate = if variable_multisample_rate { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn inherited_queries(mut self, inherited_queries: bool) -> Self {
        self.inner.inherited_queries = if inherited_queries { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceFeaturesBuilder {
    type Target = vk::PhysicalDeviceFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SemaphoreCreateInfoBuilder<'a> {
    inner: vk::SemaphoreCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SemaphoreCreateInfo {
    type Type = SemaphoreCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait SemaphoreCreateInfoNext {}
impl<'a> SemaphoreCreateInfoBuilder<'a> {
    pub fn insert_next<T: SemaphoreCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::SemaphoreCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::SemaphoreCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl<'a> Deref for SemaphoreCreateInfoBuilder<'a> {
    type Target = vk::SemaphoreCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct QueryPoolCreateInfoBuilder<'a> {
    inner: vk::QueryPoolCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::QueryPoolCreateInfo {
    type Type = QueryPoolCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait QueryPoolCreateInfoNext {}
impl<'a> QueryPoolCreateInfoBuilder<'a> {
    pub fn insert_next<T: QueryPoolCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::QueryPoolCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::QueryPoolCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn query_type(mut self, query_type: vk::QueryType) -> Self {
        self.inner.query_type = query_type;
        self
    }
    pub fn query_count(mut self, query_count: u32) -> Self {
        self.inner.query_count = query_count;
        self
    }
    pub fn pipeline_statistics(mut self, pipeline_statistics: vk::QueryPipelineStatisticFlags) -> Self {
        self.inner.pipeline_statistics = pipeline_statistics;
        self
    }
}
impl<'a> Deref for QueryPoolCreateInfoBuilder<'a> {
    type Target = vk::QueryPoolCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct FramebufferCreateInfoBuilder<'a> {
    inner: vk::FramebufferCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::FramebufferCreateInfo {
    type Type = FramebufferCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait FramebufferCreateInfoNext {}
impl<'a> FramebufferCreateInfoBuilder<'a> {
    pub fn insert_next<T: FramebufferCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::FramebufferCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::FramebufferCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn render_pass(mut self, render_pass: vk::RenderPass) -> Self {
        self.inner.render_pass = render_pass;
        self
    }
    pub fn attachment_count(mut self, attachment_count: u32) -> Self {
        self.inner.attachment_count = attachment_count;
        self
    }
    pub fn p_attachments(mut self, p_attachments: &'a [vk::ImageView]) -> Self {
        self.inner.attachment_count = p_attachments.len() as u32;
        self.inner.p_attachments = p_attachments.as_ptr();
        self
    }
    pub fn width(mut self, width: u32) -> Self {
        self.inner.width = width;
        self
    }
    pub fn height(mut self, height: u32) -> Self {
        self.inner.height = height;
        self
    }
    pub fn layers(mut self, layers: u32) -> Self {
        self.inner.layers = layers;
        self
    }
}
impl<'a> Deref for FramebufferCreateInfoBuilder<'a> {
    type Target = vk::FramebufferCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DrawIndirectCommandBuilder {
    inner: vk::DrawIndirectCommand,
}
impl Builder<'_> for vk::DrawIndirectCommand {
    type Type = DrawIndirectCommandBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DrawIndirectCommandBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DrawIndirectCommand {
        &mut self.inner
    }
    pub fn vertex_count(mut self, vertex_count: u32) -> Self {
        self.inner.vertex_count = vertex_count;
        self
    }
    pub fn instance_count(mut self, instance_count: u32) -> Self {
        self.inner.instance_count = instance_count;
        self
    }
    pub fn first_vertex(mut self, first_vertex: u32) -> Self {
        self.inner.first_vertex = first_vertex;
        self
    }
    pub fn first_instance(mut self, first_instance: u32) -> Self {
        self.inner.first_instance = first_instance;
        self
    }
}
impl Deref for DrawIndirectCommandBuilder {
    type Target = vk::DrawIndirectCommand;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DrawIndexedIndirectCommandBuilder {
    inner: vk::DrawIndexedIndirectCommand,
}
impl Builder<'_> for vk::DrawIndexedIndirectCommand {
    type Type = DrawIndexedIndirectCommandBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DrawIndexedIndirectCommandBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DrawIndexedIndirectCommand {
        &mut self.inner
    }
    pub fn index_count(mut self, index_count: u32) -> Self {
        self.inner.index_count = index_count;
        self
    }
    pub fn instance_count(mut self, instance_count: u32) -> Self {
        self.inner.instance_count = instance_count;
        self
    }
    pub fn first_index(mut self, first_index: u32) -> Self {
        self.inner.first_index = first_index;
        self
    }
    pub fn vertex_offset(mut self, vertex_offset: i32) -> Self {
        self.inner.vertex_offset = vertex_offset;
        self
    }
    pub fn first_instance(mut self, first_instance: u32) -> Self {
        self.inner.first_instance = first_instance;
        self
    }
}
impl Deref for DrawIndexedIndirectCommandBuilder {
    type Target = vk::DrawIndexedIndirectCommand;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DispatchIndirectCommandBuilder {
    inner: vk::DispatchIndirectCommand,
}
impl Builder<'_> for vk::DispatchIndirectCommand {
    type Type = DispatchIndirectCommandBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DispatchIndirectCommandBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DispatchIndirectCommand {
        &mut self.inner
    }
    pub fn x(mut self, x: u32) -> Self {
        self.inner.x = x;
        self
    }
    pub fn y(mut self, y: u32) -> Self {
        self.inner.y = y;
        self
    }
    pub fn z(mut self, z: u32) -> Self {
        self.inner.z = z;
        self
    }
}
impl Deref for DispatchIndirectCommandBuilder {
    type Target = vk::DispatchIndirectCommand;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MultiDrawInfoEXTBuilder {
    inner: vk::MultiDrawInfoEXT,
}
impl Builder<'_> for vk::MultiDrawInfoEXT {
    type Type = MultiDrawInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MultiDrawInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MultiDrawInfoEXT {
        &mut self.inner
    }
    pub fn first_vertex(mut self, first_vertex: u32) -> Self {
        self.inner.first_vertex = first_vertex;
        self
    }
    pub fn vertex_count(mut self, vertex_count: u32) -> Self {
        self.inner.vertex_count = vertex_count;
        self
    }
}
impl Deref for MultiDrawInfoEXTBuilder {
    type Target = vk::MultiDrawInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MultiDrawIndexedInfoEXTBuilder {
    inner: vk::MultiDrawIndexedInfoEXT,
}
impl Builder<'_> for vk::MultiDrawIndexedInfoEXT {
    type Type = MultiDrawIndexedInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MultiDrawIndexedInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MultiDrawIndexedInfoEXT {
        &mut self.inner
    }
    pub fn first_index(mut self, first_index: u32) -> Self {
        self.inner.first_index = first_index;
        self
    }
    pub fn index_count(mut self, index_count: u32) -> Self {
        self.inner.index_count = index_count;
        self
    }
    pub fn vertex_offset(mut self, vertex_offset: i32) -> Self {
        self.inner.vertex_offset = vertex_offset;
        self
    }
}
impl Deref for MultiDrawIndexedInfoEXTBuilder {
    type Target = vk::MultiDrawIndexedInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SubmitInfoBuilder<'a> {
    inner: vk::SubmitInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SubmitInfo {
    type Type = SubmitInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait SubmitInfoNext {}
impl<'a> SubmitInfoBuilder<'a> {
    pub fn insert_next<T: SubmitInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::SubmitInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_wait_semaphores(
        mut self,
        p_wait_semaphores: &'a [vk::Semaphore],
        p_wait_dst_stage_mask: &'a [vk::PipelineStageFlags],
    ) -> Self {
        self.inner.wait_semaphore_count = p_wait_semaphores.len() as u32;
        assert_eq!(self.inner.wait_semaphore_count, p_wait_dst_stage_mask.len() as u32);
        self.inner.p_wait_semaphores = p_wait_semaphores.as_ptr();
        self.inner.p_wait_dst_stage_mask = p_wait_dst_stage_mask.as_ptr();
        self
    }
    pub fn p_command_buffers(mut self, p_command_buffers: &'a [vk::CommandBuffer]) -> Self {
        self.inner.command_buffer_count = p_command_buffers.len() as u32;
        self.inner.p_command_buffers = p_command_buffers.as_ptr();
        self
    }
    pub fn p_signal_semaphores(mut self, p_signal_semaphores: &'a [vk::Semaphore]) -> Self {
        self.inner.signal_semaphore_count = p_signal_semaphores.len() as u32;
        self.inner.p_signal_semaphores = p_signal_semaphores.as_ptr();
        self
    }
}
impl<'a> Deref for SubmitInfoBuilder<'a> {
    type Target = vk::SubmitInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DisplayModeParametersKHRBuilder {
    inner: vk::DisplayModeParametersKHR,
}
impl Builder<'_> for vk::DisplayModeParametersKHR {
    type Type = DisplayModeParametersKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DisplayModeParametersKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DisplayModeParametersKHR {
        &mut self.inner
    }
    pub fn visible_region(mut self, visible_region: vk::Extent2D) -> Self {
        self.inner.visible_region = visible_region;
        self
    }
    pub fn refresh_rate(mut self, refresh_rate: u32) -> Self {
        self.inner.refresh_rate = refresh_rate;
        self
    }
}
impl Deref for DisplayModeParametersKHRBuilder {
    type Target = vk::DisplayModeParametersKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DisplayModeCreateInfoKHRBuilder {
    inner: vk::DisplayModeCreateInfoKHR,
}
impl Builder<'_> for vk::DisplayModeCreateInfoKHR {
    type Type = DisplayModeCreateInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DisplayModeCreateInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DisplayModeCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DisplayModeCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn parameters(mut self, parameters: vk::DisplayModeParametersKHR) -> Self {
        self.inner.parameters = parameters;
        self
    }
}
impl Deref for DisplayModeCreateInfoKHRBuilder {
    type Target = vk::DisplayModeCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DisplaySurfaceCreateInfoKHRBuilder<'a> {
    inner: vk::DisplaySurfaceCreateInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DisplaySurfaceCreateInfoKHR {
    type Type = DisplaySurfaceCreateInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DisplaySurfaceCreateInfoKHRNext {}
impl<'a> DisplaySurfaceCreateInfoKHRBuilder<'a> {
    pub fn insert_next<T: DisplaySurfaceCreateInfoKHRNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DisplaySurfaceCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DisplaySurfaceCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn display_mode(mut self, display_mode: vk::DisplayModeKHR) -> Self {
        self.inner.display_mode = display_mode;
        self
    }
    pub fn plane_index(mut self, plane_index: u32) -> Self {
        self.inner.plane_index = plane_index;
        self
    }
    pub fn plane_stack_index(mut self, plane_stack_index: u32) -> Self {
        self.inner.plane_stack_index = plane_stack_index;
        self
    }
    pub fn transform(mut self, transform: vk::SurfaceTransformFlagsKHR) -> Self {
        self.inner.transform = transform;
        self
    }
    pub fn global_alpha(mut self, global_alpha: f32) -> Self {
        self.inner.global_alpha = global_alpha;
        self
    }
    pub fn alpha_mode(mut self, alpha_mode: vk::DisplayPlaneAlphaFlagsKHR) -> Self {
        self.inner.alpha_mode = alpha_mode;
        self
    }
    pub fn image_extent(mut self, image_extent: vk::Extent2D) -> Self {
        self.inner.image_extent = image_extent;
        self
    }
}
impl<'a> Deref for DisplaySurfaceCreateInfoKHRBuilder<'a> {
    type Target = vk::DisplaySurfaceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DisplaySurfaceStereoCreateInfoNVBuilder {
    inner: vk::DisplaySurfaceStereoCreateInfoNV,
}
impl Builder<'_> for vk::DisplaySurfaceStereoCreateInfoNV {
    type Type = DisplaySurfaceStereoCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DisplaySurfaceStereoCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DisplaySurfaceStereoCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn stereo_type(mut self, stereo_type: vk::DisplaySurfaceStereoTypeNV) -> Self {
        self.inner.stereo_type = stereo_type;
        self
    }
}
impl Deref for DisplaySurfaceStereoCreateInfoNVBuilder {
    type Target = vk::DisplaySurfaceStereoCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DisplaySurfaceCreateInfoKHRNext for vk::DisplaySurfaceStereoCreateInfoNV {}
impl DisplaySurfaceCreateInfoKHRNext for DisplaySurfaceStereoCreateInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DisplayPresentInfoKHRBuilder {
    inner: vk::DisplayPresentInfoKHR,
}
impl Builder<'_> for vk::DisplayPresentInfoKHR {
    type Type = DisplayPresentInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DisplayPresentInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DisplayPresentInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_rect(mut self, src_rect: vk::Rect2D) -> Self {
        self.inner.src_rect = src_rect;
        self
    }
    pub fn dst_rect(mut self, dst_rect: vk::Rect2D) -> Self {
        self.inner.dst_rect = dst_rect;
        self
    }
    pub fn persistent(mut self, persistent: bool) -> Self {
        self.inner.persistent = if persistent { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for DisplayPresentInfoKHRBuilder {
    type Target = vk::DisplayPresentInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PresentInfoKHRNext for vk::DisplayPresentInfoKHR {}
impl PresentInfoKHRNext for DisplayPresentInfoKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct AndroidSurfaceCreateInfoKHRBuilder<'a> {
    inner: vk::AndroidSurfaceCreateInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AndroidSurfaceCreateInfoKHR {
    type Type = AndroidSurfaceCreateInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> AndroidSurfaceCreateInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::AndroidSurfaceCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::AndroidSurfaceCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn window(mut self, window: *mut vk::ANativeWindow) -> Self {
        self.inner.window = window;
        self
    }
}
impl<'a> Deref for AndroidSurfaceCreateInfoKHRBuilder<'a> {
    type Target = vk::AndroidSurfaceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ViSurfaceCreateInfoNNBuilder<'a> {
    inner: vk::ViSurfaceCreateInfoNN,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ViSurfaceCreateInfoNN {
    type Type = ViSurfaceCreateInfoNNBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ViSurfaceCreateInfoNNBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ViSurfaceCreateInfoNN {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::ViSurfaceCreateFlagsNN) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn window(mut self, window: *mut c_void) -> Self {
        self.inner.window = window;
        self
    }
}
impl<'a> Deref for ViSurfaceCreateInfoNNBuilder<'a> {
    type Target = vk::ViSurfaceCreateInfoNN;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct WaylandSurfaceCreateInfoKHRBuilder<'a> {
    inner: vk::WaylandSurfaceCreateInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::WaylandSurfaceCreateInfoKHR {
    type Type = WaylandSurfaceCreateInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> WaylandSurfaceCreateInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::WaylandSurfaceCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::WaylandSurfaceCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn display(mut self, display: *mut vk::wl_display) -> Self {
        self.inner.display = display;
        self
    }
    pub fn surface(mut self, surface: *mut vk::wl_surface) -> Self {
        self.inner.surface = surface;
        self
    }
}
impl<'a> Deref for WaylandSurfaceCreateInfoKHRBuilder<'a> {
    type Target = vk::WaylandSurfaceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct Win32SurfaceCreateInfoKHRBuilder {
    inner: vk::Win32SurfaceCreateInfoKHR,
}
impl Builder<'_> for vk::Win32SurfaceCreateInfoKHR {
    type Type = Win32SurfaceCreateInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl Win32SurfaceCreateInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::Win32SurfaceCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::Win32SurfaceCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn hinstance(mut self, hinstance: vk::HINSTANCE) -> Self {
        self.inner.hinstance = hinstance;
        self
    }
    pub fn hwnd(mut self, hwnd: vk::HWND) -> Self {
        self.inner.hwnd = hwnd;
        self
    }
}
impl Deref for Win32SurfaceCreateInfoKHRBuilder {
    type Target = vk::Win32SurfaceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct XlibSurfaceCreateInfoKHRBuilder<'a> {
    inner: vk::XlibSurfaceCreateInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::XlibSurfaceCreateInfoKHR {
    type Type = XlibSurfaceCreateInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> XlibSurfaceCreateInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::XlibSurfaceCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::XlibSurfaceCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn dpy(mut self, dpy: *mut vk::Display) -> Self {
        self.inner.dpy = dpy;
        self
    }
    pub fn window(mut self, window: vk::Window) -> Self {
        self.inner.window = window;
        self
    }
}
impl<'a> Deref for XlibSurfaceCreateInfoKHRBuilder<'a> {
    type Target = vk::XlibSurfaceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct XcbSurfaceCreateInfoKHRBuilder<'a> {
    inner: vk::XcbSurfaceCreateInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::XcbSurfaceCreateInfoKHR {
    type Type = XcbSurfaceCreateInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> XcbSurfaceCreateInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::XcbSurfaceCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::XcbSurfaceCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn connection(mut self, connection: *mut vk::xcb_connection_t) -> Self {
        self.inner.connection = connection;
        self
    }
    pub fn window(mut self, window: vk::xcb_window_t) -> Self {
        self.inner.window = window;
        self
    }
}
impl<'a> Deref for XcbSurfaceCreateInfoKHRBuilder<'a> {
    type Target = vk::XcbSurfaceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DirectFBSurfaceCreateInfoEXTBuilder<'a> {
    inner: vk::DirectFBSurfaceCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DirectFBSurfaceCreateInfoEXT {
    type Type = DirectFBSurfaceCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DirectFBSurfaceCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DirectFBSurfaceCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DirectFBSurfaceCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn dfb(mut self, dfb: *mut vk::IDirectFB) -> Self {
        self.inner.dfb = dfb;
        self
    }
    pub fn surface(mut self, surface: *mut vk::IDirectFBSurface) -> Self {
        self.inner.surface = surface;
        self
    }
}
impl<'a> Deref for DirectFBSurfaceCreateInfoEXTBuilder<'a> {
    type Target = vk::DirectFBSurfaceCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImagePipeSurfaceCreateInfoFUCHSIABuilder {
    inner: vk::ImagePipeSurfaceCreateInfoFUCHSIA,
}
impl Builder<'_> for vk::ImagePipeSurfaceCreateInfoFUCHSIA {
    type Type = ImagePipeSurfaceCreateInfoFUCHSIABuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImagePipeSurfaceCreateInfoFUCHSIABuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImagePipeSurfaceCreateInfoFUCHSIA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::ImagePipeSurfaceCreateFlagsFUCHSIA) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn image_pipe_handle(mut self, image_pipe_handle: vk::zx_handle_t) -> Self {
        self.inner.image_pipe_handle = image_pipe_handle;
        self
    }
}
impl Deref for ImagePipeSurfaceCreateInfoFUCHSIABuilder {
    type Target = vk::ImagePipeSurfaceCreateInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SwapchainCreateInfoKHRBuilder<'a> {
    inner: vk::SwapchainCreateInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SwapchainCreateInfoKHR {
    type Type = SwapchainCreateInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait SwapchainCreateInfoKHRNext {}
impl<'a> SwapchainCreateInfoKHRBuilder<'a> {
    pub fn insert_next<T: SwapchainCreateInfoKHRNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::SwapchainCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::SwapchainCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn surface(mut self, surface: vk::SurfaceKHR) -> Self {
        self.inner.surface = surface;
        self
    }
    pub fn min_image_count(mut self, min_image_count: u32) -> Self {
        self.inner.min_image_count = min_image_count;
        self
    }
    pub fn image_format(mut self, image_format: vk::Format) -> Self {
        self.inner.image_format = image_format;
        self
    }
    pub fn image_color_space(mut self, image_color_space: vk::ColorSpaceKHR) -> Self {
        self.inner.image_color_space = image_color_space;
        self
    }
    pub fn image_extent(mut self, image_extent: vk::Extent2D) -> Self {
        self.inner.image_extent = image_extent;
        self
    }
    pub fn image_array_layers(mut self, image_array_layers: u32) -> Self {
        self.inner.image_array_layers = image_array_layers;
        self
    }
    pub fn image_usage(mut self, image_usage: vk::ImageUsageFlags) -> Self {
        self.inner.image_usage = image_usage;
        self
    }
    pub fn image_sharing_mode(mut self, image_sharing_mode: vk::SharingMode) -> Self {
        self.inner.image_sharing_mode = image_sharing_mode;
        self
    }
    pub fn queue_family_index_count(mut self, queue_family_index_count: u32) -> Self {
        self.inner.queue_family_index_count = queue_family_index_count;
        self
    }
    pub fn p_queue_family_indices(mut self, p_queue_family_indices: &'a [u32]) -> Self {
        self.inner.queue_family_index_count = p_queue_family_indices.len() as u32;
        self.inner.p_queue_family_indices = p_queue_family_indices.as_ptr();
        self
    }
    pub fn pre_transform(mut self, pre_transform: vk::SurfaceTransformFlagsKHR) -> Self {
        self.inner.pre_transform = pre_transform;
        self
    }
    pub fn composite_alpha(mut self, composite_alpha: vk::CompositeAlphaFlagsKHR) -> Self {
        self.inner.composite_alpha = composite_alpha;
        self
    }
    pub fn present_mode(mut self, present_mode: vk::PresentModeKHR) -> Self {
        self.inner.present_mode = present_mode;
        self
    }
    pub fn clipped(mut self, clipped: bool) -> Self {
        self.inner.clipped = if clipped { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn old_swapchain(mut self, old_swapchain: vk::SwapchainKHR) -> Self {
        self.inner.old_swapchain = old_swapchain;
        self
    }
}
impl<'a> Deref for SwapchainCreateInfoKHRBuilder<'a> {
    type Target = vk::SwapchainCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PresentInfoKHRBuilder<'a> {
    inner: vk::PresentInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PresentInfoKHR {
    type Type = PresentInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PresentInfoKHRNext {}
impl<'a> PresentInfoKHRBuilder<'a> {
    pub fn insert_next<T: PresentInfoKHRNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PresentInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_wait_semaphores(mut self, p_wait_semaphores: &'a [vk::Semaphore]) -> Self {
        self.inner.wait_semaphore_count = p_wait_semaphores.len() as u32;
        self.inner.p_wait_semaphores = p_wait_semaphores.as_ptr();
        self
    }
    pub fn p_swapchains(
        mut self,
        p_swapchains: &'a [vk::SwapchainKHR],
        p_image_indices: &'a [u32],
        p_results: Option<&'a mut [vk::Result]>,
    ) -> Self {
        self.inner.swapchain_count = p_swapchains.len() as u32;
        assert_eq!(self.inner.swapchain_count, p_image_indices.len() as u32);
        self.inner.p_swapchains = p_swapchains.as_ptr();
        self.inner.p_image_indices = p_image_indices.as_ptr();
        self.inner.p_results = p_results.map_or(ptr::null_mut(), |s| s.as_mut_ptr());
        self
    }
}
impl<'a> Deref for PresentInfoKHRBuilder<'a> {
    type Target = vk::PresentInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DebugReportCallbackCreateInfoEXTBuilder<'a> {
    inner: vk::DebugReportCallbackCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DebugReportCallbackCreateInfoEXT {
    type Type = DebugReportCallbackCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DebugReportCallbackCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DebugReportCallbackCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DebugReportFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn pfn_callback(mut self, pfn_callback: vk::FnDebugReportCallbackEXT) -> Self {
        self.inner.pfn_callback = Some(pfn_callback);
        self
    }
    pub fn p_user_data(mut self, p_user_data: *mut c_void) -> Self {
        self.inner.p_user_data = p_user_data;
        self
    }
}
impl<'a> Deref for DebugReportCallbackCreateInfoEXTBuilder<'a> {
    type Target = vk::DebugReportCallbackCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl InstanceCreateInfoNext for vk::DebugReportCallbackCreateInfoEXT {}
impl InstanceCreateInfoNext for DebugReportCallbackCreateInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ValidationFlagsEXTBuilder<'a> {
    inner: vk::ValidationFlagsEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ValidationFlagsEXT {
    type Type = ValidationFlagsEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ValidationFlagsEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ValidationFlagsEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_disabled_validation_checks(mut self, p_disabled_validation_checks: &'a [vk::ValidationCheckEXT]) -> Self {
        self.inner.disabled_validation_check_count = p_disabled_validation_checks.len() as u32;
        self.inner.p_disabled_validation_checks = p_disabled_validation_checks.as_ptr();
        self
    }
}
impl<'a> Deref for ValidationFlagsEXTBuilder<'a> {
    type Target = vk::ValidationFlagsEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl InstanceCreateInfoNext for vk::ValidationFlagsEXT {}
impl InstanceCreateInfoNext for ValidationFlagsEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ValidationFeaturesEXTBuilder<'a> {
    inner: vk::ValidationFeaturesEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ValidationFeaturesEXT {
    type Type = ValidationFeaturesEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ValidationFeaturesEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ValidationFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_enabled_validation_features(
        mut self,
        p_enabled_validation_features: &'a [vk::ValidationFeatureEnableEXT],
    ) -> Self {
        self.inner.enabled_validation_feature_count = p_enabled_validation_features.len() as u32;
        self.inner.p_enabled_validation_features = p_enabled_validation_features.as_ptr();
        self
    }
    pub fn p_disabled_validation_features(
        mut self,
        p_disabled_validation_features: &'a [vk::ValidationFeatureDisableEXT],
    ) -> Self {
        self.inner.disabled_validation_feature_count = p_disabled_validation_features.len() as u32;
        self.inner.p_disabled_validation_features = p_disabled_validation_features.as_ptr();
        self
    }
}
impl<'a> Deref for ValidationFeaturesEXTBuilder<'a> {
    type Target = vk::ValidationFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl InstanceCreateInfoNext for vk::ValidationFeaturesEXT {}
impl InstanceCreateInfoNext for ValidationFeaturesEXTBuilder<'_> {}
impl ShaderModuleCreateInfoNext for vk::ValidationFeaturesEXT {}
impl ShaderModuleCreateInfoNext for ValidationFeaturesEXTBuilder<'_> {}
impl ShaderCreateInfoEXTNext for vk::ValidationFeaturesEXT {}
impl ShaderCreateInfoEXTNext for ValidationFeaturesEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct LayerSettingsCreateInfoEXTBuilder<'a> {
    inner: vk::LayerSettingsCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::LayerSettingsCreateInfoEXT {
    type Type = LayerSettingsCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> LayerSettingsCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::LayerSettingsCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_settings(mut self, p_settings: &'a [vk::LayerSettingEXT]) -> Self {
        self.inner.setting_count = p_settings.len() as u32;
        self.inner.p_settings = p_settings.as_ptr();
        self
    }
}
impl<'a> Deref for LayerSettingsCreateInfoEXTBuilder<'a> {
    type Target = vk::LayerSettingsCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl InstanceCreateInfoNext for vk::LayerSettingsCreateInfoEXT {}
impl InstanceCreateInfoNext for LayerSettingsCreateInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct LayerSettingEXTBuilder<'a> {
    inner: vk::LayerSettingEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::LayerSettingEXT {
    type Type = LayerSettingEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> LayerSettingEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::LayerSettingEXT {
        &mut self.inner
    }
    pub fn p_layer_name(mut self, p_layer_name: &'a CStr) -> Self {
        self.inner.p_layer_name = p_layer_name.as_ptr();
        self
    }
    pub fn p_setting_name(mut self, p_setting_name: &'a CStr) -> Self {
        self.inner.p_setting_name = p_setting_name.as_ptr();
        self
    }
    pub fn ty(mut self, ty: vk::LayerSettingTypeEXT) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn value_count(mut self, value_count: u32) -> Self {
        self.inner.value_count = value_count;
        self
    }
    pub fn p_values(mut self, p_values: *const c_void) -> Self {
        self.inner.p_values = p_values;
        self
    }
}
impl<'a> Deref for LayerSettingEXTBuilder<'a> {
    type Target = vk::LayerSettingEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineRasterizationStateRasterizationOrderAMDBuilder {
    inner: vk::PipelineRasterizationStateRasterizationOrderAMD,
}
impl Builder<'_> for vk::PipelineRasterizationStateRasterizationOrderAMD {
    type Type = PipelineRasterizationStateRasterizationOrderAMDBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineRasterizationStateRasterizationOrderAMDBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineRasterizationStateRasterizationOrderAMD {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn rasterization_order(mut self, rasterization_order: vk::RasterizationOrderAMD) -> Self {
        self.inner.rasterization_order = rasterization_order;
        self
    }
}
impl Deref for PipelineRasterizationStateRasterizationOrderAMDBuilder {
    type Target = vk::PipelineRasterizationStateRasterizationOrderAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineRasterizationStateCreateInfoNext for vk::PipelineRasterizationStateRasterizationOrderAMD {}
impl PipelineRasterizationStateCreateInfoNext for PipelineRasterizationStateRasterizationOrderAMDBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DebugMarkerObjectNameInfoEXTBuilder<'a> {
    inner: vk::DebugMarkerObjectNameInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DebugMarkerObjectNameInfoEXT {
    type Type = DebugMarkerObjectNameInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DebugMarkerObjectNameInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DebugMarkerObjectNameInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn object_type(mut self, object_type: vk::DebugReportObjectTypeEXT) -> Self {
        self.inner.object_type = object_type;
        self
    }
    pub fn object(mut self, object: u64) -> Self {
        self.inner.object = object;
        self
    }
    pub fn p_object_name(mut self, p_object_name: &'a CStr) -> Self {
        self.inner.p_object_name = p_object_name.as_ptr();
        self
    }
}
impl<'a> Deref for DebugMarkerObjectNameInfoEXTBuilder<'a> {
    type Target = vk::DebugMarkerObjectNameInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DebugMarkerObjectTagInfoEXTBuilder<'a> {
    inner: vk::DebugMarkerObjectTagInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DebugMarkerObjectTagInfoEXT {
    type Type = DebugMarkerObjectTagInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DebugMarkerObjectTagInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DebugMarkerObjectTagInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn object_type(mut self, object_type: vk::DebugReportObjectTypeEXT) -> Self {
        self.inner.object_type = object_type;
        self
    }
    pub fn object(mut self, object: u64) -> Self {
        self.inner.object = object;
        self
    }
    pub fn tag_name(mut self, tag_name: u64) -> Self {
        self.inner.tag_name = tag_name;
        self
    }
    pub fn p_tag(mut self, p_tag: &'a [u8]) -> Self {
        self.inner.tag_size = p_tag.len();
        self.inner.p_tag = p_tag.as_ptr() as *const _;
        self
    }
}
impl<'a> Deref for DebugMarkerObjectTagInfoEXTBuilder<'a> {
    type Target = vk::DebugMarkerObjectTagInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DebugMarkerMarkerInfoEXTBuilder<'a> {
    inner: vk::DebugMarkerMarkerInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DebugMarkerMarkerInfoEXT {
    type Type = DebugMarkerMarkerInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DebugMarkerMarkerInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DebugMarkerMarkerInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_marker_name(mut self, p_marker_name: &'a CStr) -> Self {
        self.inner.p_marker_name = p_marker_name.as_ptr();
        self
    }
    pub fn color(mut self, color: [f32; 4]) -> Self {
        self.inner.color = color;
        self
    }
}
impl<'a> Deref for DebugMarkerMarkerInfoEXTBuilder<'a> {
    type Target = vk::DebugMarkerMarkerInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DedicatedAllocationImageCreateInfoNVBuilder {
    inner: vk::DedicatedAllocationImageCreateInfoNV,
}
impl Builder<'_> for vk::DedicatedAllocationImageCreateInfoNV {
    type Type = DedicatedAllocationImageCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DedicatedAllocationImageCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DedicatedAllocationImageCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn dedicated_allocation(mut self, dedicated_allocation: bool) -> Self {
        self.inner.dedicated_allocation = if dedicated_allocation { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for DedicatedAllocationImageCreateInfoNVBuilder {
    type Target = vk::DedicatedAllocationImageCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageCreateInfoNext for vk::DedicatedAllocationImageCreateInfoNV {}
impl ImageCreateInfoNext for DedicatedAllocationImageCreateInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DedicatedAllocationBufferCreateInfoNVBuilder {
    inner: vk::DedicatedAllocationBufferCreateInfoNV,
}
impl Builder<'_> for vk::DedicatedAllocationBufferCreateInfoNV {
    type Type = DedicatedAllocationBufferCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DedicatedAllocationBufferCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DedicatedAllocationBufferCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn dedicated_allocation(mut self, dedicated_allocation: bool) -> Self {
        self.inner.dedicated_allocation = if dedicated_allocation { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for DedicatedAllocationBufferCreateInfoNVBuilder {
    type Target = vk::DedicatedAllocationBufferCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BufferCreateInfoNext for vk::DedicatedAllocationBufferCreateInfoNV {}
impl BufferCreateInfoNext for DedicatedAllocationBufferCreateInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DedicatedAllocationMemoryAllocateInfoNVBuilder {
    inner: vk::DedicatedAllocationMemoryAllocateInfoNV,
}
impl Builder<'_> for vk::DedicatedAllocationMemoryAllocateInfoNV {
    type Type = DedicatedAllocationMemoryAllocateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DedicatedAllocationMemoryAllocateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DedicatedAllocationMemoryAllocateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image(mut self, image: vk::Image) -> Self {
        self.inner.image = image;
        self
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
}
impl Deref for DedicatedAllocationMemoryAllocateInfoNVBuilder {
    type Target = vk::DedicatedAllocationMemoryAllocateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::DedicatedAllocationMemoryAllocateInfoNV {}
impl MemoryAllocateInfoNext for DedicatedAllocationMemoryAllocateInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExternalMemoryImageCreateInfoNVBuilder {
    inner: vk::ExternalMemoryImageCreateInfoNV,
}
impl Builder<'_> for vk::ExternalMemoryImageCreateInfoNV {
    type Type = ExternalMemoryImageCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExternalMemoryImageCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExternalMemoryImageCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_types(mut self, handle_types: vk::ExternalMemoryHandleTypeFlagsNV) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
}
impl Deref for ExternalMemoryImageCreateInfoNVBuilder {
    type Target = vk::ExternalMemoryImageCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageCreateInfoNext for vk::ExternalMemoryImageCreateInfoNV {}
impl ImageCreateInfoNext for ExternalMemoryImageCreateInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportMemoryAllocateInfoNVBuilder {
    inner: vk::ExportMemoryAllocateInfoNV,
}
impl Builder<'_> for vk::ExportMemoryAllocateInfoNV {
    type Type = ExportMemoryAllocateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExportMemoryAllocateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExportMemoryAllocateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_types(mut self, handle_types: vk::ExternalMemoryHandleTypeFlagsNV) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
}
impl Deref for ExportMemoryAllocateInfoNVBuilder {
    type Target = vk::ExportMemoryAllocateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::ExportMemoryAllocateInfoNV {}
impl MemoryAllocateInfoNext for ExportMemoryAllocateInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportMemoryWin32HandleInfoNVBuilder {
    inner: vk::ImportMemoryWin32HandleInfoNV,
}
impl Builder<'_> for vk::ImportMemoryWin32HandleInfoNV {
    type Type = ImportMemoryWin32HandleInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImportMemoryWin32HandleInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImportMemoryWin32HandleInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalMemoryHandleTypeFlagsNV) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    pub fn handle(mut self, handle: vk::HANDLE) -> Self {
        self.inner.handle = handle;
        self
    }
}
impl Deref for ImportMemoryWin32HandleInfoNVBuilder {
    type Target = vk::ImportMemoryWin32HandleInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::ImportMemoryWin32HandleInfoNV {}
impl MemoryAllocateInfoNext for ImportMemoryWin32HandleInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportMemoryWin32HandleInfoNVBuilder<'a> {
    inner: vk::ExportMemoryWin32HandleInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ExportMemoryWin32HandleInfoNV {
    type Type = ExportMemoryWin32HandleInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ExportMemoryWin32HandleInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ExportMemoryWin32HandleInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_attributes(mut self, p_attributes: Option<&'a vk::SECURITY_ATTRIBUTES>) -> Self {
        self.inner.p_attributes = p_attributes.map_or(ptr::null(), |r| r);
        self
    }
    pub fn dw_access(mut self, dw_access: vk::DWORD) -> Self {
        self.inner.dw_access = dw_access;
        self
    }
}
impl<'a> Deref for ExportMemoryWin32HandleInfoNVBuilder<'a> {
    type Target = vk::ExportMemoryWin32HandleInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::ExportMemoryWin32HandleInfoNV {}
impl MemoryAllocateInfoNext for ExportMemoryWin32HandleInfoNVBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
    inner: vk::Win32KeyedMutexAcquireReleaseInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::Win32KeyedMutexAcquireReleaseInfoNV {
    type Type = Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::Win32KeyedMutexAcquireReleaseInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_acquire_syncs(
        mut self,
        p_acquire_syncs: &'a [vk::DeviceMemory],
        p_acquire_keys: &'a [u64],
        p_acquire_timeout_milliseconds: &'a [u32],
    ) -> Self {
        self.inner.acquire_count = p_acquire_syncs.len() as u32;
        assert_eq!(self.inner.acquire_count, p_acquire_keys.len() as u32);
        assert_eq!(self.inner.acquire_count, p_acquire_timeout_milliseconds.len() as u32);
        self.inner.p_acquire_syncs = p_acquire_syncs.as_ptr();
        self.inner.p_acquire_keys = p_acquire_keys.as_ptr();
        self.inner.p_acquire_timeout_milliseconds = p_acquire_timeout_milliseconds.as_ptr();
        self
    }
    pub fn p_release_syncs(mut self, p_release_syncs: &'a [vk::DeviceMemory], p_release_keys: &'a [u64]) -> Self {
        self.inner.release_count = p_release_syncs.len() as u32;
        assert_eq!(self.inner.release_count, p_release_keys.len() as u32);
        self.inner.p_release_syncs = p_release_syncs.as_ptr();
        self.inner.p_release_keys = p_release_keys.as_ptr();
        self
    }
}
impl<'a> Deref for Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
    type Target = vk::Win32KeyedMutexAcquireReleaseInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubmitInfoNext for vk::Win32KeyedMutexAcquireReleaseInfoNV {}
impl SubmitInfoNext for Win32KeyedMutexAcquireReleaseInfoNVBuilder<'_> {}
impl SubmitInfo2Next for vk::Win32KeyedMutexAcquireReleaseInfoNV {}
impl SubmitInfo2Next for Win32KeyedMutexAcquireReleaseInfoNVBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder {
    inner: vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    type Type = PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn device_generated_commands(mut self, device_generated_commands: bool) -> Self {
        self.inner.device_generated_commands = if device_generated_commands { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNVBuilder {
    inner: vk::PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV {
    type Type = PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn device_generated_compute(mut self, device_generated_compute: bool) -> Self {
        self.inner.device_generated_compute = if device_generated_compute { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn device_generated_compute_pipelines(mut self, device_generated_compute_pipelines: bool) -> Self {
        self.inner.device_generated_compute_pipelines = if device_generated_compute_pipelines {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn device_generated_compute_capture_replay(mut self, device_generated_compute_capture_replay: bool) -> Self {
        self.inner.device_generated_compute_capture_replay = if device_generated_compute_capture_replay {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DevicePrivateDataCreateInfoBuilder {
    inner: vk::DevicePrivateDataCreateInfo,
}
impl Builder<'_> for vk::DevicePrivateDataCreateInfo {
    type Type = DevicePrivateDataCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DevicePrivateDataCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DevicePrivateDataCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn private_data_slot_request_count(mut self, private_data_slot_request_count: u32) -> Self {
        self.inner.private_data_slot_request_count = private_data_slot_request_count;
        self
    }
}
impl Deref for DevicePrivateDataCreateInfoBuilder {
    type Target = vk::DevicePrivateDataCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DeviceCreateInfoNext for vk::DevicePrivateDataCreateInfo {}
impl DeviceCreateInfoNext for DevicePrivateDataCreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PrivateDataSlotCreateInfoBuilder {
    inner: vk::PrivateDataSlotCreateInfo,
}
impl Builder<'_> for vk::PrivateDataSlotCreateInfo {
    type Type = PrivateDataSlotCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PrivateDataSlotCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PrivateDataSlotCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PrivateDataSlotCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl Deref for PrivateDataSlotCreateInfoBuilder {
    type Target = vk::PrivateDataSlotCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePrivateDataFeaturesBuilder {
    inner: vk::PhysicalDevicePrivateDataFeatures,
}
impl Builder<'_> for vk::PhysicalDevicePrivateDataFeatures {
    type Type = PhysicalDevicePrivateDataFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePrivateDataFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePrivateDataFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn private_data(mut self, private_data: bool) -> Self {
        self.inner.private_data = if private_data { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevicePrivateDataFeaturesBuilder {
    type Target = vk::PhysicalDevicePrivateDataFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePrivateDataFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePrivateDataFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePrivateDataFeatures {}
impl DeviceCreateInfoNext for PhysicalDevicePrivateDataFeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceClusterAccelerationStructureFeaturesNVBuilder {
    inner: vk::PhysicalDeviceClusterAccelerationStructureFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceClusterAccelerationStructureFeaturesNV {
    type Type = PhysicalDeviceClusterAccelerationStructureFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceClusterAccelerationStructureFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceClusterAccelerationStructureFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn cluster_acceleration_structure(mut self, cluster_acceleration_structure: bool) -> Self {
        self.inner.cluster_acceleration_structure = if cluster_acceleration_structure {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceClusterAccelerationStructureFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceClusterAccelerationStructureFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceClusterAccelerationStructureFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceClusterAccelerationStructureFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceClusterAccelerationStructureFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceClusterAccelerationStructureFeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceClusterAccelerationStructurePropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct StridedDeviceAddressNVBuilder {
    inner: vk::StridedDeviceAddressNV,
}
impl Builder<'_> for vk::StridedDeviceAddressNV {
    type Type = StridedDeviceAddressNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl StridedDeviceAddressNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::StridedDeviceAddressNV {
        &mut self.inner
    }
    pub fn start_address(mut self, start_address: vk::DeviceAddress) -> Self {
        self.inner.start_address = start_address;
        self
    }
    pub fn stride_in_bytes(mut self, stride_in_bytes: vk::DeviceSize) -> Self {
        self.inner.stride_in_bytes = stride_in_bytes;
        self
    }
}
impl Deref for StridedDeviceAddressNVBuilder {
    type Target = vk::StridedDeviceAddressNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RayTracingPipelineClusterAccelerationStructureCreateInfoNVBuilder {
    inner: vk::RayTracingPipelineClusterAccelerationStructureCreateInfoNV,
}
impl Builder<'_> for vk::RayTracingPipelineClusterAccelerationStructureCreateInfoNV {
    type Type = RayTracingPipelineClusterAccelerationStructureCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl RayTracingPipelineClusterAccelerationStructureCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::RayTracingPipelineClusterAccelerationStructureCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn allow_cluster_acceleration_structure(mut self, allow_cluster_acceleration_structure: bool) -> Self {
        self.inner.allow_cluster_acceleration_structure = if allow_cluster_acceleration_structure {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for RayTracingPipelineClusterAccelerationStructureCreateInfoNVBuilder {
    type Target = vk::RayTracingPipelineClusterAccelerationStructureCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RayTracingPipelineCreateInfoKHRNext for vk::RayTracingPipelineClusterAccelerationStructureCreateInfoNV {}
impl RayTracingPipelineCreateInfoKHRNext for RayTracingPipelineClusterAccelerationStructureCreateInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNVBuilder {
    inner: vk::ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV,
}
impl Builder<'_> for vk::ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV {
    type Type = ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV {
        &mut self.inner
    }
    pub fn geometry_index_and_reserved_and_geometry_flags(
        mut self,
        geometry_index_and_reserved_and_geometry_flags: u32,
    ) -> Self {
        self.inner.geometry_index_and_reserved_and_geometry_flags = geometry_index_and_reserved_and_geometry_flags;
        self
    }
}
impl Deref for ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNVBuilder {
    type Target = vk::ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ClusterAccelerationStructureMoveObjectsInfoNVBuilder {
    inner: vk::ClusterAccelerationStructureMoveObjectsInfoNV,
}
impl Builder<'_> for vk::ClusterAccelerationStructureMoveObjectsInfoNV {
    type Type = ClusterAccelerationStructureMoveObjectsInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClusterAccelerationStructureMoveObjectsInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClusterAccelerationStructureMoveObjectsInfoNV {
        &mut self.inner
    }
    pub fn src_acceleration_structure(mut self, src_acceleration_structure: vk::DeviceAddress) -> Self {
        self.inner.src_acceleration_structure = src_acceleration_structure;
        self
    }
}
impl Deref for ClusterAccelerationStructureMoveObjectsInfoNVBuilder {
    type Target = vk::ClusterAccelerationStructureMoveObjectsInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ClusterAccelerationStructureBuildClustersBottomLevelInfoNVBuilder {
    inner: vk::ClusterAccelerationStructureBuildClustersBottomLevelInfoNV,
}
impl Builder<'_> for vk::ClusterAccelerationStructureBuildClustersBottomLevelInfoNV {
    type Type = ClusterAccelerationStructureBuildClustersBottomLevelInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClusterAccelerationStructureBuildClustersBottomLevelInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClusterAccelerationStructureBuildClustersBottomLevelInfoNV {
        &mut self.inner
    }
    pub fn cluster_references_count(mut self, cluster_references_count: u32) -> Self {
        self.inner.cluster_references_count = cluster_references_count;
        self
    }
    pub fn cluster_references_stride(mut self, cluster_references_stride: u32) -> Self {
        self.inner.cluster_references_stride = cluster_references_stride;
        self
    }
    pub fn cluster_references(mut self, cluster_references: vk::DeviceAddress) -> Self {
        self.inner.cluster_references = cluster_references;
        self
    }
}
impl Deref for ClusterAccelerationStructureBuildClustersBottomLevelInfoNVBuilder {
    type Target = vk::ClusterAccelerationStructureBuildClustersBottomLevelInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ClusterAccelerationStructureGetTemplateIndicesInfoNVBuilder {
    inner: vk::ClusterAccelerationStructureGetTemplateIndicesInfoNV,
}
impl Builder<'_> for vk::ClusterAccelerationStructureGetTemplateIndicesInfoNV {
    type Type = ClusterAccelerationStructureGetTemplateIndicesInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClusterAccelerationStructureGetTemplateIndicesInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClusterAccelerationStructureGetTemplateIndicesInfoNV {
        &mut self.inner
    }
    pub fn cluster_template_address(mut self, cluster_template_address: vk::DeviceAddress) -> Self {
        self.inner.cluster_template_address = cluster_template_address;
        self
    }
}
impl Deref for ClusterAccelerationStructureGetTemplateIndicesInfoNVBuilder {
    type Target = vk::ClusterAccelerationStructureGetTemplateIndicesInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ClusterAccelerationStructureBuildTriangleClusterInfoNVBuilder {
    inner: vk::ClusterAccelerationStructureBuildTriangleClusterInfoNV,
}
impl Builder<'_> for vk::ClusterAccelerationStructureBuildTriangleClusterInfoNV {
    type Type = ClusterAccelerationStructureBuildTriangleClusterInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClusterAccelerationStructureBuildTriangleClusterInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClusterAccelerationStructureBuildTriangleClusterInfoNV {
        &mut self.inner
    }
    pub fn cluster_id(mut self, cluster_id: u32) -> Self {
        self.inner.cluster_id = cluster_id;
        self
    }
    pub fn cluster_flags(mut self, cluster_flags: vk::ClusterAccelerationStructureClusterFlagsNV) -> Self {
        self.inner.cluster_flags = cluster_flags;
        self
    }
    pub fn triangle_count_and_vertex_count_and_position_truncate_bit_count_and_index_type_and_opacity_micromap_index_type(
        mut self,
        triangle_count_and_vertex_count_and_position_truncate_bit_count_and_index_type_and_opacity_micromap_index_type: u32,
    ) -> Self {
        self.inner.triangle_count_and_vertex_count_and_position_truncate_bit_count_and_index_type_and_opacity_micromap_index_type = 
triangle_count_and_vertex_count_and_position_truncate_bit_count_and_index_type_and_opacity_micromap_index_type;
        self
    }
    pub fn base_geometry_index_and_geometry_flags(
        mut self,
        base_geometry_index_and_geometry_flags: vk::ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV,
    ) -> Self {
        self.inner.base_geometry_index_and_geometry_flags = base_geometry_index_and_geometry_flags;
        self
    }
    pub fn index_buffer_stride(mut self, index_buffer_stride: u16) -> Self {
        self.inner.index_buffer_stride = index_buffer_stride;
        self
    }
    pub fn vertex_buffer_stride(mut self, vertex_buffer_stride: u16) -> Self {
        self.inner.vertex_buffer_stride = vertex_buffer_stride;
        self
    }
    pub fn geometry_index_and_flags_buffer_stride(mut self, geometry_index_and_flags_buffer_stride: u16) -> Self {
        self.inner.geometry_index_and_flags_buffer_stride = geometry_index_and_flags_buffer_stride;
        self
    }
    pub fn opacity_micromap_index_buffer_stride(mut self, opacity_micromap_index_buffer_stride: u16) -> Self {
        self.inner.opacity_micromap_index_buffer_stride = opacity_micromap_index_buffer_stride;
        self
    }
    pub fn index_buffer(mut self, index_buffer: vk::DeviceAddress) -> Self {
        self.inner.index_buffer = index_buffer;
        self
    }
    pub fn vertex_buffer(mut self, vertex_buffer: vk::DeviceAddress) -> Self {
        self.inner.vertex_buffer = vertex_buffer;
        self
    }
    pub fn geometry_index_and_flags_buffer(mut self, geometry_index_and_flags_buffer: vk::DeviceAddress) -> Self {
        self.inner.geometry_index_and_flags_buffer = geometry_index_and_flags_buffer;
        self
    }
    pub fn opacity_micromap_array(mut self, opacity_micromap_array: vk::DeviceAddress) -> Self {
        self.inner.opacity_micromap_array = opacity_micromap_array;
        self
    }
    pub fn opacity_micromap_index_buffer(mut self, opacity_micromap_index_buffer: vk::DeviceAddress) -> Self {
        self.inner.opacity_micromap_index_buffer = opacity_micromap_index_buffer;
        self
    }
}
impl Deref for ClusterAccelerationStructureBuildTriangleClusterInfoNVBuilder {
    type Target = vk::ClusterAccelerationStructureBuildTriangleClusterInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ClusterAccelerationStructureBuildTriangleClusterTemplateInfoNVBuilder {
    inner: vk::ClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV,
}
impl Builder<'_> for vk::ClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV {
    type Type = ClusterAccelerationStructureBuildTriangleClusterTemplateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClusterAccelerationStructureBuildTriangleClusterTemplateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV {
        &mut self.inner
    }
    pub fn cluster_id(mut self, cluster_id: u32) -> Self {
        self.inner.cluster_id = cluster_id;
        self
    }
    pub fn cluster_flags(mut self, cluster_flags: vk::ClusterAccelerationStructureClusterFlagsNV) -> Self {
        self.inner.cluster_flags = cluster_flags;
        self
    }
    pub fn triangle_count_and_vertex_count_and_position_truncate_bit_count_and_index_type_and_opacity_micromap_index_type(
        mut self,
        triangle_count_and_vertex_count_and_position_truncate_bit_count_and_index_type_and_opacity_micromap_index_type: u32,
    ) -> Self {
        self.inner.triangle_count_and_vertex_count_and_position_truncate_bit_count_and_index_type_and_opacity_micromap_index_type = 
triangle_count_and_vertex_count_and_position_truncate_bit_count_and_index_type_and_opacity_micromap_index_type;
        self
    }
    pub fn base_geometry_index_and_geometry_flags(
        mut self,
        base_geometry_index_and_geometry_flags: vk::ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV,
    ) -> Self {
        self.inner.base_geometry_index_and_geometry_flags = base_geometry_index_and_geometry_flags;
        self
    }
    pub fn index_buffer_stride(mut self, index_buffer_stride: u16) -> Self {
        self.inner.index_buffer_stride = index_buffer_stride;
        self
    }
    pub fn vertex_buffer_stride(mut self, vertex_buffer_stride: u16) -> Self {
        self.inner.vertex_buffer_stride = vertex_buffer_stride;
        self
    }
    pub fn geometry_index_and_flags_buffer_stride(mut self, geometry_index_and_flags_buffer_stride: u16) -> Self {
        self.inner.geometry_index_and_flags_buffer_stride = geometry_index_and_flags_buffer_stride;
        self
    }
    pub fn opacity_micromap_index_buffer_stride(mut self, opacity_micromap_index_buffer_stride: u16) -> Self {
        self.inner.opacity_micromap_index_buffer_stride = opacity_micromap_index_buffer_stride;
        self
    }
    pub fn index_buffer(mut self, index_buffer: vk::DeviceAddress) -> Self {
        self.inner.index_buffer = index_buffer;
        self
    }
    pub fn vertex_buffer(mut self, vertex_buffer: vk::DeviceAddress) -> Self {
        self.inner.vertex_buffer = vertex_buffer;
        self
    }
    pub fn geometry_index_and_flags_buffer(mut self, geometry_index_and_flags_buffer: vk::DeviceAddress) -> Self {
        self.inner.geometry_index_and_flags_buffer = geometry_index_and_flags_buffer;
        self
    }
    pub fn opacity_micromap_array(mut self, opacity_micromap_array: vk::DeviceAddress) -> Self {
        self.inner.opacity_micromap_array = opacity_micromap_array;
        self
    }
    pub fn opacity_micromap_index_buffer(mut self, opacity_micromap_index_buffer: vk::DeviceAddress) -> Self {
        self.inner.opacity_micromap_index_buffer = opacity_micromap_index_buffer;
        self
    }
    pub fn instantiation_bounding_box_limit(mut self, instantiation_bounding_box_limit: vk::DeviceAddress) -> Self {
        self.inner.instantiation_bounding_box_limit = instantiation_bounding_box_limit;
        self
    }
}
impl Deref for ClusterAccelerationStructureBuildTriangleClusterTemplateInfoNVBuilder {
    type Target = vk::ClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ClusterAccelerationStructureInstantiateClusterInfoNVBuilder {
    inner: vk::ClusterAccelerationStructureInstantiateClusterInfoNV,
}
impl Builder<'_> for vk::ClusterAccelerationStructureInstantiateClusterInfoNV {
    type Type = ClusterAccelerationStructureInstantiateClusterInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClusterAccelerationStructureInstantiateClusterInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClusterAccelerationStructureInstantiateClusterInfoNV {
        &mut self.inner
    }
    pub fn cluster_id_offset(mut self, cluster_id_offset: u32) -> Self {
        self.inner.cluster_id_offset = cluster_id_offset;
        self
    }
    pub fn geometry_index_offset_and_reserved(mut self, geometry_index_offset_and_reserved: u32) -> Self {
        self.inner.geometry_index_offset_and_reserved = geometry_index_offset_and_reserved;
        self
    }
    pub fn cluster_template_address(mut self, cluster_template_address: vk::DeviceAddress) -> Self {
        self.inner.cluster_template_address = cluster_template_address;
        self
    }
    pub fn vertex_buffer(mut self, vertex_buffer: vk::StridedDeviceAddressNV) -> Self {
        self.inner.vertex_buffer = vertex_buffer;
        self
    }
}
impl Deref for ClusterAccelerationStructureInstantiateClusterInfoNVBuilder {
    type Target = vk::ClusterAccelerationStructureInstantiateClusterInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ClusterAccelerationStructureClustersBottomLevelInputNVBuilder {
    inner: vk::ClusterAccelerationStructureClustersBottomLevelInputNV,
}
impl Builder<'_> for vk::ClusterAccelerationStructureClustersBottomLevelInputNV {
    type Type = ClusterAccelerationStructureClustersBottomLevelInputNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClusterAccelerationStructureClustersBottomLevelInputNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClusterAccelerationStructureClustersBottomLevelInputNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn max_total_cluster_count(mut self, max_total_cluster_count: u32) -> Self {
        self.inner.max_total_cluster_count = max_total_cluster_count;
        self
    }
    pub fn max_cluster_count_per_acceleration_structure(
        mut self,
        max_cluster_count_per_acceleration_structure: u32,
    ) -> Self {
        self.inner.max_cluster_count_per_acceleration_structure = max_cluster_count_per_acceleration_structure;
        self
    }
}
impl Deref for ClusterAccelerationStructureClustersBottomLevelInputNVBuilder {
    type Target = vk::ClusterAccelerationStructureClustersBottomLevelInputNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ClusterAccelerationStructureTriangleClusterInputNVBuilder {
    inner: vk::ClusterAccelerationStructureTriangleClusterInputNV,
}
impl Builder<'_> for vk::ClusterAccelerationStructureTriangleClusterInputNV {
    type Type = ClusterAccelerationStructureTriangleClusterInputNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClusterAccelerationStructureTriangleClusterInputNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClusterAccelerationStructureTriangleClusterInputNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn vertex_format(mut self, vertex_format: vk::Format) -> Self {
        self.inner.vertex_format = vertex_format;
        self
    }
    pub fn max_geometry_index_value(mut self, max_geometry_index_value: u32) -> Self {
        self.inner.max_geometry_index_value = max_geometry_index_value;
        self
    }
    pub fn max_cluster_unique_geometry_count(mut self, max_cluster_unique_geometry_count: u32) -> Self {
        self.inner.max_cluster_unique_geometry_count = max_cluster_unique_geometry_count;
        self
    }
    pub fn max_cluster_triangle_count(mut self, max_cluster_triangle_count: u32) -> Self {
        self.inner.max_cluster_triangle_count = max_cluster_triangle_count;
        self
    }
    pub fn max_cluster_vertex_count(mut self, max_cluster_vertex_count: u32) -> Self {
        self.inner.max_cluster_vertex_count = max_cluster_vertex_count;
        self
    }
    pub fn max_total_triangle_count(mut self, max_total_triangle_count: u32) -> Self {
        self.inner.max_total_triangle_count = max_total_triangle_count;
        self
    }
    pub fn max_total_vertex_count(mut self, max_total_vertex_count: u32) -> Self {
        self.inner.max_total_vertex_count = max_total_vertex_count;
        self
    }
    pub fn min_position_truncate_bit_count(mut self, min_position_truncate_bit_count: u32) -> Self {
        self.inner.min_position_truncate_bit_count = min_position_truncate_bit_count;
        self
    }
}
impl Deref for ClusterAccelerationStructureTriangleClusterInputNVBuilder {
    type Target = vk::ClusterAccelerationStructureTriangleClusterInputNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ClusterAccelerationStructureMoveObjectsInputNVBuilder {
    inner: vk::ClusterAccelerationStructureMoveObjectsInputNV,
}
impl Builder<'_> for vk::ClusterAccelerationStructureMoveObjectsInputNV {
    type Type = ClusterAccelerationStructureMoveObjectsInputNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClusterAccelerationStructureMoveObjectsInputNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClusterAccelerationStructureMoveObjectsInputNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ty(mut self, ty: vk::ClusterAccelerationStructureTypeNV) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn no_move_overlap(mut self, no_move_overlap: bool) -> Self {
        self.inner.no_move_overlap = if no_move_overlap { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn max_moved_bytes(mut self, max_moved_bytes: vk::DeviceSize) -> Self {
        self.inner.max_moved_bytes = max_moved_bytes;
        self
    }
}
impl Deref for ClusterAccelerationStructureMoveObjectsInputNVBuilder {
    type Target = vk::ClusterAccelerationStructureMoveObjectsInputNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ClusterAccelerationStructureInputInfoNVBuilder {
    inner: vk::ClusterAccelerationStructureInputInfoNV,
}
impl Builder<'_> for vk::ClusterAccelerationStructureInputInfoNV {
    type Type = ClusterAccelerationStructureInputInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClusterAccelerationStructureInputInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClusterAccelerationStructureInputInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn max_acceleration_structure_count(mut self, max_acceleration_structure_count: u32) -> Self {
        self.inner.max_acceleration_structure_count = max_acceleration_structure_count;
        self
    }
    pub fn flags(mut self, flags: vk::BuildAccelerationStructureFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn op_type(mut self, op_type: vk::ClusterAccelerationStructureOpTypeNV) -> Self {
        self.inner.op_type = op_type;
        self
    }
    pub fn op_mode(mut self, op_mode: vk::ClusterAccelerationStructureOpModeNV) -> Self {
        self.inner.op_mode = op_mode;
        self
    }
    pub fn op_input(mut self, op_input: vk::ClusterAccelerationStructureOpInputNV) -> Self {
        self.inner.op_input = op_input;
        self
    }
}
impl Deref for ClusterAccelerationStructureInputInfoNVBuilder {
    type Target = vk::ClusterAccelerationStructureInputInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ClusterAccelerationStructureCommandsInfoNVBuilder {
    inner: vk::ClusterAccelerationStructureCommandsInfoNV,
}
impl Builder<'_> for vk::ClusterAccelerationStructureCommandsInfoNV {
    type Type = ClusterAccelerationStructureCommandsInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ClusterAccelerationStructureCommandsInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ClusterAccelerationStructureCommandsInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn input(mut self, input: vk::ClusterAccelerationStructureInputInfoNV) -> Self {
        self.inner.input = input;
        self
    }
    pub fn dst_implicit_data(mut self, dst_implicit_data: vk::DeviceAddress) -> Self {
        self.inner.dst_implicit_data = dst_implicit_data;
        self
    }
    pub fn scratch_data(mut self, scratch_data: vk::DeviceAddress) -> Self {
        self.inner.scratch_data = scratch_data;
        self
    }
    pub fn dst_addresses_array(mut self, dst_addresses_array: vk::StridedDeviceAddressRegionKHR) -> Self {
        self.inner.dst_addresses_array = dst_addresses_array;
        self
    }
    pub fn dst_sizes_array(mut self, dst_sizes_array: vk::StridedDeviceAddressRegionKHR) -> Self {
        self.inner.dst_sizes_array = dst_sizes_array;
        self
    }
    pub fn src_infos_array(mut self, src_infos_array: vk::StridedDeviceAddressRegionKHR) -> Self {
        self.inner.src_infos_array = src_infos_array;
        self
    }
    pub fn src_infos_count(mut self, src_infos_count: vk::DeviceAddress) -> Self {
        self.inner.src_infos_count = src_infos_count;
        self
    }
    pub fn address_resolution_flags(
        mut self,
        address_resolution_flags: vk::ClusterAccelerationStructureAddressResolutionFlagsNV,
    ) -> Self {
        self.inner.address_resolution_flags = address_resolution_flags;
        self
    }
}
impl Deref for ClusterAccelerationStructureCommandsInfoNVBuilder {
    type Target = vk::ClusterAccelerationStructureCommandsInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceMultiDrawPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct GraphicsShaderGroupCreateInfoNVBuilder<'a> {
    inner: vk::GraphicsShaderGroupCreateInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::GraphicsShaderGroupCreateInfoNV {
    type Type = GraphicsShaderGroupCreateInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> GraphicsShaderGroupCreateInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::GraphicsShaderGroupCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_stages(mut self, p_stages: &'a [vk::PipelineShaderStageCreateInfo]) -> Self {
        self.inner.stage_count = p_stages.len() as u32;
        self.inner.p_stages = p_stages.as_ptr();
        self
    }
    pub fn p_vertex_input_state(
        mut self,
        p_vertex_input_state: Option<&'a vk::PipelineVertexInputStateCreateInfo>,
    ) -> Self {
        self.inner.p_vertex_input_state = p_vertex_input_state.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_tessellation_state(
        mut self,
        p_tessellation_state: Option<&'a vk::PipelineTessellationStateCreateInfo>,
    ) -> Self {
        self.inner.p_tessellation_state = p_tessellation_state.map_or(ptr::null(), |r| r);
        self
    }
}
impl<'a> Deref for GraphicsShaderGroupCreateInfoNVBuilder<'a> {
    type Target = vk::GraphicsShaderGroupCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'a> {
    inner: vk::GraphicsPipelineShaderGroupsCreateInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::GraphicsPipelineShaderGroupsCreateInfoNV {
    type Type = GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::GraphicsPipelineShaderGroupsCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_groups(mut self, p_groups: &'a [vk::GraphicsShaderGroupCreateInfoNV]) -> Self {
        self.inner.group_count = p_groups.len() as u32;
        self.inner.p_groups = p_groups.as_ptr();
        self
    }
    pub fn p_pipelines(mut self, p_pipelines: &'a [vk::Pipeline]) -> Self {
        self.inner.pipeline_count = p_pipelines.len() as u32;
        self.inner.p_pipelines = p_pipelines.as_ptr();
        self
    }
}
impl<'a> Deref for GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'a> {
    type Target = vk::GraphicsPipelineShaderGroupsCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::GraphicsPipelineShaderGroupsCreateInfoNV {}
impl GraphicsPipelineCreateInfoNext for GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct BindShaderGroupIndirectCommandNVBuilder {
    inner: vk::BindShaderGroupIndirectCommandNV,
}
impl Builder<'_> for vk::BindShaderGroupIndirectCommandNV {
    type Type = BindShaderGroupIndirectCommandNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BindShaderGroupIndirectCommandNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BindShaderGroupIndirectCommandNV {
        &mut self.inner
    }
    pub fn group_index(mut self, group_index: u32) -> Self {
        self.inner.group_index = group_index;
        self
    }
}
impl Deref for BindShaderGroupIndirectCommandNVBuilder {
    type Target = vk::BindShaderGroupIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BindIndexBufferIndirectCommandNVBuilder {
    inner: vk::BindIndexBufferIndirectCommandNV,
}
impl Builder<'_> for vk::BindIndexBufferIndirectCommandNV {
    type Type = BindIndexBufferIndirectCommandNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BindIndexBufferIndirectCommandNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BindIndexBufferIndirectCommandNV {
        &mut self.inner
    }
    pub fn buffer_address(mut self, buffer_address: vk::DeviceAddress) -> Self {
        self.inner.buffer_address = buffer_address;
        self
    }
    pub fn size(mut self, size: u32) -> Self {
        self.inner.size = size;
        self
    }
    pub fn index_type(mut self, index_type: vk::IndexType) -> Self {
        self.inner.index_type = index_type;
        self
    }
}
impl Deref for BindIndexBufferIndirectCommandNVBuilder {
    type Target = vk::BindIndexBufferIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BindVertexBufferIndirectCommandNVBuilder {
    inner: vk::BindVertexBufferIndirectCommandNV,
}
impl Builder<'_> for vk::BindVertexBufferIndirectCommandNV {
    type Type = BindVertexBufferIndirectCommandNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BindVertexBufferIndirectCommandNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BindVertexBufferIndirectCommandNV {
        &mut self.inner
    }
    pub fn buffer_address(mut self, buffer_address: vk::DeviceAddress) -> Self {
        self.inner.buffer_address = buffer_address;
        self
    }
    pub fn size(mut self, size: u32) -> Self {
        self.inner.size = size;
        self
    }
    pub fn stride(mut self, stride: u32) -> Self {
        self.inner.stride = stride;
        self
    }
}
impl Deref for BindVertexBufferIndirectCommandNVBuilder {
    type Target = vk::BindVertexBufferIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SetStateFlagsIndirectCommandNVBuilder {
    inner: vk::SetStateFlagsIndirectCommandNV,
}
impl Builder<'_> for vk::SetStateFlagsIndirectCommandNV {
    type Type = SetStateFlagsIndirectCommandNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SetStateFlagsIndirectCommandNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SetStateFlagsIndirectCommandNV {
        &mut self.inner
    }
    pub fn data(mut self, data: u32) -> Self {
        self.inner.data = data;
        self
    }
}
impl Deref for SetStateFlagsIndirectCommandNVBuilder {
    type Target = vk::SetStateFlagsIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct IndirectCommandsStreamNVBuilder {
    inner: vk::IndirectCommandsStreamNV,
}
impl Builder<'_> for vk::IndirectCommandsStreamNV {
    type Type = IndirectCommandsStreamNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl IndirectCommandsStreamNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::IndirectCommandsStreamNV {
        &mut self.inner
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    pub fn offset(mut self, offset: vk::DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
}
impl Deref for IndirectCommandsStreamNVBuilder {
    type Target = vk::IndirectCommandsStreamNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct IndirectCommandsLayoutTokenNVBuilder<'a> {
    inner: vk::IndirectCommandsLayoutTokenNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::IndirectCommandsLayoutTokenNV {
    type Type = IndirectCommandsLayoutTokenNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> IndirectCommandsLayoutTokenNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::IndirectCommandsLayoutTokenNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn token_type(mut self, token_type: vk::IndirectCommandsTokenTypeNV) -> Self {
        self.inner.token_type = token_type;
        self
    }
    pub fn stream(mut self, stream: u32) -> Self {
        self.inner.stream = stream;
        self
    }
    pub fn offset(mut self, offset: u32) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn vertex_binding_unit(mut self, vertex_binding_unit: u32) -> Self {
        self.inner.vertex_binding_unit = vertex_binding_unit;
        self
    }
    pub fn vertex_dynamic_stride(mut self, vertex_dynamic_stride: bool) -> Self {
        self.inner.vertex_dynamic_stride = if vertex_dynamic_stride { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn pushconstant_pipeline_layout(mut self, pushconstant_pipeline_layout: vk::PipelineLayout) -> Self {
        self.inner.pushconstant_pipeline_layout = pushconstant_pipeline_layout;
        self
    }
    pub fn pushconstant_shader_stage_flags(mut self, pushconstant_shader_stage_flags: vk::ShaderStageFlags) -> Self {
        self.inner.pushconstant_shader_stage_flags = pushconstant_shader_stage_flags;
        self
    }
    pub fn pushconstant_offset(mut self, pushconstant_offset: u32) -> Self {
        self.inner.pushconstant_offset = pushconstant_offset;
        self
    }
    pub fn pushconstant_size(mut self, pushconstant_size: u32) -> Self {
        self.inner.pushconstant_size = pushconstant_size;
        self
    }
    pub fn indirect_state_flags(mut self, indirect_state_flags: vk::IndirectStateFlagsNV) -> Self {
        self.inner.indirect_state_flags = indirect_state_flags;
        self
    }
    pub fn p_index_types(mut self, p_index_types: &'a [vk::IndexType], p_index_type_values: &'a [u32]) -> Self {
        self.inner.index_type_count = p_index_types.len() as u32;
        assert_eq!(self.inner.index_type_count, p_index_type_values.len() as u32);
        self.inner.p_index_types = p_index_types.as_ptr();
        self.inner.p_index_type_values = p_index_type_values.as_ptr();
        self
    }
}
impl<'a> Deref for IndirectCommandsLayoutTokenNVBuilder<'a> {
    type Target = vk::IndirectCommandsLayoutTokenNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
    inner: vk::IndirectCommandsLayoutCreateInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::IndirectCommandsLayoutCreateInfoNV {
    type Type = IndirectCommandsLayoutCreateInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::IndirectCommandsLayoutCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::IndirectCommandsLayoutUsageFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: vk::PipelineBindPoint) -> Self {
        self.inner.pipeline_bind_point = pipeline_bind_point;
        self
    }
    pub fn p_tokens(mut self, p_tokens: &'a [vk::IndirectCommandsLayoutTokenNV]) -> Self {
        self.inner.token_count = p_tokens.len() as u32;
        self.inner.p_tokens = p_tokens.as_ptr();
        self
    }
    pub fn p_stream_strides(mut self, p_stream_strides: &'a [u32]) -> Self {
        self.inner.stream_count = p_stream_strides.len() as u32;
        self.inner.p_stream_strides = p_stream_strides.as_ptr();
        self
    }
}
impl<'a> Deref for IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
    type Target = vk::IndirectCommandsLayoutCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct GeneratedCommandsInfoNVBuilder<'a> {
    inner: vk::GeneratedCommandsInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::GeneratedCommandsInfoNV {
    type Type = GeneratedCommandsInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> GeneratedCommandsInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::GeneratedCommandsInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: vk::PipelineBindPoint) -> Self {
        self.inner.pipeline_bind_point = pipeline_bind_point;
        self
    }
    pub fn pipeline(mut self, pipeline: vk::Pipeline) -> Self {
        self.inner.pipeline = pipeline;
        self
    }
    pub fn indirect_commands_layout(mut self, indirect_commands_layout: vk::IndirectCommandsLayoutNV) -> Self {
        self.inner.indirect_commands_layout = indirect_commands_layout;
        self
    }
    pub fn p_streams(mut self, p_streams: &'a [vk::IndirectCommandsStreamNV]) -> Self {
        self.inner.stream_count = p_streams.len() as u32;
        self.inner.p_streams = p_streams.as_ptr();
        self
    }
    pub fn sequences_count(mut self, sequences_count: u32) -> Self {
        self.inner.sequences_count = sequences_count;
        self
    }
    pub fn preprocess_buffer(mut self, preprocess_buffer: vk::Buffer) -> Self {
        self.inner.preprocess_buffer = preprocess_buffer;
        self
    }
    pub fn preprocess_offset(mut self, preprocess_offset: vk::DeviceSize) -> Self {
        self.inner.preprocess_offset = preprocess_offset;
        self
    }
    pub fn preprocess_size(mut self, preprocess_size: vk::DeviceSize) -> Self {
        self.inner.preprocess_size = preprocess_size;
        self
    }
    pub fn sequences_count_buffer(mut self, sequences_count_buffer: vk::Buffer) -> Self {
        self.inner.sequences_count_buffer = sequences_count_buffer;
        self
    }
    pub fn sequences_count_offset(mut self, sequences_count_offset: vk::DeviceSize) -> Self {
        self.inner.sequences_count_offset = sequences_count_offset;
        self
    }
    pub fn sequences_index_buffer(mut self, sequences_index_buffer: vk::Buffer) -> Self {
        self.inner.sequences_index_buffer = sequences_index_buffer;
        self
    }
    pub fn sequences_index_offset(mut self, sequences_index_offset: vk::DeviceSize) -> Self {
        self.inner.sequences_index_offset = sequences_index_offset;
        self
    }
}
impl<'a> Deref for GeneratedCommandsInfoNVBuilder<'a> {
    type Target = vk::GeneratedCommandsInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct GeneratedCommandsMemoryRequirementsInfoNVBuilder {
    inner: vk::GeneratedCommandsMemoryRequirementsInfoNV,
}
impl Builder<'_> for vk::GeneratedCommandsMemoryRequirementsInfoNV {
    type Type = GeneratedCommandsMemoryRequirementsInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl GeneratedCommandsMemoryRequirementsInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::GeneratedCommandsMemoryRequirementsInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: vk::PipelineBindPoint) -> Self {
        self.inner.pipeline_bind_point = pipeline_bind_point;
        self
    }
    pub fn pipeline(mut self, pipeline: vk::Pipeline) -> Self {
        self.inner.pipeline = pipeline;
        self
    }
    pub fn indirect_commands_layout(mut self, indirect_commands_layout: vk::IndirectCommandsLayoutNV) -> Self {
        self.inner.indirect_commands_layout = indirect_commands_layout;
        self
    }
    pub fn max_sequences_count(mut self, max_sequences_count: u32) -> Self {
        self.inner.max_sequences_count = max_sequences_count;
        self
    }
}
impl Deref for GeneratedCommandsMemoryRequirementsInfoNVBuilder {
    type Target = vk::GeneratedCommandsMemoryRequirementsInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineIndirectDeviceAddressInfoNVBuilder {
    inner: vk::PipelineIndirectDeviceAddressInfoNV,
}
impl Builder<'_> for vk::PipelineIndirectDeviceAddressInfoNV {
    type Type = PipelineIndirectDeviceAddressInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineIndirectDeviceAddressInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineIndirectDeviceAddressInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: vk::PipelineBindPoint) -> Self {
        self.inner.pipeline_bind_point = pipeline_bind_point;
        self
    }
    pub fn pipeline(mut self, pipeline: vk::Pipeline) -> Self {
        self.inner.pipeline = pipeline;
        self
    }
}
impl Deref for PipelineIndirectDeviceAddressInfoNVBuilder {
    type Target = vk::PipelineIndirectDeviceAddressInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BindPipelineIndirectCommandNVBuilder {
    inner: vk::BindPipelineIndirectCommandNV,
}
impl Builder<'_> for vk::BindPipelineIndirectCommandNV {
    type Type = BindPipelineIndirectCommandNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BindPipelineIndirectCommandNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BindPipelineIndirectCommandNV {
        &mut self.inner
    }
    pub fn pipeline_address(mut self, pipeline_address: vk::DeviceAddress) -> Self {
        self.inner.pipeline_address = pipeline_address;
        self
    }
}
impl Deref for BindPipelineIndirectCommandNVBuilder {
    type Target = vk::BindPipelineIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceFeatures2Builder<'a> {
    inner: vk::PhysicalDeviceFeatures2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PhysicalDeviceFeatures2 {
    type Type = PhysicalDeviceFeatures2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PhysicalDeviceFeatures2Next {}
impl<'a> PhysicalDeviceFeatures2Builder<'a> {
    pub fn insert_next<T: PhysicalDeviceFeatures2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceFeatures2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn features(mut self, features: vk::PhysicalDeviceFeatures) -> Self {
        self.inner.features = features;
        self
    }
}
impl<'a> Deref for PhysicalDeviceFeatures2Builder<'a> {
    type Target = vk::PhysicalDeviceFeatures2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DeviceCreateInfoNext for vk::PhysicalDeviceFeatures2 {}
impl DeviceCreateInfoNext for PhysicalDeviceFeatures2Builder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceProperties2Builder<'a> {
    inner: vk::PhysicalDeviceProperties2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PhysicalDeviceProperties2 {
    type Type = PhysicalDeviceProperties2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PhysicalDeviceProperties2Next {}
impl<'a> PhysicalDeviceProperties2Builder<'a> {
    pub fn insert_next<T: PhysicalDeviceProperties2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceProperties2 {
        &mut self.inner
    }
}
impl<'a> Deref for PhysicalDeviceProperties2Builder<'a> {
    type Target = vk::PhysicalDeviceProperties2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct FormatProperties2Builder<'a> {
    inner: vk::FormatProperties2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::FormatProperties2 {
    type Type = FormatProperties2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait FormatProperties2Next {}
impl<'a> FormatProperties2Builder<'a> {
    pub fn insert_next<T: FormatProperties2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::FormatProperties2 {
        &mut self.inner
    }
}
impl<'a> Deref for FormatProperties2Builder<'a> {
    type Target = vk::FormatProperties2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageFormatProperties2Builder<'a> {
    inner: vk::ImageFormatProperties2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImageFormatProperties2 {
    type Type = ImageFormatProperties2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait ImageFormatProperties2Next {}
impl<'a> ImageFormatProperties2Builder<'a> {
    pub fn insert_next<T: ImageFormatProperties2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::ImageFormatProperties2 {
        &mut self.inner
    }
}
impl<'a> Deref for ImageFormatProperties2Builder<'a> {
    type Target = vk::ImageFormatProperties2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceImageFormatInfo2Builder<'a> {
    inner: vk::PhysicalDeviceImageFormatInfo2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PhysicalDeviceImageFormatInfo2 {
    type Type = PhysicalDeviceImageFormatInfo2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PhysicalDeviceImageFormatInfo2Next {}
impl<'a> PhysicalDeviceImageFormatInfo2Builder<'a> {
    pub fn insert_next<T: PhysicalDeviceImageFormatInfo2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceImageFormatInfo2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn format(mut self, format: vk::Format) -> Self {
        self.inner.format = format;
        self
    }
    pub fn ty(mut self, ty: vk::ImageType) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn tiling(mut self, tiling: vk::ImageTiling) -> Self {
        self.inner.tiling = tiling;
        self
    }
    pub fn usage(mut self, usage: vk::ImageUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
    pub fn flags(mut self, flags: vk::ImageCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl<'a> Deref for PhysicalDeviceImageFormatInfo2Builder<'a> {
    type Target = vk::PhysicalDeviceImageFormatInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct QueueFamilyProperties2Builder<'a> {
    inner: vk::QueueFamilyProperties2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::QueueFamilyProperties2 {
    type Type = QueueFamilyProperties2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait QueueFamilyProperties2Next {}
impl<'a> QueueFamilyProperties2Builder<'a> {
    pub fn insert_next<T: QueueFamilyProperties2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::QueueFamilyProperties2 {
        &mut self.inner
    }
}
impl<'a> Deref for QueueFamilyProperties2Builder<'a> {
    type Target = vk::QueueFamilyProperties2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMemoryProperties2Builder<'a> {
    inner: vk::PhysicalDeviceMemoryProperties2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PhysicalDeviceMemoryProperties2 {
    type Type = PhysicalDeviceMemoryProperties2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PhysicalDeviceMemoryProperties2Next {}
impl<'a> PhysicalDeviceMemoryProperties2Builder<'a> {
    pub fn insert_next<T: PhysicalDeviceMemoryProperties2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMemoryProperties2 {
        &mut self.inner
    }
}
impl<'a> Deref for PhysicalDeviceMemoryProperties2Builder<'a> {
    type Target = vk::PhysicalDeviceMemoryProperties2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceSparseImageFormatInfo2Builder {
    inner: vk::PhysicalDeviceSparseImageFormatInfo2,
}
impl Builder<'_> for vk::PhysicalDeviceSparseImageFormatInfo2 {
    type Type = PhysicalDeviceSparseImageFormatInfo2Builder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceSparseImageFormatInfo2Builder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceSparseImageFormatInfo2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn format(mut self, format: vk::Format) -> Self {
        self.inner.format = format;
        self
    }
    pub fn ty(mut self, ty: vk::ImageType) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn samples(mut self, samples: vk::SampleCountFlags) -> Self {
        self.inner.samples = samples;
        self
    }
    pub fn usage(mut self, usage: vk::ImageUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
    pub fn tiling(mut self, tiling: vk::ImageTiling) -> Self {
        self.inner.tiling = tiling;
        self
    }
}
impl Deref for PhysicalDeviceSparseImageFormatInfo2Builder {
    type Target = vk::PhysicalDeviceSparseImageFormatInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDevicePushDescriptorProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct ConformanceVersionBuilder {
    inner: vk::ConformanceVersion,
}
impl Builder<'_> for vk::ConformanceVersion {
    type Type = ConformanceVersionBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ConformanceVersionBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ConformanceVersion {
        &mut self.inner
    }
    pub fn major(mut self, major: u8) -> Self {
        self.inner.major = major;
        self
    }
    pub fn minor(mut self, minor: u8) -> Self {
        self.inner.minor = minor;
        self
    }
    pub fn subminor(mut self, subminor: u8) -> Self {
        self.inner.subminor = subminor;
        self
    }
    pub fn patch(mut self, patch: u8) -> Self {
        self.inner.patch = patch;
        self
    }
}
impl Deref for ConformanceVersionBuilder {
    type Target = vk::ConformanceVersion;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceDriverProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct PresentRegionsKHRBuilder<'a> {
    inner: vk::PresentRegionsKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PresentRegionsKHR {
    type Type = PresentRegionsKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PresentRegionsKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PresentRegionsKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_regions(mut self, p_regions: &'a [vk::PresentRegionKHR]) -> Self {
        self.inner.swapchain_count = p_regions.len() as u32;
        self.inner.p_regions = p_regions.as_ptr();
        self
    }
}
impl<'a> Deref for PresentRegionsKHRBuilder<'a> {
    type Target = vk::PresentRegionsKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PresentInfoKHRNext for vk::PresentRegionsKHR {}
impl PresentInfoKHRNext for PresentRegionsKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PresentRegionKHRBuilder<'a> {
    inner: vk::PresentRegionKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PresentRegionKHR {
    type Type = PresentRegionKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PresentRegionKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PresentRegionKHR {
        &mut self.inner
    }
    pub fn p_rectangles(mut self, p_rectangles: &'a [vk::RectLayerKHR]) -> Self {
        self.inner.rectangle_count = p_rectangles.len() as u32;
        self.inner.p_rectangles = p_rectangles.as_ptr();
        self
    }
}
impl<'a> Deref for PresentRegionKHRBuilder<'a> {
    type Target = vk::PresentRegionKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RectLayerKHRBuilder {
    inner: vk::RectLayerKHR,
}
impl Builder<'_> for vk::RectLayerKHR {
    type Type = RectLayerKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl RectLayerKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::RectLayerKHR {
        &mut self.inner
    }
    pub fn offset(mut self, offset: vk::Offset2D) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn extent(mut self, extent: vk::Extent2D) -> Self {
        self.inner.extent = extent;
        self
    }
    pub fn layer(mut self, layer: u32) -> Self {
        self.inner.layer = layer;
        self
    }
}
impl Deref for RectLayerKHRBuilder {
    type Target = vk::RectLayerKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceVariablePointersFeaturesBuilder {
    inner: vk::PhysicalDeviceVariablePointersFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceVariablePointersFeatures {
    type Type = PhysicalDeviceVariablePointersFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceVariablePointersFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceVariablePointersFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn variable_pointers_storage_buffer(mut self, variable_pointers_storage_buffer: bool) -> Self {
        self.inner.variable_pointers_storage_buffer = if variable_pointers_storage_buffer {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn variable_pointers(mut self, variable_pointers: bool) -> Self {
        self.inner.variable_pointers = if variable_pointers { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceVariablePointersFeaturesBuilder {
    type Target = vk::PhysicalDeviceVariablePointersFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceVariablePointersFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceVariablePointersFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceVariablePointersFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceVariablePointersFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceExternalImageFormatInfoBuilder {
    inner: vk::PhysicalDeviceExternalImageFormatInfo,
}
impl Builder<'_> for vk::PhysicalDeviceExternalImageFormatInfo {
    type Type = PhysicalDeviceExternalImageFormatInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceExternalImageFormatInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceExternalImageFormatInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl Deref for PhysicalDeviceExternalImageFormatInfoBuilder {
    type Target = vk::PhysicalDeviceExternalImageFormatInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceImageFormatInfo2Next for vk::PhysicalDeviceExternalImageFormatInfo {}
impl PhysicalDeviceImageFormatInfo2Next for PhysicalDeviceExternalImageFormatInfoBuilder {}
impl ImageFormatProperties2Next for vk::ExternalImageFormatProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceExternalBufferInfoBuilder<'a> {
    inner: vk::PhysicalDeviceExternalBufferInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PhysicalDeviceExternalBufferInfo {
    type Type = PhysicalDeviceExternalBufferInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PhysicalDeviceExternalBufferInfoNext {}
impl<'a> PhysicalDeviceExternalBufferInfoBuilder<'a> {
    pub fn insert_next<T: PhysicalDeviceExternalBufferInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceExternalBufferInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::BufferCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn usage(mut self, usage: vk::BufferUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl<'a> Deref for PhysicalDeviceExternalBufferInfoBuilder<'a> {
    type Target = vk::PhysicalDeviceExternalBufferInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceIDProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExternalMemoryImageCreateInfoBuilder {
    inner: vk::ExternalMemoryImageCreateInfo,
}
impl Builder<'_> for vk::ExternalMemoryImageCreateInfo {
    type Type = ExternalMemoryImageCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExternalMemoryImageCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExternalMemoryImageCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_types(mut self, handle_types: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
}
impl Deref for ExternalMemoryImageCreateInfoBuilder {
    type Target = vk::ExternalMemoryImageCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageCreateInfoNext for vk::ExternalMemoryImageCreateInfo {}
impl ImageCreateInfoNext for ExternalMemoryImageCreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExternalMemoryBufferCreateInfoBuilder {
    inner: vk::ExternalMemoryBufferCreateInfo,
}
impl Builder<'_> for vk::ExternalMemoryBufferCreateInfo {
    type Type = ExternalMemoryBufferCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExternalMemoryBufferCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExternalMemoryBufferCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_types(mut self, handle_types: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
}
impl Deref for ExternalMemoryBufferCreateInfoBuilder {
    type Target = vk::ExternalMemoryBufferCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BufferCreateInfoNext for vk::ExternalMemoryBufferCreateInfo {}
impl BufferCreateInfoNext for ExternalMemoryBufferCreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportMemoryAllocateInfoBuilder {
    inner: vk::ExportMemoryAllocateInfo,
}
impl Builder<'_> for vk::ExportMemoryAllocateInfo {
    type Type = ExportMemoryAllocateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExportMemoryAllocateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExportMemoryAllocateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_types(mut self, handle_types: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
}
impl Deref for ExportMemoryAllocateInfoBuilder {
    type Target = vk::ExportMemoryAllocateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::ExportMemoryAllocateInfo {}
impl MemoryAllocateInfoNext for ExportMemoryAllocateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportMemoryWin32HandleInfoKHRBuilder {
    inner: vk::ImportMemoryWin32HandleInfoKHR,
}
impl Builder<'_> for vk::ImportMemoryWin32HandleInfoKHR {
    type Type = ImportMemoryWin32HandleInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImportMemoryWin32HandleInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImportMemoryWin32HandleInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    pub fn handle(mut self, handle: vk::HANDLE) -> Self {
        self.inner.handle = handle;
        self
    }
    pub fn name(mut self, name: vk::LPCWSTR) -> Self {
        self.inner.name = name;
        self
    }
}
impl Deref for ImportMemoryWin32HandleInfoKHRBuilder {
    type Target = vk::ImportMemoryWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::ImportMemoryWin32HandleInfoKHR {}
impl MemoryAllocateInfoNext for ImportMemoryWin32HandleInfoKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportMemoryWin32HandleInfoKHRBuilder<'a> {
    inner: vk::ExportMemoryWin32HandleInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ExportMemoryWin32HandleInfoKHR {
    type Type = ExportMemoryWin32HandleInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ExportMemoryWin32HandleInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ExportMemoryWin32HandleInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_attributes(mut self, p_attributes: Option<&'a vk::SECURITY_ATTRIBUTES>) -> Self {
        self.inner.p_attributes = p_attributes.map_or(ptr::null(), |r| r);
        self
    }
    pub fn dw_access(mut self, dw_access: vk::DWORD) -> Self {
        self.inner.dw_access = dw_access;
        self
    }
    pub fn name(mut self, name: vk::LPCWSTR) -> Self {
        self.inner.name = name;
        self
    }
}
impl<'a> Deref for ExportMemoryWin32HandleInfoKHRBuilder<'a> {
    type Target = vk::ExportMemoryWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::ExportMemoryWin32HandleInfoKHR {}
impl MemoryAllocateInfoNext for ExportMemoryWin32HandleInfoKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportMemoryZirconHandleInfoFUCHSIABuilder {
    inner: vk::ImportMemoryZirconHandleInfoFUCHSIA,
}
impl Builder<'_> for vk::ImportMemoryZirconHandleInfoFUCHSIA {
    type Type = ImportMemoryZirconHandleInfoFUCHSIABuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImportMemoryZirconHandleInfoFUCHSIABuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImportMemoryZirconHandleInfoFUCHSIA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    pub fn handle(mut self, handle: vk::zx_handle_t) -> Self {
        self.inner.handle = handle;
        self
    }
}
impl Deref for ImportMemoryZirconHandleInfoFUCHSIABuilder {
    type Target = vk::ImportMemoryZirconHandleInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::ImportMemoryZirconHandleInfoFUCHSIA {}
impl MemoryAllocateInfoNext for ImportMemoryZirconHandleInfoFUCHSIABuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryGetZirconHandleInfoFUCHSIABuilder {
    inner: vk::MemoryGetZirconHandleInfoFUCHSIA,
}
impl Builder<'_> for vk::MemoryGetZirconHandleInfoFUCHSIA {
    type Type = MemoryGetZirconHandleInfoFUCHSIABuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryGetZirconHandleInfoFUCHSIABuilder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryGetZirconHandleInfoFUCHSIA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl Deref for MemoryGetZirconHandleInfoFUCHSIABuilder {
    type Target = vk::MemoryGetZirconHandleInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryGetWin32HandleInfoKHRBuilder {
    inner: vk::MemoryGetWin32HandleInfoKHR,
}
impl Builder<'_> for vk::MemoryGetWin32HandleInfoKHR {
    type Type = MemoryGetWin32HandleInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryGetWin32HandleInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryGetWin32HandleInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl Deref for MemoryGetWin32HandleInfoKHRBuilder {
    type Target = vk::MemoryGetWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportMemoryFdInfoKHRBuilder {
    inner: vk::ImportMemoryFdInfoKHR,
}
impl Builder<'_> for vk::ImportMemoryFdInfoKHR {
    type Type = ImportMemoryFdInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImportMemoryFdInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImportMemoryFdInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    pub fn fd(mut self, fd: c_int) -> Self {
        self.inner.fd = fd;
        self
    }
}
impl Deref for ImportMemoryFdInfoKHRBuilder {
    type Target = vk::ImportMemoryFdInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::ImportMemoryFdInfoKHR {}
impl MemoryAllocateInfoNext for ImportMemoryFdInfoKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryGetFdInfoKHRBuilder {
    inner: vk::MemoryGetFdInfoKHR,
}
impl Builder<'_> for vk::MemoryGetFdInfoKHR {
    type Type = MemoryGetFdInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryGetFdInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryGetFdInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl Deref for MemoryGetFdInfoKHRBuilder {
    type Target = vk::MemoryGetFdInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
    inner: vk::Win32KeyedMutexAcquireReleaseInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::Win32KeyedMutexAcquireReleaseInfoKHR {
    type Type = Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::Win32KeyedMutexAcquireReleaseInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_acquire_syncs(
        mut self,
        p_acquire_syncs: &'a [vk::DeviceMemory],
        p_acquire_keys: &'a [u64],
        p_acquire_timeouts: &'a [u32],
    ) -> Self {
        self.inner.acquire_count = p_acquire_syncs.len() as u32;
        assert_eq!(self.inner.acquire_count, p_acquire_keys.len() as u32);
        assert_eq!(self.inner.acquire_count, p_acquire_timeouts.len() as u32);
        self.inner.p_acquire_syncs = p_acquire_syncs.as_ptr();
        self.inner.p_acquire_keys = p_acquire_keys.as_ptr();
        self.inner.p_acquire_timeouts = p_acquire_timeouts.as_ptr();
        self
    }
    pub fn p_release_syncs(mut self, p_release_syncs: &'a [vk::DeviceMemory], p_release_keys: &'a [u64]) -> Self {
        self.inner.release_count = p_release_syncs.len() as u32;
        assert_eq!(self.inner.release_count, p_release_keys.len() as u32);
        self.inner.p_release_syncs = p_release_syncs.as_ptr();
        self.inner.p_release_keys = p_release_keys.as_ptr();
        self
    }
}
impl<'a> Deref for Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
    type Target = vk::Win32KeyedMutexAcquireReleaseInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubmitInfoNext for vk::Win32KeyedMutexAcquireReleaseInfoKHR {}
impl SubmitInfoNext for Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'_> {}
impl SubmitInfo2Next for vk::Win32KeyedMutexAcquireReleaseInfoKHR {}
impl SubmitInfo2Next for Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportMemoryMetalHandleInfoEXTBuilder<'a> {
    inner: vk::ImportMemoryMetalHandleInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImportMemoryMetalHandleInfoEXT {
    type Type = ImportMemoryMetalHandleInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ImportMemoryMetalHandleInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ImportMemoryMetalHandleInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    pub fn handle(mut self, handle: *mut c_void) -> Self {
        self.inner.handle = handle;
        self
    }
}
impl<'a> Deref for ImportMemoryMetalHandleInfoEXTBuilder<'a> {
    type Target = vk::ImportMemoryMetalHandleInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::ImportMemoryMetalHandleInfoEXT {}
impl MemoryAllocateInfoNext for ImportMemoryMetalHandleInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryGetMetalHandleInfoEXTBuilder {
    inner: vk::MemoryGetMetalHandleInfoEXT,
}
impl Builder<'_> for vk::MemoryGetMetalHandleInfoEXT {
    type Type = MemoryGetMetalHandleInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryGetMetalHandleInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryGetMetalHandleInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl Deref for MemoryGetMetalHandleInfoEXTBuilder {
    type Target = vk::MemoryGetMetalHandleInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceExternalSemaphoreInfoBuilder<'a> {
    inner: vk::PhysicalDeviceExternalSemaphoreInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PhysicalDeviceExternalSemaphoreInfo {
    type Type = PhysicalDeviceExternalSemaphoreInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PhysicalDeviceExternalSemaphoreInfoNext {}
impl<'a> PhysicalDeviceExternalSemaphoreInfoBuilder<'a> {
    pub fn insert_next<T: PhysicalDeviceExternalSemaphoreInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceExternalSemaphoreInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl<'a> Deref for PhysicalDeviceExternalSemaphoreInfoBuilder<'a> {
    type Target = vk::PhysicalDeviceExternalSemaphoreInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportSemaphoreCreateInfoBuilder {
    inner: vk::ExportSemaphoreCreateInfo,
}
impl Builder<'_> for vk::ExportSemaphoreCreateInfo {
    type Type = ExportSemaphoreCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExportSemaphoreCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExportSemaphoreCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_types(mut self, handle_types: vk::ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
}
impl Deref for ExportSemaphoreCreateInfoBuilder {
    type Target = vk::ExportSemaphoreCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SemaphoreCreateInfoNext for vk::ExportSemaphoreCreateInfo {}
impl SemaphoreCreateInfoNext for ExportSemaphoreCreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportSemaphoreWin32HandleInfoKHRBuilder {
    inner: vk::ImportSemaphoreWin32HandleInfoKHR,
}
impl Builder<'_> for vk::ImportSemaphoreWin32HandleInfoKHR {
    type Type = ImportSemaphoreWin32HandleInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImportSemaphoreWin32HandleInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImportSemaphoreWin32HandleInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn semaphore(mut self, semaphore: vk::Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    pub fn flags(mut self, flags: vk::SemaphoreImportFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    pub fn handle(mut self, handle: vk::HANDLE) -> Self {
        self.inner.handle = handle;
        self
    }
    pub fn name(mut self, name: vk::LPCWSTR) -> Self {
        self.inner.name = name;
        self
    }
}
impl Deref for ImportSemaphoreWin32HandleInfoKHRBuilder {
    type Target = vk::ImportSemaphoreWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportSemaphoreWin32HandleInfoKHRBuilder<'a> {
    inner: vk::ExportSemaphoreWin32HandleInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ExportSemaphoreWin32HandleInfoKHR {
    type Type = ExportSemaphoreWin32HandleInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ExportSemaphoreWin32HandleInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ExportSemaphoreWin32HandleInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_attributes(mut self, p_attributes: Option<&'a vk::SECURITY_ATTRIBUTES>) -> Self {
        self.inner.p_attributes = p_attributes.map_or(ptr::null(), |r| r);
        self
    }
    pub fn dw_access(mut self, dw_access: vk::DWORD) -> Self {
        self.inner.dw_access = dw_access;
        self
    }
    pub fn name(mut self, name: vk::LPCWSTR) -> Self {
        self.inner.name = name;
        self
    }
}
impl<'a> Deref for ExportSemaphoreWin32HandleInfoKHRBuilder<'a> {
    type Target = vk::ExportSemaphoreWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SemaphoreCreateInfoNext for vk::ExportSemaphoreWin32HandleInfoKHR {}
impl SemaphoreCreateInfoNext for ExportSemaphoreWin32HandleInfoKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct D3D12FenceSubmitInfoKHRBuilder<'a> {
    inner: vk::D3D12FenceSubmitInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::D3D12FenceSubmitInfoKHR {
    type Type = D3D12FenceSubmitInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> D3D12FenceSubmitInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::D3D12FenceSubmitInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_wait_semaphore_values(mut self, p_wait_semaphore_values: &'a [u64]) -> Self {
        self.inner.wait_semaphore_values_count = p_wait_semaphore_values.len() as u32;
        self.inner.p_wait_semaphore_values = p_wait_semaphore_values.as_ptr();
        self
    }
    pub fn p_signal_semaphore_values(mut self, p_signal_semaphore_values: &'a [u64]) -> Self {
        self.inner.signal_semaphore_values_count = p_signal_semaphore_values.len() as u32;
        self.inner.p_signal_semaphore_values = p_signal_semaphore_values.as_ptr();
        self
    }
}
impl<'a> Deref for D3D12FenceSubmitInfoKHRBuilder<'a> {
    type Target = vk::D3D12FenceSubmitInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubmitInfoNext for vk::D3D12FenceSubmitInfoKHR {}
impl SubmitInfoNext for D3D12FenceSubmitInfoKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct SemaphoreGetWin32HandleInfoKHRBuilder {
    inner: vk::SemaphoreGetWin32HandleInfoKHR,
}
impl Builder<'_> for vk::SemaphoreGetWin32HandleInfoKHR {
    type Type = SemaphoreGetWin32HandleInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SemaphoreGetWin32HandleInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SemaphoreGetWin32HandleInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn semaphore(mut self, semaphore: vk::Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl Deref for SemaphoreGetWin32HandleInfoKHRBuilder {
    type Target = vk::SemaphoreGetWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportSemaphoreFdInfoKHRBuilder {
    inner: vk::ImportSemaphoreFdInfoKHR,
}
impl Builder<'_> for vk::ImportSemaphoreFdInfoKHR {
    type Type = ImportSemaphoreFdInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImportSemaphoreFdInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImportSemaphoreFdInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn semaphore(mut self, semaphore: vk::Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    pub fn flags(mut self, flags: vk::SemaphoreImportFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    pub fn fd(mut self, fd: c_int) -> Self {
        self.inner.fd = fd;
        self
    }
}
impl Deref for ImportSemaphoreFdInfoKHRBuilder {
    type Target = vk::ImportSemaphoreFdInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SemaphoreGetFdInfoKHRBuilder {
    inner: vk::SemaphoreGetFdInfoKHR,
}
impl Builder<'_> for vk::SemaphoreGetFdInfoKHR {
    type Type = SemaphoreGetFdInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SemaphoreGetFdInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SemaphoreGetFdInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn semaphore(mut self, semaphore: vk::Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl Deref for SemaphoreGetFdInfoKHRBuilder {
    type Target = vk::SemaphoreGetFdInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportSemaphoreZirconHandleInfoFUCHSIABuilder {
    inner: vk::ImportSemaphoreZirconHandleInfoFUCHSIA,
}
impl Builder<'_> for vk::ImportSemaphoreZirconHandleInfoFUCHSIA {
    type Type = ImportSemaphoreZirconHandleInfoFUCHSIABuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImportSemaphoreZirconHandleInfoFUCHSIABuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImportSemaphoreZirconHandleInfoFUCHSIA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn semaphore(mut self, semaphore: vk::Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    pub fn flags(mut self, flags: vk::SemaphoreImportFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    pub fn zircon_handle(mut self, zircon_handle: vk::zx_handle_t) -> Self {
        self.inner.zircon_handle = zircon_handle;
        self
    }
}
impl Deref for ImportSemaphoreZirconHandleInfoFUCHSIABuilder {
    type Target = vk::ImportSemaphoreZirconHandleInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SemaphoreGetZirconHandleInfoFUCHSIABuilder {
    inner: vk::SemaphoreGetZirconHandleInfoFUCHSIA,
}
impl Builder<'_> for vk::SemaphoreGetZirconHandleInfoFUCHSIA {
    type Type = SemaphoreGetZirconHandleInfoFUCHSIABuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SemaphoreGetZirconHandleInfoFUCHSIABuilder {
    pub fn get_mut(&mut self) -> &mut vk::SemaphoreGetZirconHandleInfoFUCHSIA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn semaphore(mut self, semaphore: vk::Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl Deref for SemaphoreGetZirconHandleInfoFUCHSIABuilder {
    type Target = vk::SemaphoreGetZirconHandleInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceExternalFenceInfoBuilder {
    inner: vk::PhysicalDeviceExternalFenceInfo,
}
impl Builder<'_> for vk::PhysicalDeviceExternalFenceInfo {
    type Type = PhysicalDeviceExternalFenceInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceExternalFenceInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceExternalFenceInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalFenceHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl Deref for PhysicalDeviceExternalFenceInfoBuilder {
    type Target = vk::PhysicalDeviceExternalFenceInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportFenceCreateInfoBuilder {
    inner: vk::ExportFenceCreateInfo,
}
impl Builder<'_> for vk::ExportFenceCreateInfo {
    type Type = ExportFenceCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExportFenceCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExportFenceCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_types(mut self, handle_types: vk::ExternalFenceHandleTypeFlags) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
}
impl Deref for ExportFenceCreateInfoBuilder {
    type Target = vk::ExportFenceCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl FenceCreateInfoNext for vk::ExportFenceCreateInfo {}
impl FenceCreateInfoNext for ExportFenceCreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportFenceWin32HandleInfoKHRBuilder {
    inner: vk::ImportFenceWin32HandleInfoKHR,
}
impl Builder<'_> for vk::ImportFenceWin32HandleInfoKHR {
    type Type = ImportFenceWin32HandleInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImportFenceWin32HandleInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImportFenceWin32HandleInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn fence(mut self, fence: vk::Fence) -> Self {
        self.inner.fence = fence;
        self
    }
    pub fn flags(mut self, flags: vk::FenceImportFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalFenceHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    pub fn handle(mut self, handle: vk::HANDLE) -> Self {
        self.inner.handle = handle;
        self
    }
    pub fn name(mut self, name: vk::LPCWSTR) -> Self {
        self.inner.name = name;
        self
    }
}
impl Deref for ImportFenceWin32HandleInfoKHRBuilder {
    type Target = vk::ImportFenceWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportFenceWin32HandleInfoKHRBuilder<'a> {
    inner: vk::ExportFenceWin32HandleInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ExportFenceWin32HandleInfoKHR {
    type Type = ExportFenceWin32HandleInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ExportFenceWin32HandleInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ExportFenceWin32HandleInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_attributes(mut self, p_attributes: Option<&'a vk::SECURITY_ATTRIBUTES>) -> Self {
        self.inner.p_attributes = p_attributes.map_or(ptr::null(), |r| r);
        self
    }
    pub fn dw_access(mut self, dw_access: vk::DWORD) -> Self {
        self.inner.dw_access = dw_access;
        self
    }
    pub fn name(mut self, name: vk::LPCWSTR) -> Self {
        self.inner.name = name;
        self
    }
}
impl<'a> Deref for ExportFenceWin32HandleInfoKHRBuilder<'a> {
    type Target = vk::ExportFenceWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl FenceCreateInfoNext for vk::ExportFenceWin32HandleInfoKHR {}
impl FenceCreateInfoNext for ExportFenceWin32HandleInfoKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct FenceGetWin32HandleInfoKHRBuilder {
    inner: vk::FenceGetWin32HandleInfoKHR,
}
impl Builder<'_> for vk::FenceGetWin32HandleInfoKHR {
    type Type = FenceGetWin32HandleInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl FenceGetWin32HandleInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::FenceGetWin32HandleInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn fence(mut self, fence: vk::Fence) -> Self {
        self.inner.fence = fence;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalFenceHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl Deref for FenceGetWin32HandleInfoKHRBuilder {
    type Target = vk::FenceGetWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportFenceFdInfoKHRBuilder {
    inner: vk::ImportFenceFdInfoKHR,
}
impl Builder<'_> for vk::ImportFenceFdInfoKHR {
    type Type = ImportFenceFdInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImportFenceFdInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImportFenceFdInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn fence(mut self, fence: vk::Fence) -> Self {
        self.inner.fence = fence;
        self
    }
    pub fn flags(mut self, flags: vk::FenceImportFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalFenceHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    pub fn fd(mut self, fd: c_int) -> Self {
        self.inner.fd = fd;
        self
    }
}
impl Deref for ImportFenceFdInfoKHRBuilder {
    type Target = vk::ImportFenceFdInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct FenceGetFdInfoKHRBuilder {
    inner: vk::FenceGetFdInfoKHR,
}
impl Builder<'_> for vk::FenceGetFdInfoKHR {
    type Type = FenceGetFdInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl FenceGetFdInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::FenceGetFdInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn fence(mut self, fence: vk::Fence) -> Self {
        self.inner.fence = fence;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalFenceHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl Deref for FenceGetFdInfoKHRBuilder {
    type Target = vk::FenceGetFdInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMultiviewFeaturesBuilder {
    inner: vk::PhysicalDeviceMultiviewFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceMultiviewFeatures {
    type Type = PhysicalDeviceMultiviewFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMultiviewFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMultiviewFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn multiview(mut self, multiview: bool) -> Self {
        self.inner.multiview = if multiview { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn multiview_geometry_shader(mut self, multiview_geometry_shader: bool) -> Self {
        self.inner.multiview_geometry_shader = if multiview_geometry_shader { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn multiview_tessellation_shader(mut self, multiview_tessellation_shader: bool) -> Self {
        self.inner.multiview_tessellation_shader = if multiview_tessellation_shader {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceMultiviewFeaturesBuilder {
    type Target = vk::PhysicalDeviceMultiviewFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMultiviewFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMultiviewFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMultiviewFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceMultiviewFeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceMultiviewProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassMultiviewCreateInfoBuilder<'a> {
    inner: vk::RenderPassMultiviewCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderPassMultiviewCreateInfo {
    type Type = RenderPassMultiviewCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> RenderPassMultiviewCreateInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::RenderPassMultiviewCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_view_masks(mut self, p_view_masks: &'a [u32]) -> Self {
        self.inner.subpass_count = p_view_masks.len() as u32;
        self.inner.p_view_masks = p_view_masks.as_ptr();
        self
    }
    pub fn p_view_offsets(mut self, p_view_offsets: &'a [i32]) -> Self {
        self.inner.dependency_count = p_view_offsets.len() as u32;
        self.inner.p_view_offsets = p_view_offsets.as_ptr();
        self
    }
    pub fn p_correlation_masks(mut self, p_correlation_masks: &'a [u32]) -> Self {
        self.inner.correlation_mask_count = p_correlation_masks.len() as u32;
        self.inner.p_correlation_masks = p_correlation_masks.as_ptr();
        self
    }
}
impl<'a> Deref for RenderPassMultiviewCreateInfoBuilder<'a> {
    type Target = vk::RenderPassMultiviewCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderPassCreateInfoNext for vk::RenderPassMultiviewCreateInfo {}
impl RenderPassCreateInfoNext for RenderPassMultiviewCreateInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct DisplayPowerInfoEXTBuilder {
    inner: vk::DisplayPowerInfoEXT,
}
impl Builder<'_> for vk::DisplayPowerInfoEXT {
    type Type = DisplayPowerInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DisplayPowerInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DisplayPowerInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn power_state(mut self, power_state: vk::DisplayPowerStateEXT) -> Self {
        self.inner.power_state = power_state;
        self
    }
}
impl Deref for DisplayPowerInfoEXTBuilder {
    type Target = vk::DisplayPowerInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceEventInfoEXTBuilder {
    inner: vk::DeviceEventInfoEXT,
}
impl Builder<'_> for vk::DeviceEventInfoEXT {
    type Type = DeviceEventInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceEventInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceEventInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn device_event(mut self, device_event: vk::DeviceEventTypeEXT) -> Self {
        self.inner.device_event = device_event;
        self
    }
}
impl Deref for DeviceEventInfoEXTBuilder {
    type Target = vk::DeviceEventInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DisplayEventInfoEXTBuilder {
    inner: vk::DisplayEventInfoEXT,
}
impl Builder<'_> for vk::DisplayEventInfoEXT {
    type Type = DisplayEventInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DisplayEventInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DisplayEventInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn display_event(mut self, display_event: vk::DisplayEventTypeEXT) -> Self {
        self.inner.display_event = display_event;
        self
    }
}
impl Deref for DisplayEventInfoEXTBuilder {
    type Target = vk::DisplayEventInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SwapchainCounterCreateInfoEXTBuilder {
    inner: vk::SwapchainCounterCreateInfoEXT,
}
impl Builder<'_> for vk::SwapchainCounterCreateInfoEXT {
    type Type = SwapchainCounterCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SwapchainCounterCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SwapchainCounterCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn surface_counters(mut self, surface_counters: vk::SurfaceCounterFlagsEXT) -> Self {
        self.inner.surface_counters = surface_counters;
        self
    }
}
impl Deref for SwapchainCounterCreateInfoEXTBuilder {
    type Target = vk::SwapchainCounterCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SwapchainCreateInfoKHRNext for vk::SwapchainCounterCreateInfoEXT {}
impl SwapchainCreateInfoKHRNext for SwapchainCounterCreateInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryAllocateFlagsInfoBuilder {
    inner: vk::MemoryAllocateFlagsInfo,
}
impl Builder<'_> for vk::MemoryAllocateFlagsInfo {
    type Type = MemoryAllocateFlagsInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryAllocateFlagsInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryAllocateFlagsInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::MemoryAllocateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.inner.device_mask = device_mask;
        self
    }
}
impl Deref for MemoryAllocateFlagsInfoBuilder {
    type Target = vk::MemoryAllocateFlagsInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::MemoryAllocateFlagsInfo {}
impl MemoryAllocateInfoNext for MemoryAllocateFlagsInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct BindBufferMemoryInfoBuilder<'a> {
    inner: vk::BindBufferMemoryInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BindBufferMemoryInfo {
    type Type = BindBufferMemoryInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait BindBufferMemoryInfoNext {}
impl<'a> BindBufferMemoryInfoBuilder<'a> {
    pub fn insert_next<T: BindBufferMemoryInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::BindBufferMemoryInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn memory_offset(mut self, memory_offset: vk::DeviceSize) -> Self {
        self.inner.memory_offset = memory_offset;
        self
    }
}
impl<'a> Deref for BindBufferMemoryInfoBuilder<'a> {
    type Target = vk::BindBufferMemoryInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BindBufferMemoryDeviceGroupInfoBuilder<'a> {
    inner: vk::BindBufferMemoryDeviceGroupInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BindBufferMemoryDeviceGroupInfo {
    type Type = BindBufferMemoryDeviceGroupInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> BindBufferMemoryDeviceGroupInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::BindBufferMemoryDeviceGroupInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_device_indices(mut self, p_device_indices: &'a [u32]) -> Self {
        self.inner.device_index_count = p_device_indices.len() as u32;
        self.inner.p_device_indices = p_device_indices.as_ptr();
        self
    }
}
impl<'a> Deref for BindBufferMemoryDeviceGroupInfoBuilder<'a> {
    type Target = vk::BindBufferMemoryDeviceGroupInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BindBufferMemoryInfoNext for vk::BindBufferMemoryDeviceGroupInfo {}
impl BindBufferMemoryInfoNext for BindBufferMemoryDeviceGroupInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct BindImageMemoryInfoBuilder<'a> {
    inner: vk::BindImageMemoryInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BindImageMemoryInfo {
    type Type = BindImageMemoryInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait BindImageMemoryInfoNext {}
impl<'a> BindImageMemoryInfoBuilder<'a> {
    pub fn insert_next<T: BindImageMemoryInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::BindImageMemoryInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image(mut self, image: vk::Image) -> Self {
        self.inner.image = image;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn memory_offset(mut self, memory_offset: vk::DeviceSize) -> Self {
        self.inner.memory_offset = memory_offset;
        self
    }
}
impl<'a> Deref for BindImageMemoryInfoBuilder<'a> {
    type Target = vk::BindImageMemoryInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BindImageMemoryDeviceGroupInfoBuilder<'a> {
    inner: vk::BindImageMemoryDeviceGroupInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BindImageMemoryDeviceGroupInfo {
    type Type = BindImageMemoryDeviceGroupInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> BindImageMemoryDeviceGroupInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::BindImageMemoryDeviceGroupInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_device_indices(mut self, p_device_indices: &'a [u32]) -> Self {
        self.inner.device_index_count = p_device_indices.len() as u32;
        self.inner.p_device_indices = p_device_indices.as_ptr();
        self
    }
    pub fn p_split_instance_bind_regions(mut self, p_split_instance_bind_regions: &'a [vk::Rect2D]) -> Self {
        self.inner.split_instance_bind_region_count = p_split_instance_bind_regions.len() as u32;
        self.inner.p_split_instance_bind_regions = p_split_instance_bind_regions.as_ptr();
        self
    }
}
impl<'a> Deref for BindImageMemoryDeviceGroupInfoBuilder<'a> {
    type Target = vk::BindImageMemoryDeviceGroupInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BindImageMemoryInfoNext for vk::BindImageMemoryDeviceGroupInfo {}
impl BindImageMemoryInfoNext for BindImageMemoryDeviceGroupInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceGroupRenderPassBeginInfoBuilder<'a> {
    inner: vk::DeviceGroupRenderPassBeginInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DeviceGroupRenderPassBeginInfo {
    type Type = DeviceGroupRenderPassBeginInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DeviceGroupRenderPassBeginInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DeviceGroupRenderPassBeginInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.inner.device_mask = device_mask;
        self
    }
    pub fn p_device_render_areas(mut self, p_device_render_areas: &'a [vk::Rect2D]) -> Self {
        self.inner.device_render_area_count = p_device_render_areas.len() as u32;
        self.inner.p_device_render_areas = p_device_render_areas.as_ptr();
        self
    }
}
impl<'a> Deref for DeviceGroupRenderPassBeginInfoBuilder<'a> {
    type Target = vk::DeviceGroupRenderPassBeginInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderPassBeginInfoNext for vk::DeviceGroupRenderPassBeginInfo {}
impl RenderPassBeginInfoNext for DeviceGroupRenderPassBeginInfoBuilder<'_> {}
impl RenderingInfoNext for vk::DeviceGroupRenderPassBeginInfo {}
impl RenderingInfoNext for DeviceGroupRenderPassBeginInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceGroupCommandBufferBeginInfoBuilder {
    inner: vk::DeviceGroupCommandBufferBeginInfo,
}
impl Builder<'_> for vk::DeviceGroupCommandBufferBeginInfo {
    type Type = DeviceGroupCommandBufferBeginInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceGroupCommandBufferBeginInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceGroupCommandBufferBeginInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.inner.device_mask = device_mask;
        self
    }
}
impl Deref for DeviceGroupCommandBufferBeginInfoBuilder {
    type Target = vk::DeviceGroupCommandBufferBeginInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl CommandBufferBeginInfoNext for vk::DeviceGroupCommandBufferBeginInfo {}
impl CommandBufferBeginInfoNext for DeviceGroupCommandBufferBeginInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceGroupSubmitInfoBuilder<'a> {
    inner: vk::DeviceGroupSubmitInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DeviceGroupSubmitInfo {
    type Type = DeviceGroupSubmitInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DeviceGroupSubmitInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DeviceGroupSubmitInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_wait_semaphore_device_indices(mut self, p_wait_semaphore_device_indices: &'a [u32]) -> Self {
        self.inner.wait_semaphore_count = p_wait_semaphore_device_indices.len() as u32;
        self.inner.p_wait_semaphore_device_indices = p_wait_semaphore_device_indices.as_ptr();
        self
    }
    pub fn p_command_buffer_device_masks(mut self, p_command_buffer_device_masks: &'a [u32]) -> Self {
        self.inner.command_buffer_count = p_command_buffer_device_masks.len() as u32;
        self.inner.p_command_buffer_device_masks = p_command_buffer_device_masks.as_ptr();
        self
    }
    pub fn p_signal_semaphore_device_indices(mut self, p_signal_semaphore_device_indices: &'a [u32]) -> Self {
        self.inner.signal_semaphore_count = p_signal_semaphore_device_indices.len() as u32;
        self.inner.p_signal_semaphore_device_indices = p_signal_semaphore_device_indices.as_ptr();
        self
    }
}
impl<'a> Deref for DeviceGroupSubmitInfoBuilder<'a> {
    type Target = vk::DeviceGroupSubmitInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubmitInfoNext for vk::DeviceGroupSubmitInfo {}
impl SubmitInfoNext for DeviceGroupSubmitInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceGroupBindSparseInfoBuilder {
    inner: vk::DeviceGroupBindSparseInfo,
}
impl Builder<'_> for vk::DeviceGroupBindSparseInfo {
    type Type = DeviceGroupBindSparseInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceGroupBindSparseInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceGroupBindSparseInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn resource_device_index(mut self, resource_device_index: u32) -> Self {
        self.inner.resource_device_index = resource_device_index;
        self
    }
    pub fn memory_device_index(mut self, memory_device_index: u32) -> Self {
        self.inner.memory_device_index = memory_device_index;
        self
    }
}
impl Deref for DeviceGroupBindSparseInfoBuilder {
    type Target = vk::DeviceGroupBindSparseInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BindSparseInfoNext for vk::DeviceGroupBindSparseInfo {}
impl BindSparseInfoNext for DeviceGroupBindSparseInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageSwapchainCreateInfoKHRBuilder {
    inner: vk::ImageSwapchainCreateInfoKHR,
}
impl Builder<'_> for vk::ImageSwapchainCreateInfoKHR {
    type Type = ImageSwapchainCreateInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageSwapchainCreateInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageSwapchainCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn swapchain(mut self, swapchain: vk::SwapchainKHR) -> Self {
        self.inner.swapchain = swapchain;
        self
    }
}
impl Deref for ImageSwapchainCreateInfoKHRBuilder {
    type Target = vk::ImageSwapchainCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageCreateInfoNext for vk::ImageSwapchainCreateInfoKHR {}
impl ImageCreateInfoNext for ImageSwapchainCreateInfoKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct BindImageMemorySwapchainInfoKHRBuilder {
    inner: vk::BindImageMemorySwapchainInfoKHR,
}
impl Builder<'_> for vk::BindImageMemorySwapchainInfoKHR {
    type Type = BindImageMemorySwapchainInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BindImageMemorySwapchainInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BindImageMemorySwapchainInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn swapchain(mut self, swapchain: vk::SwapchainKHR) -> Self {
        self.inner.swapchain = swapchain;
        self
    }
    pub fn image_index(mut self, image_index: u32) -> Self {
        self.inner.image_index = image_index;
        self
    }
}
impl Deref for BindImageMemorySwapchainInfoKHRBuilder {
    type Target = vk::BindImageMemorySwapchainInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BindImageMemoryInfoNext for vk::BindImageMemorySwapchainInfoKHR {}
impl BindImageMemoryInfoNext for BindImageMemorySwapchainInfoKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct AcquireNextImageInfoKHRBuilder {
    inner: vk::AcquireNextImageInfoKHR,
}
impl Builder<'_> for vk::AcquireNextImageInfoKHR {
    type Type = AcquireNextImageInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AcquireNextImageInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AcquireNextImageInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn swapchain(mut self, swapchain: vk::SwapchainKHR) -> Self {
        self.inner.swapchain = swapchain;
        self
    }
    pub fn timeout(mut self, timeout: u64) -> Self {
        self.inner.timeout = timeout;
        self
    }
    pub fn semaphore(mut self, semaphore: vk::Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    pub fn fence(mut self, fence: vk::Fence) -> Self {
        self.inner.fence = fence;
        self
    }
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.inner.device_mask = device_mask;
        self
    }
}
impl Deref for AcquireNextImageInfoKHRBuilder {
    type Target = vk::AcquireNextImageInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceGroupPresentInfoKHRBuilder<'a> {
    inner: vk::DeviceGroupPresentInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DeviceGroupPresentInfoKHR {
    type Type = DeviceGroupPresentInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DeviceGroupPresentInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DeviceGroupPresentInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_device_masks(mut self, p_device_masks: &'a [u32]) -> Self {
        self.inner.swapchain_count = p_device_masks.len() as u32;
        self.inner.p_device_masks = p_device_masks.as_ptr();
        self
    }
    pub fn mode(mut self, mode: vk::DeviceGroupPresentModeFlagsKHR) -> Self {
        self.inner.mode = mode;
        self
    }
}
impl<'a> Deref for DeviceGroupPresentInfoKHRBuilder<'a> {
    type Target = vk::DeviceGroupPresentInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PresentInfoKHRNext for vk::DeviceGroupPresentInfoKHR {}
impl PresentInfoKHRNext for DeviceGroupPresentInfoKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceGroupDeviceCreateInfoBuilder<'a> {
    inner: vk::DeviceGroupDeviceCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DeviceGroupDeviceCreateInfo {
    type Type = DeviceGroupDeviceCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DeviceGroupDeviceCreateInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DeviceGroupDeviceCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_physical_devices(mut self, p_physical_devices: &'a [vk::PhysicalDevice]) -> Self {
        self.inner.physical_device_count = p_physical_devices.len() as u32;
        self.inner.p_physical_devices = p_physical_devices.as_ptr();
        self
    }
}
impl<'a> Deref for DeviceGroupDeviceCreateInfoBuilder<'a> {
    type Target = vk::DeviceGroupDeviceCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DeviceCreateInfoNext for vk::DeviceGroupDeviceCreateInfo {}
impl DeviceCreateInfoNext for DeviceGroupDeviceCreateInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceGroupSwapchainCreateInfoKHRBuilder {
    inner: vk::DeviceGroupSwapchainCreateInfoKHR,
}
impl Builder<'_> for vk::DeviceGroupSwapchainCreateInfoKHR {
    type Type = DeviceGroupSwapchainCreateInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceGroupSwapchainCreateInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceGroupSwapchainCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn modes(mut self, modes: vk::DeviceGroupPresentModeFlagsKHR) -> Self {
        self.inner.modes = modes;
        self
    }
}
impl Deref for DeviceGroupSwapchainCreateInfoKHRBuilder {
    type Target = vk::DeviceGroupSwapchainCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SwapchainCreateInfoKHRNext for vk::DeviceGroupSwapchainCreateInfoKHR {}
impl SwapchainCreateInfoKHRNext for DeviceGroupSwapchainCreateInfoKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorUpdateTemplateEntryBuilder {
    inner: vk::DescriptorUpdateTemplateEntry,
}
impl Builder<'_> for vk::DescriptorUpdateTemplateEntry {
    type Type = DescriptorUpdateTemplateEntryBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DescriptorUpdateTemplateEntryBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DescriptorUpdateTemplateEntry {
        &mut self.inner
    }
    pub fn dst_binding(mut self, dst_binding: u32) -> Self {
        self.inner.dst_binding = dst_binding;
        self
    }
    pub fn dst_array_element(mut self, dst_array_element: u32) -> Self {
        self.inner.dst_array_element = dst_array_element;
        self
    }
    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.inner.descriptor_count = descriptor_count;
        self
    }
    pub fn descriptor_type(mut self, descriptor_type: vk::DescriptorType) -> Self {
        self.inner.descriptor_type = descriptor_type;
        self
    }
    pub fn offset(mut self, offset: usize) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn stride(mut self, stride: usize) -> Self {
        self.inner.stride = stride;
        self
    }
}
impl Deref for DescriptorUpdateTemplateEntryBuilder {
    type Target = vk::DescriptorUpdateTemplateEntry;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorUpdateTemplateCreateInfoBuilder<'a> {
    inner: vk::DescriptorUpdateTemplateCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DescriptorUpdateTemplateCreateInfo {
    type Type = DescriptorUpdateTemplateCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DescriptorUpdateTemplateCreateInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DescriptorUpdateTemplateCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DescriptorUpdateTemplateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_descriptor_update_entries(
        mut self,
        p_descriptor_update_entries: &'a [vk::DescriptorUpdateTemplateEntry],
    ) -> Self {
        self.inner.descriptor_update_entry_count = p_descriptor_update_entries.len() as u32;
        self.inner.p_descriptor_update_entries = p_descriptor_update_entries.as_ptr();
        self
    }
    pub fn template_type(mut self, template_type: vk::DescriptorUpdateTemplateType) -> Self {
        self.inner.template_type = template_type;
        self
    }
    pub fn descriptor_set_layout(mut self, descriptor_set_layout: vk::DescriptorSetLayout) -> Self {
        self.inner.descriptor_set_layout = descriptor_set_layout;
        self
    }
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: vk::PipelineBindPoint) -> Self {
        self.inner.pipeline_bind_point = pipeline_bind_point;
        self
    }
    pub fn pipeline_layout(mut self, pipeline_layout: vk::PipelineLayout) -> Self {
        self.inner.pipeline_layout = pipeline_layout;
        self
    }
    pub fn set(mut self, set: u32) -> Self {
        self.inner.set = set;
        self
    }
}
impl<'a> Deref for DescriptorUpdateTemplateCreateInfoBuilder<'a> {
    type Target = vk::DescriptorUpdateTemplateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct XYColorEXTBuilder {
    inner: vk::XYColorEXT,
}
impl Builder<'_> for vk::XYColorEXT {
    type Type = XYColorEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl XYColorEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::XYColorEXT {
        &mut self.inner
    }
    pub fn x(mut self, x: f32) -> Self {
        self.inner.x = x;
        self
    }
    pub fn y(mut self, y: f32) -> Self {
        self.inner.y = y;
        self
    }
}
impl Deref for XYColorEXTBuilder {
    type Target = vk::XYColorEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePresentIdFeaturesKHRBuilder {
    inner: vk::PhysicalDevicePresentIdFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDevicePresentIdFeaturesKHR {
    type Type = PhysicalDevicePresentIdFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePresentIdFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePresentIdFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn present_id(mut self, present_id: bool) -> Self {
        self.inner.present_id = if present_id { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevicePresentIdFeaturesKHRBuilder {
    type Target = vk::PhysicalDevicePresentIdFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePresentIdFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePresentIdFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePresentIdFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDevicePresentIdFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PresentIdKHRBuilder<'a> {
    inner: vk::PresentIdKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PresentIdKHR {
    type Type = PresentIdKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PresentIdKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PresentIdKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_present_ids(mut self, p_present_ids: &'a [u64]) -> Self {
        self.inner.swapchain_count = p_present_ids.len() as u32;
        self.inner.p_present_ids = p_present_ids.as_ptr();
        self
    }
}
impl<'a> Deref for PresentIdKHRBuilder<'a> {
    type Target = vk::PresentIdKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PresentInfoKHRNext for vk::PresentIdKHR {}
impl PresentInfoKHRNext for PresentIdKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePresentId2FeaturesKHRBuilder {
    inner: vk::PhysicalDevicePresentId2FeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDevicePresentId2FeaturesKHR {
    type Type = PhysicalDevicePresentId2FeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePresentId2FeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePresentId2FeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn present_id2(mut self, present_id2: bool) -> Self {
        self.inner.present_id2 = if present_id2 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevicePresentId2FeaturesKHRBuilder {
    type Target = vk::PhysicalDevicePresentId2FeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePresentId2FeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePresentId2FeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePresentId2FeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDevicePresentId2FeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PresentId2KHRBuilder<'a> {
    inner: vk::PresentId2KHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PresentId2KHR {
    type Type = PresentId2KHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PresentId2KHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PresentId2KHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_present_ids(mut self, p_present_ids: &'a [u64]) -> Self {
        self.inner.swapchain_count = p_present_ids.len() as u32;
        self.inner.p_present_ids = p_present_ids.as_ptr();
        self
    }
}
impl<'a> Deref for PresentId2KHRBuilder<'a> {
    type Target = vk::PresentId2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PresentInfoKHRNext for vk::PresentId2KHR {}
impl PresentInfoKHRNext for PresentId2KHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PresentWait2InfoKHRBuilder {
    inner: vk::PresentWait2InfoKHR,
}
impl Builder<'_> for vk::PresentWait2InfoKHR {
    type Type = PresentWait2InfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PresentWait2InfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PresentWait2InfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn present_id(mut self, present_id: u64) -> Self {
        self.inner.present_id = present_id;
        self
    }
    pub fn timeout(mut self, timeout: u64) -> Self {
        self.inner.timeout = timeout;
        self
    }
}
impl Deref for PresentWait2InfoKHRBuilder {
    type Target = vk::PresentWait2InfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePresentWaitFeaturesKHRBuilder {
    inner: vk::PhysicalDevicePresentWaitFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDevicePresentWaitFeaturesKHR {
    type Type = PhysicalDevicePresentWaitFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePresentWaitFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePresentWaitFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn present_wait(mut self, present_wait: bool) -> Self {
        self.inner.present_wait = if present_wait { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevicePresentWaitFeaturesKHRBuilder {
    type Target = vk::PhysicalDevicePresentWaitFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePresentWaitFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePresentWaitFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePresentWaitFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDevicePresentWaitFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePresentWait2FeaturesKHRBuilder {
    inner: vk::PhysicalDevicePresentWait2FeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDevicePresentWait2FeaturesKHR {
    type Type = PhysicalDevicePresentWait2FeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePresentWait2FeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePresentWait2FeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn present_wait2(mut self, present_wait2: bool) -> Self {
        self.inner.present_wait2 = if present_wait2 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevicePresentWait2FeaturesKHRBuilder {
    type Target = vk::PhysicalDevicePresentWait2FeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePresentWait2FeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePresentWait2FeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePresentWait2FeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDevicePresentWait2FeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct HdrMetadataEXTBuilder<'a> {
    inner: vk::HdrMetadataEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::HdrMetadataEXT {
    type Type = HdrMetadataEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait HdrMetadataEXTNext {}
impl<'a> HdrMetadataEXTBuilder<'a> {
    pub fn insert_next<T: HdrMetadataEXTNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::HdrMetadataEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn display_primary_red(mut self, display_primary_red: vk::XYColorEXT) -> Self {
        self.inner.display_primary_red = display_primary_red;
        self
    }
    pub fn display_primary_green(mut self, display_primary_green: vk::XYColorEXT) -> Self {
        self.inner.display_primary_green = display_primary_green;
        self
    }
    pub fn display_primary_blue(mut self, display_primary_blue: vk::XYColorEXT) -> Self {
        self.inner.display_primary_blue = display_primary_blue;
        self
    }
    pub fn white_point(mut self, white_point: vk::XYColorEXT) -> Self {
        self.inner.white_point = white_point;
        self
    }
    pub fn max_luminance(mut self, max_luminance: f32) -> Self {
        self.inner.max_luminance = max_luminance;
        self
    }
    pub fn min_luminance(mut self, min_luminance: f32) -> Self {
        self.inner.min_luminance = min_luminance;
        self
    }
    pub fn max_content_light_level(mut self, max_content_light_level: f32) -> Self {
        self.inner.max_content_light_level = max_content_light_level;
        self
    }
    pub fn max_frame_average_light_level(mut self, max_frame_average_light_level: f32) -> Self {
        self.inner.max_frame_average_light_level = max_frame_average_light_level;
        self
    }
}
impl<'a> Deref for HdrMetadataEXTBuilder<'a> {
    type Target = vk::HdrMetadataEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct HdrVividDynamicMetadataHUAWEIBuilder<'a> {
    inner: vk::HdrVividDynamicMetadataHUAWEI,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::HdrVividDynamicMetadataHUAWEI {
    type Type = HdrVividDynamicMetadataHUAWEIBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> HdrVividDynamicMetadataHUAWEIBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::HdrVividDynamicMetadataHUAWEI {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_dynamic_metadata(mut self, p_dynamic_metadata: &'a [u8]) -> Self {
        self.inner.dynamic_metadata_size = p_dynamic_metadata.len();
        self.inner.p_dynamic_metadata = p_dynamic_metadata.as_ptr() as *const _;
        self
    }
}
impl<'a> Deref for HdrVividDynamicMetadataHUAWEIBuilder<'a> {
    type Target = vk::HdrVividDynamicMetadataHUAWEI;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl HdrMetadataEXTNext for vk::HdrVividDynamicMetadataHUAWEI {}
impl HdrMetadataEXTNext for HdrVividDynamicMetadataHUAWEIBuilder<'_> {}
impl SurfaceCapabilities2KHRNext for vk::DisplayNativeHdrSurfaceCapabilitiesAMD {}

#[repr(transparent)]
#[derive(Default)]
pub struct SwapchainDisplayNativeHdrCreateInfoAMDBuilder {
    inner: vk::SwapchainDisplayNativeHdrCreateInfoAMD,
}
impl Builder<'_> for vk::SwapchainDisplayNativeHdrCreateInfoAMD {
    type Type = SwapchainDisplayNativeHdrCreateInfoAMDBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SwapchainDisplayNativeHdrCreateInfoAMDBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SwapchainDisplayNativeHdrCreateInfoAMD {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn local_dimming_enable(mut self, local_dimming_enable: bool) -> Self {
        self.inner.local_dimming_enable = if local_dimming_enable { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for SwapchainDisplayNativeHdrCreateInfoAMDBuilder {
    type Target = vk::SwapchainDisplayNativeHdrCreateInfoAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SwapchainCreateInfoKHRNext for vk::SwapchainDisplayNativeHdrCreateInfoAMD {}
impl SwapchainCreateInfoKHRNext for SwapchainDisplayNativeHdrCreateInfoAMDBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PresentTimesInfoGOOGLEBuilder<'a> {
    inner: vk::PresentTimesInfoGOOGLE,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PresentTimesInfoGOOGLE {
    type Type = PresentTimesInfoGOOGLEBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PresentTimesInfoGOOGLEBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PresentTimesInfoGOOGLE {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_times(mut self, p_times: &'a [vk::PresentTimeGOOGLE]) -> Self {
        self.inner.swapchain_count = p_times.len() as u32;
        self.inner.p_times = p_times.as_ptr();
        self
    }
}
impl<'a> Deref for PresentTimesInfoGOOGLEBuilder<'a> {
    type Target = vk::PresentTimesInfoGOOGLE;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PresentInfoKHRNext for vk::PresentTimesInfoGOOGLE {}
impl PresentInfoKHRNext for PresentTimesInfoGOOGLEBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PresentTimeGOOGLEBuilder {
    inner: vk::PresentTimeGOOGLE,
}
impl Builder<'_> for vk::PresentTimeGOOGLE {
    type Type = PresentTimeGOOGLEBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PresentTimeGOOGLEBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PresentTimeGOOGLE {
        &mut self.inner
    }
    pub fn present_id(mut self, present_id: u32) -> Self {
        self.inner.present_id = present_id;
        self
    }
    pub fn desired_present_time(mut self, desired_present_time: u64) -> Self {
        self.inner.desired_present_time = desired_present_time;
        self
    }
}
impl Deref for PresentTimeGOOGLEBuilder {
    type Target = vk::PresentTimeGOOGLE;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct IOSSurfaceCreateInfoMVKBuilder<'a> {
    inner: vk::IOSSurfaceCreateInfoMVK,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::IOSSurfaceCreateInfoMVK {
    type Type = IOSSurfaceCreateInfoMVKBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> IOSSurfaceCreateInfoMVKBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::IOSSurfaceCreateInfoMVK {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::IOSSurfaceCreateFlagsMVK) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_view(mut self, p_view: *const c_void) -> Self {
        self.inner.p_view = p_view;
        self
    }
}
impl<'a> Deref for IOSSurfaceCreateInfoMVKBuilder<'a> {
    type Target = vk::IOSSurfaceCreateInfoMVK;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MacOSSurfaceCreateInfoMVKBuilder<'a> {
    inner: vk::MacOSSurfaceCreateInfoMVK,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::MacOSSurfaceCreateInfoMVK {
    type Type = MacOSSurfaceCreateInfoMVKBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> MacOSSurfaceCreateInfoMVKBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::MacOSSurfaceCreateInfoMVK {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::MacOSSurfaceCreateFlagsMVK) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_view(mut self, p_view: *const c_void) -> Self {
        self.inner.p_view = p_view;
        self
    }
}
impl<'a> Deref for MacOSSurfaceCreateInfoMVKBuilder<'a> {
    type Target = vk::MacOSSurfaceCreateInfoMVK;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MetalSurfaceCreateInfoEXTBuilder<'a> {
    inner: vk::MetalSurfaceCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::MetalSurfaceCreateInfoEXT {
    type Type = MetalSurfaceCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> MetalSurfaceCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::MetalSurfaceCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::MetalSurfaceCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_layer(mut self, p_layer: &'a vk::CAMetalLayer) -> Self {
        self.inner.p_layer = p_layer;
        self
    }
}
impl<'a> Deref for MetalSurfaceCreateInfoEXTBuilder<'a> {
    type Target = vk::MetalSurfaceCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ViewportWScalingNVBuilder {
    inner: vk::ViewportWScalingNV,
}
impl Builder<'_> for vk::ViewportWScalingNV {
    type Type = ViewportWScalingNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ViewportWScalingNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ViewportWScalingNV {
        &mut self.inner
    }
    pub fn xcoeff(mut self, xcoeff: f32) -> Self {
        self.inner.xcoeff = xcoeff;
        self
    }
    pub fn ycoeff(mut self, ycoeff: f32) -> Self {
        self.inner.ycoeff = ycoeff;
        self
    }
}
impl Deref for ViewportWScalingNVBuilder {
    type Target = vk::ViewportWScalingNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineViewportWScalingStateCreateInfoNVBuilder<'a> {
    inner: vk::PipelineViewportWScalingStateCreateInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineViewportWScalingStateCreateInfoNV {
    type Type = PipelineViewportWScalingStateCreateInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineViewportWScalingStateCreateInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineViewportWScalingStateCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn viewport_w_scaling_enable(mut self, viewport_w_scaling_enable: bool) -> Self {
        self.inner.viewport_w_scaling_enable = if viewport_w_scaling_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn viewport_count(mut self, viewport_count: u32) -> Self {
        self.inner.viewport_count = viewport_count;
        self
    }
    pub fn p_viewport_w_scalings(mut self, p_viewport_w_scalings: &'a [vk::ViewportWScalingNV]) -> Self {
        self.inner.viewport_count = p_viewport_w_scalings.len() as u32;
        self.inner.p_viewport_w_scalings = p_viewport_w_scalings.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineViewportWScalingStateCreateInfoNVBuilder<'a> {
    type Target = vk::PipelineViewportWScalingStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineViewportStateCreateInfoNext for vk::PipelineViewportWScalingStateCreateInfoNV {}
impl PipelineViewportStateCreateInfoNext for PipelineViewportWScalingStateCreateInfoNVBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ViewportSwizzleNVBuilder {
    inner: vk::ViewportSwizzleNV,
}
impl Builder<'_> for vk::ViewportSwizzleNV {
    type Type = ViewportSwizzleNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ViewportSwizzleNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ViewportSwizzleNV {
        &mut self.inner
    }
    pub fn x(mut self, x: vk::ViewportCoordinateSwizzleNV) -> Self {
        self.inner.x = x;
        self
    }
    pub fn y(mut self, y: vk::ViewportCoordinateSwizzleNV) -> Self {
        self.inner.y = y;
        self
    }
    pub fn z(mut self, z: vk::ViewportCoordinateSwizzleNV) -> Self {
        self.inner.z = z;
        self
    }
    pub fn w(mut self, w: vk::ViewportCoordinateSwizzleNV) -> Self {
        self.inner.w = w;
        self
    }
}
impl Deref for ViewportSwizzleNVBuilder {
    type Target = vk::ViewportSwizzleNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineViewportSwizzleStateCreateInfoNVBuilder<'a> {
    inner: vk::PipelineViewportSwizzleStateCreateInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineViewportSwizzleStateCreateInfoNV {
    type Type = PipelineViewportSwizzleStateCreateInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineViewportSwizzleStateCreateInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineViewportSwizzleStateCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineViewportSwizzleStateCreateFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_viewport_swizzles(mut self, p_viewport_swizzles: &'a [vk::ViewportSwizzleNV]) -> Self {
        self.inner.viewport_count = p_viewport_swizzles.len() as u32;
        self.inner.p_viewport_swizzles = p_viewport_swizzles.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineViewportSwizzleStateCreateInfoNVBuilder<'a> {
    type Target = vk::PipelineViewportSwizzleStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineViewportStateCreateInfoNext for vk::PipelineViewportSwizzleStateCreateInfoNV {}
impl PipelineViewportStateCreateInfoNext for PipelineViewportSwizzleStateCreateInfoNVBuilder<'_> {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceDiscardRectanglePropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineDiscardRectangleStateCreateInfoEXTBuilder<'a> {
    inner: vk::PipelineDiscardRectangleStateCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineDiscardRectangleStateCreateInfoEXT {
    type Type = PipelineDiscardRectangleStateCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineDiscardRectangleStateCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineDiscardRectangleStateCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineDiscardRectangleStateCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn discard_rectangle_mode(mut self, discard_rectangle_mode: vk::DiscardRectangleModeEXT) -> Self {
        self.inner.discard_rectangle_mode = discard_rectangle_mode;
        self
    }
    pub fn discard_rectangle_count(mut self, discard_rectangle_count: u32) -> Self {
        self.inner.discard_rectangle_count = discard_rectangle_count;
        self
    }
    pub fn p_discard_rectangles(mut self, p_discard_rectangles: &'a [vk::Rect2D]) -> Self {
        self.inner.discard_rectangle_count = p_discard_rectangles.len() as u32;
        self.inner.p_discard_rectangles = p_discard_rectangles.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineDiscardRectangleStateCreateInfoEXTBuilder<'a> {
    type Target = vk::PipelineDiscardRectangleStateCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::PipelineDiscardRectangleStateCreateInfoEXT {}
impl GraphicsPipelineCreateInfoNext for PipelineDiscardRectangleStateCreateInfoEXTBuilder<'_> {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {}

#[repr(transparent)]
#[derive(Default)]
pub struct InputAttachmentAspectReferenceBuilder {
    inner: vk::InputAttachmentAspectReference,
}
impl Builder<'_> for vk::InputAttachmentAspectReference {
    type Type = InputAttachmentAspectReferenceBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl InputAttachmentAspectReferenceBuilder {
    pub fn get_mut(&mut self) -> &mut vk::InputAttachmentAspectReference {
        &mut self.inner
    }
    pub fn subpass(mut self, subpass: u32) -> Self {
        self.inner.subpass = subpass;
        self
    }
    pub fn input_attachment_index(mut self, input_attachment_index: u32) -> Self {
        self.inner.input_attachment_index = input_attachment_index;
        self
    }
    pub fn aspect_mask(mut self, aspect_mask: vk::ImageAspectFlags) -> Self {
        self.inner.aspect_mask = aspect_mask;
        self
    }
}
impl Deref for InputAttachmentAspectReferenceBuilder {
    type Target = vk::InputAttachmentAspectReference;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassInputAttachmentAspectCreateInfoBuilder<'a> {
    inner: vk::RenderPassInputAttachmentAspectCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderPassInputAttachmentAspectCreateInfo {
    type Type = RenderPassInputAttachmentAspectCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> RenderPassInputAttachmentAspectCreateInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::RenderPassInputAttachmentAspectCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_aspect_references(mut self, p_aspect_references: &'a [vk::InputAttachmentAspectReference]) -> Self {
        self.inner.aspect_reference_count = p_aspect_references.len() as u32;
        self.inner.p_aspect_references = p_aspect_references.as_ptr();
        self
    }
}
impl<'a> Deref for RenderPassInputAttachmentAspectCreateInfoBuilder<'a> {
    type Target = vk::RenderPassInputAttachmentAspectCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderPassCreateInfoNext for vk::RenderPassInputAttachmentAspectCreateInfo {}
impl RenderPassCreateInfoNext for RenderPassInputAttachmentAspectCreateInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceSurfaceInfo2KHRBuilder<'a> {
    inner: vk::PhysicalDeviceSurfaceInfo2KHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PhysicalDeviceSurfaceInfo2KHR {
    type Type = PhysicalDeviceSurfaceInfo2KHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PhysicalDeviceSurfaceInfo2KHRNext {}
impl<'a> PhysicalDeviceSurfaceInfo2KHRBuilder<'a> {
    pub fn insert_next<T: PhysicalDeviceSurfaceInfo2KHRNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceSurfaceInfo2KHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn surface(mut self, surface: vk::SurfaceKHR) -> Self {
        self.inner.surface = surface;
        self
    }
}
impl<'a> Deref for PhysicalDeviceSurfaceInfo2KHRBuilder<'a> {
    type Target = vk::PhysicalDeviceSurfaceInfo2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SurfaceCapabilities2KHRBuilder<'a> {
    inner: vk::SurfaceCapabilities2KHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SurfaceCapabilities2KHR {
    type Type = SurfaceCapabilities2KHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait SurfaceCapabilities2KHRNext {}
impl<'a> SurfaceCapabilities2KHRBuilder<'a> {
    pub fn insert_next<T: SurfaceCapabilities2KHRNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::SurfaceCapabilities2KHR {
        &mut self.inner
    }
}
impl<'a> Deref for SurfaceCapabilities2KHRBuilder<'a> {
    type Target = vk::SurfaceCapabilities2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SurfaceFormat2KHRBuilder<'a> {
    inner: vk::SurfaceFormat2KHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SurfaceFormat2KHR {
    type Type = SurfaceFormat2KHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait SurfaceFormat2KHRNext {}
impl<'a> SurfaceFormat2KHRBuilder<'a> {
    pub fn insert_next<T: SurfaceFormat2KHRNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::SurfaceFormat2KHR {
        &mut self.inner
    }
}
impl<'a> Deref for SurfaceFormat2KHRBuilder<'a> {
    type Target = vk::SurfaceFormat2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DisplayModeProperties2KHRBuilder<'a> {
    inner: vk::DisplayModeProperties2KHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DisplayModeProperties2KHR {
    type Type = DisplayModeProperties2KHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DisplayModeProperties2KHRNext {}
impl<'a> DisplayModeProperties2KHRBuilder<'a> {
    pub fn insert_next<T: DisplayModeProperties2KHRNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DisplayModeProperties2KHR {
        &mut self.inner
    }
}
impl<'a> Deref for DisplayModeProperties2KHRBuilder<'a> {
    type Target = vk::DisplayModeProperties2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DisplayModeProperties2KHRNext for vk::DisplayModeStereoPropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct DisplayPlaneInfo2KHRBuilder {
    inner: vk::DisplayPlaneInfo2KHR,
}
impl Builder<'_> for vk::DisplayPlaneInfo2KHR {
    type Type = DisplayPlaneInfo2KHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DisplayPlaneInfo2KHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DisplayPlaneInfo2KHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn mode(mut self, mode: vk::DisplayModeKHR) -> Self {
        self.inner.mode = mode;
        self
    }
    pub fn plane_index(mut self, plane_index: u32) -> Self {
        self.inner.plane_index = plane_index;
        self
    }
}
impl Deref for DisplayPlaneInfo2KHRBuilder {
    type Target = vk::DisplayPlaneInfo2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SurfaceCapabilities2KHRNext for vk::SharedPresentSurfaceCapabilitiesKHR {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevice16BitStorageFeaturesBuilder {
    inner: vk::PhysicalDevice16BitStorageFeatures,
}
impl Builder<'_> for vk::PhysicalDevice16BitStorageFeatures {
    type Type = PhysicalDevice16BitStorageFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevice16BitStorageFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevice16BitStorageFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn storage_buffer16_bit_access(mut self, storage_buffer16_bit_access: bool) -> Self {
        self.inner.storage_buffer16_bit_access = if storage_buffer16_bit_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn uniform_and_storage_buffer16_bit_access(mut self, uniform_and_storage_buffer16_bit_access: bool) -> Self {
        self.inner.uniform_and_storage_buffer16_bit_access = if uniform_and_storage_buffer16_bit_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn storage_push_constant16(mut self, storage_push_constant16: bool) -> Self {
        self.inner.storage_push_constant16 = if storage_push_constant16 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn storage_input_output16(mut self, storage_input_output16: bool) -> Self {
        self.inner.storage_input_output16 = if storage_input_output16 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevice16BitStorageFeaturesBuilder {
    type Target = vk::PhysicalDevice16BitStorageFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevice16BitStorageFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDevice16BitStorageFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevice16BitStorageFeatures {}
impl DeviceCreateInfoNext for PhysicalDevice16BitStorageFeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceSubgroupProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder {
    inner: vk::PhysicalDeviceShaderSubgroupExtendedTypesFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    type Type = PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_subgroup_extended_types(mut self, shader_subgroup_extended_types: bool) -> Self {
        self.inner.shader_subgroup_extended_types = if shader_subgroup_extended_types {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder {
    type Target = vk::PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderSubgroupExtendedTypesFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderSubgroupExtendedTypesFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferMemoryRequirementsInfo2Builder {
    inner: vk::BufferMemoryRequirementsInfo2,
}
impl Builder<'_> for vk::BufferMemoryRequirementsInfo2 {
    type Type = BufferMemoryRequirementsInfo2Builder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BufferMemoryRequirementsInfo2Builder {
    pub fn get_mut(&mut self) -> &mut vk::BufferMemoryRequirementsInfo2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
}
impl Deref for BufferMemoryRequirementsInfo2Builder {
    type Target = vk::BufferMemoryRequirementsInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceBufferMemoryRequirementsBuilder<'a> {
    inner: vk::DeviceBufferMemoryRequirements,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DeviceBufferMemoryRequirements {
    type Type = DeviceBufferMemoryRequirementsBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DeviceBufferMemoryRequirementsBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DeviceBufferMemoryRequirements {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_create_info(mut self, p_create_info: &'a vk::BufferCreateInfo) -> Self {
        self.inner.p_create_info = p_create_info;
        self
    }
}
impl<'a> Deref for DeviceBufferMemoryRequirementsBuilder<'a> {
    type Target = vk::DeviceBufferMemoryRequirements;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageMemoryRequirementsInfo2Builder<'a> {
    inner: vk::ImageMemoryRequirementsInfo2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImageMemoryRequirementsInfo2 {
    type Type = ImageMemoryRequirementsInfo2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait ImageMemoryRequirementsInfo2Next {}
impl<'a> ImageMemoryRequirementsInfo2Builder<'a> {
    pub fn insert_next<T: ImageMemoryRequirementsInfo2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::ImageMemoryRequirementsInfo2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image(mut self, image: vk::Image) -> Self {
        self.inner.image = image;
        self
    }
}
impl<'a> Deref for ImageMemoryRequirementsInfo2Builder<'a> {
    type Target = vk::ImageMemoryRequirementsInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageSparseMemoryRequirementsInfo2Builder {
    inner: vk::ImageSparseMemoryRequirementsInfo2,
}
impl Builder<'_> for vk::ImageSparseMemoryRequirementsInfo2 {
    type Type = ImageSparseMemoryRequirementsInfo2Builder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageSparseMemoryRequirementsInfo2Builder {
    pub fn get_mut(&mut self) -> &mut vk::ImageSparseMemoryRequirementsInfo2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image(mut self, image: vk::Image) -> Self {
        self.inner.image = image;
        self
    }
}
impl Deref for ImageSparseMemoryRequirementsInfo2Builder {
    type Target = vk::ImageSparseMemoryRequirementsInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceImageMemoryRequirementsBuilder<'a> {
    inner: vk::DeviceImageMemoryRequirements,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DeviceImageMemoryRequirements {
    type Type = DeviceImageMemoryRequirementsBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DeviceImageMemoryRequirementsBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DeviceImageMemoryRequirements {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_create_info(mut self, p_create_info: &'a vk::ImageCreateInfo) -> Self {
        self.inner.p_create_info = p_create_info;
        self
    }
    pub fn plane_aspect(mut self, plane_aspect: vk::ImageAspectFlags) -> Self {
        self.inner.plane_aspect = plane_aspect;
        self
    }
}
impl<'a> Deref for DeviceImageMemoryRequirementsBuilder<'a> {
    type Target = vk::DeviceImageMemoryRequirements;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryRequirements2Builder<'a> {
    inner: vk::MemoryRequirements2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::MemoryRequirements2 {
    type Type = MemoryRequirements2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait MemoryRequirements2Next {}
impl<'a> MemoryRequirements2Builder<'a> {
    pub fn insert_next<T: MemoryRequirements2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::MemoryRequirements2 {
        &mut self.inner
    }
}
impl<'a> Deref for MemoryRequirements2Builder<'a> {
    type Target = vk::MemoryRequirements2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDevicePointClippingProperties {}
impl MemoryRequirements2Next for vk::MemoryDedicatedRequirements {}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryDedicatedAllocateInfoBuilder {
    inner: vk::MemoryDedicatedAllocateInfo,
}
impl Builder<'_> for vk::MemoryDedicatedAllocateInfo {
    type Type = MemoryDedicatedAllocateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryDedicatedAllocateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryDedicatedAllocateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image(mut self, image: vk::Image) -> Self {
        self.inner.image = image;
        self
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
}
impl Deref for MemoryDedicatedAllocateInfoBuilder {
    type Target = vk::MemoryDedicatedAllocateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::MemoryDedicatedAllocateInfo {}
impl MemoryAllocateInfoNext for MemoryDedicatedAllocateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageViewUsageCreateInfoBuilder {
    inner: vk::ImageViewUsageCreateInfo,
}
impl Builder<'_> for vk::ImageViewUsageCreateInfo {
    type Type = ImageViewUsageCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageViewUsageCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageViewUsageCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn usage(mut self, usage: vk::ImageUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
}
impl Deref for ImageViewUsageCreateInfoBuilder {
    type Target = vk::ImageViewUsageCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageViewCreateInfoNext for vk::ImageViewUsageCreateInfo {}
impl ImageViewCreateInfoNext for ImageViewUsageCreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageViewSlicedCreateInfoEXTBuilder {
    inner: vk::ImageViewSlicedCreateInfoEXT,
}
impl Builder<'_> for vk::ImageViewSlicedCreateInfoEXT {
    type Type = ImageViewSlicedCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageViewSlicedCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageViewSlicedCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn slice_offset(mut self, slice_offset: u32) -> Self {
        self.inner.slice_offset = slice_offset;
        self
    }
    pub fn slice_count(mut self, slice_count: u32) -> Self {
        self.inner.slice_count = slice_count;
        self
    }
}
impl Deref for ImageViewSlicedCreateInfoEXTBuilder {
    type Target = vk::ImageViewSlicedCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageViewCreateInfoNext for vk::ImageViewSlicedCreateInfoEXT {}
impl ImageViewCreateInfoNext for ImageViewSlicedCreateInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineTessellationDomainOriginStateCreateInfoBuilder {
    inner: vk::PipelineTessellationDomainOriginStateCreateInfo,
}
impl Builder<'_> for vk::PipelineTessellationDomainOriginStateCreateInfo {
    type Type = PipelineTessellationDomainOriginStateCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineTessellationDomainOriginStateCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineTessellationDomainOriginStateCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn domain_origin(mut self, domain_origin: vk::TessellationDomainOrigin) -> Self {
        self.inner.domain_origin = domain_origin;
        self
    }
}
impl Deref for PipelineTessellationDomainOriginStateCreateInfoBuilder {
    type Target = vk::PipelineTessellationDomainOriginStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineTessellationStateCreateInfoNext for vk::PipelineTessellationDomainOriginStateCreateInfo {}
impl PipelineTessellationStateCreateInfoNext for PipelineTessellationDomainOriginStateCreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SamplerYcbcrConversionInfoBuilder {
    inner: vk::SamplerYcbcrConversionInfo,
}
impl Builder<'_> for vk::SamplerYcbcrConversionInfo {
    type Type = SamplerYcbcrConversionInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SamplerYcbcrConversionInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SamplerYcbcrConversionInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn conversion(mut self, conversion: vk::SamplerYcbcrConversion) -> Self {
        self.inner.conversion = conversion;
        self
    }
}
impl Deref for SamplerYcbcrConversionInfoBuilder {
    type Target = vk::SamplerYcbcrConversionInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SamplerCreateInfoNext for vk::SamplerYcbcrConversionInfo {}
impl SamplerCreateInfoNext for SamplerYcbcrConversionInfoBuilder {}
impl ImageViewCreateInfoNext for vk::SamplerYcbcrConversionInfo {}
impl ImageViewCreateInfoNext for SamplerYcbcrConversionInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SamplerYcbcrConversionCreateInfoBuilder<'a> {
    inner: vk::SamplerYcbcrConversionCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SamplerYcbcrConversionCreateInfo {
    type Type = SamplerYcbcrConversionCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait SamplerYcbcrConversionCreateInfoNext {}
impl<'a> SamplerYcbcrConversionCreateInfoBuilder<'a> {
    pub fn insert_next<T: SamplerYcbcrConversionCreateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::SamplerYcbcrConversionCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn format(mut self, format: vk::Format) -> Self {
        self.inner.format = format;
        self
    }
    pub fn ycbcr_model(mut self, ycbcr_model: vk::SamplerYcbcrModelConversion) -> Self {
        self.inner.ycbcr_model = ycbcr_model;
        self
    }
    pub fn ycbcr_range(mut self, ycbcr_range: vk::SamplerYcbcrRange) -> Self {
        self.inner.ycbcr_range = ycbcr_range;
        self
    }
    pub fn components(mut self, components: vk::ComponentMapping) -> Self {
        self.inner.components = components;
        self
    }
    pub fn x_chroma_offset(mut self, x_chroma_offset: vk::ChromaLocation) -> Self {
        self.inner.x_chroma_offset = x_chroma_offset;
        self
    }
    pub fn y_chroma_offset(mut self, y_chroma_offset: vk::ChromaLocation) -> Self {
        self.inner.y_chroma_offset = y_chroma_offset;
        self
    }
    pub fn chroma_filter(mut self, chroma_filter: vk::Filter) -> Self {
        self.inner.chroma_filter = chroma_filter;
        self
    }
    pub fn force_explicit_reconstruction(mut self, force_explicit_reconstruction: bool) -> Self {
        self.inner.force_explicit_reconstruction = if force_explicit_reconstruction {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl<'a> Deref for SamplerYcbcrConversionCreateInfoBuilder<'a> {
    type Target = vk::SamplerYcbcrConversionCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BindImagePlaneMemoryInfoBuilder {
    inner: vk::BindImagePlaneMemoryInfo,
}
impl Builder<'_> for vk::BindImagePlaneMemoryInfo {
    type Type = BindImagePlaneMemoryInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BindImagePlaneMemoryInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BindImagePlaneMemoryInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn plane_aspect(mut self, plane_aspect: vk::ImageAspectFlags) -> Self {
        self.inner.plane_aspect = plane_aspect;
        self
    }
}
impl Deref for BindImagePlaneMemoryInfoBuilder {
    type Target = vk::BindImagePlaneMemoryInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BindImageMemoryInfoNext for vk::BindImagePlaneMemoryInfo {}
impl BindImageMemoryInfoNext for BindImagePlaneMemoryInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImagePlaneMemoryRequirementsInfoBuilder {
    inner: vk::ImagePlaneMemoryRequirementsInfo,
}
impl Builder<'_> for vk::ImagePlaneMemoryRequirementsInfo {
    type Type = ImagePlaneMemoryRequirementsInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImagePlaneMemoryRequirementsInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImagePlaneMemoryRequirementsInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn plane_aspect(mut self, plane_aspect: vk::ImageAspectFlags) -> Self {
        self.inner.plane_aspect = plane_aspect;
        self
    }
}
impl Deref for ImagePlaneMemoryRequirementsInfoBuilder {
    type Target = vk::ImagePlaneMemoryRequirementsInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageMemoryRequirementsInfo2Next for vk::ImagePlaneMemoryRequirementsInfo {}
impl ImageMemoryRequirementsInfo2Next for ImagePlaneMemoryRequirementsInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder {
    inner: vk::PhysicalDeviceSamplerYcbcrConversionFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceSamplerYcbcrConversionFeatures {
    type Type = PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceSamplerYcbcrConversionFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn sampler_ycbcr_conversion(mut self, sampler_ycbcr_conversion: bool) -> Self {
        self.inner.sampler_ycbcr_conversion = if sampler_ycbcr_conversion { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder {
    type Target = vk::PhysicalDeviceSamplerYcbcrConversionFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceSamplerYcbcrConversionFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceSamplerYcbcrConversionFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder {}
impl ImageFormatProperties2Next for vk::SamplerYcbcrConversionImageFormatProperties {}
impl ImageFormatProperties2Next for vk::TextureLODGatherFormatPropertiesAMD {}

#[repr(transparent)]
#[derive(Default)]
pub struct ConditionalRenderingBeginInfoEXTBuilder {
    inner: vk::ConditionalRenderingBeginInfoEXT,
}
impl Builder<'_> for vk::ConditionalRenderingBeginInfoEXT {
    type Type = ConditionalRenderingBeginInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ConditionalRenderingBeginInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ConditionalRenderingBeginInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    pub fn offset(mut self, offset: vk::DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn flags(mut self, flags: vk::ConditionalRenderingFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl Deref for ConditionalRenderingBeginInfoEXTBuilder {
    type Target = vk::ConditionalRenderingBeginInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ProtectedSubmitInfoBuilder {
    inner: vk::ProtectedSubmitInfo,
}
impl Builder<'_> for vk::ProtectedSubmitInfo {
    type Type = ProtectedSubmitInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ProtectedSubmitInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ProtectedSubmitInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn protected_submit(mut self, protected_submit: bool) -> Self {
        self.inner.protected_submit = if protected_submit { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for ProtectedSubmitInfoBuilder {
    type Target = vk::ProtectedSubmitInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubmitInfoNext for vk::ProtectedSubmitInfo {}
impl SubmitInfoNext for ProtectedSubmitInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceProtectedMemoryFeaturesBuilder {
    inner: vk::PhysicalDeviceProtectedMemoryFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceProtectedMemoryFeatures {
    type Type = PhysicalDeviceProtectedMemoryFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceProtectedMemoryFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceProtectedMemoryFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn protected_memory(mut self, protected_memory: bool) -> Self {
        self.inner.protected_memory = if protected_memory { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceProtectedMemoryFeaturesBuilder {
    type Target = vk::PhysicalDeviceProtectedMemoryFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceProtectedMemoryFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceProtectedMemoryFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceProtectedMemoryFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceProtectedMemoryFeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceProtectedMemoryProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceQueueInfo2Builder {
    inner: vk::DeviceQueueInfo2,
}
impl Builder<'_> for vk::DeviceQueueInfo2 {
    type Type = DeviceQueueInfo2Builder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceQueueInfo2Builder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceQueueInfo2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DeviceQueueCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.inner.queue_family_index = queue_family_index;
        self
    }
    pub fn queue_index(mut self, queue_index: u32) -> Self {
        self.inner.queue_index = queue_index;
        self
    }
}
impl Deref for DeviceQueueInfo2Builder {
    type Target = vk::DeviceQueueInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineCoverageToColorStateCreateInfoNVBuilder {
    inner: vk::PipelineCoverageToColorStateCreateInfoNV,
}
impl Builder<'_> for vk::PipelineCoverageToColorStateCreateInfoNV {
    type Type = PipelineCoverageToColorStateCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineCoverageToColorStateCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineCoverageToColorStateCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineCoverageToColorStateCreateFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn coverage_to_color_enable(mut self, coverage_to_color_enable: bool) -> Self {
        self.inner.coverage_to_color_enable = if coverage_to_color_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn coverage_to_color_location(mut self, coverage_to_color_location: u32) -> Self {
        self.inner.coverage_to_color_location = coverage_to_color_location;
        self
    }
}
impl Deref for PipelineCoverageToColorStateCreateInfoNVBuilder {
    type Target = vk::PipelineCoverageToColorStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineMultisampleStateCreateInfoNext for vk::PipelineCoverageToColorStateCreateInfoNV {}
impl PipelineMultisampleStateCreateInfoNext for PipelineCoverageToColorStateCreateInfoNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceSamplerFilterMinmaxProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct SampleLocationEXTBuilder {
    inner: vk::SampleLocationEXT,
}
impl Builder<'_> for vk::SampleLocationEXT {
    type Type = SampleLocationEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SampleLocationEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SampleLocationEXT {
        &mut self.inner
    }
    pub fn x(mut self, x: f32) -> Self {
        self.inner.x = x;
        self
    }
    pub fn y(mut self, y: f32) -> Self {
        self.inner.y = y;
        self
    }
}
impl Deref for SampleLocationEXTBuilder {
    type Target = vk::SampleLocationEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SampleLocationsInfoEXTBuilder<'a> {
    inner: vk::SampleLocationsInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SampleLocationsInfoEXT {
    type Type = SampleLocationsInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> SampleLocationsInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::SampleLocationsInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn sample_locations_per_pixel(mut self, sample_locations_per_pixel: vk::SampleCountFlags) -> Self {
        self.inner.sample_locations_per_pixel = sample_locations_per_pixel;
        self
    }
    pub fn sample_location_grid_size(mut self, sample_location_grid_size: vk::Extent2D) -> Self {
        self.inner.sample_location_grid_size = sample_location_grid_size;
        self
    }
    pub fn p_sample_locations(mut self, p_sample_locations: &'a [vk::SampleLocationEXT]) -> Self {
        self.inner.sample_locations_count = p_sample_locations.len() as u32;
        self.inner.p_sample_locations = p_sample_locations.as_ptr();
        self
    }
}
impl<'a> Deref for SampleLocationsInfoEXTBuilder<'a> {
    type Target = vk::SampleLocationsInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageMemoryBarrierNext for vk::SampleLocationsInfoEXT {}
impl ImageMemoryBarrierNext for SampleLocationsInfoEXTBuilder<'_> {}
impl ImageMemoryBarrier2Next for vk::SampleLocationsInfoEXT {}
impl ImageMemoryBarrier2Next for SampleLocationsInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct AttachmentSampleLocationsEXTBuilder {
    inner: vk::AttachmentSampleLocationsEXT,
}
impl Builder<'_> for vk::AttachmentSampleLocationsEXT {
    type Type = AttachmentSampleLocationsEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AttachmentSampleLocationsEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AttachmentSampleLocationsEXT {
        &mut self.inner
    }
    pub fn attachment_index(mut self, attachment_index: u32) -> Self {
        self.inner.attachment_index = attachment_index;
        self
    }
    pub fn sample_locations_info(mut self, sample_locations_info: vk::SampleLocationsInfoEXT) -> Self {
        self.inner.sample_locations_info = sample_locations_info;
        self
    }
}
impl Deref for AttachmentSampleLocationsEXTBuilder {
    type Target = vk::AttachmentSampleLocationsEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SubpassSampleLocationsEXTBuilder {
    inner: vk::SubpassSampleLocationsEXT,
}
impl Builder<'_> for vk::SubpassSampleLocationsEXT {
    type Type = SubpassSampleLocationsEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SubpassSampleLocationsEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SubpassSampleLocationsEXT {
        &mut self.inner
    }
    pub fn subpass_index(mut self, subpass_index: u32) -> Self {
        self.inner.subpass_index = subpass_index;
        self
    }
    pub fn sample_locations_info(mut self, sample_locations_info: vk::SampleLocationsInfoEXT) -> Self {
        self.inner.sample_locations_info = sample_locations_info;
        self
    }
}
impl Deref for SubpassSampleLocationsEXTBuilder {
    type Target = vk::SubpassSampleLocationsEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassSampleLocationsBeginInfoEXTBuilder<'a> {
    inner: vk::RenderPassSampleLocationsBeginInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderPassSampleLocationsBeginInfoEXT {
    type Type = RenderPassSampleLocationsBeginInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> RenderPassSampleLocationsBeginInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::RenderPassSampleLocationsBeginInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_attachment_initial_sample_locations(
        mut self,
        p_attachment_initial_sample_locations: &'a [vk::AttachmentSampleLocationsEXT],
    ) -> Self {
        self.inner.attachment_initial_sample_locations_count = p_attachment_initial_sample_locations.len() as u32;
        self.inner.p_attachment_initial_sample_locations = p_attachment_initial_sample_locations.as_ptr();
        self
    }
    pub fn p_post_subpass_sample_locations(
        mut self,
        p_post_subpass_sample_locations: &'a [vk::SubpassSampleLocationsEXT],
    ) -> Self {
        self.inner.post_subpass_sample_locations_count = p_post_subpass_sample_locations.len() as u32;
        self.inner.p_post_subpass_sample_locations = p_post_subpass_sample_locations.as_ptr();
        self
    }
}
impl<'a> Deref for RenderPassSampleLocationsBeginInfoEXTBuilder<'a> {
    type Target = vk::RenderPassSampleLocationsBeginInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderPassBeginInfoNext for vk::RenderPassSampleLocationsBeginInfoEXT {}
impl RenderPassBeginInfoNext for RenderPassSampleLocationsBeginInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineSampleLocationsStateCreateInfoEXTBuilder {
    inner: vk::PipelineSampleLocationsStateCreateInfoEXT,
}
impl Builder<'_> for vk::PipelineSampleLocationsStateCreateInfoEXT {
    type Type = PipelineSampleLocationsStateCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineSampleLocationsStateCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineSampleLocationsStateCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn sample_locations_enable(mut self, sample_locations_enable: bool) -> Self {
        self.inner.sample_locations_enable = if sample_locations_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sample_locations_info(mut self, sample_locations_info: vk::SampleLocationsInfoEXT) -> Self {
        self.inner.sample_locations_info = sample_locations_info;
        self
    }
}
impl Deref for PipelineSampleLocationsStateCreateInfoEXTBuilder {
    type Target = vk::PipelineSampleLocationsStateCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineMultisampleStateCreateInfoNext for vk::PipelineSampleLocationsStateCreateInfoEXT {}
impl PipelineMultisampleStateCreateInfoNext for PipelineSampleLocationsStateCreateInfoEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceSampleLocationsPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct SamplerReductionModeCreateInfoBuilder {
    inner: vk::SamplerReductionModeCreateInfo,
}
impl Builder<'_> for vk::SamplerReductionModeCreateInfo {
    type Type = SamplerReductionModeCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SamplerReductionModeCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SamplerReductionModeCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn reduction_mode(mut self, reduction_mode: vk::SamplerReductionMode) -> Self {
        self.inner.reduction_mode = reduction_mode;
        self
    }
}
impl Deref for SamplerReductionModeCreateInfoBuilder {
    type Target = vk::SamplerReductionModeCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SamplerCreateInfoNext for vk::SamplerReductionModeCreateInfo {}
impl SamplerCreateInfoNext for SamplerReductionModeCreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceBlendOperationAdvancedFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    type Type = PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn advanced_blend_coherent_operations(mut self, advanced_blend_coherent_operations: bool) -> Self {
        self.inner.advanced_blend_coherent_operations = if advanced_blend_coherent_operations {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceBlendOperationAdvancedFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceBlendOperationAdvancedFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceBlendOperationAdvancedFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMultiDrawFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceMultiDrawFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceMultiDrawFeaturesEXT {
    type Type = PhysicalDeviceMultiDrawFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMultiDrawFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMultiDrawFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn multi_draw(mut self, multi_draw: bool) -> Self {
        self.inner.multi_draw = if multi_draw { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceMultiDrawFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceMultiDrawFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMultiDrawFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMultiDrawFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMultiDrawFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceMultiDrawFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceBlendOperationAdvancedPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineColorBlendAdvancedStateCreateInfoEXTBuilder {
    inner: vk::PipelineColorBlendAdvancedStateCreateInfoEXT,
}
impl Builder<'_> for vk::PipelineColorBlendAdvancedStateCreateInfoEXT {
    type Type = PipelineColorBlendAdvancedStateCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineColorBlendAdvancedStateCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineColorBlendAdvancedStateCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_premultiplied(mut self, src_premultiplied: bool) -> Self {
        self.inner.src_premultiplied = if src_premultiplied { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn dst_premultiplied(mut self, dst_premultiplied: bool) -> Self {
        self.inner.dst_premultiplied = if dst_premultiplied { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn blend_overlap(mut self, blend_overlap: vk::BlendOverlapEXT) -> Self {
        self.inner.blend_overlap = blend_overlap;
        self
    }
}
impl Deref for PipelineColorBlendAdvancedStateCreateInfoEXTBuilder {
    type Target = vk::PipelineColorBlendAdvancedStateCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineColorBlendStateCreateInfoNext for vk::PipelineColorBlendAdvancedStateCreateInfoEXT {}
impl PipelineColorBlendStateCreateInfoNext for PipelineColorBlendAdvancedStateCreateInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceInlineUniformBlockFeaturesBuilder {
    inner: vk::PhysicalDeviceInlineUniformBlockFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceInlineUniformBlockFeatures {
    type Type = PhysicalDeviceInlineUniformBlockFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceInlineUniformBlockFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceInlineUniformBlockFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn inline_uniform_block(mut self, inline_uniform_block: bool) -> Self {
        self.inner.inline_uniform_block = if inline_uniform_block { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn descriptor_binding_inline_uniform_block_update_after_bind(
        mut self,
        descriptor_binding_inline_uniform_block_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_inline_uniform_block_update_after_bind =
            if descriptor_binding_inline_uniform_block_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
}
impl Deref for PhysicalDeviceInlineUniformBlockFeaturesBuilder {
    type Target = vk::PhysicalDeviceInlineUniformBlockFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceInlineUniformBlockFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceInlineUniformBlockFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceInlineUniformBlockFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceInlineUniformBlockFeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceInlineUniformBlockProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct WriteDescriptorSetInlineUniformBlockBuilder<'a> {
    inner: vk::WriteDescriptorSetInlineUniformBlock,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::WriteDescriptorSetInlineUniformBlock {
    type Type = WriteDescriptorSetInlineUniformBlockBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> WriteDescriptorSetInlineUniformBlockBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::WriteDescriptorSetInlineUniformBlock {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_data(mut self, p_data: &'a [u8]) -> Self {
        self.inner.data_size = p_data.len() as u32;
        self.inner.p_data = p_data.as_ptr() as *const _;
        self
    }
}
impl<'a> Deref for WriteDescriptorSetInlineUniformBlockBuilder<'a> {
    type Target = vk::WriteDescriptorSetInlineUniformBlock;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl WriteDescriptorSetNext for vk::WriteDescriptorSetInlineUniformBlock {}
impl WriteDescriptorSetNext for WriteDescriptorSetInlineUniformBlockBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorPoolInlineUniformBlockCreateInfoBuilder {
    inner: vk::DescriptorPoolInlineUniformBlockCreateInfo,
}
impl Builder<'_> for vk::DescriptorPoolInlineUniformBlockCreateInfo {
    type Type = DescriptorPoolInlineUniformBlockCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DescriptorPoolInlineUniformBlockCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DescriptorPoolInlineUniformBlockCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn max_inline_uniform_block_bindings(mut self, max_inline_uniform_block_bindings: u32) -> Self {
        self.inner.max_inline_uniform_block_bindings = max_inline_uniform_block_bindings;
        self
    }
}
impl Deref for DescriptorPoolInlineUniformBlockCreateInfoBuilder {
    type Target = vk::DescriptorPoolInlineUniformBlockCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DescriptorPoolCreateInfoNext for vk::DescriptorPoolInlineUniformBlockCreateInfo {}
impl DescriptorPoolCreateInfoNext for DescriptorPoolInlineUniformBlockCreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineCoverageModulationStateCreateInfoNVBuilder<'a> {
    inner: vk::PipelineCoverageModulationStateCreateInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineCoverageModulationStateCreateInfoNV {
    type Type = PipelineCoverageModulationStateCreateInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineCoverageModulationStateCreateInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineCoverageModulationStateCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineCoverageModulationStateCreateFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn coverage_modulation_mode(mut self, coverage_modulation_mode: vk::CoverageModulationModeNV) -> Self {
        self.inner.coverage_modulation_mode = coverage_modulation_mode;
        self
    }
    pub fn coverage_modulation_table_enable(mut self, coverage_modulation_table_enable: bool) -> Self {
        self.inner.coverage_modulation_table_enable = if coverage_modulation_table_enable {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn coverage_modulation_table_count(mut self, coverage_modulation_table_count: u32) -> Self {
        self.inner.coverage_modulation_table_count = coverage_modulation_table_count;
        self
    }
    pub fn p_coverage_modulation_table(mut self, p_coverage_modulation_table: &'a [f32]) -> Self {
        self.inner.coverage_modulation_table_count = p_coverage_modulation_table.len() as u32;
        self.inner.p_coverage_modulation_table = p_coverage_modulation_table.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineCoverageModulationStateCreateInfoNVBuilder<'a> {
    type Target = vk::PipelineCoverageModulationStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineMultisampleStateCreateInfoNext for vk::PipelineCoverageModulationStateCreateInfoNV {}
impl PipelineMultisampleStateCreateInfoNext for PipelineCoverageModulationStateCreateInfoNVBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageFormatListCreateInfoBuilder<'a> {
    inner: vk::ImageFormatListCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImageFormatListCreateInfo {
    type Type = ImageFormatListCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ImageFormatListCreateInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ImageFormatListCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_view_formats(mut self, p_view_formats: &'a [vk::Format]) -> Self {
        self.inner.view_format_count = p_view_formats.len() as u32;
        self.inner.p_view_formats = p_view_formats.as_ptr();
        self
    }
}
impl<'a> Deref for ImageFormatListCreateInfoBuilder<'a> {
    type Target = vk::ImageFormatListCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageCreateInfoNext for vk::ImageFormatListCreateInfo {}
impl ImageCreateInfoNext for ImageFormatListCreateInfoBuilder<'_> {}
impl SwapchainCreateInfoKHRNext for vk::ImageFormatListCreateInfo {}
impl SwapchainCreateInfoKHRNext for ImageFormatListCreateInfoBuilder<'_> {}
impl PhysicalDeviceImageFormatInfo2Next for vk::ImageFormatListCreateInfo {}
impl PhysicalDeviceImageFormatInfo2Next for ImageFormatListCreateInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ValidationCacheCreateInfoEXTBuilder<'a> {
    inner: vk::ValidationCacheCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ValidationCacheCreateInfoEXT {
    type Type = ValidationCacheCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ValidationCacheCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ValidationCacheCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::ValidationCacheCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_initial_data(mut self, p_initial_data: &'a [u8]) -> Self {
        self.inner.initial_data_size = p_initial_data.len();
        self.inner.p_initial_data = p_initial_data.as_ptr() as *const _;
        self
    }
}
impl<'a> Deref for ValidationCacheCreateInfoEXTBuilder<'a> {
    type Target = vk::ValidationCacheCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ShaderModuleValidationCacheCreateInfoEXTBuilder {
    inner: vk::ShaderModuleValidationCacheCreateInfoEXT,
}
impl Builder<'_> for vk::ShaderModuleValidationCacheCreateInfoEXT {
    type Type = ShaderModuleValidationCacheCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ShaderModuleValidationCacheCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ShaderModuleValidationCacheCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn validation_cache(mut self, validation_cache: vk::ValidationCacheEXT) -> Self {
        self.inner.validation_cache = validation_cache;
        self
    }
}
impl Deref for ShaderModuleValidationCacheCreateInfoEXTBuilder {
    type Target = vk::ShaderModuleValidationCacheCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ShaderModuleCreateInfoNext for vk::ShaderModuleValidationCacheCreateInfoEXT {}
impl ShaderModuleCreateInfoNext for ShaderModuleValidationCacheCreateInfoEXTBuilder {}
impl PipelineShaderStageCreateInfoNext for vk::ShaderModuleValidationCacheCreateInfoEXT {}
impl PipelineShaderStageCreateInfoNext for ShaderModuleValidationCacheCreateInfoEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceMaintenance3Properties {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMaintenance4FeaturesBuilder {
    inner: vk::PhysicalDeviceMaintenance4Features,
}
impl Builder<'_> for vk::PhysicalDeviceMaintenance4Features {
    type Type = PhysicalDeviceMaintenance4FeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMaintenance4FeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMaintenance4Features {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn maintenance4(mut self, maintenance4: bool) -> Self {
        self.inner.maintenance4 = if maintenance4 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceMaintenance4FeaturesBuilder {
    type Target = vk::PhysicalDeviceMaintenance4Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMaintenance4Features {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMaintenance4FeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMaintenance4Features {}
impl DeviceCreateInfoNext for PhysicalDeviceMaintenance4FeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceMaintenance4Properties {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMaintenance5FeaturesBuilder {
    inner: vk::PhysicalDeviceMaintenance5Features,
}
impl Builder<'_> for vk::PhysicalDeviceMaintenance5Features {
    type Type = PhysicalDeviceMaintenance5FeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMaintenance5FeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMaintenance5Features {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn maintenance5(mut self, maintenance5: bool) -> Self {
        self.inner.maintenance5 = if maintenance5 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceMaintenance5FeaturesBuilder {
    type Target = vk::PhysicalDeviceMaintenance5Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMaintenance5Features {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMaintenance5FeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMaintenance5Features {}
impl DeviceCreateInfoNext for PhysicalDeviceMaintenance5FeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceMaintenance5Properties {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMaintenance6FeaturesBuilder {
    inner: vk::PhysicalDeviceMaintenance6Features,
}
impl Builder<'_> for vk::PhysicalDeviceMaintenance6Features {
    type Type = PhysicalDeviceMaintenance6FeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMaintenance6FeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMaintenance6Features {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn maintenance6(mut self, maintenance6: bool) -> Self {
        self.inner.maintenance6 = if maintenance6 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceMaintenance6FeaturesBuilder {
    type Target = vk::PhysicalDeviceMaintenance6Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMaintenance6Features {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMaintenance6FeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMaintenance6Features {}
impl DeviceCreateInfoNext for PhysicalDeviceMaintenance6FeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceMaintenance6Properties {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMaintenance7FeaturesKHRBuilder {
    inner: vk::PhysicalDeviceMaintenance7FeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceMaintenance7FeaturesKHR {
    type Type = PhysicalDeviceMaintenance7FeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMaintenance7FeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMaintenance7FeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn maintenance7(mut self, maintenance7: bool) -> Self {
        self.inner.maintenance7 = if maintenance7 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceMaintenance7FeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceMaintenance7FeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMaintenance7FeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMaintenance7FeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMaintenance7FeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceMaintenance7FeaturesKHRBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceMaintenance7PropertiesKHR {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceLayeredApiPropertiesListKHRBuilder<'a> {
    inner: vk::PhysicalDeviceLayeredApiPropertiesListKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PhysicalDeviceLayeredApiPropertiesListKHR {
    type Type = PhysicalDeviceLayeredApiPropertiesListKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PhysicalDeviceLayeredApiPropertiesListKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceLayeredApiPropertiesListKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_layered_apis(mut self, p_layered_apis: &'a mut [vk::PhysicalDeviceLayeredApiPropertiesKHR]) -> Self {
        self.inner.layered_api_count = p_layered_apis.len() as u32;
        self.inner.p_layered_apis = p_layered_apis.as_mut_ptr();
        self
    }
}
impl<'a> Deref for PhysicalDeviceLayeredApiPropertiesListKHRBuilder<'a> {
    type Target = vk::PhysicalDeviceLayeredApiPropertiesListKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceLayeredApiPropertiesListKHR {}
impl PhysicalDeviceProperties2Next for PhysicalDeviceLayeredApiPropertiesListKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceLayeredApiPropertiesKHRBuilder<'a> {
    inner: vk::PhysicalDeviceLayeredApiPropertiesKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PhysicalDeviceLayeredApiPropertiesKHR {
    type Type = PhysicalDeviceLayeredApiPropertiesKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PhysicalDeviceLayeredApiPropertiesKHRNext {}
impl<'a> PhysicalDeviceLayeredApiPropertiesKHRBuilder<'a> {
    pub fn insert_next<T: PhysicalDeviceLayeredApiPropertiesKHRNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceLayeredApiPropertiesKHR {
        &mut self.inner
    }
}
impl<'a> Deref for PhysicalDeviceLayeredApiPropertiesKHRBuilder<'a> {
    type Target = vk::PhysicalDeviceLayeredApiPropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceLayeredApiPropertiesKHRNext for vk::PhysicalDeviceLayeredApiVulkanPropertiesKHR {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMaintenance8FeaturesKHRBuilder {
    inner: vk::PhysicalDeviceMaintenance8FeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceMaintenance8FeaturesKHR {
    type Type = PhysicalDeviceMaintenance8FeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMaintenance8FeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMaintenance8FeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn maintenance8(mut self, maintenance8: bool) -> Self {
        self.inner.maintenance8 = if maintenance8 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceMaintenance8FeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceMaintenance8FeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMaintenance8FeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMaintenance8FeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMaintenance8FeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceMaintenance8FeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMaintenance9FeaturesKHRBuilder {
    inner: vk::PhysicalDeviceMaintenance9FeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceMaintenance9FeaturesKHR {
    type Type = PhysicalDeviceMaintenance9FeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMaintenance9FeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMaintenance9FeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn maintenance9(mut self, maintenance9: bool) -> Self {
        self.inner.maintenance9 = if maintenance9 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceMaintenance9FeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceMaintenance9FeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMaintenance9FeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMaintenance9FeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMaintenance9FeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceMaintenance9FeaturesKHRBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceMaintenance9PropertiesKHR {}
impl QueueFamilyProperties2Next for vk::QueueFamilyOwnershipTransferPropertiesKHR {}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderingAreaInfoBuilder<'a> {
    inner: vk::RenderingAreaInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderingAreaInfo {
    type Type = RenderingAreaInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> RenderingAreaInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::RenderingAreaInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.inner.view_mask = view_mask;
        self
    }
    pub fn color_attachment_count(mut self, color_attachment_count: u32) -> Self {
        self.inner.color_attachment_count = color_attachment_count;
        self
    }
    pub fn p_color_attachment_formats(mut self, p_color_attachment_formats: &'a [vk::Format]) -> Self {
        self.inner.color_attachment_count = p_color_attachment_formats.len() as u32;
        self.inner.p_color_attachment_formats = p_color_attachment_formats.as_ptr();
        self
    }
    pub fn depth_attachment_format(mut self, depth_attachment_format: vk::Format) -> Self {
        self.inner.depth_attachment_format = depth_attachment_format;
        self
    }
    pub fn stencil_attachment_format(mut self, stencil_attachment_format: vk::Format) -> Self {
        self.inner.stencil_attachment_format = stencil_attachment_format;
        self
    }
}
impl<'a> Deref for RenderingAreaInfoBuilder<'a> {
    type Target = vk::RenderingAreaInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorSetLayoutSupportBuilder<'a> {
    inner: vk::DescriptorSetLayoutSupport,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DescriptorSetLayoutSupport {
    type Type = DescriptorSetLayoutSupportBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DescriptorSetLayoutSupportNext {}
impl<'a> DescriptorSetLayoutSupportBuilder<'a> {
    pub fn insert_next<T: DescriptorSetLayoutSupportNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DescriptorSetLayoutSupport {
        &mut self.inner
    }
}
impl<'a> Deref for DescriptorSetLayoutSupportBuilder<'a> {
    type Target = vk::DescriptorSetLayoutSupport;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderDrawParametersFeaturesBuilder {
    inner: vk::PhysicalDeviceShaderDrawParametersFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceShaderDrawParametersFeatures {
    type Type = PhysicalDeviceShaderDrawParametersFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderDrawParametersFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderDrawParametersFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_draw_parameters(mut self, shader_draw_parameters: bool) -> Self {
        self.inner.shader_draw_parameters = if shader_draw_parameters { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceShaderDrawParametersFeaturesBuilder {
    type Target = vk::PhysicalDeviceShaderDrawParametersFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderDrawParametersFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderDrawParametersFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderDrawParametersFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderDrawParametersFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderFloat16Int8FeaturesBuilder {
    inner: vk::PhysicalDeviceShaderFloat16Int8Features,
}
impl Builder<'_> for vk::PhysicalDeviceShaderFloat16Int8Features {
    type Type = PhysicalDeviceShaderFloat16Int8FeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderFloat16Int8FeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderFloat16Int8Features {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_float16(mut self, shader_float16: bool) -> Self {
        self.inner.shader_float16 = if shader_float16 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_int8(mut self, shader_int8: bool) -> Self {
        self.inner.shader_int8 = if shader_int8 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceShaderFloat16Int8FeaturesBuilder {
    type Target = vk::PhysicalDeviceShaderFloat16Int8Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderFloat16Int8Features {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderFloat16Int8FeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderFloat16Int8Features {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderFloat16Int8FeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceFloatControlsProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceHostQueryResetFeaturesBuilder {
    inner: vk::PhysicalDeviceHostQueryResetFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceHostQueryResetFeatures {
    type Type = PhysicalDeviceHostQueryResetFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceHostQueryResetFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceHostQueryResetFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn host_query_reset(mut self, host_query_reset: bool) -> Self {
        self.inner.host_query_reset = if host_query_reset { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceHostQueryResetFeaturesBuilder {
    type Target = vk::PhysicalDeviceHostQueryResetFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceHostQueryResetFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceHostQueryResetFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceHostQueryResetFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceHostQueryResetFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceQueueGlobalPriorityCreateInfoBuilder {
    inner: vk::DeviceQueueGlobalPriorityCreateInfo,
}
impl Builder<'_> for vk::DeviceQueueGlobalPriorityCreateInfo {
    type Type = DeviceQueueGlobalPriorityCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceQueueGlobalPriorityCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceQueueGlobalPriorityCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn global_priority(mut self, global_priority: vk::QueueGlobalPriority) -> Self {
        self.inner.global_priority = global_priority;
        self
    }
}
impl Deref for DeviceQueueGlobalPriorityCreateInfoBuilder {
    type Target = vk::DeviceQueueGlobalPriorityCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DeviceQueueCreateInfoNext for vk::DeviceQueueGlobalPriorityCreateInfo {}
impl DeviceQueueCreateInfoNext for DeviceQueueGlobalPriorityCreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceGlobalPriorityQueryFeaturesBuilder {
    inner: vk::PhysicalDeviceGlobalPriorityQueryFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceGlobalPriorityQueryFeatures {
    type Type = PhysicalDeviceGlobalPriorityQueryFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceGlobalPriorityQueryFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceGlobalPriorityQueryFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn global_priority_query(mut self, global_priority_query: bool) -> Self {
        self.inner.global_priority_query = if global_priority_query { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceGlobalPriorityQueryFeaturesBuilder {
    type Target = vk::PhysicalDeviceGlobalPriorityQueryFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceGlobalPriorityQueryFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceGlobalPriorityQueryFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceGlobalPriorityQueryFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceGlobalPriorityQueryFeaturesBuilder {}
impl QueueFamilyProperties2Next for vk::QueueFamilyGlobalPriorityProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct DebugUtilsObjectNameInfoEXTBuilder<'a> {
    inner: vk::DebugUtilsObjectNameInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DebugUtilsObjectNameInfoEXT {
    type Type = DebugUtilsObjectNameInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DebugUtilsObjectNameInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DebugUtilsObjectNameInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn object_type(mut self, object_type: vk::ObjectType) -> Self {
        self.inner.object_type = object_type;
        self
    }
    pub fn object_handle(mut self, object_handle: u64) -> Self {
        self.inner.object_handle = object_handle;
        self
    }
    pub fn p_object_name(mut self, p_object_name: Option<&'a CStr>) -> Self {
        self.inner.p_object_name = p_object_name.map_or(ptr::null(), |r| r.as_ptr());
        self
    }
}
impl<'a> Deref for DebugUtilsObjectNameInfoEXTBuilder<'a> {
    type Target = vk::DebugUtilsObjectNameInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineShaderStageCreateInfoNext for vk::DebugUtilsObjectNameInfoEXT {}
impl PipelineShaderStageCreateInfoNext for DebugUtilsObjectNameInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct DebugUtilsObjectTagInfoEXTBuilder<'a> {
    inner: vk::DebugUtilsObjectTagInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DebugUtilsObjectTagInfoEXT {
    type Type = DebugUtilsObjectTagInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DebugUtilsObjectTagInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DebugUtilsObjectTagInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn object_type(mut self, object_type: vk::ObjectType) -> Self {
        self.inner.object_type = object_type;
        self
    }
    pub fn object_handle(mut self, object_handle: u64) -> Self {
        self.inner.object_handle = object_handle;
        self
    }
    pub fn tag_name(mut self, tag_name: u64) -> Self {
        self.inner.tag_name = tag_name;
        self
    }
    pub fn p_tag(mut self, p_tag: &'a [u8]) -> Self {
        self.inner.tag_size = p_tag.len();
        self.inner.p_tag = p_tag.as_ptr() as *const _;
        self
    }
}
impl<'a> Deref for DebugUtilsObjectTagInfoEXTBuilder<'a> {
    type Target = vk::DebugUtilsObjectTagInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DebugUtilsLabelEXTBuilder<'a> {
    inner: vk::DebugUtilsLabelEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DebugUtilsLabelEXT {
    type Type = DebugUtilsLabelEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DebugUtilsLabelEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DebugUtilsLabelEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_label_name(mut self, p_label_name: &'a CStr) -> Self {
        self.inner.p_label_name = p_label_name.as_ptr();
        self
    }
    pub fn color(mut self, color: [f32; 4]) -> Self {
        self.inner.color = color;
        self
    }
}
impl<'a> Deref for DebugUtilsLabelEXTBuilder<'a> {
    type Target = vk::DebugUtilsLabelEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
    inner: vk::DebugUtilsMessengerCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DebugUtilsMessengerCreateInfoEXT {
    type Type = DebugUtilsMessengerCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DebugUtilsMessengerCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DebugUtilsMessengerCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn message_severity(mut self, message_severity: vk::DebugUtilsMessageSeverityFlagsEXT) -> Self {
        self.inner.message_severity = message_severity;
        self
    }
    pub fn message_type(mut self, message_type: vk::DebugUtilsMessageTypeFlagsEXT) -> Self {
        self.inner.message_type = message_type;
        self
    }
    pub fn pfn_user_callback(mut self, pfn_user_callback: vk::FnDebugUtilsMessengerCallbackEXT) -> Self {
        self.inner.pfn_user_callback = Some(pfn_user_callback);
        self
    }
    pub fn p_user_data(mut self, p_user_data: *mut c_void) -> Self {
        self.inner.p_user_data = p_user_data;
        self
    }
}
impl<'a> Deref for DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
    type Target = vk::DebugUtilsMessengerCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl InstanceCreateInfoNext for vk::DebugUtilsMessengerCreateInfoEXT {}
impl InstanceCreateInfoNext for DebugUtilsMessengerCreateInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
    inner: vk::DebugUtilsMessengerCallbackDataEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DebugUtilsMessengerCallbackDataEXT {
    type Type = DebugUtilsMessengerCallbackDataEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DebugUtilsMessengerCallbackDataEXTNext {}
impl<'a> DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
    pub fn insert_next<T: DebugUtilsMessengerCallbackDataEXTNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DebugUtilsMessengerCallbackDataEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DebugUtilsMessengerCallbackDataFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_message_id_name(mut self, p_message_id_name: Option<&'a CStr>) -> Self {
        self.inner.p_message_id_name = p_message_id_name.map_or(ptr::null(), |r| r.as_ptr());
        self
    }
    pub fn message_id_number(mut self, message_id_number: i32) -> Self {
        self.inner.message_id_number = message_id_number;
        self
    }
    pub fn p_message(mut self, p_message: Option<&'a CStr>) -> Self {
        self.inner.p_message = p_message.map_or(ptr::null(), |r| r.as_ptr());
        self
    }
    pub fn p_queue_labels(mut self, p_queue_labels: &'a [vk::DebugUtilsLabelEXT]) -> Self {
        self.inner.queue_label_count = p_queue_labels.len() as u32;
        self.inner.p_queue_labels = p_queue_labels.as_ptr();
        self
    }
    pub fn p_cmd_buf_labels(mut self, p_cmd_buf_labels: &'a [vk::DebugUtilsLabelEXT]) -> Self {
        self.inner.cmd_buf_label_count = p_cmd_buf_labels.len() as u32;
        self.inner.p_cmd_buf_labels = p_cmd_buf_labels.as_ptr();
        self
    }
    pub fn p_objects(mut self, p_objects: &'a [vk::DebugUtilsObjectNameInfoEXT]) -> Self {
        self.inner.object_count = p_objects.len() as u32;
        self.inner.p_objects = p_objects.as_ptr();
        self
    }
}
impl<'a> Deref for DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
    type Target = vk::DebugUtilsMessengerCallbackDataEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceDeviceMemoryReportFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceDeviceMemoryReportFeaturesEXT {
    type Type = PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDeviceMemoryReportFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn device_memory_report(mut self, device_memory_report: bool) -> Self {
        self.inner.device_memory_report = if device_memory_report { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceDeviceMemoryReportFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDeviceMemoryReportFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDeviceMemoryReportFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceDeviceMemoryReportCreateInfoEXTBuilder<'a> {
    inner: vk::DeviceDeviceMemoryReportCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DeviceDeviceMemoryReportCreateInfoEXT {
    type Type = DeviceDeviceMemoryReportCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DeviceDeviceMemoryReportCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DeviceDeviceMemoryReportCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DeviceMemoryReportFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn pfn_user_callback(mut self, pfn_user_callback: vk::FnDeviceMemoryReportCallbackEXT) -> Self {
        self.inner.pfn_user_callback = Some(pfn_user_callback);
        self
    }
    pub fn p_user_data(mut self, p_user_data: *mut c_void) -> Self {
        self.inner.p_user_data = p_user_data;
        self
    }
}
impl<'a> Deref for DeviceDeviceMemoryReportCreateInfoEXTBuilder<'a> {
    type Target = vk::DeviceDeviceMemoryReportCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DeviceCreateInfoNext for vk::DeviceDeviceMemoryReportCreateInfoEXT {}
impl DeviceCreateInfoNext for DeviceDeviceMemoryReportCreateInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportMemoryHostPointerInfoEXTBuilder<'a> {
    inner: vk::ImportMemoryHostPointerInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImportMemoryHostPointerInfoEXT {
    type Type = ImportMemoryHostPointerInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ImportMemoryHostPointerInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ImportMemoryHostPointerInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    pub fn p_host_pointer(mut self, p_host_pointer: *mut c_void) -> Self {
        self.inner.p_host_pointer = p_host_pointer;
        self
    }
}
impl<'a> Deref for ImportMemoryHostPointerInfoEXTBuilder<'a> {
    type Target = vk::ImportMemoryHostPointerInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::ImportMemoryHostPointerInfoEXT {}
impl MemoryAllocateInfoNext for ImportMemoryHostPointerInfoEXTBuilder<'_> {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceExternalMemoryHostPropertiesEXT {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceConservativeRasterizationPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct CalibratedTimestampInfoKHRBuilder {
    inner: vk::CalibratedTimestampInfoKHR,
}
impl Builder<'_> for vk::CalibratedTimestampInfoKHR {
    type Type = CalibratedTimestampInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CalibratedTimestampInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CalibratedTimestampInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn time_domain(mut self, time_domain: vk::TimeDomainKHR) -> Self {
        self.inner.time_domain = time_domain;
        self
    }
}
impl Deref for CalibratedTimestampInfoKHRBuilder {
    type Target = vk::CalibratedTimestampInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceShaderCorePropertiesAMD {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceShaderCoreProperties2AMD {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineRasterizationConservativeStateCreateInfoEXTBuilder {
    inner: vk::PipelineRasterizationConservativeStateCreateInfoEXT,
}
impl Builder<'_> for vk::PipelineRasterizationConservativeStateCreateInfoEXT {
    type Type = PipelineRasterizationConservativeStateCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineRasterizationConservativeStateCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineRasterizationConservativeStateCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineRasterizationConservativeStateCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn conservative_rasterization_mode(
        mut self,
        conservative_rasterization_mode: vk::ConservativeRasterizationModeEXT,
    ) -> Self {
        self.inner.conservative_rasterization_mode = conservative_rasterization_mode;
        self
    }
    pub fn extra_primitive_overestimation_size(mut self, extra_primitive_overestimation_size: f32) -> Self {
        self.inner.extra_primitive_overestimation_size = extra_primitive_overestimation_size;
        self
    }
}
impl Deref for PipelineRasterizationConservativeStateCreateInfoEXTBuilder {
    type Target = vk::PipelineRasterizationConservativeStateCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineRasterizationStateCreateInfoNext for vk::PipelineRasterizationConservativeStateCreateInfoEXT {}
impl PipelineRasterizationStateCreateInfoNext for PipelineRasterizationConservativeStateCreateInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDescriptorIndexingFeaturesBuilder {
    inner: vk::PhysicalDeviceDescriptorIndexingFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceDescriptorIndexingFeatures {
    type Type = PhysicalDeviceDescriptorIndexingFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDescriptorIndexingFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDescriptorIndexingFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_input_attachment_array_dynamic_indexing(
        mut self,
        shader_input_attachment_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_input_attachment_array_dynamic_indexing = if shader_input_attachment_array_dynamic_indexing {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_uniform_texel_buffer_array_dynamic_indexing(
        mut self,
        shader_uniform_texel_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_uniform_texel_buffer_array_dynamic_indexing =
            if shader_uniform_texel_buffer_array_dynamic_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn shader_storage_texel_buffer_array_dynamic_indexing(
        mut self,
        shader_storage_texel_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_texel_buffer_array_dynamic_indexing =
            if shader_storage_texel_buffer_array_dynamic_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn shader_uniform_buffer_array_non_uniform_indexing(
        mut self,
        shader_uniform_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_uniform_buffer_array_non_uniform_indexing =
            if shader_uniform_buffer_array_non_uniform_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn shader_sampled_image_array_non_uniform_indexing(
        mut self,
        shader_sampled_image_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_sampled_image_array_non_uniform_indexing = if shader_sampled_image_array_non_uniform_indexing
        {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_storage_buffer_array_non_uniform_indexing(
        mut self,
        shader_storage_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_buffer_array_non_uniform_indexing =
            if shader_storage_buffer_array_non_uniform_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn shader_storage_image_array_non_uniform_indexing(
        mut self,
        shader_storage_image_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_image_array_non_uniform_indexing = if shader_storage_image_array_non_uniform_indexing
        {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_input_attachment_array_non_uniform_indexing(
        mut self,
        shader_input_attachment_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_input_attachment_array_non_uniform_indexing =
            if shader_input_attachment_array_non_uniform_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn shader_uniform_texel_buffer_array_non_uniform_indexing(
        mut self,
        shader_uniform_texel_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_uniform_texel_buffer_array_non_uniform_indexing =
            if shader_uniform_texel_buffer_array_non_uniform_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn shader_storage_texel_buffer_array_non_uniform_indexing(
        mut self,
        shader_storage_texel_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_texel_buffer_array_non_uniform_indexing =
            if shader_storage_texel_buffer_array_non_uniform_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_uniform_buffer_update_after_bind(
        mut self,
        descriptor_binding_uniform_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_uniform_buffer_update_after_bind =
            if descriptor_binding_uniform_buffer_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_sampled_image_update_after_bind(
        mut self,
        descriptor_binding_sampled_image_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_sampled_image_update_after_bind =
            if descriptor_binding_sampled_image_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_storage_image_update_after_bind(
        mut self,
        descriptor_binding_storage_image_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_storage_image_update_after_bind =
            if descriptor_binding_storage_image_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_storage_buffer_update_after_bind(
        mut self,
        descriptor_binding_storage_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_storage_buffer_update_after_bind =
            if descriptor_binding_storage_buffer_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_uniform_texel_buffer_update_after_bind(
        mut self,
        descriptor_binding_uniform_texel_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_uniform_texel_buffer_update_after_bind =
            if descriptor_binding_uniform_texel_buffer_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_storage_texel_buffer_update_after_bind(
        mut self,
        descriptor_binding_storage_texel_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_storage_texel_buffer_update_after_bind =
            if descriptor_binding_storage_texel_buffer_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_update_unused_while_pending(
        mut self,
        descriptor_binding_update_unused_while_pending: bool,
    ) -> Self {
        self.inner.descriptor_binding_update_unused_while_pending = if descriptor_binding_update_unused_while_pending {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn descriptor_binding_partially_bound(mut self, descriptor_binding_partially_bound: bool) -> Self {
        self.inner.descriptor_binding_partially_bound = if descriptor_binding_partially_bound {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn descriptor_binding_variable_descriptor_count(
        mut self,
        descriptor_binding_variable_descriptor_count: bool,
    ) -> Self {
        self.inner.descriptor_binding_variable_descriptor_count = if descriptor_binding_variable_descriptor_count {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn runtime_descriptor_array(mut self, runtime_descriptor_array: bool) -> Self {
        self.inner.runtime_descriptor_array = if runtime_descriptor_array { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceDescriptorIndexingFeaturesBuilder {
    type Target = vk::PhysicalDeviceDescriptorIndexingFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDescriptorIndexingFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDescriptorIndexingFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDescriptorIndexingFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceDescriptorIndexingFeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceDescriptorIndexingProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorSetLayoutBindingFlagsCreateInfoBuilder<'a> {
    inner: vk::DescriptorSetLayoutBindingFlagsCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DescriptorSetLayoutBindingFlagsCreateInfo {
    type Type = DescriptorSetLayoutBindingFlagsCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DescriptorSetLayoutBindingFlagsCreateInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DescriptorSetLayoutBindingFlagsCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_binding_flags(mut self, p_binding_flags: &'a [vk::DescriptorBindingFlags]) -> Self {
        self.inner.binding_count = p_binding_flags.len() as u32;
        self.inner.p_binding_flags = p_binding_flags.as_ptr();
        self
    }
}
impl<'a> Deref for DescriptorSetLayoutBindingFlagsCreateInfoBuilder<'a> {
    type Target = vk::DescriptorSetLayoutBindingFlagsCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DescriptorSetLayoutCreateInfoNext for vk::DescriptorSetLayoutBindingFlagsCreateInfo {}
impl DescriptorSetLayoutCreateInfoNext for DescriptorSetLayoutBindingFlagsCreateInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorSetVariableDescriptorCountAllocateInfoBuilder<'a> {
    inner: vk::DescriptorSetVariableDescriptorCountAllocateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DescriptorSetVariableDescriptorCountAllocateInfo {
    type Type = DescriptorSetVariableDescriptorCountAllocateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DescriptorSetVariableDescriptorCountAllocateInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DescriptorSetVariableDescriptorCountAllocateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_descriptor_counts(mut self, p_descriptor_counts: &'a [u32]) -> Self {
        self.inner.descriptor_set_count = p_descriptor_counts.len() as u32;
        self.inner.p_descriptor_counts = p_descriptor_counts.as_ptr();
        self
    }
}
impl<'a> Deref for DescriptorSetVariableDescriptorCountAllocateInfoBuilder<'a> {
    type Target = vk::DescriptorSetVariableDescriptorCountAllocateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DescriptorSetAllocateInfoNext for vk::DescriptorSetVariableDescriptorCountAllocateInfo {}
impl DescriptorSetAllocateInfoNext for DescriptorSetVariableDescriptorCountAllocateInfoBuilder<'_> {}
impl DescriptorSetLayoutSupportNext for vk::DescriptorSetVariableDescriptorCountLayoutSupport {}

#[repr(transparent)]
#[derive(Default)]
pub struct AttachmentDescription2Builder<'a> {
    inner: vk::AttachmentDescription2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AttachmentDescription2 {
    type Type = AttachmentDescription2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait AttachmentDescription2Next {}
impl<'a> AttachmentDescription2Builder<'a> {
    pub fn insert_next<T: AttachmentDescription2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::AttachmentDescription2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::AttachmentDescriptionFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn format(mut self, format: vk::Format) -> Self {
        self.inner.format = format;
        self
    }
    pub fn samples(mut self, samples: vk::SampleCountFlags) -> Self {
        self.inner.samples = samples;
        self
    }
    pub fn load_op(mut self, load_op: vk::AttachmentLoadOp) -> Self {
        self.inner.load_op = load_op;
        self
    }
    pub fn store_op(mut self, store_op: vk::AttachmentStoreOp) -> Self {
        self.inner.store_op = store_op;
        self
    }
    pub fn stencil_load_op(mut self, stencil_load_op: vk::AttachmentLoadOp) -> Self {
        self.inner.stencil_load_op = stencil_load_op;
        self
    }
    pub fn stencil_store_op(mut self, stencil_store_op: vk::AttachmentStoreOp) -> Self {
        self.inner.stencil_store_op = stencil_store_op;
        self
    }
    pub fn initial_layout(mut self, initial_layout: vk::ImageLayout) -> Self {
        self.inner.initial_layout = initial_layout;
        self
    }
    pub fn final_layout(mut self, final_layout: vk::ImageLayout) -> Self {
        self.inner.final_layout = final_layout;
        self
    }
}
impl<'a> Deref for AttachmentDescription2Builder<'a> {
    type Target = vk::AttachmentDescription2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AttachmentReference2Builder<'a> {
    inner: vk::AttachmentReference2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AttachmentReference2 {
    type Type = AttachmentReference2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait AttachmentReference2Next {}
impl<'a> AttachmentReference2Builder<'a> {
    pub fn insert_next<T: AttachmentReference2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::AttachmentReference2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn attachment(mut self, attachment: u32) -> Self {
        self.inner.attachment = attachment;
        self
    }
    pub fn layout(mut self, layout: vk::ImageLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    pub fn aspect_mask(mut self, aspect_mask: vk::ImageAspectFlags) -> Self {
        self.inner.aspect_mask = aspect_mask;
        self
    }
}
impl<'a> Deref for AttachmentReference2Builder<'a> {
    type Target = vk::AttachmentReference2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SubpassDescription2Builder<'a> {
    inner: vk::SubpassDescription2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SubpassDescription2 {
    type Type = SubpassDescription2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait SubpassDescription2Next {}
impl<'a> SubpassDescription2Builder<'a> {
    pub fn insert_next<T: SubpassDescription2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::SubpassDescription2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::SubpassDescriptionFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: vk::PipelineBindPoint) -> Self {
        self.inner.pipeline_bind_point = pipeline_bind_point;
        self
    }
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.inner.view_mask = view_mask;
        self
    }
    pub fn p_input_attachments(mut self, p_input_attachments: &'a [vk::AttachmentReference2]) -> Self {
        self.inner.input_attachment_count = p_input_attachments.len() as u32;
        self.inner.p_input_attachments = p_input_attachments.as_ptr();
        self
    }
    pub fn p_color_attachments(
        mut self,
        p_color_attachments: &'a [vk::AttachmentReference2],
        p_resolve_attachments: Option<&'a [vk::AttachmentReference2]>,
    ) -> Self {
        self.inner.color_attachment_count = p_color_attachments.len() as u32;
        self.inner.p_color_attachments = p_color_attachments.as_ptr();
        self.inner.p_resolve_attachments = p_resolve_attachments.map_or(ptr::null(), |s| s.as_ptr());
        self
    }
    pub fn p_depth_stencil_attachment(
        mut self,
        p_depth_stencil_attachment: Option<&'a vk::AttachmentReference2>,
    ) -> Self {
        self.inner.p_depth_stencil_attachment = p_depth_stencil_attachment.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_preserve_attachments(mut self, p_preserve_attachments: &'a [u32]) -> Self {
        self.inner.preserve_attachment_count = p_preserve_attachments.len() as u32;
        self.inner.p_preserve_attachments = p_preserve_attachments.as_ptr();
        self
    }
}
impl<'a> Deref for SubpassDescription2Builder<'a> {
    type Target = vk::SubpassDescription2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SubpassDependency2Builder<'a> {
    inner: vk::SubpassDependency2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SubpassDependency2 {
    type Type = SubpassDependency2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait SubpassDependency2Next {}
impl<'a> SubpassDependency2Builder<'a> {
    pub fn insert_next<T: SubpassDependency2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::SubpassDependency2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_subpass(mut self, src_subpass: u32) -> Self {
        self.inner.src_subpass = src_subpass;
        self
    }
    pub fn dst_subpass(mut self, dst_subpass: u32) -> Self {
        self.inner.dst_subpass = dst_subpass;
        self
    }
    pub fn src_stage_mask(mut self, src_stage_mask: vk::PipelineStageFlags) -> Self {
        self.inner.src_stage_mask = src_stage_mask;
        self
    }
    pub fn dst_stage_mask(mut self, dst_stage_mask: vk::PipelineStageFlags) -> Self {
        self.inner.dst_stage_mask = dst_stage_mask;
        self
    }
    pub fn src_access_mask(mut self, src_access_mask: vk::AccessFlags) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    pub fn dst_access_mask(mut self, dst_access_mask: vk::AccessFlags) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    pub fn dependency_flags(mut self, dependency_flags: vk::DependencyFlags) -> Self {
        self.inner.dependency_flags = dependency_flags;
        self
    }
    pub fn view_offset(mut self, view_offset: i32) -> Self {
        self.inner.view_offset = view_offset;
        self
    }
}
impl<'a> Deref for SubpassDependency2Builder<'a> {
    type Target = vk::SubpassDependency2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassCreateInfo2Builder<'a> {
    inner: vk::RenderPassCreateInfo2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderPassCreateInfo2 {
    type Type = RenderPassCreateInfo2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait RenderPassCreateInfo2Next {}
impl<'a> RenderPassCreateInfo2Builder<'a> {
    pub fn insert_next<T: RenderPassCreateInfo2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::RenderPassCreateInfo2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::RenderPassCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_attachments(mut self, p_attachments: &'a [vk::AttachmentDescription2]) -> Self {
        self.inner.attachment_count = p_attachments.len() as u32;
        self.inner.p_attachments = p_attachments.as_ptr();
        self
    }
    pub fn p_subpasses(mut self, p_subpasses: &'a [vk::SubpassDescription2]) -> Self {
        self.inner.subpass_count = p_subpasses.len() as u32;
        self.inner.p_subpasses = p_subpasses.as_ptr();
        self
    }
    pub fn p_dependencies(mut self, p_dependencies: &'a [vk::SubpassDependency2]) -> Self {
        self.inner.dependency_count = p_dependencies.len() as u32;
        self.inner.p_dependencies = p_dependencies.as_ptr();
        self
    }
    pub fn p_correlated_view_masks(mut self, p_correlated_view_masks: &'a [u32]) -> Self {
        self.inner.correlated_view_mask_count = p_correlated_view_masks.len() as u32;
        self.inner.p_correlated_view_masks = p_correlated_view_masks.as_ptr();
        self
    }
}
impl<'a> Deref for RenderPassCreateInfo2Builder<'a> {
    type Target = vk::RenderPassCreateInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SubpassBeginInfoBuilder {
    inner: vk::SubpassBeginInfo,
}
impl Builder<'_> for vk::SubpassBeginInfo {
    type Type = SubpassBeginInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SubpassBeginInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SubpassBeginInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn contents(mut self, contents: vk::SubpassContents) -> Self {
        self.inner.contents = contents;
        self
    }
}
impl Deref for SubpassBeginInfoBuilder {
    type Target = vk::SubpassBeginInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SubpassEndInfoBuilder<'a> {
    inner: vk::SubpassEndInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SubpassEndInfo {
    type Type = SubpassEndInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait SubpassEndInfoNext {}
impl<'a> SubpassEndInfoBuilder<'a> {
    pub fn insert_next<T: SubpassEndInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::SubpassEndInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
}
impl<'a> Deref for SubpassEndInfoBuilder<'a> {
    type Target = vk::SubpassEndInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceTimelineSemaphoreFeaturesBuilder {
    inner: vk::PhysicalDeviceTimelineSemaphoreFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceTimelineSemaphoreFeatures {
    type Type = PhysicalDeviceTimelineSemaphoreFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceTimelineSemaphoreFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceTimelineSemaphoreFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn timeline_semaphore(mut self, timeline_semaphore: bool) -> Self {
        self.inner.timeline_semaphore = if timeline_semaphore { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceTimelineSemaphoreFeaturesBuilder {
    type Target = vk::PhysicalDeviceTimelineSemaphoreFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceTimelineSemaphoreFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceTimelineSemaphoreFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceTimelineSemaphoreFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceTimelineSemaphoreFeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceTimelineSemaphoreProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct SemaphoreTypeCreateInfoBuilder {
    inner: vk::SemaphoreTypeCreateInfo,
}
impl Builder<'_> for vk::SemaphoreTypeCreateInfo {
    type Type = SemaphoreTypeCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SemaphoreTypeCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SemaphoreTypeCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn semaphore_type(mut self, semaphore_type: vk::SemaphoreType) -> Self {
        self.inner.semaphore_type = semaphore_type;
        self
    }
    pub fn initial_value(mut self, initial_value: u64) -> Self {
        self.inner.initial_value = initial_value;
        self
    }
}
impl Deref for SemaphoreTypeCreateInfoBuilder {
    type Target = vk::SemaphoreTypeCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SemaphoreCreateInfoNext for vk::SemaphoreTypeCreateInfo {}
impl SemaphoreCreateInfoNext for SemaphoreTypeCreateInfoBuilder {}
impl PhysicalDeviceExternalSemaphoreInfoNext for vk::SemaphoreTypeCreateInfo {}
impl PhysicalDeviceExternalSemaphoreInfoNext for SemaphoreTypeCreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct TimelineSemaphoreSubmitInfoBuilder<'a> {
    inner: vk::TimelineSemaphoreSubmitInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::TimelineSemaphoreSubmitInfo {
    type Type = TimelineSemaphoreSubmitInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> TimelineSemaphoreSubmitInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::TimelineSemaphoreSubmitInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_wait_semaphore_values(mut self, p_wait_semaphore_values: &'a [u64]) -> Self {
        self.inner.wait_semaphore_value_count = p_wait_semaphore_values.len() as u32;
        self.inner.p_wait_semaphore_values = p_wait_semaphore_values.as_ptr();
        self
    }
    pub fn p_signal_semaphore_values(mut self, p_signal_semaphore_values: &'a [u64]) -> Self {
        self.inner.signal_semaphore_value_count = p_signal_semaphore_values.len() as u32;
        self.inner.p_signal_semaphore_values = p_signal_semaphore_values.as_ptr();
        self
    }
}
impl<'a> Deref for TimelineSemaphoreSubmitInfoBuilder<'a> {
    type Target = vk::TimelineSemaphoreSubmitInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubmitInfoNext for vk::TimelineSemaphoreSubmitInfo {}
impl SubmitInfoNext for TimelineSemaphoreSubmitInfoBuilder<'_> {}
impl BindSparseInfoNext for vk::TimelineSemaphoreSubmitInfo {}
impl BindSparseInfoNext for TimelineSemaphoreSubmitInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct SemaphoreWaitInfoBuilder<'a> {
    inner: vk::SemaphoreWaitInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SemaphoreWaitInfo {
    type Type = SemaphoreWaitInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> SemaphoreWaitInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::SemaphoreWaitInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::SemaphoreWaitFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_semaphores(mut self, p_semaphores: &'a [vk::Semaphore], p_values: &'a [u64]) -> Self {
        self.inner.semaphore_count = p_semaphores.len() as u32;
        assert_eq!(self.inner.semaphore_count, p_values.len() as u32);
        self.inner.p_semaphores = p_semaphores.as_ptr();
        self.inner.p_values = p_values.as_ptr();
        self
    }
}
impl<'a> Deref for SemaphoreWaitInfoBuilder<'a> {
    type Target = vk::SemaphoreWaitInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SemaphoreSignalInfoBuilder {
    inner: vk::SemaphoreSignalInfo,
}
impl Builder<'_> for vk::SemaphoreSignalInfo {
    type Type = SemaphoreSignalInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SemaphoreSignalInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SemaphoreSignalInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn semaphore(mut self, semaphore: vk::Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    pub fn value(mut self, value: u64) -> Self {
        self.inner.value = value;
        self
    }
}
impl Deref for SemaphoreSignalInfoBuilder {
    type Target = vk::SemaphoreSignalInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct VertexInputBindingDivisorDescriptionBuilder {
    inner: vk::VertexInputBindingDivisorDescription,
}
impl Builder<'_> for vk::VertexInputBindingDivisorDescription {
    type Type = VertexInputBindingDivisorDescriptionBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl VertexInputBindingDivisorDescriptionBuilder {
    pub fn get_mut(&mut self) -> &mut vk::VertexInputBindingDivisorDescription {
        &mut self.inner
    }
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
    pub fn divisor(mut self, divisor: u32) -> Self {
        self.inner.divisor = divisor;
        self
    }
}
impl Deref for VertexInputBindingDivisorDescriptionBuilder {
    type Target = vk::VertexInputBindingDivisorDescription;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineVertexInputDivisorStateCreateInfoBuilder<'a> {
    inner: vk::PipelineVertexInputDivisorStateCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineVertexInputDivisorStateCreateInfo {
    type Type = PipelineVertexInputDivisorStateCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineVertexInputDivisorStateCreateInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineVertexInputDivisorStateCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_vertex_binding_divisors(
        mut self,
        p_vertex_binding_divisors: &'a [vk::VertexInputBindingDivisorDescription],
    ) -> Self {
        self.inner.vertex_binding_divisor_count = p_vertex_binding_divisors.len() as u32;
        self.inner.p_vertex_binding_divisors = p_vertex_binding_divisors.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineVertexInputDivisorStateCreateInfoBuilder<'a> {
    type Target = vk::PipelineVertexInputDivisorStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineVertexInputStateCreateInfoNext for vk::PipelineVertexInputDivisorStateCreateInfo {}
impl PipelineVertexInputStateCreateInfoNext for PipelineVertexInputDivisorStateCreateInfoBuilder<'_> {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceVertexAttributeDivisorPropertiesEXT {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceVertexAttributeDivisorProperties {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDevicePCIBusInfoPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportAndroidHardwareBufferInfoANDROIDBuilder<'a> {
    inner: vk::ImportAndroidHardwareBufferInfoANDROID,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImportAndroidHardwareBufferInfoANDROID {
    type Type = ImportAndroidHardwareBufferInfoANDROIDBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ImportAndroidHardwareBufferInfoANDROIDBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ImportAndroidHardwareBufferInfoANDROID {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn buffer(mut self, buffer: *mut vk::AHardwareBuffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
}
impl<'a> Deref for ImportAndroidHardwareBufferInfoANDROIDBuilder<'a> {
    type Target = vk::ImportAndroidHardwareBufferInfoANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::ImportAndroidHardwareBufferInfoANDROID {}
impl MemoryAllocateInfoNext for ImportAndroidHardwareBufferInfoANDROIDBuilder<'_> {}
impl ImageFormatProperties2Next for vk::AndroidHardwareBufferUsageANDROID {}

#[repr(transparent)]
#[derive(Default)]
pub struct AndroidHardwareBufferPropertiesANDROIDBuilder<'a> {
    inner: vk::AndroidHardwareBufferPropertiesANDROID,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AndroidHardwareBufferPropertiesANDROID {
    type Type = AndroidHardwareBufferPropertiesANDROIDBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait AndroidHardwareBufferPropertiesANDROIDNext {}
impl<'a> AndroidHardwareBufferPropertiesANDROIDBuilder<'a> {
    pub fn insert_next<T: AndroidHardwareBufferPropertiesANDROIDNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::AndroidHardwareBufferPropertiesANDROID {
        &mut self.inner
    }
}
impl<'a> Deref for AndroidHardwareBufferPropertiesANDROIDBuilder<'a> {
    type Target = vk::AndroidHardwareBufferPropertiesANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryGetAndroidHardwareBufferInfoANDROIDBuilder {
    inner: vk::MemoryGetAndroidHardwareBufferInfoANDROID,
}
impl Builder<'_> for vk::MemoryGetAndroidHardwareBufferInfoANDROID {
    type Type = MemoryGetAndroidHardwareBufferInfoANDROIDBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryGetAndroidHardwareBufferInfoANDROIDBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryGetAndroidHardwareBufferInfoANDROID {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
}
impl Deref for MemoryGetAndroidHardwareBufferInfoANDROIDBuilder {
    type Target = vk::MemoryGetAndroidHardwareBufferInfoANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl AndroidHardwareBufferPropertiesANDROIDNext for vk::AndroidHardwareBufferFormatPropertiesANDROID {}

#[repr(transparent)]
#[derive(Default)]
pub struct CommandBufferInheritanceConditionalRenderingInfoEXTBuilder {
    inner: vk::CommandBufferInheritanceConditionalRenderingInfoEXT,
}
impl Builder<'_> for vk::CommandBufferInheritanceConditionalRenderingInfoEXT {
    type Type = CommandBufferInheritanceConditionalRenderingInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CommandBufferInheritanceConditionalRenderingInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CommandBufferInheritanceConditionalRenderingInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn conditional_rendering_enable(mut self, conditional_rendering_enable: bool) -> Self {
        self.inner.conditional_rendering_enable = if conditional_rendering_enable {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for CommandBufferInheritanceConditionalRenderingInfoEXTBuilder {
    type Target = vk::CommandBufferInheritanceConditionalRenderingInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl CommandBufferInheritanceInfoNext for vk::CommandBufferInheritanceConditionalRenderingInfoEXT {}
impl CommandBufferInheritanceInfoNext for CommandBufferInheritanceConditionalRenderingInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExternalFormatANDROIDBuilder {
    inner: vk::ExternalFormatANDROID,
}
impl Builder<'_> for vk::ExternalFormatANDROID {
    type Type = ExternalFormatANDROIDBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExternalFormatANDROIDBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExternalFormatANDROID {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn external_format(mut self, external_format: u64) -> Self {
        self.inner.external_format = external_format;
        self
    }
}
impl Deref for ExternalFormatANDROIDBuilder {
    type Target = vk::ExternalFormatANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageCreateInfoNext for vk::ExternalFormatANDROID {}
impl ImageCreateInfoNext for ExternalFormatANDROIDBuilder {}
impl SamplerYcbcrConversionCreateInfoNext for vk::ExternalFormatANDROID {}
impl SamplerYcbcrConversionCreateInfoNext for ExternalFormatANDROIDBuilder {}
impl AttachmentDescription2Next for vk::ExternalFormatANDROID {}
impl AttachmentDescription2Next for ExternalFormatANDROIDBuilder {}
impl GraphicsPipelineCreateInfoNext for vk::ExternalFormatANDROID {}
impl GraphicsPipelineCreateInfoNext for ExternalFormatANDROIDBuilder {}
impl CommandBufferInheritanceInfoNext for vk::ExternalFormatANDROID {}
impl CommandBufferInheritanceInfoNext for ExternalFormatANDROIDBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevice8BitStorageFeaturesBuilder {
    inner: vk::PhysicalDevice8BitStorageFeatures,
}
impl Builder<'_> for vk::PhysicalDevice8BitStorageFeatures {
    type Type = PhysicalDevice8BitStorageFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevice8BitStorageFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevice8BitStorageFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn storage_buffer8_bit_access(mut self, storage_buffer8_bit_access: bool) -> Self {
        self.inner.storage_buffer8_bit_access = if storage_buffer8_bit_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn uniform_and_storage_buffer8_bit_access(mut self, uniform_and_storage_buffer8_bit_access: bool) -> Self {
        self.inner.uniform_and_storage_buffer8_bit_access = if uniform_and_storage_buffer8_bit_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn storage_push_constant8(mut self, storage_push_constant8: bool) -> Self {
        self.inner.storage_push_constant8 = if storage_push_constant8 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevice8BitStorageFeaturesBuilder {
    type Target = vk::PhysicalDevice8BitStorageFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevice8BitStorageFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDevice8BitStorageFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevice8BitStorageFeatures {}
impl DeviceCreateInfoNext for PhysicalDevice8BitStorageFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceConditionalRenderingFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceConditionalRenderingFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceConditionalRenderingFeaturesEXT {
    type Type = PhysicalDeviceConditionalRenderingFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceConditionalRenderingFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceConditionalRenderingFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn conditional_rendering(mut self, conditional_rendering: bool) -> Self {
        self.inner.conditional_rendering = if conditional_rendering { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn inherited_conditional_rendering(mut self, inherited_conditional_rendering: bool) -> Self {
        self.inner.inherited_conditional_rendering = if inherited_conditional_rendering {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceConditionalRenderingFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceConditionalRenderingFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceConditionalRenderingFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceConditionalRenderingFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceConditionalRenderingFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceConditionalRenderingFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceVulkanMemoryModelFeaturesBuilder {
    inner: vk::PhysicalDeviceVulkanMemoryModelFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceVulkanMemoryModelFeatures {
    type Type = PhysicalDeviceVulkanMemoryModelFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceVulkanMemoryModelFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceVulkanMemoryModelFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn vulkan_memory_model(mut self, vulkan_memory_model: bool) -> Self {
        self.inner.vulkan_memory_model = if vulkan_memory_model { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn vulkan_memory_model_device_scope(mut self, vulkan_memory_model_device_scope: bool) -> Self {
        self.inner.vulkan_memory_model_device_scope = if vulkan_memory_model_device_scope {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn vulkan_memory_model_availability_visibility_chains(
        mut self,
        vulkan_memory_model_availability_visibility_chains: bool,
    ) -> Self {
        self.inner.vulkan_memory_model_availability_visibility_chains =
            if vulkan_memory_model_availability_visibility_chains {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
}
impl Deref for PhysicalDeviceVulkanMemoryModelFeaturesBuilder {
    type Target = vk::PhysicalDeviceVulkanMemoryModelFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceVulkanMemoryModelFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceVulkanMemoryModelFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceVulkanMemoryModelFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceVulkanMemoryModelFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderAtomicInt64FeaturesBuilder {
    inner: vk::PhysicalDeviceShaderAtomicInt64Features,
}
impl Builder<'_> for vk::PhysicalDeviceShaderAtomicInt64Features {
    type Type = PhysicalDeviceShaderAtomicInt64FeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderAtomicInt64FeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderAtomicInt64Features {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_buffer_int64_atomics(mut self, shader_buffer_int64_atomics: bool) -> Self {
        self.inner.shader_buffer_int64_atomics = if shader_buffer_int64_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_shared_int64_atomics(mut self, shader_shared_int64_atomics: bool) -> Self {
        self.inner.shader_shared_int64_atomics = if shader_shared_int64_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderAtomicInt64FeaturesBuilder {
    type Target = vk::PhysicalDeviceShaderAtomicInt64Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderAtomicInt64Features {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderAtomicInt64FeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderAtomicInt64Features {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderAtomicInt64FeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceShaderAtomicFloatFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    type Type = PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderAtomicFloatFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_buffer_float32_atomics(mut self, shader_buffer_float32_atomics: bool) -> Self {
        self.inner.shader_buffer_float32_atomics = if shader_buffer_float32_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_buffer_float32_atomic_add(mut self, shader_buffer_float32_atomic_add: bool) -> Self {
        self.inner.shader_buffer_float32_atomic_add = if shader_buffer_float32_atomic_add {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_buffer_float64_atomics(mut self, shader_buffer_float64_atomics: bool) -> Self {
        self.inner.shader_buffer_float64_atomics = if shader_buffer_float64_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_buffer_float64_atomic_add(mut self, shader_buffer_float64_atomic_add: bool) -> Self {
        self.inner.shader_buffer_float64_atomic_add = if shader_buffer_float64_atomic_add {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_shared_float32_atomics(mut self, shader_shared_float32_atomics: bool) -> Self {
        self.inner.shader_shared_float32_atomics = if shader_shared_float32_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_shared_float32_atomic_add(mut self, shader_shared_float32_atomic_add: bool) -> Self {
        self.inner.shader_shared_float32_atomic_add = if shader_shared_float32_atomic_add {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_shared_float64_atomics(mut self, shader_shared_float64_atomics: bool) -> Self {
        self.inner.shader_shared_float64_atomics = if shader_shared_float64_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_shared_float64_atomic_add(mut self, shader_shared_float64_atomic_add: bool) -> Self {
        self.inner.shader_shared_float64_atomic_add = if shader_shared_float64_atomic_add {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_image_float32_atomics(mut self, shader_image_float32_atomics: bool) -> Self {
        self.inner.shader_image_float32_atomics = if shader_image_float32_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_image_float32_atomic_add(mut self, shader_image_float32_atomic_add: bool) -> Self {
        self.inner.shader_image_float32_atomic_add = if shader_image_float32_atomic_add {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn sparse_image_float32_atomics(mut self, sparse_image_float32_atomics: bool) -> Self {
        self.inner.sparse_image_float32_atomics = if sparse_image_float32_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn sparse_image_float32_atomic_add(mut self, sparse_image_float32_atomic_add: bool) -> Self {
        self.inner.sparse_image_float32_atomic_add = if sparse_image_float32_atomic_add {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceShaderAtomicFloatFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderAtomicFloatFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderAtomicFloatFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder {
    inner: vk::PhysicalDeviceShaderAtomicFloat2FeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    type Type = PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_buffer_float16_atomics(mut self, shader_buffer_float16_atomics: bool) -> Self {
        self.inner.shader_buffer_float16_atomics = if shader_buffer_float16_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_buffer_float16_atomic_add(mut self, shader_buffer_float16_atomic_add: bool) -> Self {
        self.inner.shader_buffer_float16_atomic_add = if shader_buffer_float16_atomic_add {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_buffer_float16_atomic_min_max(mut self, shader_buffer_float16_atomic_min_max: bool) -> Self {
        self.inner.shader_buffer_float16_atomic_min_max = if shader_buffer_float16_atomic_min_max {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_buffer_float32_atomic_min_max(mut self, shader_buffer_float32_atomic_min_max: bool) -> Self {
        self.inner.shader_buffer_float32_atomic_min_max = if shader_buffer_float32_atomic_min_max {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_buffer_float64_atomic_min_max(mut self, shader_buffer_float64_atomic_min_max: bool) -> Self {
        self.inner.shader_buffer_float64_atomic_min_max = if shader_buffer_float64_atomic_min_max {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_shared_float16_atomics(mut self, shader_shared_float16_atomics: bool) -> Self {
        self.inner.shader_shared_float16_atomics = if shader_shared_float16_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_shared_float16_atomic_add(mut self, shader_shared_float16_atomic_add: bool) -> Self {
        self.inner.shader_shared_float16_atomic_add = if shader_shared_float16_atomic_add {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_shared_float16_atomic_min_max(mut self, shader_shared_float16_atomic_min_max: bool) -> Self {
        self.inner.shader_shared_float16_atomic_min_max = if shader_shared_float16_atomic_min_max {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_shared_float32_atomic_min_max(mut self, shader_shared_float32_atomic_min_max: bool) -> Self {
        self.inner.shader_shared_float32_atomic_min_max = if shader_shared_float32_atomic_min_max {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_shared_float64_atomic_min_max(mut self, shader_shared_float64_atomic_min_max: bool) -> Self {
        self.inner.shader_shared_float64_atomic_min_max = if shader_shared_float64_atomic_min_max {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_image_float32_atomic_min_max(mut self, shader_image_float32_atomic_min_max: bool) -> Self {
        self.inner.shader_image_float32_atomic_min_max = if shader_image_float32_atomic_min_max {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn sparse_image_float32_atomic_min_max(mut self, sparse_image_float32_atomic_min_max: bool) -> Self {
        self.inner.sparse_image_float32_atomic_min_max = if sparse_image_float32_atomic_min_max {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceShaderAtomicFloat2FeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderAtomicFloat2FeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderAtomicFloat2FeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceVertexAttributeDivisorFeaturesBuilder {
    inner: vk::PhysicalDeviceVertexAttributeDivisorFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceVertexAttributeDivisorFeatures {
    type Type = PhysicalDeviceVertexAttributeDivisorFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceVertexAttributeDivisorFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceVertexAttributeDivisorFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn vertex_attribute_instance_rate_divisor(mut self, vertex_attribute_instance_rate_divisor: bool) -> Self {
        self.inner.vertex_attribute_instance_rate_divisor = if vertex_attribute_instance_rate_divisor {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn vertex_attribute_instance_rate_zero_divisor(
        mut self,
        vertex_attribute_instance_rate_zero_divisor: bool,
    ) -> Self {
        self.inner.vertex_attribute_instance_rate_zero_divisor = if vertex_attribute_instance_rate_zero_divisor {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceVertexAttributeDivisorFeaturesBuilder {
    type Target = vk::PhysicalDeviceVertexAttributeDivisorFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceVertexAttributeDivisorFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceVertexAttributeDivisorFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceVertexAttributeDivisorFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceVertexAttributeDivisorFeaturesBuilder {}
impl QueueFamilyProperties2Next for vk::QueueFamilyCheckpointPropertiesNV {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceDepthStencilResolveProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct SubpassDescriptionDepthStencilResolveBuilder<'a> {
    inner: vk::SubpassDescriptionDepthStencilResolve,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SubpassDescriptionDepthStencilResolve {
    type Type = SubpassDescriptionDepthStencilResolveBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> SubpassDescriptionDepthStencilResolveBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::SubpassDescriptionDepthStencilResolve {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn depth_resolve_mode(mut self, depth_resolve_mode: vk::ResolveModeFlags) -> Self {
        self.inner.depth_resolve_mode = depth_resolve_mode;
        self
    }
    pub fn stencil_resolve_mode(mut self, stencil_resolve_mode: vk::ResolveModeFlags) -> Self {
        self.inner.stencil_resolve_mode = stencil_resolve_mode;
        self
    }
    pub fn p_depth_stencil_resolve_attachment(
        mut self,
        p_depth_stencil_resolve_attachment: Option<&'a vk::AttachmentReference2>,
    ) -> Self {
        self.inner.p_depth_stencil_resolve_attachment = p_depth_stencil_resolve_attachment.map_or(ptr::null(), |r| r);
        self
    }
}
impl<'a> Deref for SubpassDescriptionDepthStencilResolveBuilder<'a> {
    type Target = vk::SubpassDescriptionDepthStencilResolve;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubpassDescription2Next for vk::SubpassDescriptionDepthStencilResolve {}
impl SubpassDescription2Next for SubpassDescriptionDepthStencilResolveBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageViewASTCDecodeModeEXTBuilder {
    inner: vk::ImageViewASTCDecodeModeEXT,
}
impl Builder<'_> for vk::ImageViewASTCDecodeModeEXT {
    type Type = ImageViewASTCDecodeModeEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageViewASTCDecodeModeEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageViewASTCDecodeModeEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn decode_mode(mut self, decode_mode: vk::Format) -> Self {
        self.inner.decode_mode = decode_mode;
        self
    }
}
impl Deref for ImageViewASTCDecodeModeEXTBuilder {
    type Target = vk::ImageViewASTCDecodeModeEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageViewCreateInfoNext for vk::ImageViewASTCDecodeModeEXT {}
impl ImageViewCreateInfoNext for ImageViewASTCDecodeModeEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceASTCDecodeFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceASTCDecodeFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceASTCDecodeFeaturesEXT {
    type Type = PhysicalDeviceASTCDecodeFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceASTCDecodeFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceASTCDecodeFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn decode_mode_shared_exponent(mut self, decode_mode_shared_exponent: bool) -> Self {
        self.inner.decode_mode_shared_exponent = if decode_mode_shared_exponent {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceASTCDecodeFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceASTCDecodeFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceASTCDecodeFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceASTCDecodeFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceASTCDecodeFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceASTCDecodeFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceTransformFeedbackFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceTransformFeedbackFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceTransformFeedbackFeaturesEXT {
    type Type = PhysicalDeviceTransformFeedbackFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceTransformFeedbackFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceTransformFeedbackFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn transform_feedback(mut self, transform_feedback: bool) -> Self {
        self.inner.transform_feedback = if transform_feedback { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn geometry_streams(mut self, geometry_streams: bool) -> Self {
        self.inner.geometry_streams = if geometry_streams { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceTransformFeedbackFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceTransformFeedbackFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceTransformFeedbackFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceTransformFeedbackFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceTransformFeedbackFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceTransformFeedbackFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceTransformFeedbackPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineRasterizationStateStreamCreateInfoEXTBuilder {
    inner: vk::PipelineRasterizationStateStreamCreateInfoEXT,
}
impl Builder<'_> for vk::PipelineRasterizationStateStreamCreateInfoEXT {
    type Type = PipelineRasterizationStateStreamCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineRasterizationStateStreamCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineRasterizationStateStreamCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineRasterizationStateStreamCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn rasterization_stream(mut self, rasterization_stream: u32) -> Self {
        self.inner.rasterization_stream = rasterization_stream;
        self
    }
}
impl Deref for PipelineRasterizationStateStreamCreateInfoEXTBuilder {
    type Target = vk::PipelineRasterizationStateStreamCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineRasterizationStateCreateInfoNext for vk::PipelineRasterizationStateStreamCreateInfoEXT {}
impl PipelineRasterizationStateCreateInfoNext for PipelineRasterizationStateStreamCreateInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder {
    inner: vk::PhysicalDeviceRepresentativeFragmentTestFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    type Type = PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn representative_fragment_test(mut self, representative_fragment_test: bool) -> Self {
        self.inner.representative_fragment_test = if representative_fragment_test {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceRepresentativeFragmentTestFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRepresentativeFragmentTestFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRepresentativeFragmentTestFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineRepresentativeFragmentTestStateCreateInfoNVBuilder {
    inner: vk::PipelineRepresentativeFragmentTestStateCreateInfoNV,
}
impl Builder<'_> for vk::PipelineRepresentativeFragmentTestStateCreateInfoNV {
    type Type = PipelineRepresentativeFragmentTestStateCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineRepresentativeFragmentTestStateCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineRepresentativeFragmentTestStateCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn representative_fragment_test_enable(mut self, representative_fragment_test_enable: bool) -> Self {
        self.inner.representative_fragment_test_enable = if representative_fragment_test_enable {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PipelineRepresentativeFragmentTestStateCreateInfoNVBuilder {
    type Target = vk::PipelineRepresentativeFragmentTestStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::PipelineRepresentativeFragmentTestStateCreateInfoNV {}
impl GraphicsPipelineCreateInfoNext for PipelineRepresentativeFragmentTestStateCreateInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceExclusiveScissorFeaturesNVBuilder {
    inner: vk::PhysicalDeviceExclusiveScissorFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceExclusiveScissorFeaturesNV {
    type Type = PhysicalDeviceExclusiveScissorFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceExclusiveScissorFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceExclusiveScissorFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn exclusive_scissor(mut self, exclusive_scissor: bool) -> Self {
        self.inner.exclusive_scissor = if exclusive_scissor { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceExclusiveScissorFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceExclusiveScissorFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceExclusiveScissorFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceExclusiveScissorFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceExclusiveScissorFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceExclusiveScissorFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineViewportExclusiveScissorStateCreateInfoNVBuilder<'a> {
    inner: vk::PipelineViewportExclusiveScissorStateCreateInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineViewportExclusiveScissorStateCreateInfoNV {
    type Type = PipelineViewportExclusiveScissorStateCreateInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineViewportExclusiveScissorStateCreateInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineViewportExclusiveScissorStateCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn exclusive_scissor_count(mut self, exclusive_scissor_count: u32) -> Self {
        self.inner.exclusive_scissor_count = exclusive_scissor_count;
        self
    }
    pub fn p_exclusive_scissors(mut self, p_exclusive_scissors: &'a [vk::Rect2D]) -> Self {
        self.inner.exclusive_scissor_count = p_exclusive_scissors.len() as u32;
        self.inner.p_exclusive_scissors = p_exclusive_scissors.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineViewportExclusiveScissorStateCreateInfoNVBuilder<'a> {
    type Target = vk::PipelineViewportExclusiveScissorStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineViewportStateCreateInfoNext for vk::PipelineViewportExclusiveScissorStateCreateInfoNV {}
impl PipelineViewportStateCreateInfoNext for PipelineViewportExclusiveScissorStateCreateInfoNVBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceCornerSampledImageFeaturesNVBuilder {
    inner: vk::PhysicalDeviceCornerSampledImageFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceCornerSampledImageFeaturesNV {
    type Type = PhysicalDeviceCornerSampledImageFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceCornerSampledImageFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceCornerSampledImageFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn corner_sampled_image(mut self, corner_sampled_image: bool) -> Self {
        self.inner.corner_sampled_image = if corner_sampled_image { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceCornerSampledImageFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceCornerSampledImageFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceCornerSampledImageFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceCornerSampledImageFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceCornerSampledImageFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceCornerSampledImageFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceComputeShaderDerivativesFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceComputeShaderDerivativesFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceComputeShaderDerivativesFeaturesKHR {
    type Type = PhysicalDeviceComputeShaderDerivativesFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceComputeShaderDerivativesFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceComputeShaderDerivativesFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn compute_derivative_group_quads(mut self, compute_derivative_group_quads: bool) -> Self {
        self.inner.compute_derivative_group_quads = if compute_derivative_group_quads {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn compute_derivative_group_linear(mut self, compute_derivative_group_linear: bool) -> Self {
        self.inner.compute_derivative_group_linear = if compute_derivative_group_linear {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceComputeShaderDerivativesFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceComputeShaderDerivativesFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceComputeShaderDerivativesFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceComputeShaderDerivativesFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceComputeShaderDerivativesFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceComputeShaderDerivativesFeaturesKHRBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceComputeShaderDerivativesPropertiesKHR {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderImageFootprintFeaturesNVBuilder {
    inner: vk::PhysicalDeviceShaderImageFootprintFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceShaderImageFootprintFeaturesNV {
    type Type = PhysicalDeviceShaderImageFootprintFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderImageFootprintFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderImageFootprintFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image_footprint(mut self, image_footprint: bool) -> Self {
        self.inner.image_footprint = if image_footprint { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceShaderImageFootprintFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceShaderImageFootprintFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderImageFootprintFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderImageFootprintFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderImageFootprintFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderImageFootprintFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder {
    inner: vk::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    type Type = PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn dedicated_allocation_image_aliasing(mut self, dedicated_allocation_image_aliasing: bool) -> Self {
        self.inner.dedicated_allocation_image_aliasing = if dedicated_allocation_image_aliasing {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceCopyMemoryIndirectFeaturesNVBuilder {
    inner: vk::PhysicalDeviceCopyMemoryIndirectFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceCopyMemoryIndirectFeaturesNV {
    type Type = PhysicalDeviceCopyMemoryIndirectFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceCopyMemoryIndirectFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceCopyMemoryIndirectFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn indirect_copy(mut self, indirect_copy: bool) -> Self {
        self.inner.indirect_copy = if indirect_copy { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceCopyMemoryIndirectFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceCopyMemoryIndirectFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceCopyMemoryIndirectFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceCopyMemoryIndirectFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceCopyMemoryIndirectFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceCopyMemoryIndirectFeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceCopyMemoryIndirectPropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMemoryDecompressionFeaturesNVBuilder {
    inner: vk::PhysicalDeviceMemoryDecompressionFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceMemoryDecompressionFeaturesNV {
    type Type = PhysicalDeviceMemoryDecompressionFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMemoryDecompressionFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMemoryDecompressionFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn memory_decompression(mut self, memory_decompression: bool) -> Self {
        self.inner.memory_decompression = if memory_decompression { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceMemoryDecompressionFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceMemoryDecompressionFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMemoryDecompressionFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMemoryDecompressionFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMemoryDecompressionFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceMemoryDecompressionFeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceMemoryDecompressionPropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct ShadingRatePaletteNVBuilder<'a> {
    inner: vk::ShadingRatePaletteNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ShadingRatePaletteNV {
    type Type = ShadingRatePaletteNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ShadingRatePaletteNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ShadingRatePaletteNV {
        &mut self.inner
    }
    pub fn p_shading_rate_palette_entries(
        mut self,
        p_shading_rate_palette_entries: &'a [vk::ShadingRatePaletteEntryNV],
    ) -> Self {
        self.inner.shading_rate_palette_entry_count = p_shading_rate_palette_entries.len() as u32;
        self.inner.p_shading_rate_palette_entries = p_shading_rate_palette_entries.as_ptr();
        self
    }
}
impl<'a> Deref for ShadingRatePaletteNVBuilder<'a> {
    type Target = vk::ShadingRatePaletteNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'a> {
    inner: vk::PipelineViewportShadingRateImageStateCreateInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineViewportShadingRateImageStateCreateInfoNV {
    type Type = PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineViewportShadingRateImageStateCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shading_rate_image_enable(mut self, shading_rate_image_enable: bool) -> Self {
        self.inner.shading_rate_image_enable = if shading_rate_image_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn viewport_count(mut self, viewport_count: u32) -> Self {
        self.inner.viewport_count = viewport_count;
        self
    }
    pub fn p_shading_rate_palettes(mut self, p_shading_rate_palettes: &'a [vk::ShadingRatePaletteNV]) -> Self {
        self.inner.viewport_count = p_shading_rate_palettes.len() as u32;
        self.inner.p_shading_rate_palettes = p_shading_rate_palettes.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'a> {
    type Target = vk::PipelineViewportShadingRateImageStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineViewportStateCreateInfoNext for vk::PipelineViewportShadingRateImageStateCreateInfoNV {}
impl PipelineViewportStateCreateInfoNext for PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShadingRateImageFeaturesNVBuilder {
    inner: vk::PhysicalDeviceShadingRateImageFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceShadingRateImageFeaturesNV {
    type Type = PhysicalDeviceShadingRateImageFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShadingRateImageFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShadingRateImageFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shading_rate_image(mut self, shading_rate_image: bool) -> Self {
        self.inner.shading_rate_image = if shading_rate_image { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shading_rate_coarse_sample_order(mut self, shading_rate_coarse_sample_order: bool) -> Self {
        self.inner.shading_rate_coarse_sample_order = if shading_rate_coarse_sample_order {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShadingRateImageFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceShadingRateImageFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShadingRateImageFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShadingRateImageFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShadingRateImageFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceShadingRateImageFeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceShadingRateImagePropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder {
    inner: vk::PhysicalDeviceInvocationMaskFeaturesHUAWEI,
}
impl Builder<'_> for vk::PhysicalDeviceInvocationMaskFeaturesHUAWEI {
    type Type = PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceInvocationMaskFeaturesHUAWEI {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn invocation_mask(mut self, invocation_mask: bool) -> Self {
        self.inner.invocation_mask = if invocation_mask { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder {
    type Target = vk::PhysicalDeviceInvocationMaskFeaturesHUAWEI;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceInvocationMaskFeaturesHUAWEI {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceInvocationMaskFeaturesHUAWEI {}
impl DeviceCreateInfoNext for PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct CoarseSampleLocationNVBuilder {
    inner: vk::CoarseSampleLocationNV,
}
impl Builder<'_> for vk::CoarseSampleLocationNV {
    type Type = CoarseSampleLocationNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CoarseSampleLocationNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CoarseSampleLocationNV {
        &mut self.inner
    }
    pub fn pixel_x(mut self, pixel_x: u32) -> Self {
        self.inner.pixel_x = pixel_x;
        self
    }
    pub fn pixel_y(mut self, pixel_y: u32) -> Self {
        self.inner.pixel_y = pixel_y;
        self
    }
    pub fn sample(mut self, sample: u32) -> Self {
        self.inner.sample = sample;
        self
    }
}
impl Deref for CoarseSampleLocationNVBuilder {
    type Target = vk::CoarseSampleLocationNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CoarseSampleOrderCustomNVBuilder<'a> {
    inner: vk::CoarseSampleOrderCustomNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CoarseSampleOrderCustomNV {
    type Type = CoarseSampleOrderCustomNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CoarseSampleOrderCustomNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CoarseSampleOrderCustomNV {
        &mut self.inner
    }
    pub fn shading_rate(mut self, shading_rate: vk::ShadingRatePaletteEntryNV) -> Self {
        self.inner.shading_rate = shading_rate;
        self
    }
    pub fn sample_count(mut self, sample_count: u32) -> Self {
        self.inner.sample_count = sample_count;
        self
    }
    pub fn p_sample_locations(mut self, p_sample_locations: &'a [vk::CoarseSampleLocationNV]) -> Self {
        self.inner.sample_location_count = p_sample_locations.len() as u32;
        self.inner.p_sample_locations = p_sample_locations.as_ptr();
        self
    }
}
impl<'a> Deref for CoarseSampleOrderCustomNVBuilder<'a> {
    type Target = vk::CoarseSampleOrderCustomNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'a> {
    inner: vk::PipelineViewportCoarseSampleOrderStateCreateInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineViewportCoarseSampleOrderStateCreateInfoNV {
    type Type = PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineViewportCoarseSampleOrderStateCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn sample_order_type(mut self, sample_order_type: vk::CoarseSampleOrderTypeNV) -> Self {
        self.inner.sample_order_type = sample_order_type;
        self
    }
    pub fn p_custom_sample_orders(mut self, p_custom_sample_orders: &'a [vk::CoarseSampleOrderCustomNV]) -> Self {
        self.inner.custom_sample_order_count = p_custom_sample_orders.len() as u32;
        self.inner.p_custom_sample_orders = p_custom_sample_orders.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'a> {
    type Target = vk::PipelineViewportCoarseSampleOrderStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineViewportStateCreateInfoNext for vk::PipelineViewportCoarseSampleOrderStateCreateInfoNV {}
impl PipelineViewportStateCreateInfoNext for PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMeshShaderFeaturesNVBuilder {
    inner: vk::PhysicalDeviceMeshShaderFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceMeshShaderFeaturesNV {
    type Type = PhysicalDeviceMeshShaderFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMeshShaderFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMeshShaderFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn task_shader(mut self, task_shader: bool) -> Self {
        self.inner.task_shader = if task_shader { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn mesh_shader(mut self, mesh_shader: bool) -> Self {
        self.inner.mesh_shader = if mesh_shader { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceMeshShaderFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceMeshShaderFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMeshShaderFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMeshShaderFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMeshShaderFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceMeshShaderFeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceMeshShaderPropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct DrawMeshTasksIndirectCommandNVBuilder {
    inner: vk::DrawMeshTasksIndirectCommandNV,
}
impl Builder<'_> for vk::DrawMeshTasksIndirectCommandNV {
    type Type = DrawMeshTasksIndirectCommandNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DrawMeshTasksIndirectCommandNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DrawMeshTasksIndirectCommandNV {
        &mut self.inner
    }
    pub fn task_count(mut self, task_count: u32) -> Self {
        self.inner.task_count = task_count;
        self
    }
    pub fn first_task(mut self, first_task: u32) -> Self {
        self.inner.first_task = first_task;
        self
    }
}
impl Deref for DrawMeshTasksIndirectCommandNVBuilder {
    type Target = vk::DrawMeshTasksIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMeshShaderFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceMeshShaderFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceMeshShaderFeaturesEXT {
    type Type = PhysicalDeviceMeshShaderFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMeshShaderFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMeshShaderFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn task_shader(mut self, task_shader: bool) -> Self {
        self.inner.task_shader = if task_shader { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn mesh_shader(mut self, mesh_shader: bool) -> Self {
        self.inner.mesh_shader = if mesh_shader { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn multiview_mesh_shader(mut self, multiview_mesh_shader: bool) -> Self {
        self.inner.multiview_mesh_shader = if multiview_mesh_shader { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn primitive_fragment_shading_rate_mesh_shader(
        mut self,
        primitive_fragment_shading_rate_mesh_shader: bool,
    ) -> Self {
        self.inner.primitive_fragment_shading_rate_mesh_shader = if primitive_fragment_shading_rate_mesh_shader {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn mesh_shader_queries(mut self, mesh_shader_queries: bool) -> Self {
        self.inner.mesh_shader_queries = if mesh_shader_queries { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceMeshShaderFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceMeshShaderFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMeshShaderFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMeshShaderFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMeshShaderFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceMeshShaderFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceMeshShaderPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct DrawMeshTasksIndirectCommandEXTBuilder {
    inner: vk::DrawMeshTasksIndirectCommandEXT,
}
impl Builder<'_> for vk::DrawMeshTasksIndirectCommandEXT {
    type Type = DrawMeshTasksIndirectCommandEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DrawMeshTasksIndirectCommandEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DrawMeshTasksIndirectCommandEXT {
        &mut self.inner
    }
    pub fn group_count_x(mut self, group_count_x: u32) -> Self {
        self.inner.group_count_x = group_count_x;
        self
    }
    pub fn group_count_y(mut self, group_count_y: u32) -> Self {
        self.inner.group_count_y = group_count_y;
        self
    }
    pub fn group_count_z(mut self, group_count_z: u32) -> Self {
        self.inner.group_count_z = group_count_z;
        self
    }
}
impl Deref for DrawMeshTasksIndirectCommandEXTBuilder {
    type Target = vk::DrawMeshTasksIndirectCommandEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RayTracingShaderGroupCreateInfoNVBuilder {
    inner: vk::RayTracingShaderGroupCreateInfoNV,
}
impl Builder<'_> for vk::RayTracingShaderGroupCreateInfoNV {
    type Type = RayTracingShaderGroupCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl RayTracingShaderGroupCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::RayTracingShaderGroupCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ty(mut self, ty: vk::RayTracingShaderGroupTypeKHR) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn general_shader(mut self, general_shader: u32) -> Self {
        self.inner.general_shader = general_shader;
        self
    }
    pub fn closest_hit_shader(mut self, closest_hit_shader: u32) -> Self {
        self.inner.closest_hit_shader = closest_hit_shader;
        self
    }
    pub fn any_hit_shader(mut self, any_hit_shader: u32) -> Self {
        self.inner.any_hit_shader = any_hit_shader;
        self
    }
    pub fn intersection_shader(mut self, intersection_shader: u32) -> Self {
        self.inner.intersection_shader = intersection_shader;
        self
    }
}
impl Deref for RayTracingShaderGroupCreateInfoNVBuilder {
    type Target = vk::RayTracingShaderGroupCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
    inner: vk::RayTracingShaderGroupCreateInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RayTracingShaderGroupCreateInfoKHR {
    type Type = RayTracingShaderGroupCreateInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::RayTracingShaderGroupCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ty(mut self, ty: vk::RayTracingShaderGroupTypeKHR) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn general_shader(mut self, general_shader: u32) -> Self {
        self.inner.general_shader = general_shader;
        self
    }
    pub fn closest_hit_shader(mut self, closest_hit_shader: u32) -> Self {
        self.inner.closest_hit_shader = closest_hit_shader;
        self
    }
    pub fn any_hit_shader(mut self, any_hit_shader: u32) -> Self {
        self.inner.any_hit_shader = any_hit_shader;
        self
    }
    pub fn intersection_shader(mut self, intersection_shader: u32) -> Self {
        self.inner.intersection_shader = intersection_shader;
        self
    }
    pub fn p_shader_group_capture_replay_handle(mut self, p_shader_group_capture_replay_handle: *const c_void) -> Self {
        self.inner.p_shader_group_capture_replay_handle = p_shader_group_capture_replay_handle;
        self
    }
}
impl<'a> Deref for RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
    type Target = vk::RayTracingShaderGroupCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RayTracingPipelineCreateInfoNVBuilder<'a> {
    inner: vk::RayTracingPipelineCreateInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RayTracingPipelineCreateInfoNV {
    type Type = RayTracingPipelineCreateInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait RayTracingPipelineCreateInfoNVNext {}
impl<'a> RayTracingPipelineCreateInfoNVBuilder<'a> {
    pub fn insert_next<T: RayTracingPipelineCreateInfoNVNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::RayTracingPipelineCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_stages(mut self, p_stages: &'a [vk::PipelineShaderStageCreateInfo]) -> Self {
        self.inner.stage_count = p_stages.len() as u32;
        self.inner.p_stages = p_stages.as_ptr();
        self
    }
    pub fn p_groups(mut self, p_groups: &'a [vk::RayTracingShaderGroupCreateInfoNV]) -> Self {
        self.inner.group_count = p_groups.len() as u32;
        self.inner.p_groups = p_groups.as_ptr();
        self
    }
    pub fn max_recursion_depth(mut self, max_recursion_depth: u32) -> Self {
        self.inner.max_recursion_depth = max_recursion_depth;
        self
    }
    pub fn layout(mut self, layout: vk::PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    pub fn base_pipeline_handle(mut self, base_pipeline_handle: vk::Pipeline) -> Self {
        self.inner.base_pipeline_handle = base_pipeline_handle;
        self
    }
    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.inner.base_pipeline_index = base_pipeline_index;
        self
    }
}
impl<'a> Deref for RayTracingPipelineCreateInfoNVBuilder<'a> {
    type Target = vk::RayTracingPipelineCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RayTracingPipelineCreateInfoKHRBuilder<'a> {
    inner: vk::RayTracingPipelineCreateInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RayTracingPipelineCreateInfoKHR {
    type Type = RayTracingPipelineCreateInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait RayTracingPipelineCreateInfoKHRNext {}
impl<'a> RayTracingPipelineCreateInfoKHRBuilder<'a> {
    pub fn insert_next<T: RayTracingPipelineCreateInfoKHRNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::RayTracingPipelineCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_stages(mut self, p_stages: &'a [vk::PipelineShaderStageCreateInfo]) -> Self {
        self.inner.stage_count = p_stages.len() as u32;
        self.inner.p_stages = p_stages.as_ptr();
        self
    }
    pub fn p_groups(mut self, p_groups: &'a [vk::RayTracingShaderGroupCreateInfoKHR]) -> Self {
        self.inner.group_count = p_groups.len() as u32;
        self.inner.p_groups = p_groups.as_ptr();
        self
    }
    pub fn max_pipeline_ray_recursion_depth(mut self, max_pipeline_ray_recursion_depth: u32) -> Self {
        self.inner.max_pipeline_ray_recursion_depth = max_pipeline_ray_recursion_depth;
        self
    }
    pub fn p_library_info(mut self, p_library_info: Option<&'a vk::PipelineLibraryCreateInfoKHR>) -> Self {
        self.inner.p_library_info = p_library_info.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_library_interface(
        mut self,
        p_library_interface: Option<&'a vk::RayTracingPipelineInterfaceCreateInfoKHR>,
    ) -> Self {
        self.inner.p_library_interface = p_library_interface.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_dynamic_state(mut self, p_dynamic_state: Option<&'a vk::PipelineDynamicStateCreateInfo>) -> Self {
        self.inner.p_dynamic_state = p_dynamic_state.map_or(ptr::null(), |r| r);
        self
    }
    pub fn layout(mut self, layout: vk::PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    pub fn base_pipeline_handle(mut self, base_pipeline_handle: vk::Pipeline) -> Self {
        self.inner.base_pipeline_handle = base_pipeline_handle;
        self
    }
    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.inner.base_pipeline_index = base_pipeline_index;
        self
    }
}
impl<'a> Deref for RayTracingPipelineCreateInfoKHRBuilder<'a> {
    type Target = vk::RayTracingPipelineCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct GeometryTrianglesNVBuilder {
    inner: vk::GeometryTrianglesNV,
}
impl Builder<'_> for vk::GeometryTrianglesNV {
    type Type = GeometryTrianglesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl GeometryTrianglesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::GeometryTrianglesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn vertex_data(mut self, vertex_data: vk::Buffer) -> Self {
        self.inner.vertex_data = vertex_data;
        self
    }
    pub fn vertex_offset(mut self, vertex_offset: vk::DeviceSize) -> Self {
        self.inner.vertex_offset = vertex_offset;
        self
    }
    pub fn vertex_count(mut self, vertex_count: u32) -> Self {
        self.inner.vertex_count = vertex_count;
        self
    }
    pub fn vertex_stride(mut self, vertex_stride: vk::DeviceSize) -> Self {
        self.inner.vertex_stride = vertex_stride;
        self
    }
    pub fn vertex_format(mut self, vertex_format: vk::Format) -> Self {
        self.inner.vertex_format = vertex_format;
        self
    }
    pub fn index_data(mut self, index_data: vk::Buffer) -> Self {
        self.inner.index_data = index_data;
        self
    }
    pub fn index_offset(mut self, index_offset: vk::DeviceSize) -> Self {
        self.inner.index_offset = index_offset;
        self
    }
    pub fn index_count(mut self, index_count: u32) -> Self {
        self.inner.index_count = index_count;
        self
    }
    pub fn index_type(mut self, index_type: vk::IndexType) -> Self {
        self.inner.index_type = index_type;
        self
    }
    pub fn transform_data(mut self, transform_data: vk::Buffer) -> Self {
        self.inner.transform_data = transform_data;
        self
    }
    pub fn transform_offset(mut self, transform_offset: vk::DeviceSize) -> Self {
        self.inner.transform_offset = transform_offset;
        self
    }
}
impl Deref for GeometryTrianglesNVBuilder {
    type Target = vk::GeometryTrianglesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct GeometryAABBNVBuilder {
    inner: vk::GeometryAABBNV,
}
impl Builder<'_> for vk::GeometryAABBNV {
    type Type = GeometryAABBNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl GeometryAABBNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::GeometryAABBNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn aabb_data(mut self, aabb_data: vk::Buffer) -> Self {
        self.inner.aabb_data = aabb_data;
        self
    }
    pub fn num_aab_bs(mut self, num_aab_bs: u32) -> Self {
        self.inner.num_aab_bs = num_aab_bs;
        self
    }
    pub fn stride(mut self, stride: u32) -> Self {
        self.inner.stride = stride;
        self
    }
    pub fn offset(mut self, offset: vk::DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
}
impl Deref for GeometryAABBNVBuilder {
    type Target = vk::GeometryAABBNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct GeometryDataNVBuilder {
    inner: vk::GeometryDataNV,
}
impl Builder<'_> for vk::GeometryDataNV {
    type Type = GeometryDataNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl GeometryDataNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::GeometryDataNV {
        &mut self.inner
    }
    pub fn triangles(mut self, triangles: vk::GeometryTrianglesNV) -> Self {
        self.inner.triangles = triangles;
        self
    }
    pub fn aabbs(mut self, aabbs: vk::GeometryAABBNV) -> Self {
        self.inner.aabbs = aabbs;
        self
    }
}
impl Deref for GeometryDataNVBuilder {
    type Target = vk::GeometryDataNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct GeometryNVBuilder {
    inner: vk::GeometryNV,
}
impl Builder<'_> for vk::GeometryNV {
    type Type = GeometryNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl GeometryNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::GeometryNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn geometry_type(mut self, geometry_type: vk::GeometryTypeKHR) -> Self {
        self.inner.geometry_type = geometry_type;
        self
    }
    pub fn geometry(mut self, geometry: vk::GeometryDataNV) -> Self {
        self.inner.geometry = geometry;
        self
    }
    pub fn flags(mut self, flags: vk::GeometryFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl Deref for GeometryNVBuilder {
    type Target = vk::GeometryNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureInfoNVBuilder<'a> {
    inner: vk::AccelerationStructureInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AccelerationStructureInfoNV {
    type Type = AccelerationStructureInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> AccelerationStructureInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ty(mut self, ty: vk::AccelerationStructureTypeNV) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn flags(mut self, flags: vk::BuildAccelerationStructureFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn instance_count(mut self, instance_count: u32) -> Self {
        self.inner.instance_count = instance_count;
        self
    }
    pub fn p_geometries(mut self, p_geometries: &'a [vk::GeometryNV]) -> Self {
        self.inner.geometry_count = p_geometries.len() as u32;
        self.inner.p_geometries = p_geometries.as_ptr();
        self
    }
}
impl<'a> Deref for AccelerationStructureInfoNVBuilder<'a> {
    type Target = vk::AccelerationStructureInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureCreateInfoNVBuilder<'a> {
    inner: vk::AccelerationStructureCreateInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AccelerationStructureCreateInfoNV {
    type Type = AccelerationStructureCreateInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait AccelerationStructureCreateInfoNVNext {}
impl<'a> AccelerationStructureCreateInfoNVBuilder<'a> {
    pub fn insert_next<T: AccelerationStructureCreateInfoNVNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn compacted_size(mut self, compacted_size: vk::DeviceSize) -> Self {
        self.inner.compacted_size = compacted_size;
        self
    }
    pub fn info(mut self, info: vk::AccelerationStructureInfoNV) -> Self {
        self.inner.info = info;
        self
    }
}
impl<'a> Deref for AccelerationStructureCreateInfoNVBuilder<'a> {
    type Target = vk::AccelerationStructureCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BindAccelerationStructureMemoryInfoNVBuilder<'a> {
    inner: vk::BindAccelerationStructureMemoryInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BindAccelerationStructureMemoryInfoNV {
    type Type = BindAccelerationStructureMemoryInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> BindAccelerationStructureMemoryInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::BindAccelerationStructureMemoryInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn acceleration_structure(mut self, acceleration_structure: vk::AccelerationStructureNV) -> Self {
        self.inner.acceleration_structure = acceleration_structure;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn memory_offset(mut self, memory_offset: vk::DeviceSize) -> Self {
        self.inner.memory_offset = memory_offset;
        self
    }
    pub fn p_device_indices(mut self, p_device_indices: &'a [u32]) -> Self {
        self.inner.device_index_count = p_device_indices.len() as u32;
        self.inner.p_device_indices = p_device_indices.as_ptr();
        self
    }
}
impl<'a> Deref for BindAccelerationStructureMemoryInfoNVBuilder<'a> {
    type Target = vk::BindAccelerationStructureMemoryInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct WriteDescriptorSetAccelerationStructureKHRBuilder<'a> {
    inner: vk::WriteDescriptorSetAccelerationStructureKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::WriteDescriptorSetAccelerationStructureKHR {
    type Type = WriteDescriptorSetAccelerationStructureKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> WriteDescriptorSetAccelerationStructureKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::WriteDescriptorSetAccelerationStructureKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_acceleration_structures(mut self, p_acceleration_structures: &'a [vk::AccelerationStructureKHR]) -> Self {
        self.inner.acceleration_structure_count = p_acceleration_structures.len() as u32;
        self.inner.p_acceleration_structures = p_acceleration_structures.as_ptr();
        self
    }
}
impl<'a> Deref for WriteDescriptorSetAccelerationStructureKHRBuilder<'a> {
    type Target = vk::WriteDescriptorSetAccelerationStructureKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl WriteDescriptorSetNext for vk::WriteDescriptorSetAccelerationStructureKHR {}
impl WriteDescriptorSetNext for WriteDescriptorSetAccelerationStructureKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct WriteDescriptorSetAccelerationStructureNVBuilder<'a> {
    inner: vk::WriteDescriptorSetAccelerationStructureNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::WriteDescriptorSetAccelerationStructureNV {
    type Type = WriteDescriptorSetAccelerationStructureNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> WriteDescriptorSetAccelerationStructureNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::WriteDescriptorSetAccelerationStructureNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_acceleration_structures(mut self, p_acceleration_structures: &'a [vk::AccelerationStructureNV]) -> Self {
        self.inner.acceleration_structure_count = p_acceleration_structures.len() as u32;
        self.inner.p_acceleration_structures = p_acceleration_structures.as_ptr();
        self
    }
}
impl<'a> Deref for WriteDescriptorSetAccelerationStructureNVBuilder<'a> {
    type Target = vk::WriteDescriptorSetAccelerationStructureNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl WriteDescriptorSetNext for vk::WriteDescriptorSetAccelerationStructureNV {}
impl WriteDescriptorSetNext for WriteDescriptorSetAccelerationStructureNVBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureMemoryRequirementsInfoNVBuilder {
    inner: vk::AccelerationStructureMemoryRequirementsInfoNV,
}
impl Builder<'_> for vk::AccelerationStructureMemoryRequirementsInfoNV {
    type Type = AccelerationStructureMemoryRequirementsInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AccelerationStructureMemoryRequirementsInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureMemoryRequirementsInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ty(mut self, ty: vk::AccelerationStructureMemoryRequirementsTypeNV) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn acceleration_structure(mut self, acceleration_structure: vk::AccelerationStructureNV) -> Self {
        self.inner.acceleration_structure = acceleration_structure;
        self
    }
}
impl Deref for AccelerationStructureMemoryRequirementsInfoNVBuilder {
    type Target = vk::AccelerationStructureMemoryRequirementsInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceAccelerationStructureFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceAccelerationStructureFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceAccelerationStructureFeaturesKHR {
    type Type = PhysicalDeviceAccelerationStructureFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceAccelerationStructureFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceAccelerationStructureFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn acceleration_structure(mut self, acceleration_structure: bool) -> Self {
        self.inner.acceleration_structure = if acceleration_structure { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn acceleration_structure_capture_replay(mut self, acceleration_structure_capture_replay: bool) -> Self {
        self.inner.acceleration_structure_capture_replay = if acceleration_structure_capture_replay {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn acceleration_structure_indirect_build(mut self, acceleration_structure_indirect_build: bool) -> Self {
        self.inner.acceleration_structure_indirect_build = if acceleration_structure_indirect_build {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn acceleration_structure_host_commands(mut self, acceleration_structure_host_commands: bool) -> Self {
        self.inner.acceleration_structure_host_commands = if acceleration_structure_host_commands {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn descriptor_binding_acceleration_structure_update_after_bind(
        mut self,
        descriptor_binding_acceleration_structure_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_acceleration_structure_update_after_bind =
            if descriptor_binding_acceleration_structure_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
}
impl Deref for PhysicalDeviceAccelerationStructureFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceAccelerationStructureFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceAccelerationStructureFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceAccelerationStructureFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceAccelerationStructureFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceAccelerationStructureFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceRayTracingPipelineFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceRayTracingPipelineFeaturesKHR {
    type Type = PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRayTracingPipelineFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ray_tracing_pipeline(mut self, ray_tracing_pipeline: bool) -> Self {
        self.inner.ray_tracing_pipeline = if ray_tracing_pipeline { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn ray_tracing_pipeline_shader_group_handle_capture_replay(
        mut self,
        ray_tracing_pipeline_shader_group_handle_capture_replay: bool,
    ) -> Self {
        self.inner.ray_tracing_pipeline_shader_group_handle_capture_replay =
            if ray_tracing_pipeline_shader_group_handle_capture_replay {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn ray_tracing_pipeline_shader_group_handle_capture_replay_mixed(
        mut self,
        ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: bool,
    ) -> Self {
        self.inner.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed =
            if ray_tracing_pipeline_shader_group_handle_capture_replay_mixed {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn ray_tracing_pipeline_trace_rays_indirect(mut self, ray_tracing_pipeline_trace_rays_indirect: bool) -> Self {
        self.inner.ray_tracing_pipeline_trace_rays_indirect = if ray_tracing_pipeline_trace_rays_indirect {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn ray_traversal_primitive_culling(mut self, ray_traversal_primitive_culling: bool) -> Self {
        self.inner.ray_traversal_primitive_culling = if ray_traversal_primitive_culling {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceRayTracingPipelineFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRayTracingPipelineFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRayTracingPipelineFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRayQueryFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceRayQueryFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceRayQueryFeaturesKHR {
    type Type = PhysicalDeviceRayQueryFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRayQueryFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRayQueryFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ray_query(mut self, ray_query: bool) -> Self {
        self.inner.ray_query = if ray_query { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceRayQueryFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceRayQueryFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRayQueryFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRayQueryFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRayQueryFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceRayQueryFeaturesKHRBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceAccelerationStructurePropertiesKHR {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceRayTracingPipelinePropertiesKHR {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceRayTracingPropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct StridedDeviceAddressRegionKHRBuilder {
    inner: vk::StridedDeviceAddressRegionKHR,
}
impl Builder<'_> for vk::StridedDeviceAddressRegionKHR {
    type Type = StridedDeviceAddressRegionKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl StridedDeviceAddressRegionKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::StridedDeviceAddressRegionKHR {
        &mut self.inner
    }
    pub fn device_address(mut self, device_address: vk::DeviceAddress) -> Self {
        self.inner.device_address = device_address;
        self
    }
    pub fn stride(mut self, stride: vk::DeviceSize) -> Self {
        self.inner.stride = stride;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
}
impl Deref for StridedDeviceAddressRegionKHRBuilder {
    type Target = vk::StridedDeviceAddressRegionKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct TraceRaysIndirectCommandKHRBuilder {
    inner: vk::TraceRaysIndirectCommandKHR,
}
impl Builder<'_> for vk::TraceRaysIndirectCommandKHR {
    type Type = TraceRaysIndirectCommandKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl TraceRaysIndirectCommandKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::TraceRaysIndirectCommandKHR {
        &mut self.inner
    }
    pub fn width(mut self, width: u32) -> Self {
        self.inner.width = width;
        self
    }
    pub fn height(mut self, height: u32) -> Self {
        self.inner.height = height;
        self
    }
    pub fn depth(mut self, depth: u32) -> Self {
        self.inner.depth = depth;
        self
    }
}
impl Deref for TraceRaysIndirectCommandKHRBuilder {
    type Target = vk::TraceRaysIndirectCommandKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct TraceRaysIndirectCommand2KHRBuilder {
    inner: vk::TraceRaysIndirectCommand2KHR,
}
impl Builder<'_> for vk::TraceRaysIndirectCommand2KHR {
    type Type = TraceRaysIndirectCommand2KHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl TraceRaysIndirectCommand2KHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::TraceRaysIndirectCommand2KHR {
        &mut self.inner
    }
    pub fn raygen_shader_record_address(mut self, raygen_shader_record_address: vk::DeviceAddress) -> Self {
        self.inner.raygen_shader_record_address = raygen_shader_record_address;
        self
    }
    pub fn raygen_shader_record_size(mut self, raygen_shader_record_size: vk::DeviceSize) -> Self {
        self.inner.raygen_shader_record_size = raygen_shader_record_size;
        self
    }
    pub fn miss_shader_binding_table_address(mut self, miss_shader_binding_table_address: vk::DeviceAddress) -> Self {
        self.inner.miss_shader_binding_table_address = miss_shader_binding_table_address;
        self
    }
    pub fn miss_shader_binding_table_size(mut self, miss_shader_binding_table_size: vk::DeviceSize) -> Self {
        self.inner.miss_shader_binding_table_size = miss_shader_binding_table_size;
        self
    }
    pub fn miss_shader_binding_table_stride(mut self, miss_shader_binding_table_stride: vk::DeviceSize) -> Self {
        self.inner.miss_shader_binding_table_stride = miss_shader_binding_table_stride;
        self
    }
    pub fn hit_shader_binding_table_address(mut self, hit_shader_binding_table_address: vk::DeviceAddress) -> Self {
        self.inner.hit_shader_binding_table_address = hit_shader_binding_table_address;
        self
    }
    pub fn hit_shader_binding_table_size(mut self, hit_shader_binding_table_size: vk::DeviceSize) -> Self {
        self.inner.hit_shader_binding_table_size = hit_shader_binding_table_size;
        self
    }
    pub fn hit_shader_binding_table_stride(mut self, hit_shader_binding_table_stride: vk::DeviceSize) -> Self {
        self.inner.hit_shader_binding_table_stride = hit_shader_binding_table_stride;
        self
    }
    pub fn callable_shader_binding_table_address(
        mut self,
        callable_shader_binding_table_address: vk::DeviceAddress,
    ) -> Self {
        self.inner.callable_shader_binding_table_address = callable_shader_binding_table_address;
        self
    }
    pub fn callable_shader_binding_table_size(mut self, callable_shader_binding_table_size: vk::DeviceSize) -> Self {
        self.inner.callable_shader_binding_table_size = callable_shader_binding_table_size;
        self
    }
    pub fn callable_shader_binding_table_stride(
        mut self,
        callable_shader_binding_table_stride: vk::DeviceSize,
    ) -> Self {
        self.inner.callable_shader_binding_table_stride = callable_shader_binding_table_stride;
        self
    }
    pub fn width(mut self, width: u32) -> Self {
        self.inner.width = width;
        self
    }
    pub fn height(mut self, height: u32) -> Self {
        self.inner.height = height;
        self
    }
    pub fn depth(mut self, depth: u32) -> Self {
        self.inner.depth = depth;
        self
    }
}
impl Deref for TraceRaysIndirectCommand2KHRBuilder {
    type Target = vk::TraceRaysIndirectCommand2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRayTracingMaintenance1FeaturesKHRBuilder {
    inner: vk::PhysicalDeviceRayTracingMaintenance1FeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceRayTracingMaintenance1FeaturesKHR {
    type Type = PhysicalDeviceRayTracingMaintenance1FeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRayTracingMaintenance1FeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRayTracingMaintenance1FeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ray_tracing_maintenance1(mut self, ray_tracing_maintenance1: bool) -> Self {
        self.inner.ray_tracing_maintenance1 = if ray_tracing_maintenance1 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn ray_tracing_pipeline_trace_rays_indirect2(
        mut self,
        ray_tracing_pipeline_trace_rays_indirect2: bool,
    ) -> Self {
        self.inner.ray_tracing_pipeline_trace_rays_indirect2 = if ray_tracing_pipeline_trace_rays_indirect2 {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceRayTracingMaintenance1FeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceRayTracingMaintenance1FeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRayTracingMaintenance1FeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRayTracingMaintenance1FeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRayTracingMaintenance1FeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceRayTracingMaintenance1FeaturesKHRBuilder {}
impl FormatProperties2Next for vk::DrmFormatModifierPropertiesListEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'a> {
    inner: vk::PhysicalDeviceImageDrmFormatModifierInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PhysicalDeviceImageDrmFormatModifierInfoEXT {
    type Type = PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceImageDrmFormatModifierInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
        self.inner.drm_format_modifier = drm_format_modifier;
        self
    }
    pub fn sharing_mode(mut self, sharing_mode: vk::SharingMode) -> Self {
        self.inner.sharing_mode = sharing_mode;
        self
    }
    pub fn queue_family_index_count(mut self, queue_family_index_count: u32) -> Self {
        self.inner.queue_family_index_count = queue_family_index_count;
        self
    }
    pub fn p_queue_family_indices(mut self, p_queue_family_indices: &'a [u32]) -> Self {
        self.inner.queue_family_index_count = p_queue_family_indices.len() as u32;
        self.inner.p_queue_family_indices = p_queue_family_indices.as_ptr();
        self
    }
}
impl<'a> Deref for PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'a> {
    type Target = vk::PhysicalDeviceImageDrmFormatModifierInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceImageFormatInfo2Next for vk::PhysicalDeviceImageDrmFormatModifierInfoEXT {}
impl PhysicalDeviceImageFormatInfo2Next for PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageDrmFormatModifierListCreateInfoEXTBuilder<'a> {
    inner: vk::ImageDrmFormatModifierListCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImageDrmFormatModifierListCreateInfoEXT {
    type Type = ImageDrmFormatModifierListCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ImageDrmFormatModifierListCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ImageDrmFormatModifierListCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_drm_format_modifiers(mut self, p_drm_format_modifiers: &'a [u64]) -> Self {
        self.inner.drm_format_modifier_count = p_drm_format_modifiers.len() as u32;
        self.inner.p_drm_format_modifiers = p_drm_format_modifiers.as_ptr();
        self
    }
}
impl<'a> Deref for ImageDrmFormatModifierListCreateInfoEXTBuilder<'a> {
    type Target = vk::ImageDrmFormatModifierListCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageCreateInfoNext for vk::ImageDrmFormatModifierListCreateInfoEXT {}
impl ImageCreateInfoNext for ImageDrmFormatModifierListCreateInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'a> {
    inner: vk::ImageDrmFormatModifierExplicitCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImageDrmFormatModifierExplicitCreateInfoEXT {
    type Type = ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ImageDrmFormatModifierExplicitCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
        self.inner.drm_format_modifier = drm_format_modifier;
        self
    }
    pub fn p_plane_layouts(mut self, p_plane_layouts: &'a [vk::SubresourceLayout]) -> Self {
        self.inner.drm_format_modifier_plane_count = p_plane_layouts.len() as u32;
        self.inner.p_plane_layouts = p_plane_layouts.as_ptr();
        self
    }
}
impl<'a> Deref for ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'a> {
    type Target = vk::ImageDrmFormatModifierExplicitCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageCreateInfoNext for vk::ImageDrmFormatModifierExplicitCreateInfoEXT {}
impl ImageCreateInfoNext for ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageStencilUsageCreateInfoBuilder {
    inner: vk::ImageStencilUsageCreateInfo,
}
impl Builder<'_> for vk::ImageStencilUsageCreateInfo {
    type Type = ImageStencilUsageCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageStencilUsageCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageStencilUsageCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn stencil_usage(mut self, stencil_usage: vk::ImageUsageFlags) -> Self {
        self.inner.stencil_usage = stencil_usage;
        self
    }
}
impl Deref for ImageStencilUsageCreateInfoBuilder {
    type Target = vk::ImageStencilUsageCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageCreateInfoNext for vk::ImageStencilUsageCreateInfo {}
impl ImageCreateInfoNext for ImageStencilUsageCreateInfoBuilder {}
impl PhysicalDeviceImageFormatInfo2Next for vk::ImageStencilUsageCreateInfo {}
impl PhysicalDeviceImageFormatInfo2Next for ImageStencilUsageCreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceMemoryOverallocationCreateInfoAMDBuilder {
    inner: vk::DeviceMemoryOverallocationCreateInfoAMD,
}
impl Builder<'_> for vk::DeviceMemoryOverallocationCreateInfoAMD {
    type Type = DeviceMemoryOverallocationCreateInfoAMDBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceMemoryOverallocationCreateInfoAMDBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceMemoryOverallocationCreateInfoAMD {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn overallocation_behavior(mut self, overallocation_behavior: vk::MemoryOverallocationBehaviorAMD) -> Self {
        self.inner.overallocation_behavior = overallocation_behavior;
        self
    }
}
impl Deref for DeviceMemoryOverallocationCreateInfoAMDBuilder {
    type Target = vk::DeviceMemoryOverallocationCreateInfoAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DeviceCreateInfoNext for vk::DeviceMemoryOverallocationCreateInfoAMD {}
impl DeviceCreateInfoNext for DeviceMemoryOverallocationCreateInfoAMDBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceFragmentDensityMapFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceFragmentDensityMapFeaturesEXT {
    type Type = PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceFragmentDensityMapFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn fragment_density_map(mut self, fragment_density_map: bool) -> Self {
        self.inner.fragment_density_map = if fragment_density_map { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn fragment_density_map_dynamic(mut self, fragment_density_map_dynamic: bool) -> Self {
        self.inner.fragment_density_map_dynamic = if fragment_density_map_dynamic {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn fragment_density_map_non_subsampled_images(
        mut self,
        fragment_density_map_non_subsampled_images: bool,
    ) -> Self {
        self.inner.fragment_density_map_non_subsampled_images = if fragment_density_map_non_subsampled_images {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceFragmentDensityMapFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceFragmentDensityMapFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceFragmentDensityMapFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder {
    inner: vk::PhysicalDeviceFragmentDensityMap2FeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceFragmentDensityMap2FeaturesEXT {
    type Type = PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceFragmentDensityMap2FeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn fragment_density_map_deferred(mut self, fragment_density_map_deferred: bool) -> Self {
        self.inner.fragment_density_map_deferred = if fragment_density_map_deferred {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceFragmentDensityMap2FeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceFragmentDensityMap2FeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceFragmentDensityMap2FeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceFragmentDensityMapOffsetFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT {
    type Type = PhysicalDeviceFragmentDensityMapOffsetFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceFragmentDensityMapOffsetFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn fragment_density_map_offset(mut self, fragment_density_map_offset: bool) -> Self {
        self.inner.fragment_density_map_offset = if fragment_density_map_offset {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceFragmentDensityMapOffsetFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceFragmentDensityMapOffsetFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceFragmentDensityMapOffsetFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceFragmentDensityMapPropertiesEXT {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceFragmentDensityMap2PropertiesEXT {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassFragmentDensityMapCreateInfoEXTBuilder {
    inner: vk::RenderPassFragmentDensityMapCreateInfoEXT,
}
impl Builder<'_> for vk::RenderPassFragmentDensityMapCreateInfoEXT {
    type Type = RenderPassFragmentDensityMapCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl RenderPassFragmentDensityMapCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::RenderPassFragmentDensityMapCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn fragment_density_map_attachment(mut self, fragment_density_map_attachment: vk::AttachmentReference) -> Self {
        self.inner.fragment_density_map_attachment = fragment_density_map_attachment;
        self
    }
}
impl Deref for RenderPassFragmentDensityMapCreateInfoEXTBuilder {
    type Target = vk::RenderPassFragmentDensityMapCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderPassCreateInfoNext for vk::RenderPassFragmentDensityMapCreateInfoEXT {}
impl RenderPassCreateInfoNext for RenderPassFragmentDensityMapCreateInfoEXTBuilder {}
impl RenderPassCreateInfo2Next for vk::RenderPassFragmentDensityMapCreateInfoEXT {}
impl RenderPassCreateInfo2Next for RenderPassFragmentDensityMapCreateInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassFragmentDensityMapOffsetEndInfoEXTBuilder<'a> {
    inner: vk::RenderPassFragmentDensityMapOffsetEndInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderPassFragmentDensityMapOffsetEndInfoEXT {
    type Type = RenderPassFragmentDensityMapOffsetEndInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> RenderPassFragmentDensityMapOffsetEndInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::RenderPassFragmentDensityMapOffsetEndInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_fragment_density_offsets(mut self, p_fragment_density_offsets: &'a [vk::Offset2D]) -> Self {
        self.inner.fragment_density_offset_count = p_fragment_density_offsets.len() as u32;
        self.inner.p_fragment_density_offsets = p_fragment_density_offsets.as_ptr();
        self
    }
}
impl<'a> Deref for RenderPassFragmentDensityMapOffsetEndInfoEXTBuilder<'a> {
    type Target = vk::RenderPassFragmentDensityMapOffsetEndInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubpassEndInfoNext for vk::RenderPassFragmentDensityMapOffsetEndInfoEXT {}
impl SubpassEndInfoNext for RenderPassFragmentDensityMapOffsetEndInfoEXTBuilder<'_> {}
impl RenderingEndInfoEXTNext for vk::RenderPassFragmentDensityMapOffsetEndInfoEXT {}
impl RenderingEndInfoEXTNext for RenderPassFragmentDensityMapOffsetEndInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceScalarBlockLayoutFeaturesBuilder {
    inner: vk::PhysicalDeviceScalarBlockLayoutFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceScalarBlockLayoutFeatures {
    type Type = PhysicalDeviceScalarBlockLayoutFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceScalarBlockLayoutFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceScalarBlockLayoutFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn scalar_block_layout(mut self, scalar_block_layout: bool) -> Self {
        self.inner.scalar_block_layout = if scalar_block_layout { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceScalarBlockLayoutFeaturesBuilder {
    type Target = vk::PhysicalDeviceScalarBlockLayoutFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceScalarBlockLayoutFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceScalarBlockLayoutFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceScalarBlockLayoutFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceScalarBlockLayoutFeaturesBuilder {}
impl SurfaceCapabilities2KHRNext for vk::SurfaceProtectedCapabilitiesKHR {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder {
    inner: vk::PhysicalDeviceUniformBufferStandardLayoutFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceUniformBufferStandardLayoutFeatures {
    type Type = PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceUniformBufferStandardLayoutFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn uniform_buffer_standard_layout(mut self, uniform_buffer_standard_layout: bool) -> Self {
        self.inner.uniform_buffer_standard_layout = if uniform_buffer_standard_layout {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder {
    type Target = vk::PhysicalDeviceUniformBufferStandardLayoutFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceUniformBufferStandardLayoutFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceUniformBufferStandardLayoutFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDepthClipEnableFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceDepthClipEnableFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceDepthClipEnableFeaturesEXT {
    type Type = PhysicalDeviceDepthClipEnableFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDepthClipEnableFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDepthClipEnableFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn depth_clip_enable(mut self, depth_clip_enable: bool) -> Self {
        self.inner.depth_clip_enable = if depth_clip_enable { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceDepthClipEnableFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceDepthClipEnableFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDepthClipEnableFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDepthClipEnableFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDepthClipEnableFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceDepthClipEnableFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineRasterizationDepthClipStateCreateInfoEXTBuilder {
    inner: vk::PipelineRasterizationDepthClipStateCreateInfoEXT,
}
impl Builder<'_> for vk::PipelineRasterizationDepthClipStateCreateInfoEXT {
    type Type = PipelineRasterizationDepthClipStateCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineRasterizationDepthClipStateCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineRasterizationDepthClipStateCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineRasterizationDepthClipStateCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn depth_clip_enable(mut self, depth_clip_enable: bool) -> Self {
        self.inner.depth_clip_enable = if depth_clip_enable { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PipelineRasterizationDepthClipStateCreateInfoEXTBuilder {
    type Target = vk::PipelineRasterizationDepthClipStateCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineRasterizationStateCreateInfoNext for vk::PipelineRasterizationDepthClipStateCreateInfoEXT {}
impl PipelineRasterizationStateCreateInfoNext for PipelineRasterizationDepthClipStateCreateInfoEXTBuilder {}
impl PhysicalDeviceMemoryProperties2Next for vk::PhysicalDeviceMemoryBudgetPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMemoryPriorityFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceMemoryPriorityFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceMemoryPriorityFeaturesEXT {
    type Type = PhysicalDeviceMemoryPriorityFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMemoryPriorityFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMemoryPriorityFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn memory_priority(mut self, memory_priority: bool) -> Self {
        self.inner.memory_priority = if memory_priority { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceMemoryPriorityFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceMemoryPriorityFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMemoryPriorityFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMemoryPriorityFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMemoryPriorityFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceMemoryPriorityFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryPriorityAllocateInfoEXTBuilder {
    inner: vk::MemoryPriorityAllocateInfoEXT,
}
impl Builder<'_> for vk::MemoryPriorityAllocateInfoEXT {
    type Type = MemoryPriorityAllocateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryPriorityAllocateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryPriorityAllocateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn priority(mut self, priority: f32) -> Self {
        self.inner.priority = priority;
        self
    }
}
impl Deref for MemoryPriorityAllocateInfoEXTBuilder {
    type Target = vk::MemoryPriorityAllocateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::MemoryPriorityAllocateInfoEXT {}
impl MemoryAllocateInfoNext for MemoryPriorityAllocateInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePageableDeviceLocalMemoryFeaturesEXTBuilder {
    inner: vk::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
    type Type = PhysicalDevicePageableDeviceLocalMemoryFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePageableDeviceLocalMemoryFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pageable_device_local_memory(mut self, pageable_device_local_memory: bool) -> Self {
        self.inner.pageable_device_local_memory = if pageable_device_local_memory {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXTBuilder {
    type Target = vk::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceBufferDeviceAddressFeaturesBuilder {
    inner: vk::PhysicalDeviceBufferDeviceAddressFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceBufferDeviceAddressFeatures {
    type Type = PhysicalDeviceBufferDeviceAddressFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceBufferDeviceAddressFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceBufferDeviceAddressFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn buffer_device_address(mut self, buffer_device_address: bool) -> Self {
        self.inner.buffer_device_address = if buffer_device_address { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn buffer_device_address_capture_replay(mut self, buffer_device_address_capture_replay: bool) -> Self {
        self.inner.buffer_device_address_capture_replay = if buffer_device_address_capture_replay {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn buffer_device_address_multi_device(mut self, buffer_device_address_multi_device: bool) -> Self {
        self.inner.buffer_device_address_multi_device = if buffer_device_address_multi_device {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceBufferDeviceAddressFeaturesBuilder {
    type Target = vk::PhysicalDeviceBufferDeviceAddressFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceBufferDeviceAddressFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceBufferDeviceAddressFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceBufferDeviceAddressFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceBufferDeviceAddressFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceBufferDeviceAddressFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceBufferDeviceAddressFeaturesEXT {
    type Type = PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceBufferDeviceAddressFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn buffer_device_address(mut self, buffer_device_address: bool) -> Self {
        self.inner.buffer_device_address = if buffer_device_address { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn buffer_device_address_capture_replay(mut self, buffer_device_address_capture_replay: bool) -> Self {
        self.inner.buffer_device_address_capture_replay = if buffer_device_address_capture_replay {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn buffer_device_address_multi_device(mut self, buffer_device_address_multi_device: bool) -> Self {
        self.inner.buffer_device_address_multi_device = if buffer_device_address_multi_device {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceBufferDeviceAddressFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceBufferDeviceAddressFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceBufferDeviceAddressFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferDeviceAddressInfoBuilder {
    inner: vk::BufferDeviceAddressInfo,
}
impl Builder<'_> for vk::BufferDeviceAddressInfo {
    type Type = BufferDeviceAddressInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BufferDeviceAddressInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BufferDeviceAddressInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
}
impl Deref for BufferDeviceAddressInfoBuilder {
    type Target = vk::BufferDeviceAddressInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferOpaqueCaptureAddressCreateInfoBuilder {
    inner: vk::BufferOpaqueCaptureAddressCreateInfo,
}
impl Builder<'_> for vk::BufferOpaqueCaptureAddressCreateInfo {
    type Type = BufferOpaqueCaptureAddressCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BufferOpaqueCaptureAddressCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BufferOpaqueCaptureAddressCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn opaque_capture_address(mut self, opaque_capture_address: u64) -> Self {
        self.inner.opaque_capture_address = opaque_capture_address;
        self
    }
}
impl Deref for BufferOpaqueCaptureAddressCreateInfoBuilder {
    type Target = vk::BufferOpaqueCaptureAddressCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BufferCreateInfoNext for vk::BufferOpaqueCaptureAddressCreateInfo {}
impl BufferCreateInfoNext for BufferOpaqueCaptureAddressCreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferDeviceAddressCreateInfoEXTBuilder {
    inner: vk::BufferDeviceAddressCreateInfoEXT,
}
impl Builder<'_> for vk::BufferDeviceAddressCreateInfoEXT {
    type Type = BufferDeviceAddressCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BufferDeviceAddressCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BufferDeviceAddressCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn device_address(mut self, device_address: vk::DeviceAddress) -> Self {
        self.inner.device_address = device_address;
        self
    }
}
impl Deref for BufferDeviceAddressCreateInfoEXTBuilder {
    type Target = vk::BufferDeviceAddressCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BufferCreateInfoNext for vk::BufferDeviceAddressCreateInfoEXT {}
impl BufferCreateInfoNext for BufferDeviceAddressCreateInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceImageViewImageFormatInfoEXTBuilder {
    inner: vk::PhysicalDeviceImageViewImageFormatInfoEXT,
}
impl Builder<'_> for vk::PhysicalDeviceImageViewImageFormatInfoEXT {
    type Type = PhysicalDeviceImageViewImageFormatInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceImageViewImageFormatInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceImageViewImageFormatInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image_view_type(mut self, image_view_type: vk::ImageViewType) -> Self {
        self.inner.image_view_type = image_view_type;
        self
    }
}
impl Deref for PhysicalDeviceImageViewImageFormatInfoEXTBuilder {
    type Target = vk::PhysicalDeviceImageViewImageFormatInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceImageFormatInfo2Next for vk::PhysicalDeviceImageViewImageFormatInfoEXT {}
impl PhysicalDeviceImageFormatInfo2Next for PhysicalDeviceImageViewImageFormatInfoEXTBuilder {}
impl ImageFormatProperties2Next for vk::FilterCubicImageViewImageFormatPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceImagelessFramebufferFeaturesBuilder {
    inner: vk::PhysicalDeviceImagelessFramebufferFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceImagelessFramebufferFeatures {
    type Type = PhysicalDeviceImagelessFramebufferFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceImagelessFramebufferFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceImagelessFramebufferFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn imageless_framebuffer(mut self, imageless_framebuffer: bool) -> Self {
        self.inner.imageless_framebuffer = if imageless_framebuffer { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceImagelessFramebufferFeaturesBuilder {
    type Target = vk::PhysicalDeviceImagelessFramebufferFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceImagelessFramebufferFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceImagelessFramebufferFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceImagelessFramebufferFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceImagelessFramebufferFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct FramebufferAttachmentsCreateInfoBuilder<'a> {
    inner: vk::FramebufferAttachmentsCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::FramebufferAttachmentsCreateInfo {
    type Type = FramebufferAttachmentsCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> FramebufferAttachmentsCreateInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::FramebufferAttachmentsCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_attachment_image_infos(
        mut self,
        p_attachment_image_infos: &'a [vk::FramebufferAttachmentImageInfo],
    ) -> Self {
        self.inner.attachment_image_info_count = p_attachment_image_infos.len() as u32;
        self.inner.p_attachment_image_infos = p_attachment_image_infos.as_ptr();
        self
    }
}
impl<'a> Deref for FramebufferAttachmentsCreateInfoBuilder<'a> {
    type Target = vk::FramebufferAttachmentsCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl FramebufferCreateInfoNext for vk::FramebufferAttachmentsCreateInfo {}
impl FramebufferCreateInfoNext for FramebufferAttachmentsCreateInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct FramebufferAttachmentImageInfoBuilder<'a> {
    inner: vk::FramebufferAttachmentImageInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::FramebufferAttachmentImageInfo {
    type Type = FramebufferAttachmentImageInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> FramebufferAttachmentImageInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::FramebufferAttachmentImageInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::ImageCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn usage(mut self, usage: vk::ImageUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
    pub fn width(mut self, width: u32) -> Self {
        self.inner.width = width;
        self
    }
    pub fn height(mut self, height: u32) -> Self {
        self.inner.height = height;
        self
    }
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.inner.layer_count = layer_count;
        self
    }
    pub fn p_view_formats(mut self, p_view_formats: &'a [vk::Format]) -> Self {
        self.inner.view_format_count = p_view_formats.len() as u32;
        self.inner.p_view_formats = p_view_formats.as_ptr();
        self
    }
}
impl<'a> Deref for FramebufferAttachmentImageInfoBuilder<'a> {
    type Target = vk::FramebufferAttachmentImageInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassAttachmentBeginInfoBuilder<'a> {
    inner: vk::RenderPassAttachmentBeginInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderPassAttachmentBeginInfo {
    type Type = RenderPassAttachmentBeginInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> RenderPassAttachmentBeginInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::RenderPassAttachmentBeginInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_attachments(mut self, p_attachments: &'a [vk::ImageView]) -> Self {
        self.inner.attachment_count = p_attachments.len() as u32;
        self.inner.p_attachments = p_attachments.as_ptr();
        self
    }
}
impl<'a> Deref for RenderPassAttachmentBeginInfoBuilder<'a> {
    type Target = vk::RenderPassAttachmentBeginInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderPassBeginInfoNext for vk::RenderPassAttachmentBeginInfo {}
impl RenderPassBeginInfoNext for RenderPassAttachmentBeginInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder {
    inner: vk::PhysicalDeviceTextureCompressionASTCHDRFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceTextureCompressionASTCHDRFeatures {
    type Type = PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceTextureCompressionASTCHDRFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn texture_compression_astc_hdr(mut self, texture_compression_astc_hdr: bool) -> Self {
        self.inner.texture_compression_astc_hdr = if texture_compression_astc_hdr {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder {
    type Target = vk::PhysicalDeviceTextureCompressionASTCHDRFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceTextureCompressionASTCHDRFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceTextureCompressionASTCHDRFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceCooperativeMatrixFeaturesNVBuilder {
    inner: vk::PhysicalDeviceCooperativeMatrixFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceCooperativeMatrixFeaturesNV {
    type Type = PhysicalDeviceCooperativeMatrixFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceCooperativeMatrixFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceCooperativeMatrixFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn cooperative_matrix(mut self, cooperative_matrix: bool) -> Self {
        self.inner.cooperative_matrix = if cooperative_matrix { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn cooperative_matrix_robust_buffer_access(mut self, cooperative_matrix_robust_buffer_access: bool) -> Self {
        self.inner.cooperative_matrix_robust_buffer_access = if cooperative_matrix_robust_buffer_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceCooperativeMatrixFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceCooperativeMatrixFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceCooperativeMatrixFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceCooperativeMatrixFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceCooperativeMatrixFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceCooperativeMatrixFeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceCooperativeMatrixPropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceYcbcrImageArraysFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceYcbcrImageArraysFeaturesEXT {
    type Type = PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceYcbcrImageArraysFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ycbcr_image_arrays(mut self, ycbcr_image_arrays: bool) -> Self {
        self.inner.ycbcr_image_arrays = if ycbcr_image_arrays { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceYcbcrImageArraysFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceYcbcrImageArraysFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceYcbcrImageArraysFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageViewHandleInfoNVXBuilder {
    inner: vk::ImageViewHandleInfoNVX,
}
impl Builder<'_> for vk::ImageViewHandleInfoNVX {
    type Type = ImageViewHandleInfoNVXBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageViewHandleInfoNVXBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageViewHandleInfoNVX {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image_view(mut self, image_view: vk::ImageView) -> Self {
        self.inner.image_view = image_view;
        self
    }
    pub fn descriptor_type(mut self, descriptor_type: vk::DescriptorType) -> Self {
        self.inner.descriptor_type = descriptor_type;
        self
    }
    pub fn sampler(mut self, sampler: vk::Sampler) -> Self {
        self.inner.sampler = sampler;
        self
    }
}
impl Deref for ImageViewHandleInfoNVXBuilder {
    type Target = vk::ImageViewHandleInfoNVX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineCreationFeedbackCreateInfoBuilder<'a> {
    inner: vk::PipelineCreationFeedbackCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineCreationFeedbackCreateInfo {
    type Type = PipelineCreationFeedbackCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineCreationFeedbackCreateInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineCreationFeedbackCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_pipeline_creation_feedback(
        mut self,
        p_pipeline_creation_feedback: *mut vk::PipelineCreationFeedback,
    ) -> Self {
        self.inner.p_pipeline_creation_feedback = p_pipeline_creation_feedback;
        self
    }
    pub fn p_pipeline_stage_creation_feedbacks(
        mut self,
        p_pipeline_stage_creation_feedbacks: &'a mut [vk::PipelineCreationFeedback],
    ) -> Self {
        self.inner.pipeline_stage_creation_feedback_count = p_pipeline_stage_creation_feedbacks.len() as u32;
        self.inner.p_pipeline_stage_creation_feedbacks = p_pipeline_stage_creation_feedbacks.as_mut_ptr();
        self
    }
}
impl<'a> Deref for PipelineCreationFeedbackCreateInfoBuilder<'a> {
    type Target = vk::PipelineCreationFeedbackCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::PipelineCreationFeedbackCreateInfo {}
impl GraphicsPipelineCreateInfoNext for PipelineCreationFeedbackCreateInfoBuilder<'_> {}
impl ComputePipelineCreateInfoNext for vk::PipelineCreationFeedbackCreateInfo {}
impl ComputePipelineCreateInfoNext for PipelineCreationFeedbackCreateInfoBuilder<'_> {}
impl RayTracingPipelineCreateInfoNVNext for vk::PipelineCreationFeedbackCreateInfo {}
impl RayTracingPipelineCreateInfoNVNext for PipelineCreationFeedbackCreateInfoBuilder<'_> {}
impl RayTracingPipelineCreateInfoKHRNext for vk::PipelineCreationFeedbackCreateInfo {}
impl RayTracingPipelineCreateInfoKHRNext for PipelineCreationFeedbackCreateInfoBuilder<'_> {}
impl ExecutionGraphPipelineCreateInfoAMDXNext for vk::PipelineCreationFeedbackCreateInfo {}
impl ExecutionGraphPipelineCreateInfoAMDXNext for PipelineCreationFeedbackCreateInfoBuilder<'_> {}
impl DataGraphPipelineCreateInfoARMNext for vk::PipelineCreationFeedbackCreateInfo {}
impl DataGraphPipelineCreateInfoARMNext for PipelineCreationFeedbackCreateInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct SurfaceFullScreenExclusiveInfoEXTBuilder {
    inner: vk::SurfaceFullScreenExclusiveInfoEXT,
}
impl Builder<'_> for vk::SurfaceFullScreenExclusiveInfoEXT {
    type Type = SurfaceFullScreenExclusiveInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SurfaceFullScreenExclusiveInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SurfaceFullScreenExclusiveInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn full_screen_exclusive(mut self, full_screen_exclusive: vk::FullScreenExclusiveEXT) -> Self {
        self.inner.full_screen_exclusive = full_screen_exclusive;
        self
    }
}
impl Deref for SurfaceFullScreenExclusiveInfoEXTBuilder {
    type Target = vk::SurfaceFullScreenExclusiveInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceSurfaceInfo2KHRNext for vk::SurfaceFullScreenExclusiveInfoEXT {}
impl PhysicalDeviceSurfaceInfo2KHRNext for SurfaceFullScreenExclusiveInfoEXTBuilder {}
impl SwapchainCreateInfoKHRNext for vk::SurfaceFullScreenExclusiveInfoEXT {}
impl SwapchainCreateInfoKHRNext for SurfaceFullScreenExclusiveInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SurfaceFullScreenExclusiveWin32InfoEXTBuilder {
    inner: vk::SurfaceFullScreenExclusiveWin32InfoEXT,
}
impl Builder<'_> for vk::SurfaceFullScreenExclusiveWin32InfoEXT {
    type Type = SurfaceFullScreenExclusiveWin32InfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SurfaceFullScreenExclusiveWin32InfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SurfaceFullScreenExclusiveWin32InfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn hmonitor(mut self, hmonitor: vk::HMONITOR) -> Self {
        self.inner.hmonitor = hmonitor;
        self
    }
}
impl Deref for SurfaceFullScreenExclusiveWin32InfoEXTBuilder {
    type Target = vk::SurfaceFullScreenExclusiveWin32InfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceSurfaceInfo2KHRNext for vk::SurfaceFullScreenExclusiveWin32InfoEXT {}
impl PhysicalDeviceSurfaceInfo2KHRNext for SurfaceFullScreenExclusiveWin32InfoEXTBuilder {}
impl SwapchainCreateInfoKHRNext for vk::SurfaceFullScreenExclusiveWin32InfoEXT {}
impl SwapchainCreateInfoKHRNext for SurfaceFullScreenExclusiveWin32InfoEXTBuilder {}
impl SurfaceCapabilities2KHRNext for vk::SurfaceCapabilitiesFullScreenExclusiveEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePresentBarrierFeaturesNVBuilder {
    inner: vk::PhysicalDevicePresentBarrierFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDevicePresentBarrierFeaturesNV {
    type Type = PhysicalDevicePresentBarrierFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePresentBarrierFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePresentBarrierFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn present_barrier(mut self, present_barrier: bool) -> Self {
        self.inner.present_barrier = if present_barrier { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevicePresentBarrierFeaturesNVBuilder {
    type Target = vk::PhysicalDevicePresentBarrierFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePresentBarrierFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePresentBarrierFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePresentBarrierFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDevicePresentBarrierFeaturesNVBuilder {}
impl SurfaceCapabilities2KHRNext for vk::SurfaceCapabilitiesPresentBarrierNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct SwapchainPresentBarrierCreateInfoNVBuilder {
    inner: vk::SwapchainPresentBarrierCreateInfoNV,
}
impl Builder<'_> for vk::SwapchainPresentBarrierCreateInfoNV {
    type Type = SwapchainPresentBarrierCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SwapchainPresentBarrierCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SwapchainPresentBarrierCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn present_barrier_enable(mut self, present_barrier_enable: bool) -> Self {
        self.inner.present_barrier_enable = if present_barrier_enable { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for SwapchainPresentBarrierCreateInfoNVBuilder {
    type Target = vk::SwapchainPresentBarrierCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SwapchainCreateInfoKHRNext for vk::SwapchainPresentBarrierCreateInfoNV {}
impl SwapchainCreateInfoKHRNext for SwapchainPresentBarrierCreateInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePerformanceQueryFeaturesKHRBuilder {
    inner: vk::PhysicalDevicePerformanceQueryFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDevicePerformanceQueryFeaturesKHR {
    type Type = PhysicalDevicePerformanceQueryFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePerformanceQueryFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePerformanceQueryFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn performance_counter_query_pools(mut self, performance_counter_query_pools: bool) -> Self {
        self.inner.performance_counter_query_pools = if performance_counter_query_pools {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn performance_counter_multiple_query_pools(mut self, performance_counter_multiple_query_pools: bool) -> Self {
        self.inner.performance_counter_multiple_query_pools = if performance_counter_multiple_query_pools {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDevicePerformanceQueryFeaturesKHRBuilder {
    type Target = vk::PhysicalDevicePerformanceQueryFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePerformanceQueryFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePerformanceQueryFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePerformanceQueryFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDevicePerformanceQueryFeaturesKHRBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDevicePerformanceQueryPropertiesKHR {}

#[repr(transparent)]
#[derive(Default)]
pub struct QueryPoolPerformanceCreateInfoKHRBuilder<'a> {
    inner: vk::QueryPoolPerformanceCreateInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::QueryPoolPerformanceCreateInfoKHR {
    type Type = QueryPoolPerformanceCreateInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> QueryPoolPerformanceCreateInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::QueryPoolPerformanceCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.inner.queue_family_index = queue_family_index;
        self
    }
    pub fn p_counter_indices(mut self, p_counter_indices: &'a [u32]) -> Self {
        self.inner.counter_index_count = p_counter_indices.len() as u32;
        self.inner.p_counter_indices = p_counter_indices.as_ptr();
        self
    }
}
impl<'a> Deref for QueryPoolPerformanceCreateInfoKHRBuilder<'a> {
    type Target = vk::QueryPoolPerformanceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl QueryPoolCreateInfoNext for vk::QueryPoolPerformanceCreateInfoKHR {}
impl QueryPoolCreateInfoNext for QueryPoolPerformanceCreateInfoKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct AcquireProfilingLockInfoKHRBuilder {
    inner: vk::AcquireProfilingLockInfoKHR,
}
impl Builder<'_> for vk::AcquireProfilingLockInfoKHR {
    type Type = AcquireProfilingLockInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AcquireProfilingLockInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AcquireProfilingLockInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::AcquireProfilingLockFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn timeout(mut self, timeout: u64) -> Self {
        self.inner.timeout = timeout;
        self
    }
}
impl Deref for AcquireProfilingLockInfoKHRBuilder {
    type Target = vk::AcquireProfilingLockInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PerformanceQuerySubmitInfoKHRBuilder {
    inner: vk::PerformanceQuerySubmitInfoKHR,
}
impl Builder<'_> for vk::PerformanceQuerySubmitInfoKHR {
    type Type = PerformanceQuerySubmitInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PerformanceQuerySubmitInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PerformanceQuerySubmitInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn counter_pass_index(mut self, counter_pass_index: u32) -> Self {
        self.inner.counter_pass_index = counter_pass_index;
        self
    }
}
impl Deref for PerformanceQuerySubmitInfoKHRBuilder {
    type Target = vk::PerformanceQuerySubmitInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubmitInfoNext for vk::PerformanceQuerySubmitInfoKHR {}
impl SubmitInfoNext for PerformanceQuerySubmitInfoKHRBuilder {}
impl SubmitInfo2Next for vk::PerformanceQuerySubmitInfoKHR {}
impl SubmitInfo2Next for PerformanceQuerySubmitInfoKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct HeadlessSurfaceCreateInfoEXTBuilder {
    inner: vk::HeadlessSurfaceCreateInfoEXT,
}
impl Builder<'_> for vk::HeadlessSurfaceCreateInfoEXT {
    type Type = HeadlessSurfaceCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl HeadlessSurfaceCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::HeadlessSurfaceCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::HeadlessSurfaceCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl Deref for HeadlessSurfaceCreateInfoEXTBuilder {
    type Target = vk::HeadlessSurfaceCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceCoverageReductionModeFeaturesNVBuilder {
    inner: vk::PhysicalDeviceCoverageReductionModeFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceCoverageReductionModeFeaturesNV {
    type Type = PhysicalDeviceCoverageReductionModeFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceCoverageReductionModeFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceCoverageReductionModeFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn coverage_reduction_mode(mut self, coverage_reduction_mode: bool) -> Self {
        self.inner.coverage_reduction_mode = if coverage_reduction_mode { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceCoverageReductionModeFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceCoverageReductionModeFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceCoverageReductionModeFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceCoverageReductionModeFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceCoverageReductionModeFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceCoverageReductionModeFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineCoverageReductionStateCreateInfoNVBuilder {
    inner: vk::PipelineCoverageReductionStateCreateInfoNV,
}
impl Builder<'_> for vk::PipelineCoverageReductionStateCreateInfoNV {
    type Type = PipelineCoverageReductionStateCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineCoverageReductionStateCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineCoverageReductionStateCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineCoverageReductionStateCreateFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn coverage_reduction_mode(mut self, coverage_reduction_mode: vk::CoverageReductionModeNV) -> Self {
        self.inner.coverage_reduction_mode = coverage_reduction_mode;
        self
    }
}
impl Deref for PipelineCoverageReductionStateCreateInfoNVBuilder {
    type Target = vk::PipelineCoverageReductionStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineMultisampleStateCreateInfoNext for vk::PipelineCoverageReductionStateCreateInfoNV {}
impl PipelineMultisampleStateCreateInfoNext for PipelineCoverageReductionStateCreateInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder {
    inner: vk::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,
}
impl Builder<'_> for vk::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    type Type = PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_integer_functions2(mut self, shader_integer_functions2: bool) -> Self {
        self.inner.shader_integer_functions2 = if shader_integer_functions2 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder {
    type Target = vk::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct InitializePerformanceApiInfoINTELBuilder<'a> {
    inner: vk::InitializePerformanceApiInfoINTEL,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::InitializePerformanceApiInfoINTEL {
    type Type = InitializePerformanceApiInfoINTELBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> InitializePerformanceApiInfoINTELBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::InitializePerformanceApiInfoINTEL {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_user_data(mut self, p_user_data: *mut c_void) -> Self {
        self.inner.p_user_data = p_user_data;
        self
    }
}
impl<'a> Deref for InitializePerformanceApiInfoINTELBuilder<'a> {
    type Target = vk::InitializePerformanceApiInfoINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct QueryPoolPerformanceQueryCreateInfoINTELBuilder {
    inner: vk::QueryPoolPerformanceQueryCreateInfoINTEL,
}
impl Builder<'_> for vk::QueryPoolPerformanceQueryCreateInfoINTEL {
    type Type = QueryPoolPerformanceQueryCreateInfoINTELBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl QueryPoolPerformanceQueryCreateInfoINTELBuilder {
    pub fn get_mut(&mut self) -> &mut vk::QueryPoolPerformanceQueryCreateInfoINTEL {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn performance_counters_sampling(
        mut self,
        performance_counters_sampling: vk::QueryPoolSamplingModeINTEL,
    ) -> Self {
        self.inner.performance_counters_sampling = performance_counters_sampling;
        self
    }
}
impl Deref for QueryPoolPerformanceQueryCreateInfoINTELBuilder {
    type Target = vk::QueryPoolPerformanceQueryCreateInfoINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl QueryPoolCreateInfoNext for vk::QueryPoolPerformanceQueryCreateInfoINTEL {}
impl QueryPoolCreateInfoNext for QueryPoolPerformanceQueryCreateInfoINTELBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PerformanceMarkerInfoINTELBuilder {
    inner: vk::PerformanceMarkerInfoINTEL,
}
impl Builder<'_> for vk::PerformanceMarkerInfoINTEL {
    type Type = PerformanceMarkerInfoINTELBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PerformanceMarkerInfoINTELBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PerformanceMarkerInfoINTEL {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn marker(mut self, marker: u64) -> Self {
        self.inner.marker = marker;
        self
    }
}
impl Deref for PerformanceMarkerInfoINTELBuilder {
    type Target = vk::PerformanceMarkerInfoINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PerformanceStreamMarkerInfoINTELBuilder {
    inner: vk::PerformanceStreamMarkerInfoINTEL,
}
impl Builder<'_> for vk::PerformanceStreamMarkerInfoINTEL {
    type Type = PerformanceStreamMarkerInfoINTELBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PerformanceStreamMarkerInfoINTELBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PerformanceStreamMarkerInfoINTEL {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn marker(mut self, marker: u32) -> Self {
        self.inner.marker = marker;
        self
    }
}
impl Deref for PerformanceStreamMarkerInfoINTELBuilder {
    type Target = vk::PerformanceStreamMarkerInfoINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PerformanceOverrideInfoINTELBuilder {
    inner: vk::PerformanceOverrideInfoINTEL,
}
impl Builder<'_> for vk::PerformanceOverrideInfoINTEL {
    type Type = PerformanceOverrideInfoINTELBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PerformanceOverrideInfoINTELBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PerformanceOverrideInfoINTEL {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ty(mut self, ty: vk::PerformanceOverrideTypeINTEL) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn enable(mut self, enable: bool) -> Self {
        self.inner.enable = if enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn parameter(mut self, parameter: u64) -> Self {
        self.inner.parameter = parameter;
        self
    }
}
impl Deref for PerformanceOverrideInfoINTELBuilder {
    type Target = vk::PerformanceOverrideInfoINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PerformanceConfigurationAcquireInfoINTELBuilder {
    inner: vk::PerformanceConfigurationAcquireInfoINTEL,
}
impl Builder<'_> for vk::PerformanceConfigurationAcquireInfoINTEL {
    type Type = PerformanceConfigurationAcquireInfoINTELBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PerformanceConfigurationAcquireInfoINTELBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PerformanceConfigurationAcquireInfoINTEL {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ty(mut self, ty: vk::PerformanceConfigurationTypeINTEL) -> Self {
        self.inner.ty = ty;
        self
    }
}
impl Deref for PerformanceConfigurationAcquireInfoINTELBuilder {
    type Target = vk::PerformanceConfigurationAcquireInfoINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderClockFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceShaderClockFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceShaderClockFeaturesKHR {
    type Type = PhysicalDeviceShaderClockFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderClockFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderClockFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_subgroup_clock(mut self, shader_subgroup_clock: bool) -> Self {
        self.inner.shader_subgroup_clock = if shader_subgroup_clock { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_device_clock(mut self, shader_device_clock: bool) -> Self {
        self.inner.shader_device_clock = if shader_device_clock { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceShaderClockFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceShaderClockFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderClockFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderClockFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderClockFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderClockFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceIndexTypeUint8FeaturesBuilder {
    inner: vk::PhysicalDeviceIndexTypeUint8Features,
}
impl Builder<'_> for vk::PhysicalDeviceIndexTypeUint8Features {
    type Type = PhysicalDeviceIndexTypeUint8FeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceIndexTypeUint8FeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceIndexTypeUint8Features {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn index_type_uint8(mut self, index_type_uint8: bool) -> Self {
        self.inner.index_type_uint8 = if index_type_uint8 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceIndexTypeUint8FeaturesBuilder {
    type Target = vk::PhysicalDeviceIndexTypeUint8Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceIndexTypeUint8Features {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceIndexTypeUint8FeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceIndexTypeUint8Features {}
impl DeviceCreateInfoNext for PhysicalDeviceIndexTypeUint8FeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceShaderSMBuiltinsPropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder {
    inner: vk::PhysicalDeviceShaderSMBuiltinsFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceShaderSMBuiltinsFeaturesNV {
    type Type = PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderSMBuiltinsFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_sm_builtins(mut self, shader_sm_builtins: bool) -> Self {
        self.inner.shader_sm_builtins = if shader_sm_builtins { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceShaderSMBuiltinsFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderSMBuiltinsFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderSMBuiltinsFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceFragmentShaderInterlockFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    type Type = PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn fragment_shader_sample_interlock(mut self, fragment_shader_sample_interlock: bool) -> Self {
        self.inner.fragment_shader_sample_interlock = if fragment_shader_sample_interlock {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn fragment_shader_pixel_interlock(mut self, fragment_shader_pixel_interlock: bool) -> Self {
        self.inner.fragment_shader_pixel_interlock = if fragment_shader_pixel_interlock {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn fragment_shader_shading_rate_interlock(mut self, fragment_shader_shading_rate_interlock: bool) -> Self {
        self.inner.fragment_shader_shading_rate_interlock = if fragment_shader_shading_rate_interlock {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceFragmentShaderInterlockFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceFragmentShaderInterlockFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceFragmentShaderInterlockFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder {
    inner: vk::PhysicalDeviceSeparateDepthStencilLayoutsFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    type Type = PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn separate_depth_stencil_layouts(mut self, separate_depth_stencil_layouts: bool) -> Self {
        self.inner.separate_depth_stencil_layouts = if separate_depth_stencil_layouts {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder {
    type Target = vk::PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceSeparateDepthStencilLayoutsFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceSeparateDepthStencilLayoutsFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct AttachmentReferenceStencilLayoutBuilder {
    inner: vk::AttachmentReferenceStencilLayout,
}
impl Builder<'_> for vk::AttachmentReferenceStencilLayout {
    type Type = AttachmentReferenceStencilLayoutBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AttachmentReferenceStencilLayoutBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AttachmentReferenceStencilLayout {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn stencil_layout(mut self, stencil_layout: vk::ImageLayout) -> Self {
        self.inner.stencil_layout = stencil_layout;
        self
    }
}
impl Deref for AttachmentReferenceStencilLayoutBuilder {
    type Target = vk::AttachmentReferenceStencilLayout;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl AttachmentReference2Next for vk::AttachmentReferenceStencilLayout {}
impl AttachmentReference2Next for AttachmentReferenceStencilLayoutBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePrimitiveTopologyListRestartFeaturesEXTBuilder {
    inner: vk::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
    type Type = PhysicalDevicePrimitiveTopologyListRestartFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePrimitiveTopologyListRestartFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn primitive_topology_list_restart(mut self, primitive_topology_list_restart: bool) -> Self {
        self.inner.primitive_topology_list_restart = if primitive_topology_list_restart {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn primitive_topology_patch_list_restart(mut self, primitive_topology_patch_list_restart: bool) -> Self {
        self.inner.primitive_topology_patch_list_restart = if primitive_topology_patch_list_restart {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXTBuilder {
    type Target = vk::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct AttachmentDescriptionStencilLayoutBuilder {
    inner: vk::AttachmentDescriptionStencilLayout,
}
impl Builder<'_> for vk::AttachmentDescriptionStencilLayout {
    type Type = AttachmentDescriptionStencilLayoutBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AttachmentDescriptionStencilLayoutBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AttachmentDescriptionStencilLayout {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn stencil_initial_layout(mut self, stencil_initial_layout: vk::ImageLayout) -> Self {
        self.inner.stencil_initial_layout = stencil_initial_layout;
        self
    }
    pub fn stencil_final_layout(mut self, stencil_final_layout: vk::ImageLayout) -> Self {
        self.inner.stencil_final_layout = stencil_final_layout;
        self
    }
}
impl Deref for AttachmentDescriptionStencilLayoutBuilder {
    type Target = vk::AttachmentDescriptionStencilLayout;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl AttachmentDescription2Next for vk::AttachmentDescriptionStencilLayout {}
impl AttachmentDescription2Next for AttachmentDescriptionStencilLayoutBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder {
    inner: vk::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    type Type = PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline_executable_info(mut self, pipeline_executable_info: bool) -> Self {
        self.inner.pipeline_executable_info = if pipeline_executable_info { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder {
    type Target = vk::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineInfoKHRBuilder {
    inner: vk::PipelineInfoKHR,
}
impl Builder<'_> for vk::PipelineInfoKHR {
    type Type = PipelineInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline(mut self, pipeline: vk::Pipeline) -> Self {
        self.inner.pipeline = pipeline;
        self
    }
}
impl Deref for PipelineInfoKHRBuilder {
    type Target = vk::PipelineInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineExecutableInfoKHRBuilder {
    inner: vk::PipelineExecutableInfoKHR,
}
impl Builder<'_> for vk::PipelineExecutableInfoKHR {
    type Type = PipelineExecutableInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineExecutableInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineExecutableInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline(mut self, pipeline: vk::Pipeline) -> Self {
        self.inner.pipeline = pipeline;
        self
    }
    pub fn executable_index(mut self, executable_index: u32) -> Self {
        self.inner.executable_index = executable_index;
        self
    }
}
impl Deref for PipelineExecutableInfoKHRBuilder {
    type Target = vk::PipelineExecutableInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder {
    inner: vk::PhysicalDeviceShaderDemoteToHelperInvocationFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    type Type = PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_demote_to_helper_invocation(mut self, shader_demote_to_helper_invocation: bool) -> Self {
        self.inner.shader_demote_to_helper_invocation = if shader_demote_to_helper_invocation {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder {
    type Target = vk::PhysicalDeviceShaderDemoteToHelperInvocationFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderDemoteToHelperInvocationFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderDemoteToHelperInvocationFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceTexelBufferAlignmentFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    type Type = PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn texel_buffer_alignment(mut self, texel_buffer_alignment: bool) -> Self {
        self.inner.texel_buffer_alignment = if texel_buffer_alignment { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceTexelBufferAlignmentFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceTexelBufferAlignmentFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceTexelBufferAlignmentFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceTexelBufferAlignmentProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceSubgroupSizeControlFeaturesBuilder {
    inner: vk::PhysicalDeviceSubgroupSizeControlFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceSubgroupSizeControlFeatures {
    type Type = PhysicalDeviceSubgroupSizeControlFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceSubgroupSizeControlFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceSubgroupSizeControlFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn subgroup_size_control(mut self, subgroup_size_control: bool) -> Self {
        self.inner.subgroup_size_control = if subgroup_size_control { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn compute_full_subgroups(mut self, compute_full_subgroups: bool) -> Self {
        self.inner.compute_full_subgroups = if compute_full_subgroups { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceSubgroupSizeControlFeaturesBuilder {
    type Target = vk::PhysicalDeviceSubgroupSizeControlFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceSubgroupSizeControlFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceSubgroupSizeControlFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceSubgroupSizeControlFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceSubgroupSizeControlFeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceSubgroupSizeControlProperties {}
impl PipelineShaderStageCreateInfoNext for vk::PipelineShaderStageRequiredSubgroupSizeCreateInfo {}
impl ShaderCreateInfoEXTNext for vk::PipelineShaderStageRequiredSubgroupSizeCreateInfo {}

#[repr(transparent)]
#[derive(Default)]
pub struct SubpassShadingPipelineCreateInfoHUAWEIBuilder {
    inner: vk::SubpassShadingPipelineCreateInfoHUAWEI,
}
impl Builder<'_> for vk::SubpassShadingPipelineCreateInfoHUAWEI {
    type Type = SubpassShadingPipelineCreateInfoHUAWEIBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SubpassShadingPipelineCreateInfoHUAWEIBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SubpassShadingPipelineCreateInfoHUAWEI {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn render_pass(mut self, render_pass: vk::RenderPass) -> Self {
        self.inner.render_pass = render_pass;
        self
    }
    pub fn subpass(mut self, subpass: u32) -> Self {
        self.inner.subpass = subpass;
        self
    }
}
impl Deref for SubpassShadingPipelineCreateInfoHUAWEIBuilder {
    type Target = vk::SubpassShadingPipelineCreateInfoHUAWEI;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ComputePipelineCreateInfoNext for vk::SubpassShadingPipelineCreateInfoHUAWEI {}
impl ComputePipelineCreateInfoNext for SubpassShadingPipelineCreateInfoHUAWEIBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceSubpassShadingPropertiesHUAWEI {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceClusterCullingShaderPropertiesHUAWEI {}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryOpaqueCaptureAddressAllocateInfoBuilder {
    inner: vk::MemoryOpaqueCaptureAddressAllocateInfo,
}
impl Builder<'_> for vk::MemoryOpaqueCaptureAddressAllocateInfo {
    type Type = MemoryOpaqueCaptureAddressAllocateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryOpaqueCaptureAddressAllocateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryOpaqueCaptureAddressAllocateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn opaque_capture_address(mut self, opaque_capture_address: u64) -> Self {
        self.inner.opaque_capture_address = opaque_capture_address;
        self
    }
}
impl Deref for MemoryOpaqueCaptureAddressAllocateInfoBuilder {
    type Target = vk::MemoryOpaqueCaptureAddressAllocateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::MemoryOpaqueCaptureAddressAllocateInfo {}
impl MemoryAllocateInfoNext for MemoryOpaqueCaptureAddressAllocateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceMemoryOpaqueCaptureAddressInfoBuilder {
    inner: vk::DeviceMemoryOpaqueCaptureAddressInfo,
}
impl Builder<'_> for vk::DeviceMemoryOpaqueCaptureAddressInfo {
    type Type = DeviceMemoryOpaqueCaptureAddressInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceMemoryOpaqueCaptureAddressInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceMemoryOpaqueCaptureAddressInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
}
impl Deref for DeviceMemoryOpaqueCaptureAddressInfoBuilder {
    type Target = vk::DeviceMemoryOpaqueCaptureAddressInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceLineRasterizationFeaturesBuilder {
    inner: vk::PhysicalDeviceLineRasterizationFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceLineRasterizationFeatures {
    type Type = PhysicalDeviceLineRasterizationFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceLineRasterizationFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceLineRasterizationFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn rectangular_lines(mut self, rectangular_lines: bool) -> Self {
        self.inner.rectangular_lines = if rectangular_lines { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn bresenham_lines(mut self, bresenham_lines: bool) -> Self {
        self.inner.bresenham_lines = if bresenham_lines { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn smooth_lines(mut self, smooth_lines: bool) -> Self {
        self.inner.smooth_lines = if smooth_lines { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn stippled_rectangular_lines(mut self, stippled_rectangular_lines: bool) -> Self {
        self.inner.stippled_rectangular_lines = if stippled_rectangular_lines {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn stippled_bresenham_lines(mut self, stippled_bresenham_lines: bool) -> Self {
        self.inner.stippled_bresenham_lines = if stippled_bresenham_lines { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn stippled_smooth_lines(mut self, stippled_smooth_lines: bool) -> Self {
        self.inner.stippled_smooth_lines = if stippled_smooth_lines { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceLineRasterizationFeaturesBuilder {
    type Target = vk::PhysicalDeviceLineRasterizationFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceLineRasterizationFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceLineRasterizationFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceLineRasterizationFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceLineRasterizationFeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceLineRasterizationProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineRasterizationLineStateCreateInfoBuilder {
    inner: vk::PipelineRasterizationLineStateCreateInfo,
}
impl Builder<'_> for vk::PipelineRasterizationLineStateCreateInfo {
    type Type = PipelineRasterizationLineStateCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineRasterizationLineStateCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineRasterizationLineStateCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn line_rasterization_mode(mut self, line_rasterization_mode: vk::LineRasterizationMode) -> Self {
        self.inner.line_rasterization_mode = line_rasterization_mode;
        self
    }
    pub fn stippled_line_enable(mut self, stippled_line_enable: bool) -> Self {
        self.inner.stippled_line_enable = if stippled_line_enable { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn line_stipple_factor(mut self, line_stipple_factor: u32) -> Self {
        self.inner.line_stipple_factor = line_stipple_factor;
        self
    }
    pub fn line_stipple_pattern(mut self, line_stipple_pattern: u16) -> Self {
        self.inner.line_stipple_pattern = line_stipple_pattern;
        self
    }
}
impl Deref for PipelineRasterizationLineStateCreateInfoBuilder {
    type Target = vk::PipelineRasterizationLineStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineRasterizationStateCreateInfoNext for vk::PipelineRasterizationLineStateCreateInfo {}
impl PipelineRasterizationStateCreateInfoNext for PipelineRasterizationLineStateCreateInfoBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePipelineCreationCacheControlFeaturesBuilder {
    inner: vk::PhysicalDevicePipelineCreationCacheControlFeatures,
}
impl Builder<'_> for vk::PhysicalDevicePipelineCreationCacheControlFeatures {
    type Type = PhysicalDevicePipelineCreationCacheControlFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePipelineCreationCacheControlFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePipelineCreationCacheControlFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline_creation_cache_control(mut self, pipeline_creation_cache_control: bool) -> Self {
        self.inner.pipeline_creation_cache_control = if pipeline_creation_cache_control {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDevicePipelineCreationCacheControlFeaturesBuilder {
    type Target = vk::PhysicalDevicePipelineCreationCacheControlFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePipelineCreationCacheControlFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePipelineCreationCacheControlFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePipelineCreationCacheControlFeatures {}
impl DeviceCreateInfoNext for PhysicalDevicePipelineCreationCacheControlFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceVulkan11FeaturesBuilder {
    inner: vk::PhysicalDeviceVulkan11Features,
}
impl Builder<'_> for vk::PhysicalDeviceVulkan11Features {
    type Type = PhysicalDeviceVulkan11FeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceVulkan11FeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceVulkan11Features {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn storage_buffer16_bit_access(mut self, storage_buffer16_bit_access: bool) -> Self {
        self.inner.storage_buffer16_bit_access = if storage_buffer16_bit_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn uniform_and_storage_buffer16_bit_access(mut self, uniform_and_storage_buffer16_bit_access: bool) -> Self {
        self.inner.uniform_and_storage_buffer16_bit_access = if uniform_and_storage_buffer16_bit_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn storage_push_constant16(mut self, storage_push_constant16: bool) -> Self {
        self.inner.storage_push_constant16 = if storage_push_constant16 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn storage_input_output16(mut self, storage_input_output16: bool) -> Self {
        self.inner.storage_input_output16 = if storage_input_output16 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn multiview(mut self, multiview: bool) -> Self {
        self.inner.multiview = if multiview { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn multiview_geometry_shader(mut self, multiview_geometry_shader: bool) -> Self {
        self.inner.multiview_geometry_shader = if multiview_geometry_shader { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn multiview_tessellation_shader(mut self, multiview_tessellation_shader: bool) -> Self {
        self.inner.multiview_tessellation_shader = if multiview_tessellation_shader {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn variable_pointers_storage_buffer(mut self, variable_pointers_storage_buffer: bool) -> Self {
        self.inner.variable_pointers_storage_buffer = if variable_pointers_storage_buffer {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn variable_pointers(mut self, variable_pointers: bool) -> Self {
        self.inner.variable_pointers = if variable_pointers { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn protected_memory(mut self, protected_memory: bool) -> Self {
        self.inner.protected_memory = if protected_memory { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sampler_ycbcr_conversion(mut self, sampler_ycbcr_conversion: bool) -> Self {
        self.inner.sampler_ycbcr_conversion = if sampler_ycbcr_conversion { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_draw_parameters(mut self, shader_draw_parameters: bool) -> Self {
        self.inner.shader_draw_parameters = if shader_draw_parameters { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceVulkan11FeaturesBuilder {
    type Target = vk::PhysicalDeviceVulkan11Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceVulkan11Features {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceVulkan11FeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceVulkan11Features {}
impl DeviceCreateInfoNext for PhysicalDeviceVulkan11FeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceVulkan11Properties {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceVulkan12FeaturesBuilder {
    inner: vk::PhysicalDeviceVulkan12Features,
}
impl Builder<'_> for vk::PhysicalDeviceVulkan12Features {
    type Type = PhysicalDeviceVulkan12FeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceVulkan12FeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceVulkan12Features {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn sampler_mirror_clamp_to_edge(mut self, sampler_mirror_clamp_to_edge: bool) -> Self {
        self.inner.sampler_mirror_clamp_to_edge = if sampler_mirror_clamp_to_edge {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn draw_indirect_count(mut self, draw_indirect_count: bool) -> Self {
        self.inner.draw_indirect_count = if draw_indirect_count { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn storage_buffer8_bit_access(mut self, storage_buffer8_bit_access: bool) -> Self {
        self.inner.storage_buffer8_bit_access = if storage_buffer8_bit_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn uniform_and_storage_buffer8_bit_access(mut self, uniform_and_storage_buffer8_bit_access: bool) -> Self {
        self.inner.uniform_and_storage_buffer8_bit_access = if uniform_and_storage_buffer8_bit_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn storage_push_constant8(mut self, storage_push_constant8: bool) -> Self {
        self.inner.storage_push_constant8 = if storage_push_constant8 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_buffer_int64_atomics(mut self, shader_buffer_int64_atomics: bool) -> Self {
        self.inner.shader_buffer_int64_atomics = if shader_buffer_int64_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_shared_int64_atomics(mut self, shader_shared_int64_atomics: bool) -> Self {
        self.inner.shader_shared_int64_atomics = if shader_shared_int64_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_float16(mut self, shader_float16: bool) -> Self {
        self.inner.shader_float16 = if shader_float16 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_int8(mut self, shader_int8: bool) -> Self {
        self.inner.shader_int8 = if shader_int8 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn descriptor_indexing(mut self, descriptor_indexing: bool) -> Self {
        self.inner.descriptor_indexing = if descriptor_indexing { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_input_attachment_array_dynamic_indexing(
        mut self,
        shader_input_attachment_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_input_attachment_array_dynamic_indexing = if shader_input_attachment_array_dynamic_indexing {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_uniform_texel_buffer_array_dynamic_indexing(
        mut self,
        shader_uniform_texel_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_uniform_texel_buffer_array_dynamic_indexing =
            if shader_uniform_texel_buffer_array_dynamic_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn shader_storage_texel_buffer_array_dynamic_indexing(
        mut self,
        shader_storage_texel_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_texel_buffer_array_dynamic_indexing =
            if shader_storage_texel_buffer_array_dynamic_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn shader_uniform_buffer_array_non_uniform_indexing(
        mut self,
        shader_uniform_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_uniform_buffer_array_non_uniform_indexing =
            if shader_uniform_buffer_array_non_uniform_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn shader_sampled_image_array_non_uniform_indexing(
        mut self,
        shader_sampled_image_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_sampled_image_array_non_uniform_indexing = if shader_sampled_image_array_non_uniform_indexing
        {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_storage_buffer_array_non_uniform_indexing(
        mut self,
        shader_storage_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_buffer_array_non_uniform_indexing =
            if shader_storage_buffer_array_non_uniform_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn shader_storage_image_array_non_uniform_indexing(
        mut self,
        shader_storage_image_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_image_array_non_uniform_indexing = if shader_storage_image_array_non_uniform_indexing
        {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_input_attachment_array_non_uniform_indexing(
        mut self,
        shader_input_attachment_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_input_attachment_array_non_uniform_indexing =
            if shader_input_attachment_array_non_uniform_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn shader_uniform_texel_buffer_array_non_uniform_indexing(
        mut self,
        shader_uniform_texel_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_uniform_texel_buffer_array_non_uniform_indexing =
            if shader_uniform_texel_buffer_array_non_uniform_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn shader_storage_texel_buffer_array_non_uniform_indexing(
        mut self,
        shader_storage_texel_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_texel_buffer_array_non_uniform_indexing =
            if shader_storage_texel_buffer_array_non_uniform_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_uniform_buffer_update_after_bind(
        mut self,
        descriptor_binding_uniform_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_uniform_buffer_update_after_bind =
            if descriptor_binding_uniform_buffer_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_sampled_image_update_after_bind(
        mut self,
        descriptor_binding_sampled_image_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_sampled_image_update_after_bind =
            if descriptor_binding_sampled_image_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_storage_image_update_after_bind(
        mut self,
        descriptor_binding_storage_image_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_storage_image_update_after_bind =
            if descriptor_binding_storage_image_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_storage_buffer_update_after_bind(
        mut self,
        descriptor_binding_storage_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_storage_buffer_update_after_bind =
            if descriptor_binding_storage_buffer_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_uniform_texel_buffer_update_after_bind(
        mut self,
        descriptor_binding_uniform_texel_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_uniform_texel_buffer_update_after_bind =
            if descriptor_binding_uniform_texel_buffer_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_storage_texel_buffer_update_after_bind(
        mut self,
        descriptor_binding_storage_texel_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_storage_texel_buffer_update_after_bind =
            if descriptor_binding_storage_texel_buffer_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_update_unused_while_pending(
        mut self,
        descriptor_binding_update_unused_while_pending: bool,
    ) -> Self {
        self.inner.descriptor_binding_update_unused_while_pending = if descriptor_binding_update_unused_while_pending {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn descriptor_binding_partially_bound(mut self, descriptor_binding_partially_bound: bool) -> Self {
        self.inner.descriptor_binding_partially_bound = if descriptor_binding_partially_bound {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn descriptor_binding_variable_descriptor_count(
        mut self,
        descriptor_binding_variable_descriptor_count: bool,
    ) -> Self {
        self.inner.descriptor_binding_variable_descriptor_count = if descriptor_binding_variable_descriptor_count {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn runtime_descriptor_array(mut self, runtime_descriptor_array: bool) -> Self {
        self.inner.runtime_descriptor_array = if runtime_descriptor_array { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sampler_filter_minmax(mut self, sampler_filter_minmax: bool) -> Self {
        self.inner.sampler_filter_minmax = if sampler_filter_minmax { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn scalar_block_layout(mut self, scalar_block_layout: bool) -> Self {
        self.inner.scalar_block_layout = if scalar_block_layout { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn imageless_framebuffer(mut self, imageless_framebuffer: bool) -> Self {
        self.inner.imageless_framebuffer = if imageless_framebuffer { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn uniform_buffer_standard_layout(mut self, uniform_buffer_standard_layout: bool) -> Self {
        self.inner.uniform_buffer_standard_layout = if uniform_buffer_standard_layout {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_subgroup_extended_types(mut self, shader_subgroup_extended_types: bool) -> Self {
        self.inner.shader_subgroup_extended_types = if shader_subgroup_extended_types {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn separate_depth_stencil_layouts(mut self, separate_depth_stencil_layouts: bool) -> Self {
        self.inner.separate_depth_stencil_layouts = if separate_depth_stencil_layouts {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn host_query_reset(mut self, host_query_reset: bool) -> Self {
        self.inner.host_query_reset = if host_query_reset { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn timeline_semaphore(mut self, timeline_semaphore: bool) -> Self {
        self.inner.timeline_semaphore = if timeline_semaphore { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn buffer_device_address(mut self, buffer_device_address: bool) -> Self {
        self.inner.buffer_device_address = if buffer_device_address { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn buffer_device_address_capture_replay(mut self, buffer_device_address_capture_replay: bool) -> Self {
        self.inner.buffer_device_address_capture_replay = if buffer_device_address_capture_replay {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn buffer_device_address_multi_device(mut self, buffer_device_address_multi_device: bool) -> Self {
        self.inner.buffer_device_address_multi_device = if buffer_device_address_multi_device {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn vulkan_memory_model(mut self, vulkan_memory_model: bool) -> Self {
        self.inner.vulkan_memory_model = if vulkan_memory_model { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn vulkan_memory_model_device_scope(mut self, vulkan_memory_model_device_scope: bool) -> Self {
        self.inner.vulkan_memory_model_device_scope = if vulkan_memory_model_device_scope {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn vulkan_memory_model_availability_visibility_chains(
        mut self,
        vulkan_memory_model_availability_visibility_chains: bool,
    ) -> Self {
        self.inner.vulkan_memory_model_availability_visibility_chains =
            if vulkan_memory_model_availability_visibility_chains {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn shader_output_viewport_index(mut self, shader_output_viewport_index: bool) -> Self {
        self.inner.shader_output_viewport_index = if shader_output_viewport_index {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_output_layer(mut self, shader_output_layer: bool) -> Self {
        self.inner.shader_output_layer = if shader_output_layer { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn subgroup_broadcast_dynamic_id(mut self, subgroup_broadcast_dynamic_id: bool) -> Self {
        self.inner.subgroup_broadcast_dynamic_id = if subgroup_broadcast_dynamic_id {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceVulkan12FeaturesBuilder {
    type Target = vk::PhysicalDeviceVulkan12Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceVulkan12Features {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceVulkan12FeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceVulkan12Features {}
impl DeviceCreateInfoNext for PhysicalDeviceVulkan12FeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceVulkan12Properties {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceVulkan13FeaturesBuilder {
    inner: vk::PhysicalDeviceVulkan13Features,
}
impl Builder<'_> for vk::PhysicalDeviceVulkan13Features {
    type Type = PhysicalDeviceVulkan13FeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceVulkan13FeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceVulkan13Features {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn robust_image_access(mut self, robust_image_access: bool) -> Self {
        self.inner.robust_image_access = if robust_image_access { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn inline_uniform_block(mut self, inline_uniform_block: bool) -> Self {
        self.inner.inline_uniform_block = if inline_uniform_block { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn descriptor_binding_inline_uniform_block_update_after_bind(
        mut self,
        descriptor_binding_inline_uniform_block_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_inline_uniform_block_update_after_bind =
            if descriptor_binding_inline_uniform_block_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn pipeline_creation_cache_control(mut self, pipeline_creation_cache_control: bool) -> Self {
        self.inner.pipeline_creation_cache_control = if pipeline_creation_cache_control {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn private_data(mut self, private_data: bool) -> Self {
        self.inner.private_data = if private_data { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_demote_to_helper_invocation(mut self, shader_demote_to_helper_invocation: bool) -> Self {
        self.inner.shader_demote_to_helper_invocation = if shader_demote_to_helper_invocation {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_terminate_invocation(mut self, shader_terminate_invocation: bool) -> Self {
        self.inner.shader_terminate_invocation = if shader_terminate_invocation {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn subgroup_size_control(mut self, subgroup_size_control: bool) -> Self {
        self.inner.subgroup_size_control = if subgroup_size_control { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn compute_full_subgroups(mut self, compute_full_subgroups: bool) -> Self {
        self.inner.compute_full_subgroups = if compute_full_subgroups { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn synchronization2(mut self, synchronization2: bool) -> Self {
        self.inner.synchronization2 = if synchronization2 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn texture_compression_astc_hdr(mut self, texture_compression_astc_hdr: bool) -> Self {
        self.inner.texture_compression_astc_hdr = if texture_compression_astc_hdr {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_zero_initialize_workgroup_memory(mut self, shader_zero_initialize_workgroup_memory: bool) -> Self {
        self.inner.shader_zero_initialize_workgroup_memory = if shader_zero_initialize_workgroup_memory {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn dynamic_rendering(mut self, dynamic_rendering: bool) -> Self {
        self.inner.dynamic_rendering = if dynamic_rendering { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_integer_dot_product(mut self, shader_integer_dot_product: bool) -> Self {
        self.inner.shader_integer_dot_product = if shader_integer_dot_product {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn maintenance4(mut self, maintenance4: bool) -> Self {
        self.inner.maintenance4 = if maintenance4 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceVulkan13FeaturesBuilder {
    type Target = vk::PhysicalDeviceVulkan13Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceVulkan13Features {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceVulkan13FeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceVulkan13Features {}
impl DeviceCreateInfoNext for PhysicalDeviceVulkan13FeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceVulkan13Properties {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceVulkan14FeaturesBuilder {
    inner: vk::PhysicalDeviceVulkan14Features,
}
impl Builder<'_> for vk::PhysicalDeviceVulkan14Features {
    type Type = PhysicalDeviceVulkan14FeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceVulkan14FeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceVulkan14Features {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn global_priority_query(mut self, global_priority_query: bool) -> Self {
        self.inner.global_priority_query = if global_priority_query { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_subgroup_rotate(mut self, shader_subgroup_rotate: bool) -> Self {
        self.inner.shader_subgroup_rotate = if shader_subgroup_rotate { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_subgroup_rotate_clustered(mut self, shader_subgroup_rotate_clustered: bool) -> Self {
        self.inner.shader_subgroup_rotate_clustered = if shader_subgroup_rotate_clustered {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_float_controls2(mut self, shader_float_controls2: bool) -> Self {
        self.inner.shader_float_controls2 = if shader_float_controls2 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_expect_assume(mut self, shader_expect_assume: bool) -> Self {
        self.inner.shader_expect_assume = if shader_expect_assume { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn rectangular_lines(mut self, rectangular_lines: bool) -> Self {
        self.inner.rectangular_lines = if rectangular_lines { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn bresenham_lines(mut self, bresenham_lines: bool) -> Self {
        self.inner.bresenham_lines = if bresenham_lines { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn smooth_lines(mut self, smooth_lines: bool) -> Self {
        self.inner.smooth_lines = if smooth_lines { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn stippled_rectangular_lines(mut self, stippled_rectangular_lines: bool) -> Self {
        self.inner.stippled_rectangular_lines = if stippled_rectangular_lines {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn stippled_bresenham_lines(mut self, stippled_bresenham_lines: bool) -> Self {
        self.inner.stippled_bresenham_lines = if stippled_bresenham_lines { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn stippled_smooth_lines(mut self, stippled_smooth_lines: bool) -> Self {
        self.inner.stippled_smooth_lines = if stippled_smooth_lines { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn vertex_attribute_instance_rate_divisor(mut self, vertex_attribute_instance_rate_divisor: bool) -> Self {
        self.inner.vertex_attribute_instance_rate_divisor = if vertex_attribute_instance_rate_divisor {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn vertex_attribute_instance_rate_zero_divisor(
        mut self,
        vertex_attribute_instance_rate_zero_divisor: bool,
    ) -> Self {
        self.inner.vertex_attribute_instance_rate_zero_divisor = if vertex_attribute_instance_rate_zero_divisor {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn index_type_uint8(mut self, index_type_uint8: bool) -> Self {
        self.inner.index_type_uint8 = if index_type_uint8 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn dynamic_rendering_local_read(mut self, dynamic_rendering_local_read: bool) -> Self {
        self.inner.dynamic_rendering_local_read = if dynamic_rendering_local_read {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn maintenance5(mut self, maintenance5: bool) -> Self {
        self.inner.maintenance5 = if maintenance5 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn maintenance6(mut self, maintenance6: bool) -> Self {
        self.inner.maintenance6 = if maintenance6 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn pipeline_protected_access(mut self, pipeline_protected_access: bool) -> Self {
        self.inner.pipeline_protected_access = if pipeline_protected_access { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn pipeline_robustness(mut self, pipeline_robustness: bool) -> Self {
        self.inner.pipeline_robustness = if pipeline_robustness { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn host_image_copy(mut self, host_image_copy: bool) -> Self {
        self.inner.host_image_copy = if host_image_copy { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn push_descriptor(mut self, push_descriptor: bool) -> Self {
        self.inner.push_descriptor = if push_descriptor { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceVulkan14FeaturesBuilder {
    type Target = vk::PhysicalDeviceVulkan14Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceVulkan14Features {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceVulkan14FeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceVulkan14Features {}
impl DeviceCreateInfoNext for PhysicalDeviceVulkan14FeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceVulkan14Properties {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineCompilerControlCreateInfoAMDBuilder {
    inner: vk::PipelineCompilerControlCreateInfoAMD,
}
impl Builder<'_> for vk::PipelineCompilerControlCreateInfoAMD {
    type Type = PipelineCompilerControlCreateInfoAMDBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineCompilerControlCreateInfoAMDBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineCompilerControlCreateInfoAMD {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn compiler_control_flags(mut self, compiler_control_flags: vk::PipelineCompilerControlFlagsAMD) -> Self {
        self.inner.compiler_control_flags = compiler_control_flags;
        self
    }
}
impl Deref for PipelineCompilerControlCreateInfoAMDBuilder {
    type Target = vk::PipelineCompilerControlCreateInfoAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::PipelineCompilerControlCreateInfoAMD {}
impl GraphicsPipelineCreateInfoNext for PipelineCompilerControlCreateInfoAMDBuilder {}
impl ComputePipelineCreateInfoNext for vk::PipelineCompilerControlCreateInfoAMD {}
impl ComputePipelineCreateInfoNext for PipelineCompilerControlCreateInfoAMDBuilder {}
impl ExecutionGraphPipelineCreateInfoAMDXNext for vk::PipelineCompilerControlCreateInfoAMD {}
impl ExecutionGraphPipelineCreateInfoAMDXNext for PipelineCompilerControlCreateInfoAMDBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceCoherentMemoryFeaturesAMDBuilder {
    inner: vk::PhysicalDeviceCoherentMemoryFeaturesAMD,
}
impl Builder<'_> for vk::PhysicalDeviceCoherentMemoryFeaturesAMD {
    type Type = PhysicalDeviceCoherentMemoryFeaturesAMDBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceCoherentMemoryFeaturesAMDBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceCoherentMemoryFeaturesAMD {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn device_coherent_memory(mut self, device_coherent_memory: bool) -> Self {
        self.inner.device_coherent_memory = if device_coherent_memory { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceCoherentMemoryFeaturesAMDBuilder {
    type Target = vk::PhysicalDeviceCoherentMemoryFeaturesAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceCoherentMemoryFeaturesAMD {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceCoherentMemoryFeaturesAMDBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceCoherentMemoryFeaturesAMD {}
impl DeviceCreateInfoNext for PhysicalDeviceCoherentMemoryFeaturesAMDBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SamplerCustomBorderColorCreateInfoEXTBuilder {
    inner: vk::SamplerCustomBorderColorCreateInfoEXT,
}
impl Builder<'_> for vk::SamplerCustomBorderColorCreateInfoEXT {
    type Type = SamplerCustomBorderColorCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SamplerCustomBorderColorCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SamplerCustomBorderColorCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn custom_border_color(mut self, custom_border_color: vk::ClearColorValue) -> Self {
        self.inner.custom_border_color = custom_border_color;
        self
    }
    pub fn format(mut self, format: vk::Format) -> Self {
        self.inner.format = format;
        self
    }
}
impl Deref for SamplerCustomBorderColorCreateInfoEXTBuilder {
    type Target = vk::SamplerCustomBorderColorCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SamplerCreateInfoNext for vk::SamplerCustomBorderColorCreateInfoEXT {}
impl SamplerCreateInfoNext for SamplerCustomBorderColorCreateInfoEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceCustomBorderColorPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceCustomBorderColorFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceCustomBorderColorFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceCustomBorderColorFeaturesEXT {
    type Type = PhysicalDeviceCustomBorderColorFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceCustomBorderColorFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceCustomBorderColorFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn custom_border_colors(mut self, custom_border_colors: bool) -> Self {
        self.inner.custom_border_colors = if custom_border_colors { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn custom_border_color_without_format(mut self, custom_border_color_without_format: bool) -> Self {
        self.inner.custom_border_color_without_format = if custom_border_color_without_format {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceCustomBorderColorFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceCustomBorderColorFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceCustomBorderColorFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceCustomBorderColorFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceCustomBorderColorFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceCustomBorderColorFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SamplerBorderColorComponentMappingCreateInfoEXTBuilder {
    inner: vk::SamplerBorderColorComponentMappingCreateInfoEXT,
}
impl Builder<'_> for vk::SamplerBorderColorComponentMappingCreateInfoEXT {
    type Type = SamplerBorderColorComponentMappingCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SamplerBorderColorComponentMappingCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SamplerBorderColorComponentMappingCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn components(mut self, components: vk::ComponentMapping) -> Self {
        self.inner.components = components;
        self
    }
    pub fn srgb(mut self, srgb: bool) -> Self {
        self.inner.srgb = if srgb { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for SamplerBorderColorComponentMappingCreateInfoEXTBuilder {
    type Target = vk::SamplerBorderColorComponentMappingCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SamplerCreateInfoNext for vk::SamplerBorderColorComponentMappingCreateInfoEXT {}
impl SamplerCreateInfoNext for SamplerBorderColorComponentMappingCreateInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceBorderColorSwizzleFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceBorderColorSwizzleFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceBorderColorSwizzleFeaturesEXT {
    type Type = PhysicalDeviceBorderColorSwizzleFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceBorderColorSwizzleFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceBorderColorSwizzleFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn border_color_swizzle(mut self, border_color_swizzle: bool) -> Self {
        self.inner.border_color_swizzle = if border_color_swizzle { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn border_color_swizzle_from_image(mut self, border_color_swizzle_from_image: bool) -> Self {
        self.inner.border_color_swizzle_from_image = if border_color_swizzle_from_image {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceBorderColorSwizzleFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceBorderColorSwizzleFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceBorderColorSwizzleFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceBorderColorSwizzleFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceBorderColorSwizzleFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceBorderColorSwizzleFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
    inner: vk::AccelerationStructureGeometryTrianglesDataKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AccelerationStructureGeometryTrianglesDataKHR {
    type Type = AccelerationStructureGeometryTrianglesDataKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait AccelerationStructureGeometryTrianglesDataKHRNext {}
impl<'a> AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
    pub fn insert_next<T: AccelerationStructureGeometryTrianglesDataKHRNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureGeometryTrianglesDataKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn vertex_format(mut self, vertex_format: vk::Format) -> Self {
        self.inner.vertex_format = vertex_format;
        self
    }
    pub fn vertex_data(mut self, vertex_data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.vertex_data = vertex_data;
        self
    }
    pub fn vertex_stride(mut self, vertex_stride: vk::DeviceSize) -> Self {
        self.inner.vertex_stride = vertex_stride;
        self
    }
    pub fn max_vertex(mut self, max_vertex: u32) -> Self {
        self.inner.max_vertex = max_vertex;
        self
    }
    pub fn index_type(mut self, index_type: vk::IndexType) -> Self {
        self.inner.index_type = index_type;
        self
    }
    pub fn index_data(mut self, index_data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.index_data = index_data;
        self
    }
    pub fn transform_data(mut self, transform_data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.transform_data = transform_data;
        self
    }
}
impl<'a> Deref for AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
    type Target = vk::AccelerationStructureGeometryTrianglesDataKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureGeometryAabbsDataKHRBuilder {
    inner: vk::AccelerationStructureGeometryAabbsDataKHR,
}
impl Builder<'_> for vk::AccelerationStructureGeometryAabbsDataKHR {
    type Type = AccelerationStructureGeometryAabbsDataKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AccelerationStructureGeometryAabbsDataKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureGeometryAabbsDataKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn data(mut self, data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.data = data;
        self
    }
    pub fn stride(mut self, stride: vk::DeviceSize) -> Self {
        self.inner.stride = stride;
        self
    }
}
impl Deref for AccelerationStructureGeometryAabbsDataKHRBuilder {
    type Target = vk::AccelerationStructureGeometryAabbsDataKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureGeometryInstancesDataKHRBuilder {
    inner: vk::AccelerationStructureGeometryInstancesDataKHR,
}
impl Builder<'_> for vk::AccelerationStructureGeometryInstancesDataKHR {
    type Type = AccelerationStructureGeometryInstancesDataKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AccelerationStructureGeometryInstancesDataKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureGeometryInstancesDataKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn array_of_pointers(mut self, array_of_pointers: bool) -> Self {
        self.inner.array_of_pointers = if array_of_pointers { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn data(mut self, data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.data = data;
        self
    }
}
impl Deref for AccelerationStructureGeometryInstancesDataKHRBuilder {
    type Target = vk::AccelerationStructureGeometryInstancesDataKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureGeometryLinearSweptSpheresDataNVBuilder {
    inner: vk::AccelerationStructureGeometryLinearSweptSpheresDataNV,
}
impl Builder<'_> for vk::AccelerationStructureGeometryLinearSweptSpheresDataNV {
    type Type = AccelerationStructureGeometryLinearSweptSpheresDataNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AccelerationStructureGeometryLinearSweptSpheresDataNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureGeometryLinearSweptSpheresDataNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn vertex_format(mut self, vertex_format: vk::Format) -> Self {
        self.inner.vertex_format = vertex_format;
        self
    }
    pub fn vertex_data(mut self, vertex_data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.vertex_data = vertex_data;
        self
    }
    pub fn vertex_stride(mut self, vertex_stride: vk::DeviceSize) -> Self {
        self.inner.vertex_stride = vertex_stride;
        self
    }
    pub fn radius_format(mut self, radius_format: vk::Format) -> Self {
        self.inner.radius_format = radius_format;
        self
    }
    pub fn radius_data(mut self, radius_data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.radius_data = radius_data;
        self
    }
    pub fn radius_stride(mut self, radius_stride: vk::DeviceSize) -> Self {
        self.inner.radius_stride = radius_stride;
        self
    }
    pub fn index_type(mut self, index_type: vk::IndexType) -> Self {
        self.inner.index_type = index_type;
        self
    }
    pub fn index_data(mut self, index_data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.index_data = index_data;
        self
    }
    pub fn index_stride(mut self, index_stride: vk::DeviceSize) -> Self {
        self.inner.index_stride = index_stride;
        self
    }
    pub fn indexing_mode(mut self, indexing_mode: vk::RayTracingLssIndexingModeNV) -> Self {
        self.inner.indexing_mode = indexing_mode;
        self
    }
    pub fn end_caps_mode(mut self, end_caps_mode: vk::RayTracingLssPrimitiveEndCapsModeNV) -> Self {
        self.inner.end_caps_mode = end_caps_mode;
        self
    }
}
impl Deref for AccelerationStructureGeometryLinearSweptSpheresDataNVBuilder {
    type Target = vk::AccelerationStructureGeometryLinearSweptSpheresDataNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl AccelerationStructureGeometryKHRNext for vk::AccelerationStructureGeometryLinearSweptSpheresDataNV {}
impl AccelerationStructureGeometryKHRNext for AccelerationStructureGeometryLinearSweptSpheresDataNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureGeometrySpheresDataNVBuilder {
    inner: vk::AccelerationStructureGeometrySpheresDataNV,
}
impl Builder<'_> for vk::AccelerationStructureGeometrySpheresDataNV {
    type Type = AccelerationStructureGeometrySpheresDataNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AccelerationStructureGeometrySpheresDataNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureGeometrySpheresDataNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn vertex_format(mut self, vertex_format: vk::Format) -> Self {
        self.inner.vertex_format = vertex_format;
        self
    }
    pub fn vertex_data(mut self, vertex_data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.vertex_data = vertex_data;
        self
    }
    pub fn vertex_stride(mut self, vertex_stride: vk::DeviceSize) -> Self {
        self.inner.vertex_stride = vertex_stride;
        self
    }
    pub fn radius_format(mut self, radius_format: vk::Format) -> Self {
        self.inner.radius_format = radius_format;
        self
    }
    pub fn radius_data(mut self, radius_data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.radius_data = radius_data;
        self
    }
    pub fn radius_stride(mut self, radius_stride: vk::DeviceSize) -> Self {
        self.inner.radius_stride = radius_stride;
        self
    }
    pub fn index_type(mut self, index_type: vk::IndexType) -> Self {
        self.inner.index_type = index_type;
        self
    }
    pub fn index_data(mut self, index_data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.index_data = index_data;
        self
    }
    pub fn index_stride(mut self, index_stride: vk::DeviceSize) -> Self {
        self.inner.index_stride = index_stride;
        self
    }
}
impl Deref for AccelerationStructureGeometrySpheresDataNVBuilder {
    type Target = vk::AccelerationStructureGeometrySpheresDataNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl AccelerationStructureGeometryKHRNext for vk::AccelerationStructureGeometrySpheresDataNV {}
impl AccelerationStructureGeometryKHRNext for AccelerationStructureGeometrySpheresDataNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureGeometryKHRBuilder<'a> {
    inner: vk::AccelerationStructureGeometryKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AccelerationStructureGeometryKHR {
    type Type = AccelerationStructureGeometryKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait AccelerationStructureGeometryKHRNext {}
impl<'a> AccelerationStructureGeometryKHRBuilder<'a> {
    pub fn insert_next<T: AccelerationStructureGeometryKHRNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureGeometryKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn geometry_type(mut self, geometry_type: vk::GeometryTypeKHR) -> Self {
        self.inner.geometry_type = geometry_type;
        self
    }
    pub fn geometry(mut self, geometry: vk::AccelerationStructureGeometryDataKHR) -> Self {
        self.inner.geometry = geometry;
        self
    }
    pub fn flags(mut self, flags: vk::GeometryFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl<'a> Deref for AccelerationStructureGeometryKHRBuilder<'a> {
    type Target = vk::AccelerationStructureGeometryKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
    inner: vk::AccelerationStructureBuildGeometryInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AccelerationStructureBuildGeometryInfoKHR {
    type Type = AccelerationStructureBuildGeometryInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureBuildGeometryInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ty(mut self, ty: vk::AccelerationStructureTypeKHR) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn flags(mut self, flags: vk::BuildAccelerationStructureFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn mode(mut self, mode: vk::BuildAccelerationStructureModeKHR) -> Self {
        self.inner.mode = mode;
        self
    }
    pub fn src_acceleration_structure(mut self, src_acceleration_structure: vk::AccelerationStructureKHR) -> Self {
        self.inner.src_acceleration_structure = src_acceleration_structure;
        self
    }
    pub fn dst_acceleration_structure(mut self, dst_acceleration_structure: vk::AccelerationStructureKHR) -> Self {
        self.inner.dst_acceleration_structure = dst_acceleration_structure;
        self
    }
    pub fn p_geometries(
        mut self,
        p_geometries: Option<&'a [vk::AccelerationStructureGeometryKHR]>,
        pp_geometries: Option<&'a [*const vk::AccelerationStructureGeometryKHR]>,
    ) -> Self {
        self.inner.geometry_count = p_geometries
            .map(|s| s.len() as u32)
            .or(pp_geometries.map(|s| s.len() as u32))
            .unwrap_or(0);
        if let Some(len) = p_geometries.map(|s| s.len()) {
            assert_eq!(self.inner.geometry_count, len as u32);
        }
        if let Some(len) = pp_geometries.map(|s| s.len()) {
            assert_eq!(self.inner.geometry_count, len as u32);
        }
        self.inner.p_geometries = p_geometries.map_or(ptr::null(), |s| s.as_ptr());
        self.inner.pp_geometries = pp_geometries.map_or(ptr::null(), |s| s.as_ptr());
        self
    }
    pub fn scratch_data(mut self, scratch_data: vk::DeviceOrHostAddressKHR) -> Self {
        self.inner.scratch_data = scratch_data;
        self
    }
}
impl<'a> Deref for AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
    type Target = vk::AccelerationStructureBuildGeometryInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureBuildRangeInfoKHRBuilder {
    inner: vk::AccelerationStructureBuildRangeInfoKHR,
}
impl Builder<'_> for vk::AccelerationStructureBuildRangeInfoKHR {
    type Type = AccelerationStructureBuildRangeInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AccelerationStructureBuildRangeInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureBuildRangeInfoKHR {
        &mut self.inner
    }
    pub fn primitive_count(mut self, primitive_count: u32) -> Self {
        self.inner.primitive_count = primitive_count;
        self
    }
    pub fn primitive_offset(mut self, primitive_offset: u32) -> Self {
        self.inner.primitive_offset = primitive_offset;
        self
    }
    pub fn first_vertex(mut self, first_vertex: u32) -> Self {
        self.inner.first_vertex = first_vertex;
        self
    }
    pub fn transform_offset(mut self, transform_offset: u32) -> Self {
        self.inner.transform_offset = transform_offset;
        self
    }
}
impl Deref for AccelerationStructureBuildRangeInfoKHRBuilder {
    type Target = vk::AccelerationStructureBuildRangeInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureCreateInfoKHRBuilder<'a> {
    inner: vk::AccelerationStructureCreateInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AccelerationStructureCreateInfoKHR {
    type Type = AccelerationStructureCreateInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait AccelerationStructureCreateInfoKHRNext {}
impl<'a> AccelerationStructureCreateInfoKHRBuilder<'a> {
    pub fn insert_next<T: AccelerationStructureCreateInfoKHRNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn create_flags(mut self, create_flags: vk::AccelerationStructureCreateFlagsKHR) -> Self {
        self.inner.create_flags = create_flags;
        self
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    pub fn offset(mut self, offset: vk::DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    pub fn ty(mut self, ty: vk::AccelerationStructureTypeKHR) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn device_address(mut self, device_address: vk::DeviceAddress) -> Self {
        self.inner.device_address = device_address;
        self
    }
}
impl<'a> Deref for AccelerationStructureCreateInfoKHRBuilder<'a> {
    type Target = vk::AccelerationStructureCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AabbPositionsKHRBuilder {
    inner: vk::AabbPositionsKHR,
}
impl Builder<'_> for vk::AabbPositionsKHR {
    type Type = AabbPositionsKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AabbPositionsKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AabbPositionsKHR {
        &mut self.inner
    }
    pub fn min_x(mut self, min_x: f32) -> Self {
        self.inner.min_x = min_x;
        self
    }
    pub fn min_y(mut self, min_y: f32) -> Self {
        self.inner.min_y = min_y;
        self
    }
    pub fn min_z(mut self, min_z: f32) -> Self {
        self.inner.min_z = min_z;
        self
    }
    pub fn max_x(mut self, max_x: f32) -> Self {
        self.inner.max_x = max_x;
        self
    }
    pub fn max_y(mut self, max_y: f32) -> Self {
        self.inner.max_y = max_y;
        self
    }
    pub fn max_z(mut self, max_z: f32) -> Self {
        self.inner.max_z = max_z;
        self
    }
}
impl Deref for AabbPositionsKHRBuilder {
    type Target = vk::AabbPositionsKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct TransformMatrixKHRBuilder {
    inner: vk::TransformMatrixKHR,
}
impl Builder<'_> for vk::TransformMatrixKHR {
    type Type = TransformMatrixKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl TransformMatrixKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::TransformMatrixKHR {
        &mut self.inner
    }
    pub fn matrix(mut self, matrix: [f32; 12]) -> Self {
        self.inner.matrix = matrix;
        self
    }
}
impl Deref for TransformMatrixKHRBuilder {
    type Target = vk::TransformMatrixKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureInstanceKHRBuilder {
    inner: vk::AccelerationStructureInstanceKHR,
}
impl Builder<'_> for vk::AccelerationStructureInstanceKHR {
    type Type = AccelerationStructureInstanceKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AccelerationStructureInstanceKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureInstanceKHR {
        &mut self.inner
    }
    pub fn transform(mut self, transform: vk::TransformMatrixKHR) -> Self {
        self.inner.transform = transform;
        self
    }
    pub fn instance_custom_index_and_mask(mut self, instance_custom_index_and_mask: u32) -> Self {
        self.inner.instance_custom_index_and_mask = instance_custom_index_and_mask;
        self
    }
    pub fn instance_shader_binding_table_record_offset_and_flags(
        mut self,
        instance_shader_binding_table_record_offset_and_flags: u32,
    ) -> Self {
        self.inner.instance_shader_binding_table_record_offset_and_flags =
            instance_shader_binding_table_record_offset_and_flags;
        self
    }
    pub fn acceleration_structure_reference(mut self, acceleration_structure_reference: u64) -> Self {
        self.inner.acceleration_structure_reference = acceleration_structure_reference;
        self
    }
}
impl Deref for AccelerationStructureInstanceKHRBuilder {
    type Target = vk::AccelerationStructureInstanceKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureDeviceAddressInfoKHRBuilder {
    inner: vk::AccelerationStructureDeviceAddressInfoKHR,
}
impl Builder<'_> for vk::AccelerationStructureDeviceAddressInfoKHR {
    type Type = AccelerationStructureDeviceAddressInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AccelerationStructureDeviceAddressInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureDeviceAddressInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn acceleration_structure(mut self, acceleration_structure: vk::AccelerationStructureKHR) -> Self {
        self.inner.acceleration_structure = acceleration_structure;
        self
    }
}
impl Deref for AccelerationStructureDeviceAddressInfoKHRBuilder {
    type Target = vk::AccelerationStructureDeviceAddressInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureVersionInfoKHRBuilder<'a> {
    inner: vk::AccelerationStructureVersionInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AccelerationStructureVersionInfoKHR {
    type Type = AccelerationStructureVersionInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> AccelerationStructureVersionInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureVersionInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_version_data(mut self, p_version_data: *const u8) -> Self {
        self.inner.p_version_data = p_version_data;
        self
    }
}
impl<'a> Deref for AccelerationStructureVersionInfoKHRBuilder<'a> {
    type Target = vk::AccelerationStructureVersionInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyAccelerationStructureInfoKHRBuilder {
    inner: vk::CopyAccelerationStructureInfoKHR,
}
impl Builder<'_> for vk::CopyAccelerationStructureInfoKHR {
    type Type = CopyAccelerationStructureInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CopyAccelerationStructureInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CopyAccelerationStructureInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src(mut self, src: vk::AccelerationStructureKHR) -> Self {
        self.inner.src = src;
        self
    }
    pub fn dst(mut self, dst: vk::AccelerationStructureKHR) -> Self {
        self.inner.dst = dst;
        self
    }
    pub fn mode(mut self, mode: vk::CopyAccelerationStructureModeKHR) -> Self {
        self.inner.mode = mode;
        self
    }
}
impl Deref for CopyAccelerationStructureInfoKHRBuilder {
    type Target = vk::CopyAccelerationStructureInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyAccelerationStructureToMemoryInfoKHRBuilder {
    inner: vk::CopyAccelerationStructureToMemoryInfoKHR,
}
impl Builder<'_> for vk::CopyAccelerationStructureToMemoryInfoKHR {
    type Type = CopyAccelerationStructureToMemoryInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CopyAccelerationStructureToMemoryInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CopyAccelerationStructureToMemoryInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src(mut self, src: vk::AccelerationStructureKHR) -> Self {
        self.inner.src = src;
        self
    }
    pub fn dst(mut self, dst: vk::DeviceOrHostAddressKHR) -> Self {
        self.inner.dst = dst;
        self
    }
    pub fn mode(mut self, mode: vk::CopyAccelerationStructureModeKHR) -> Self {
        self.inner.mode = mode;
        self
    }
}
impl Deref for CopyAccelerationStructureToMemoryInfoKHRBuilder {
    type Target = vk::CopyAccelerationStructureToMemoryInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyMemoryToAccelerationStructureInfoKHRBuilder {
    inner: vk::CopyMemoryToAccelerationStructureInfoKHR,
}
impl Builder<'_> for vk::CopyMemoryToAccelerationStructureInfoKHR {
    type Type = CopyMemoryToAccelerationStructureInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CopyMemoryToAccelerationStructureInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CopyMemoryToAccelerationStructureInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src(mut self, src: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.src = src;
        self
    }
    pub fn dst(mut self, dst: vk::AccelerationStructureKHR) -> Self {
        self.inner.dst = dst;
        self
    }
    pub fn mode(mut self, mode: vk::CopyAccelerationStructureModeKHR) -> Self {
        self.inner.mode = mode;
        self
    }
}
impl Deref for CopyMemoryToAccelerationStructureInfoKHRBuilder {
    type Target = vk::CopyMemoryToAccelerationStructureInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RayTracingPipelineInterfaceCreateInfoKHRBuilder {
    inner: vk::RayTracingPipelineInterfaceCreateInfoKHR,
}
impl Builder<'_> for vk::RayTracingPipelineInterfaceCreateInfoKHR {
    type Type = RayTracingPipelineInterfaceCreateInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl RayTracingPipelineInterfaceCreateInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::RayTracingPipelineInterfaceCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn max_pipeline_ray_payload_size(mut self, max_pipeline_ray_payload_size: u32) -> Self {
        self.inner.max_pipeline_ray_payload_size = max_pipeline_ray_payload_size;
        self
    }
    pub fn max_pipeline_ray_hit_attribute_size(mut self, max_pipeline_ray_hit_attribute_size: u32) -> Self {
        self.inner.max_pipeline_ray_hit_attribute_size = max_pipeline_ray_hit_attribute_size;
        self
    }
}
impl Deref for RayTracingPipelineInterfaceCreateInfoKHRBuilder {
    type Target = vk::RayTracingPipelineInterfaceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineLibraryCreateInfoKHRBuilder<'a> {
    inner: vk::PipelineLibraryCreateInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineLibraryCreateInfoKHR {
    type Type = PipelineLibraryCreateInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineLibraryCreateInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineLibraryCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_libraries(mut self, p_libraries: &'a [vk::Pipeline]) -> Self {
        self.inner.library_count = p_libraries.len() as u32;
        self.inner.p_libraries = p_libraries.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineLibraryCreateInfoKHRBuilder<'a> {
    type Target = vk::PipelineLibraryCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::PipelineLibraryCreateInfoKHR {}
impl GraphicsPipelineCreateInfoNext for PipelineLibraryCreateInfoKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT {
    type Type = PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn extended_dynamic_state(mut self, extended_dynamic_state: bool) -> Self {
        self.inner.extended_dynamic_state = if extended_dynamic_state { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder {
    inner: vk::PhysicalDeviceExtendedDynamicState2FeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceExtendedDynamicState2FeaturesEXT {
    type Type = PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceExtendedDynamicState2FeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn extended_dynamic_state2(mut self, extended_dynamic_state2: bool) -> Self {
        self.inner.extended_dynamic_state2 = if extended_dynamic_state2 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn extended_dynamic_state2_logic_op(mut self, extended_dynamic_state2_logic_op: bool) -> Self {
        self.inner.extended_dynamic_state2_logic_op = if extended_dynamic_state2_logic_op {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state2_patch_control_points(
        mut self,
        extended_dynamic_state2_patch_control_points: bool,
    ) -> Self {
        self.inner.extended_dynamic_state2_patch_control_points = if extended_dynamic_state2_patch_control_points {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceExtendedDynamicState2FeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceExtendedDynamicState2FeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceExtendedDynamicState2FeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceExtendedDynamicState3FeaturesEXTBuilder {
    inner: vk::PhysicalDeviceExtendedDynamicState3FeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceExtendedDynamicState3FeaturesEXT {
    type Type = PhysicalDeviceExtendedDynamicState3FeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceExtendedDynamicState3FeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceExtendedDynamicState3FeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn extended_dynamic_state3_tessellation_domain_origin(
        mut self,
        extended_dynamic_state3_tessellation_domain_origin: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_tessellation_domain_origin =
            if extended_dynamic_state3_tessellation_domain_origin {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn extended_dynamic_state3_depth_clamp_enable(
        mut self,
        extended_dynamic_state3_depth_clamp_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_depth_clamp_enable = if extended_dynamic_state3_depth_clamp_enable {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_polygon_mode(mut self, extended_dynamic_state3_polygon_mode: bool) -> Self {
        self.inner.extended_dynamic_state3_polygon_mode = if extended_dynamic_state3_polygon_mode {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_rasterization_samples(
        mut self,
        extended_dynamic_state3_rasterization_samples: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_rasterization_samples = if extended_dynamic_state3_rasterization_samples {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_sample_mask(mut self, extended_dynamic_state3_sample_mask: bool) -> Self {
        self.inner.extended_dynamic_state3_sample_mask = if extended_dynamic_state3_sample_mask {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_alpha_to_coverage_enable(
        mut self,
        extended_dynamic_state3_alpha_to_coverage_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_alpha_to_coverage_enable =
            if extended_dynamic_state3_alpha_to_coverage_enable {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn extended_dynamic_state3_alpha_to_one_enable(
        mut self,
        extended_dynamic_state3_alpha_to_one_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_alpha_to_one_enable = if extended_dynamic_state3_alpha_to_one_enable {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_logic_op_enable(mut self, extended_dynamic_state3_logic_op_enable: bool) -> Self {
        self.inner.extended_dynamic_state3_logic_op_enable = if extended_dynamic_state3_logic_op_enable {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_color_blend_enable(
        mut self,
        extended_dynamic_state3_color_blend_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_color_blend_enable = if extended_dynamic_state3_color_blend_enable {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_color_blend_equation(
        mut self,
        extended_dynamic_state3_color_blend_equation: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_color_blend_equation = if extended_dynamic_state3_color_blend_equation {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_color_write_mask(mut self, extended_dynamic_state3_color_write_mask: bool) -> Self {
        self.inner.extended_dynamic_state3_color_write_mask = if extended_dynamic_state3_color_write_mask {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_rasterization_stream(
        mut self,
        extended_dynamic_state3_rasterization_stream: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_rasterization_stream = if extended_dynamic_state3_rasterization_stream {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_conservative_rasterization_mode(
        mut self,
        extended_dynamic_state3_conservative_rasterization_mode: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_conservative_rasterization_mode =
            if extended_dynamic_state3_conservative_rasterization_mode {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn extended_dynamic_state3_extra_primitive_overestimation_size(
        mut self,
        extended_dynamic_state3_extra_primitive_overestimation_size: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_extra_primitive_overestimation_size =
            if extended_dynamic_state3_extra_primitive_overestimation_size {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn extended_dynamic_state3_depth_clip_enable(
        mut self,
        extended_dynamic_state3_depth_clip_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_depth_clip_enable = if extended_dynamic_state3_depth_clip_enable {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_sample_locations_enable(
        mut self,
        extended_dynamic_state3_sample_locations_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_sample_locations_enable = if extended_dynamic_state3_sample_locations_enable
        {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_color_blend_advanced(
        mut self,
        extended_dynamic_state3_color_blend_advanced: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_color_blend_advanced = if extended_dynamic_state3_color_blend_advanced {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_provoking_vertex_mode(
        mut self,
        extended_dynamic_state3_provoking_vertex_mode: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_provoking_vertex_mode = if extended_dynamic_state3_provoking_vertex_mode {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_line_rasterization_mode(
        mut self,
        extended_dynamic_state3_line_rasterization_mode: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_line_rasterization_mode = if extended_dynamic_state3_line_rasterization_mode
        {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_line_stipple_enable(
        mut self,
        extended_dynamic_state3_line_stipple_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_line_stipple_enable = if extended_dynamic_state3_line_stipple_enable {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_depth_clip_negative_one_to_one(
        mut self,
        extended_dynamic_state3_depth_clip_negative_one_to_one: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_depth_clip_negative_one_to_one =
            if extended_dynamic_state3_depth_clip_negative_one_to_one {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn extended_dynamic_state3_viewport_w_scaling_enable(
        mut self,
        extended_dynamic_state3_viewport_w_scaling_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_viewport_w_scaling_enable =
            if extended_dynamic_state3_viewport_w_scaling_enable {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn extended_dynamic_state3_viewport_swizzle(mut self, extended_dynamic_state3_viewport_swizzle: bool) -> Self {
        self.inner.extended_dynamic_state3_viewport_swizzle = if extended_dynamic_state3_viewport_swizzle {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_coverage_to_color_enable(
        mut self,
        extended_dynamic_state3_coverage_to_color_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_coverage_to_color_enable =
            if extended_dynamic_state3_coverage_to_color_enable {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn extended_dynamic_state3_coverage_to_color_location(
        mut self,
        extended_dynamic_state3_coverage_to_color_location: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_coverage_to_color_location =
            if extended_dynamic_state3_coverage_to_color_location {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn extended_dynamic_state3_coverage_modulation_mode(
        mut self,
        extended_dynamic_state3_coverage_modulation_mode: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_coverage_modulation_mode =
            if extended_dynamic_state3_coverage_modulation_mode {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn extended_dynamic_state3_coverage_modulation_table_enable(
        mut self,
        extended_dynamic_state3_coverage_modulation_table_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_coverage_modulation_table_enable =
            if extended_dynamic_state3_coverage_modulation_table_enable {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn extended_dynamic_state3_coverage_modulation_table(
        mut self,
        extended_dynamic_state3_coverage_modulation_table: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_coverage_modulation_table =
            if extended_dynamic_state3_coverage_modulation_table {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn extended_dynamic_state3_coverage_reduction_mode(
        mut self,
        extended_dynamic_state3_coverage_reduction_mode: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_coverage_reduction_mode = if extended_dynamic_state3_coverage_reduction_mode
        {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn extended_dynamic_state3_representative_fragment_test_enable(
        mut self,
        extended_dynamic_state3_representative_fragment_test_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_representative_fragment_test_enable =
            if extended_dynamic_state3_representative_fragment_test_enable {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn extended_dynamic_state3_shading_rate_image_enable(
        mut self,
        extended_dynamic_state3_shading_rate_image_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_shading_rate_image_enable =
            if extended_dynamic_state3_shading_rate_image_enable {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
}
impl Deref for PhysicalDeviceExtendedDynamicState3FeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceExtendedDynamicState3FeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceExtendedDynamicState3FeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceExtendedDynamicState3FeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceExtendedDynamicState3FeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceExtendedDynamicState3FeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceExtendedDynamicState3PropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct ColorBlendEquationEXTBuilder {
    inner: vk::ColorBlendEquationEXT,
}
impl Builder<'_> for vk::ColorBlendEquationEXT {
    type Type = ColorBlendEquationEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ColorBlendEquationEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ColorBlendEquationEXT {
        &mut self.inner
    }
    pub fn src_color_blend_factor(mut self, src_color_blend_factor: vk::BlendFactor) -> Self {
        self.inner.src_color_blend_factor = src_color_blend_factor;
        self
    }
    pub fn dst_color_blend_factor(mut self, dst_color_blend_factor: vk::BlendFactor) -> Self {
        self.inner.dst_color_blend_factor = dst_color_blend_factor;
        self
    }
    pub fn color_blend_op(mut self, color_blend_op: vk::BlendOp) -> Self {
        self.inner.color_blend_op = color_blend_op;
        self
    }
    pub fn src_alpha_blend_factor(mut self, src_alpha_blend_factor: vk::BlendFactor) -> Self {
        self.inner.src_alpha_blend_factor = src_alpha_blend_factor;
        self
    }
    pub fn dst_alpha_blend_factor(mut self, dst_alpha_blend_factor: vk::BlendFactor) -> Self {
        self.inner.dst_alpha_blend_factor = dst_alpha_blend_factor;
        self
    }
    pub fn alpha_blend_op(mut self, alpha_blend_op: vk::BlendOp) -> Self {
        self.inner.alpha_blend_op = alpha_blend_op;
        self
    }
}
impl Deref for ColorBlendEquationEXTBuilder {
    type Target = vk::ColorBlendEquationEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ColorBlendAdvancedEXTBuilder {
    inner: vk::ColorBlendAdvancedEXT,
}
impl Builder<'_> for vk::ColorBlendAdvancedEXT {
    type Type = ColorBlendAdvancedEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ColorBlendAdvancedEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ColorBlendAdvancedEXT {
        &mut self.inner
    }
    pub fn advanced_blend_op(mut self, advanced_blend_op: vk::BlendOp) -> Self {
        self.inner.advanced_blend_op = advanced_blend_op;
        self
    }
    pub fn src_premultiplied(mut self, src_premultiplied: bool) -> Self {
        self.inner.src_premultiplied = if src_premultiplied { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn dst_premultiplied(mut self, dst_premultiplied: bool) -> Self {
        self.inner.dst_premultiplied = if dst_premultiplied { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn blend_overlap(mut self, blend_overlap: vk::BlendOverlapEXT) -> Self {
        self.inner.blend_overlap = blend_overlap;
        self
    }
    pub fn clamp_results(mut self, clamp_results: bool) -> Self {
        self.inner.clamp_results = if clamp_results { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for ColorBlendAdvancedEXTBuilder {
    type Target = vk::ColorBlendAdvancedEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassTransformBeginInfoQCOMBuilder {
    inner: vk::RenderPassTransformBeginInfoQCOM,
}
impl Builder<'_> for vk::RenderPassTransformBeginInfoQCOM {
    type Type = RenderPassTransformBeginInfoQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl RenderPassTransformBeginInfoQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::RenderPassTransformBeginInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn transform(mut self, transform: vk::SurfaceTransformFlagsKHR) -> Self {
        self.inner.transform = transform;
        self
    }
}
impl Deref for RenderPassTransformBeginInfoQCOMBuilder {
    type Target = vk::RenderPassTransformBeginInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderPassBeginInfoNext for vk::RenderPassTransformBeginInfoQCOM {}
impl RenderPassBeginInfoNext for RenderPassTransformBeginInfoQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyCommandTransformInfoQCOMBuilder {
    inner: vk::CopyCommandTransformInfoQCOM,
}
impl Builder<'_> for vk::CopyCommandTransformInfoQCOM {
    type Type = CopyCommandTransformInfoQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CopyCommandTransformInfoQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CopyCommandTransformInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn transform(mut self, transform: vk::SurfaceTransformFlagsKHR) -> Self {
        self.inner.transform = transform;
        self
    }
}
impl Deref for CopyCommandTransformInfoQCOMBuilder {
    type Target = vk::CopyCommandTransformInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BufferImageCopy2Next for vk::CopyCommandTransformInfoQCOM {}
impl BufferImageCopy2Next for CopyCommandTransformInfoQCOMBuilder {}
impl ImageBlit2Next for vk::CopyCommandTransformInfoQCOM {}
impl ImageBlit2Next for CopyCommandTransformInfoQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder {
    inner: vk::CommandBufferInheritanceRenderPassTransformInfoQCOM,
}
impl Builder<'_> for vk::CommandBufferInheritanceRenderPassTransformInfoQCOM {
    type Type = CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CommandBufferInheritanceRenderPassTransformInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn transform(mut self, transform: vk::SurfaceTransformFlagsKHR) -> Self {
        self.inner.transform = transform;
        self
    }
    pub fn render_area(mut self, render_area: vk::Rect2D) -> Self {
        self.inner.render_area = render_area;
        self
    }
}
impl Deref for CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder {
    type Target = vk::CommandBufferInheritanceRenderPassTransformInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl CommandBufferInheritanceInfoNext for vk::CommandBufferInheritanceRenderPassTransformInfoQCOM {}
impl CommandBufferInheritanceInfoNext for CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePartitionedAccelerationStructureFeaturesNVBuilder {
    inner: vk::PhysicalDevicePartitionedAccelerationStructureFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDevicePartitionedAccelerationStructureFeaturesNV {
    type Type = PhysicalDevicePartitionedAccelerationStructureFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePartitionedAccelerationStructureFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePartitionedAccelerationStructureFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn partitioned_acceleration_structure(mut self, partitioned_acceleration_structure: bool) -> Self {
        self.inner.partitioned_acceleration_structure = if partitioned_acceleration_structure {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDevicePartitionedAccelerationStructureFeaturesNVBuilder {
    type Target = vk::PhysicalDevicePartitionedAccelerationStructureFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePartitionedAccelerationStructureFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePartitionedAccelerationStructureFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePartitionedAccelerationStructureFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDevicePartitionedAccelerationStructureFeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDevicePartitionedAccelerationStructurePropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct BuildPartitionedAccelerationStructureIndirectCommandNVBuilder {
    inner: vk::BuildPartitionedAccelerationStructureIndirectCommandNV,
}
impl Builder<'_> for vk::BuildPartitionedAccelerationStructureIndirectCommandNV {
    type Type = BuildPartitionedAccelerationStructureIndirectCommandNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BuildPartitionedAccelerationStructureIndirectCommandNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BuildPartitionedAccelerationStructureIndirectCommandNV {
        &mut self.inner
    }
    pub fn op_type(mut self, op_type: vk::PartitionedAccelerationStructureOpTypeNV) -> Self {
        self.inner.op_type = op_type;
        self
    }
    pub fn arg_count(mut self, arg_count: u32) -> Self {
        self.inner.arg_count = arg_count;
        self
    }
    pub fn arg_data(mut self, arg_data: vk::StridedDeviceAddressNV) -> Self {
        self.inner.arg_data = arg_data;
        self
    }
}
impl Deref for BuildPartitionedAccelerationStructureIndirectCommandNVBuilder {
    type Target = vk::BuildPartitionedAccelerationStructureIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PartitionedAccelerationStructureFlagsNVBuilder {
    inner: vk::PartitionedAccelerationStructureFlagsNV,
}
impl Builder<'_> for vk::PartitionedAccelerationStructureFlagsNV {
    type Type = PartitionedAccelerationStructureFlagsNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PartitionedAccelerationStructureFlagsNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PartitionedAccelerationStructureFlagsNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn enable_partition_translation(mut self, enable_partition_translation: bool) -> Self {
        self.inner.enable_partition_translation = if enable_partition_translation {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PartitionedAccelerationStructureFlagsNVBuilder {
    type Target = vk::PartitionedAccelerationStructureFlagsNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PartitionedAccelerationStructureInstancesInputNVNext for vk::PartitionedAccelerationStructureFlagsNV {}
impl PartitionedAccelerationStructureInstancesInputNVNext for PartitionedAccelerationStructureFlagsNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PartitionedAccelerationStructureWriteInstanceDataNVBuilder {
    inner: vk::PartitionedAccelerationStructureWriteInstanceDataNV,
}
impl Builder<'_> for vk::PartitionedAccelerationStructureWriteInstanceDataNV {
    type Type = PartitionedAccelerationStructureWriteInstanceDataNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PartitionedAccelerationStructureWriteInstanceDataNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PartitionedAccelerationStructureWriteInstanceDataNV {
        &mut self.inner
    }
    pub fn transform(mut self, transform: vk::TransformMatrixKHR) -> Self {
        self.inner.transform = transform;
        self
    }
    pub fn explicit_aabb(mut self, explicit_aabb: [f32; 6]) -> Self {
        self.inner.explicit_aabb = explicit_aabb;
        self
    }
    pub fn instance_id(mut self, instance_id: u32) -> Self {
        self.inner.instance_id = instance_id;
        self
    }
    pub fn instance_mask(mut self, instance_mask: u32) -> Self {
        self.inner.instance_mask = instance_mask;
        self
    }
    pub fn instance_contribution_to_hit_group_index(mut self, instance_contribution_to_hit_group_index: u32) -> Self {
        self.inner.instance_contribution_to_hit_group_index = instance_contribution_to_hit_group_index;
        self
    }
    pub fn instance_flags(mut self, instance_flags: vk::PartitionedAccelerationStructureInstanceFlagsNV) -> Self {
        self.inner.instance_flags = instance_flags;
        self
    }
    pub fn instance_index(mut self, instance_index: u32) -> Self {
        self.inner.instance_index = instance_index;
        self
    }
    pub fn partition_index(mut self, partition_index: u32) -> Self {
        self.inner.partition_index = partition_index;
        self
    }
    pub fn acceleration_structure(mut self, acceleration_structure: vk::DeviceAddress) -> Self {
        self.inner.acceleration_structure = acceleration_structure;
        self
    }
}
impl Deref for PartitionedAccelerationStructureWriteInstanceDataNVBuilder {
    type Target = vk::PartitionedAccelerationStructureWriteInstanceDataNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PartitionedAccelerationStructureUpdateInstanceDataNVBuilder {
    inner: vk::PartitionedAccelerationStructureUpdateInstanceDataNV,
}
impl Builder<'_> for vk::PartitionedAccelerationStructureUpdateInstanceDataNV {
    type Type = PartitionedAccelerationStructureUpdateInstanceDataNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PartitionedAccelerationStructureUpdateInstanceDataNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PartitionedAccelerationStructureUpdateInstanceDataNV {
        &mut self.inner
    }
    pub fn instance_index(mut self, instance_index: u32) -> Self {
        self.inner.instance_index = instance_index;
        self
    }
    pub fn instance_contribution_to_hit_group_index(mut self, instance_contribution_to_hit_group_index: u32) -> Self {
        self.inner.instance_contribution_to_hit_group_index = instance_contribution_to_hit_group_index;
        self
    }
    pub fn acceleration_structure(mut self, acceleration_structure: vk::DeviceAddress) -> Self {
        self.inner.acceleration_structure = acceleration_structure;
        self
    }
}
impl Deref for PartitionedAccelerationStructureUpdateInstanceDataNVBuilder {
    type Target = vk::PartitionedAccelerationStructureUpdateInstanceDataNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PartitionedAccelerationStructureWritePartitionTranslationDataNVBuilder {
    inner: vk::PartitionedAccelerationStructureWritePartitionTranslationDataNV,
}
impl Builder<'_> for vk::PartitionedAccelerationStructureWritePartitionTranslationDataNV {
    type Type = PartitionedAccelerationStructureWritePartitionTranslationDataNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PartitionedAccelerationStructureWritePartitionTranslationDataNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PartitionedAccelerationStructureWritePartitionTranslationDataNV {
        &mut self.inner
    }
    pub fn partition_index(mut self, partition_index: u32) -> Self {
        self.inner.partition_index = partition_index;
        self
    }
    pub fn partition_translation(mut self, partition_translation: [f32; 3]) -> Self {
        self.inner.partition_translation = partition_translation;
        self
    }
}
impl Deref for PartitionedAccelerationStructureWritePartitionTranslationDataNVBuilder {
    type Target = vk::PartitionedAccelerationStructureWritePartitionTranslationDataNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct WriteDescriptorSetPartitionedAccelerationStructureNVBuilder<'a> {
    inner: vk::WriteDescriptorSetPartitionedAccelerationStructureNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::WriteDescriptorSetPartitionedAccelerationStructureNV {
    type Type = WriteDescriptorSetPartitionedAccelerationStructureNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> WriteDescriptorSetPartitionedAccelerationStructureNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::WriteDescriptorSetPartitionedAccelerationStructureNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_acceleration_structures(mut self, p_acceleration_structures: &'a [vk::DeviceAddress]) -> Self {
        self.inner.acceleration_structure_count = p_acceleration_structures.len() as u32;
        self.inner.p_acceleration_structures = p_acceleration_structures.as_ptr();
        self
    }
}
impl<'a> Deref for WriteDescriptorSetPartitionedAccelerationStructureNVBuilder<'a> {
    type Target = vk::WriteDescriptorSetPartitionedAccelerationStructureNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl WriteDescriptorSetNext for vk::WriteDescriptorSetPartitionedAccelerationStructureNV {}
impl WriteDescriptorSetNext for WriteDescriptorSetPartitionedAccelerationStructureNVBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PartitionedAccelerationStructureInstancesInputNVBuilder<'a> {
    inner: vk::PartitionedAccelerationStructureInstancesInputNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PartitionedAccelerationStructureInstancesInputNV {
    type Type = PartitionedAccelerationStructureInstancesInputNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PartitionedAccelerationStructureInstancesInputNVNext {}
impl<'a> PartitionedAccelerationStructureInstancesInputNVBuilder<'a> {
    pub fn insert_next<T: PartitionedAccelerationStructureInstancesInputNVNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PartitionedAccelerationStructureInstancesInputNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::BuildAccelerationStructureFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn instance_count(mut self, instance_count: u32) -> Self {
        self.inner.instance_count = instance_count;
        self
    }
    pub fn max_instance_per_partition_count(mut self, max_instance_per_partition_count: u32) -> Self {
        self.inner.max_instance_per_partition_count = max_instance_per_partition_count;
        self
    }
    pub fn partition_count(mut self, partition_count: u32) -> Self {
        self.inner.partition_count = partition_count;
        self
    }
    pub fn max_instance_in_global_partition_count(mut self, max_instance_in_global_partition_count: u32) -> Self {
        self.inner.max_instance_in_global_partition_count = max_instance_in_global_partition_count;
        self
    }
}
impl<'a> Deref for PartitionedAccelerationStructureInstancesInputNVBuilder<'a> {
    type Target = vk::PartitionedAccelerationStructureInstancesInputNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BuildPartitionedAccelerationStructureInfoNVBuilder {
    inner: vk::BuildPartitionedAccelerationStructureInfoNV,
}
impl Builder<'_> for vk::BuildPartitionedAccelerationStructureInfoNV {
    type Type = BuildPartitionedAccelerationStructureInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BuildPartitionedAccelerationStructureInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BuildPartitionedAccelerationStructureInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn input(mut self, input: vk::PartitionedAccelerationStructureInstancesInputNV) -> Self {
        self.inner.input = input;
        self
    }
    pub fn src_acceleration_structure_data(mut self, src_acceleration_structure_data: vk::DeviceAddress) -> Self {
        self.inner.src_acceleration_structure_data = src_acceleration_structure_data;
        self
    }
    pub fn dst_acceleration_structure_data(mut self, dst_acceleration_structure_data: vk::DeviceAddress) -> Self {
        self.inner.dst_acceleration_structure_data = dst_acceleration_structure_data;
        self
    }
    pub fn scratch_data(mut self, scratch_data: vk::DeviceAddress) -> Self {
        self.inner.scratch_data = scratch_data;
        self
    }
    pub fn src_infos(mut self, src_infos: vk::DeviceAddress) -> Self {
        self.inner.src_infos = src_infos;
        self
    }
    pub fn src_infos_count(mut self, src_infos_count: vk::DeviceAddress) -> Self {
        self.inner.src_infos_count = src_infos_count;
        self
    }
}
impl Deref for BuildPartitionedAccelerationStructureInfoNVBuilder {
    type Target = vk::BuildPartitionedAccelerationStructureInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder {
    inner: vk::PhysicalDeviceDiagnosticsConfigFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceDiagnosticsConfigFeaturesNV {
    type Type = PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDiagnosticsConfigFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn diagnostics_config(mut self, diagnostics_config: bool) -> Self {
        self.inner.diagnostics_config = if diagnostics_config { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceDiagnosticsConfigFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDiagnosticsConfigFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDiagnosticsConfigFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceDiagnosticsConfigCreateInfoNVBuilder {
    inner: vk::DeviceDiagnosticsConfigCreateInfoNV,
}
impl Builder<'_> for vk::DeviceDiagnosticsConfigCreateInfoNV {
    type Type = DeviceDiagnosticsConfigCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceDiagnosticsConfigCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceDiagnosticsConfigCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DeviceDiagnosticsConfigFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl Deref for DeviceDiagnosticsConfigCreateInfoNVBuilder {
    type Target = vk::DeviceDiagnosticsConfigCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DeviceCreateInfoNext for vk::DeviceDiagnosticsConfigCreateInfoNV {}
impl DeviceCreateInfoNext for DeviceDiagnosticsConfigCreateInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder {
    inner: vk::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    type Type = PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_zero_initialize_workgroup_memory(mut self, shader_zero_initialize_workgroup_memory: bool) -> Self {
        self.inner.shader_zero_initialize_workgroup_memory = if shader_zero_initialize_workgroup_memory {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder {
    type Target = vk::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
    type Type = PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_subgroup_uniform_control_flow(mut self, shader_subgroup_uniform_control_flow: bool) -> Self {
        self.inner.shader_subgroup_uniform_control_flow = if shader_subgroup_uniform_control_flow {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRobustness2FeaturesKHRBuilder {
    inner: vk::PhysicalDeviceRobustness2FeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceRobustness2FeaturesKHR {
    type Type = PhysicalDeviceRobustness2FeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRobustness2FeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRobustness2FeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn robust_buffer_access2(mut self, robust_buffer_access2: bool) -> Self {
        self.inner.robust_buffer_access2 = if robust_buffer_access2 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn robust_image_access2(mut self, robust_image_access2: bool) -> Self {
        self.inner.robust_image_access2 = if robust_image_access2 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn null_descriptor(mut self, null_descriptor: bool) -> Self {
        self.inner.null_descriptor = if null_descriptor { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceRobustness2FeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceRobustness2FeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRobustness2FeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRobustness2FeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRobustness2FeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceRobustness2FeaturesKHRBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceRobustness2PropertiesKHR {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceImageRobustnessFeaturesBuilder {
    inner: vk::PhysicalDeviceImageRobustnessFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceImageRobustnessFeatures {
    type Type = PhysicalDeviceImageRobustnessFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceImageRobustnessFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceImageRobustnessFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn robust_image_access(mut self, robust_image_access: bool) -> Self {
        self.inner.robust_image_access = if robust_image_access { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceImageRobustnessFeaturesBuilder {
    type Target = vk::PhysicalDeviceImageRobustnessFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceImageRobustnessFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceImageRobustnessFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceImageRobustnessFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceImageRobustnessFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    type Type = PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn workgroup_memory_explicit_layout(mut self, workgroup_memory_explicit_layout: bool) -> Self {
        self.inner.workgroup_memory_explicit_layout = if workgroup_memory_explicit_layout {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn workgroup_memory_explicit_layout_scalar_block_layout(
        mut self,
        workgroup_memory_explicit_layout_scalar_block_layout: bool,
    ) -> Self {
        self.inner.workgroup_memory_explicit_layout_scalar_block_layout =
            if workgroup_memory_explicit_layout_scalar_block_layout {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn workgroup_memory_explicit_layout8_bit_access(
        mut self,
        workgroup_memory_explicit_layout8_bit_access: bool,
    ) -> Self {
        self.inner.workgroup_memory_explicit_layout8_bit_access = if workgroup_memory_explicit_layout8_bit_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn workgroup_memory_explicit_layout16_bit_access(
        mut self,
        workgroup_memory_explicit_layout16_bit_access: bool,
    ) -> Self {
        self.inner.workgroup_memory_explicit_layout16_bit_access = if workgroup_memory_explicit_layout16_bit_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePortabilitySubsetFeaturesKHRBuilder {
    inner: vk::PhysicalDevicePortabilitySubsetFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDevicePortabilitySubsetFeaturesKHR {
    type Type = PhysicalDevicePortabilitySubsetFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePortabilitySubsetFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePortabilitySubsetFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn constant_alpha_color_blend_factors(mut self, constant_alpha_color_blend_factors: bool) -> Self {
        self.inner.constant_alpha_color_blend_factors = if constant_alpha_color_blend_factors {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn events(mut self, events: bool) -> Self {
        self.inner.events = if events { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn image_view_format_reinterpretation(mut self, image_view_format_reinterpretation: bool) -> Self {
        self.inner.image_view_format_reinterpretation = if image_view_format_reinterpretation {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn image_view_format_swizzle(mut self, image_view_format_swizzle: bool) -> Self {
        self.inner.image_view_format_swizzle = if image_view_format_swizzle { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn image_view_2d_on_3d_image(mut self, image_view_2d_on_3d_image: bool) -> Self {
        self.inner.image_view_2d_on_3d_image = if image_view_2d_on_3d_image { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn multisample_array_image(mut self, multisample_array_image: bool) -> Self {
        self.inner.multisample_array_image = if multisample_array_image { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn mutable_comparison_samplers(mut self, mutable_comparison_samplers: bool) -> Self {
        self.inner.mutable_comparison_samplers = if mutable_comparison_samplers {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn point_polygons(mut self, point_polygons: bool) -> Self {
        self.inner.point_polygons = if point_polygons { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sampler_mip_lod_bias(mut self, sampler_mip_lod_bias: bool) -> Self {
        self.inner.sampler_mip_lod_bias = if sampler_mip_lod_bias { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn separate_stencil_mask_ref(mut self, separate_stencil_mask_ref: bool) -> Self {
        self.inner.separate_stencil_mask_ref = if separate_stencil_mask_ref { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_sample_rate_interpolation_functions(
        mut self,
        shader_sample_rate_interpolation_functions: bool,
    ) -> Self {
        self.inner.shader_sample_rate_interpolation_functions = if shader_sample_rate_interpolation_functions {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn tessellation_isolines(mut self, tessellation_isolines: bool) -> Self {
        self.inner.tessellation_isolines = if tessellation_isolines { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn tessellation_point_mode(mut self, tessellation_point_mode: bool) -> Self {
        self.inner.tessellation_point_mode = if tessellation_point_mode { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn triangle_fans(mut self, triangle_fans: bool) -> Self {
        self.inner.triangle_fans = if triangle_fans { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn vertex_attribute_access_beyond_stride(mut self, vertex_attribute_access_beyond_stride: bool) -> Self {
        self.inner.vertex_attribute_access_beyond_stride = if vertex_attribute_access_beyond_stride {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDevicePortabilitySubsetFeaturesKHRBuilder {
    type Target = vk::PhysicalDevicePortabilitySubsetFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePortabilitySubsetFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePortabilitySubsetFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePortabilitySubsetFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDevicePortabilitySubsetFeaturesKHRBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDevicePortabilitySubsetPropertiesKHR {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevice4444FormatsFeaturesEXTBuilder {
    inner: vk::PhysicalDevice4444FormatsFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDevice4444FormatsFeaturesEXT {
    type Type = PhysicalDevice4444FormatsFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevice4444FormatsFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevice4444FormatsFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn format_a4r4g4b4(mut self, format_a4r4g4b4: bool) -> Self {
        self.inner.format_a4r4g4b4 = if format_a4r4g4b4 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn format_a4b4g4r4(mut self, format_a4b4g4r4: bool) -> Self {
        self.inner.format_a4b4g4r4 = if format_a4b4g4r4 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevice4444FormatsFeaturesEXTBuilder {
    type Target = vk::PhysicalDevice4444FormatsFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevice4444FormatsFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDevice4444FormatsFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevice4444FormatsFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDevice4444FormatsFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder {
    inner: vk::PhysicalDeviceSubpassShadingFeaturesHUAWEI,
}
impl Builder<'_> for vk::PhysicalDeviceSubpassShadingFeaturesHUAWEI {
    type Type = PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceSubpassShadingFeaturesHUAWEI {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn subpass_shading(mut self, subpass_shading: bool) -> Self {
        self.inner.subpass_shading = if subpass_shading { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder {
    type Target = vk::PhysicalDeviceSubpassShadingFeaturesHUAWEI;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceSubpassShadingFeaturesHUAWEI {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceSubpassShadingFeaturesHUAWEI {}
impl DeviceCreateInfoNext for PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceClusterCullingShaderFeaturesHUAWEIBuilder<'a> {
    inner: vk::PhysicalDeviceClusterCullingShaderFeaturesHUAWEI,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PhysicalDeviceClusterCullingShaderFeaturesHUAWEI {
    type Type = PhysicalDeviceClusterCullingShaderFeaturesHUAWEIBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PhysicalDeviceClusterCullingShaderFeaturesHUAWEINext {}
impl<'a> PhysicalDeviceClusterCullingShaderFeaturesHUAWEIBuilder<'a> {
    pub fn insert_next<T: PhysicalDeviceClusterCullingShaderFeaturesHUAWEINext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceClusterCullingShaderFeaturesHUAWEI {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn clusterculling_shader(mut self, clusterculling_shader: bool) -> Self {
        self.inner.clusterculling_shader = if clusterculling_shader { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn multiview_cluster_culling_shader(mut self, multiview_cluster_culling_shader: bool) -> Self {
        self.inner.multiview_cluster_culling_shader = if multiview_cluster_culling_shader {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl<'a> Deref for PhysicalDeviceClusterCullingShaderFeaturesHUAWEIBuilder<'a> {
    type Target = vk::PhysicalDeviceClusterCullingShaderFeaturesHUAWEI;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceClusterCullingShaderFeaturesHUAWEI {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceClusterCullingShaderFeaturesHUAWEIBuilder<'_> {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceClusterCullingShaderFeaturesHUAWEI {}
impl DeviceCreateInfoNext for PhysicalDeviceClusterCullingShaderFeaturesHUAWEIBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEIBuilder {
    inner: vk::PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI,
}
impl Builder<'_> for vk::PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI {
    type Type = PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEIBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEIBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn cluster_shading_rate(mut self, cluster_shading_rate: bool) -> Self {
        self.inner.cluster_shading_rate = if cluster_shading_rate { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEIBuilder {
    type Target = vk::PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceClusterCullingShaderFeaturesHUAWEINext for vk::PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI {}
impl PhysicalDeviceClusterCullingShaderFeaturesHUAWEINext
    for PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEIBuilder
{
}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferCopy2Builder {
    inner: vk::BufferCopy2,
}
impl Builder<'_> for vk::BufferCopy2 {
    type Type = BufferCopy2Builder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BufferCopy2Builder {
    pub fn get_mut(&mut self) -> &mut vk::BufferCopy2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_offset(mut self, src_offset: vk::DeviceSize) -> Self {
        self.inner.src_offset = src_offset;
        self
    }
    pub fn dst_offset(mut self, dst_offset: vk::DeviceSize) -> Self {
        self.inner.dst_offset = dst_offset;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
}
impl Deref for BufferCopy2Builder {
    type Target = vk::BufferCopy2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageCopy2Builder {
    inner: vk::ImageCopy2,
}
impl Builder<'_> for vk::ImageCopy2 {
    type Type = ImageCopy2Builder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageCopy2Builder {
    pub fn get_mut(&mut self) -> &mut vk::ImageCopy2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_subresource(mut self, src_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.src_subresource = src_subresource;
        self
    }
    pub fn src_offset(mut self, src_offset: vk::Offset3D) -> Self {
        self.inner.src_offset = src_offset;
        self
    }
    pub fn dst_subresource(mut self, dst_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.dst_subresource = dst_subresource;
        self
    }
    pub fn dst_offset(mut self, dst_offset: vk::Offset3D) -> Self {
        self.inner.dst_offset = dst_offset;
        self
    }
    pub fn extent(mut self, extent: vk::Extent3D) -> Self {
        self.inner.extent = extent;
        self
    }
}
impl Deref for ImageCopy2Builder {
    type Target = vk::ImageCopy2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageBlit2Builder<'a> {
    inner: vk::ImageBlit2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImageBlit2 {
    type Type = ImageBlit2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait ImageBlit2Next {}
impl<'a> ImageBlit2Builder<'a> {
    pub fn insert_next<T: ImageBlit2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::ImageBlit2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_subresource(mut self, src_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.src_subresource = src_subresource;
        self
    }
    pub fn src_offsets(mut self, src_offsets: [vk::Offset3D; 2]) -> Self {
        self.inner.src_offsets = src_offsets;
        self
    }
    pub fn dst_subresource(mut self, dst_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.dst_subresource = dst_subresource;
        self
    }
    pub fn dst_offsets(mut self, dst_offsets: [vk::Offset3D; 2]) -> Self {
        self.inner.dst_offsets = dst_offsets;
        self
    }
}
impl<'a> Deref for ImageBlit2Builder<'a> {
    type Target = vk::ImageBlit2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferImageCopy2Builder<'a> {
    inner: vk::BufferImageCopy2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BufferImageCopy2 {
    type Type = BufferImageCopy2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait BufferImageCopy2Next {}
impl<'a> BufferImageCopy2Builder<'a> {
    pub fn insert_next<T: BufferImageCopy2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::BufferImageCopy2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn buffer_offset(mut self, buffer_offset: vk::DeviceSize) -> Self {
        self.inner.buffer_offset = buffer_offset;
        self
    }
    pub fn buffer_row_length(mut self, buffer_row_length: u32) -> Self {
        self.inner.buffer_row_length = buffer_row_length;
        self
    }
    pub fn buffer_image_height(mut self, buffer_image_height: u32) -> Self {
        self.inner.buffer_image_height = buffer_image_height;
        self
    }
    pub fn image_subresource(mut self, image_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.image_subresource = image_subresource;
        self
    }
    pub fn image_offset(mut self, image_offset: vk::Offset3D) -> Self {
        self.inner.image_offset = image_offset;
        self
    }
    pub fn image_extent(mut self, image_extent: vk::Extent3D) -> Self {
        self.inner.image_extent = image_extent;
        self
    }
}
impl<'a> Deref for BufferImageCopy2Builder<'a> {
    type Target = vk::BufferImageCopy2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageResolve2Builder {
    inner: vk::ImageResolve2,
}
impl Builder<'_> for vk::ImageResolve2 {
    type Type = ImageResolve2Builder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageResolve2Builder {
    pub fn get_mut(&mut self) -> &mut vk::ImageResolve2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_subresource(mut self, src_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.src_subresource = src_subresource;
        self
    }
    pub fn src_offset(mut self, src_offset: vk::Offset3D) -> Self {
        self.inner.src_offset = src_offset;
        self
    }
    pub fn dst_subresource(mut self, dst_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.dst_subresource = dst_subresource;
        self
    }
    pub fn dst_offset(mut self, dst_offset: vk::Offset3D) -> Self {
        self.inner.dst_offset = dst_offset;
        self
    }
    pub fn extent(mut self, extent: vk::Extent3D) -> Self {
        self.inner.extent = extent;
        self
    }
}
impl Deref for ImageResolve2Builder {
    type Target = vk::ImageResolve2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyBufferInfo2Builder<'a> {
    inner: vk::CopyBufferInfo2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CopyBufferInfo2 {
    type Type = CopyBufferInfo2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CopyBufferInfo2Builder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CopyBufferInfo2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_buffer(mut self, src_buffer: vk::Buffer) -> Self {
        self.inner.src_buffer = src_buffer;
        self
    }
    pub fn dst_buffer(mut self, dst_buffer: vk::Buffer) -> Self {
        self.inner.dst_buffer = dst_buffer;
        self
    }
    pub fn p_regions(mut self, p_regions: &'a [vk::BufferCopy2]) -> Self {
        self.inner.region_count = p_regions.len() as u32;
        self.inner.p_regions = p_regions.as_ptr();
        self
    }
}
impl<'a> Deref for CopyBufferInfo2Builder<'a> {
    type Target = vk::CopyBufferInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyImageInfo2Builder<'a> {
    inner: vk::CopyImageInfo2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CopyImageInfo2 {
    type Type = CopyImageInfo2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CopyImageInfo2Builder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CopyImageInfo2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_image(mut self, src_image: vk::Image) -> Self {
        self.inner.src_image = src_image;
        self
    }
    pub fn src_image_layout(mut self, src_image_layout: vk::ImageLayout) -> Self {
        self.inner.src_image_layout = src_image_layout;
        self
    }
    pub fn dst_image(mut self, dst_image: vk::Image) -> Self {
        self.inner.dst_image = dst_image;
        self
    }
    pub fn dst_image_layout(mut self, dst_image_layout: vk::ImageLayout) -> Self {
        self.inner.dst_image_layout = dst_image_layout;
        self
    }
    pub fn p_regions(mut self, p_regions: &'a [vk::ImageCopy2]) -> Self {
        self.inner.region_count = p_regions.len() as u32;
        self.inner.p_regions = p_regions.as_ptr();
        self
    }
}
impl<'a> Deref for CopyImageInfo2Builder<'a> {
    type Target = vk::CopyImageInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BlitImageInfo2Builder<'a> {
    inner: vk::BlitImageInfo2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BlitImageInfo2 {
    type Type = BlitImageInfo2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait BlitImageInfo2Next {}
impl<'a> BlitImageInfo2Builder<'a> {
    pub fn insert_next<T: BlitImageInfo2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::BlitImageInfo2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_image(mut self, src_image: vk::Image) -> Self {
        self.inner.src_image = src_image;
        self
    }
    pub fn src_image_layout(mut self, src_image_layout: vk::ImageLayout) -> Self {
        self.inner.src_image_layout = src_image_layout;
        self
    }
    pub fn dst_image(mut self, dst_image: vk::Image) -> Self {
        self.inner.dst_image = dst_image;
        self
    }
    pub fn dst_image_layout(mut self, dst_image_layout: vk::ImageLayout) -> Self {
        self.inner.dst_image_layout = dst_image_layout;
        self
    }
    pub fn p_regions(mut self, p_regions: &'a [vk::ImageBlit2]) -> Self {
        self.inner.region_count = p_regions.len() as u32;
        self.inner.p_regions = p_regions.as_ptr();
        self
    }
    pub fn filter(mut self, filter: vk::Filter) -> Self {
        self.inner.filter = filter;
        self
    }
}
impl<'a> Deref for BlitImageInfo2Builder<'a> {
    type Target = vk::BlitImageInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyBufferToImageInfo2Builder<'a> {
    inner: vk::CopyBufferToImageInfo2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CopyBufferToImageInfo2 {
    type Type = CopyBufferToImageInfo2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CopyBufferToImageInfo2Builder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CopyBufferToImageInfo2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_buffer(mut self, src_buffer: vk::Buffer) -> Self {
        self.inner.src_buffer = src_buffer;
        self
    }
    pub fn dst_image(mut self, dst_image: vk::Image) -> Self {
        self.inner.dst_image = dst_image;
        self
    }
    pub fn dst_image_layout(mut self, dst_image_layout: vk::ImageLayout) -> Self {
        self.inner.dst_image_layout = dst_image_layout;
        self
    }
    pub fn p_regions(mut self, p_regions: &'a [vk::BufferImageCopy2]) -> Self {
        self.inner.region_count = p_regions.len() as u32;
        self.inner.p_regions = p_regions.as_ptr();
        self
    }
}
impl<'a> Deref for CopyBufferToImageInfo2Builder<'a> {
    type Target = vk::CopyBufferToImageInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyImageToBufferInfo2Builder<'a> {
    inner: vk::CopyImageToBufferInfo2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CopyImageToBufferInfo2 {
    type Type = CopyImageToBufferInfo2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CopyImageToBufferInfo2Builder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CopyImageToBufferInfo2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_image(mut self, src_image: vk::Image) -> Self {
        self.inner.src_image = src_image;
        self
    }
    pub fn src_image_layout(mut self, src_image_layout: vk::ImageLayout) -> Self {
        self.inner.src_image_layout = src_image_layout;
        self
    }
    pub fn dst_buffer(mut self, dst_buffer: vk::Buffer) -> Self {
        self.inner.dst_buffer = dst_buffer;
        self
    }
    pub fn p_regions(mut self, p_regions: &'a [vk::BufferImageCopy2]) -> Self {
        self.inner.region_count = p_regions.len() as u32;
        self.inner.p_regions = p_regions.as_ptr();
        self
    }
}
impl<'a> Deref for CopyImageToBufferInfo2Builder<'a> {
    type Target = vk::CopyImageToBufferInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ResolveImageInfo2Builder<'a> {
    inner: vk::ResolveImageInfo2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ResolveImageInfo2 {
    type Type = ResolveImageInfo2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ResolveImageInfo2Builder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ResolveImageInfo2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_image(mut self, src_image: vk::Image) -> Self {
        self.inner.src_image = src_image;
        self
    }
    pub fn src_image_layout(mut self, src_image_layout: vk::ImageLayout) -> Self {
        self.inner.src_image_layout = src_image_layout;
        self
    }
    pub fn dst_image(mut self, dst_image: vk::Image) -> Self {
        self.inner.dst_image = dst_image;
        self
    }
    pub fn dst_image_layout(mut self, dst_image_layout: vk::ImageLayout) -> Self {
        self.inner.dst_image_layout = dst_image_layout;
        self
    }
    pub fn p_regions(mut self, p_regions: &'a [vk::ImageResolve2]) -> Self {
        self.inner.region_count = p_regions.len() as u32;
        self.inner.p_regions = p_regions.as_ptr();
        self
    }
}
impl<'a> Deref for ResolveImageInfo2Builder<'a> {
    type Target = vk::ResolveImageInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder {
    inner: vk::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    type Type = PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_image_int64_atomics(mut self, shader_image_int64_atomics: bool) -> Self {
        self.inner.shader_image_int64_atomics = if shader_image_int64_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn sparse_image_int64_atomics(mut self, sparse_image_int64_atomics: bool) -> Self {
        self.inner.sparse_image_int64_atomics = if sparse_image_int64_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct FragmentShadingRateAttachmentInfoKHRBuilder<'a> {
    inner: vk::FragmentShadingRateAttachmentInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::FragmentShadingRateAttachmentInfoKHR {
    type Type = FragmentShadingRateAttachmentInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> FragmentShadingRateAttachmentInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::FragmentShadingRateAttachmentInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_fragment_shading_rate_attachment(
        mut self,
        p_fragment_shading_rate_attachment: Option<&'a vk::AttachmentReference2>,
    ) -> Self {
        self.inner.p_fragment_shading_rate_attachment = p_fragment_shading_rate_attachment.map_or(ptr::null(), |r| r);
        self
    }
    pub fn shading_rate_attachment_texel_size(mut self, shading_rate_attachment_texel_size: vk::Extent2D) -> Self {
        self.inner.shading_rate_attachment_texel_size = shading_rate_attachment_texel_size;
        self
    }
}
impl<'a> Deref for FragmentShadingRateAttachmentInfoKHRBuilder<'a> {
    type Target = vk::FragmentShadingRateAttachmentInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubpassDescription2Next for vk::FragmentShadingRateAttachmentInfoKHR {}
impl SubpassDescription2Next for FragmentShadingRateAttachmentInfoKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineFragmentShadingRateStateCreateInfoKHRBuilder {
    inner: vk::PipelineFragmentShadingRateStateCreateInfoKHR,
}
impl Builder<'_> for vk::PipelineFragmentShadingRateStateCreateInfoKHR {
    type Type = PipelineFragmentShadingRateStateCreateInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineFragmentShadingRateStateCreateInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineFragmentShadingRateStateCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn fragment_size(mut self, fragment_size: vk::Extent2D) -> Self {
        self.inner.fragment_size = fragment_size;
        self
    }
    pub fn combiner_ops(mut self, combiner_ops: [vk::FragmentShadingRateCombinerOpKHR; 2]) -> Self {
        self.inner.combiner_ops = combiner_ops;
        self
    }
}
impl Deref for PipelineFragmentShadingRateStateCreateInfoKHRBuilder {
    type Target = vk::PipelineFragmentShadingRateStateCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::PipelineFragmentShadingRateStateCreateInfoKHR {}
impl GraphicsPipelineCreateInfoNext for PipelineFragmentShadingRateStateCreateInfoKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceFragmentShadingRateFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceFragmentShadingRateFeaturesKHR {
    type Type = PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceFragmentShadingRateFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline_fragment_shading_rate(mut self, pipeline_fragment_shading_rate: bool) -> Self {
        self.inner.pipeline_fragment_shading_rate = if pipeline_fragment_shading_rate {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn primitive_fragment_shading_rate(mut self, primitive_fragment_shading_rate: bool) -> Self {
        self.inner.primitive_fragment_shading_rate = if primitive_fragment_shading_rate {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn attachment_fragment_shading_rate(mut self, attachment_fragment_shading_rate: bool) -> Self {
        self.inner.attachment_fragment_shading_rate = if attachment_fragment_shading_rate {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceFragmentShadingRateFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceFragmentShadingRateFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceFragmentShadingRateFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceFragmentShadingRatePropertiesKHR {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderTerminateInvocationFeaturesBuilder {
    inner: vk::PhysicalDeviceShaderTerminateInvocationFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceShaderTerminateInvocationFeatures {
    type Type = PhysicalDeviceShaderTerminateInvocationFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderTerminateInvocationFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderTerminateInvocationFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_terminate_invocation(mut self, shader_terminate_invocation: bool) -> Self {
        self.inner.shader_terminate_invocation = if shader_terminate_invocation {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderTerminateInvocationFeaturesBuilder {
    type Target = vk::PhysicalDeviceShaderTerminateInvocationFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderTerminateInvocationFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderTerminateInvocationFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderTerminateInvocationFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderTerminateInvocationFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder {
    inner: vk::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    type Type = PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn fragment_shading_rate_enums(mut self, fragment_shading_rate_enums: bool) -> Self {
        self.inner.fragment_shading_rate_enums = if fragment_shading_rate_enums {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn supersample_fragment_shading_rates(mut self, supersample_fragment_shading_rates: bool) -> Self {
        self.inner.supersample_fragment_shading_rates = if supersample_fragment_shading_rates {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn no_invocation_fragment_shading_rates(mut self, no_invocation_fragment_shading_rates: bool) -> Self {
        self.inner.no_invocation_fragment_shading_rates = if no_invocation_fragment_shading_rates {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder {
    inner: vk::PipelineFragmentShadingRateEnumStateCreateInfoNV,
}
impl Builder<'_> for vk::PipelineFragmentShadingRateEnumStateCreateInfoNV {
    type Type = PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineFragmentShadingRateEnumStateCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shading_rate_type(mut self, shading_rate_type: vk::FragmentShadingRateTypeNV) -> Self {
        self.inner.shading_rate_type = shading_rate_type;
        self
    }
    pub fn shading_rate(mut self, shading_rate: vk::FragmentShadingRateNV) -> Self {
        self.inner.shading_rate = shading_rate;
        self
    }
    pub fn combiner_ops(mut self, combiner_ops: [vk::FragmentShadingRateCombinerOpKHR; 2]) -> Self {
        self.inner.combiner_ops = combiner_ops;
        self
    }
}
impl Deref for PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder {
    type Target = vk::PipelineFragmentShadingRateEnumStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::PipelineFragmentShadingRateEnumStateCreateInfoNV {}
impl GraphicsPipelineCreateInfoNext for PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceImage2DViewOf3DFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceImage2DViewOf3DFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceImage2DViewOf3DFeaturesEXT {
    type Type = PhysicalDeviceImage2DViewOf3DFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceImage2DViewOf3DFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceImage2DViewOf3DFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image_2d_view_of_3d(mut self, image_2d_view_of_3d: bool) -> Self {
        self.inner.image_2d_view_of_3d = if image_2d_view_of_3d { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn sampler_2d_view_of_3d(mut self, sampler_2d_view_of_3d: bool) -> Self {
        self.inner.sampler_2d_view_of_3d = if sampler_2d_view_of_3d { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceImage2DViewOf3DFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceImage2DViewOf3DFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceImage2DViewOf3DFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceImage2DViewOf3DFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceImage2DViewOf3DFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceImage2DViewOf3DFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceImageSlicedViewOf3DFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceImageSlicedViewOf3DFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceImageSlicedViewOf3DFeaturesEXT {
    type Type = PhysicalDeviceImageSlicedViewOf3DFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceImageSlicedViewOf3DFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceImageSlicedViewOf3DFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image_sliced_view_of_3d(mut self, image_sliced_view_of_3d: bool) -> Self {
        self.inner.image_sliced_view_of_3d = if image_sliced_view_of_3d { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceImageSlicedViewOf3DFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceImageSlicedViewOf3DFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceImageSlicedViewOf3DFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceImageSlicedViewOf3DFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceImageSlicedViewOf3DFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceImageSlicedViewOf3DFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {
    type Type = PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn attachment_feedback_loop_dynamic_state(mut self, attachment_feedback_loop_dynamic_state: bool) -> Self {
        self.inner.attachment_feedback_loop_dynamic_state = if attachment_feedback_loop_dynamic_state {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceLegacyVertexAttributesFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceLegacyVertexAttributesFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceLegacyVertexAttributesFeaturesEXT {
    type Type = PhysicalDeviceLegacyVertexAttributesFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceLegacyVertexAttributesFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceLegacyVertexAttributesFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn legacy_vertex_attributes(mut self, legacy_vertex_attributes: bool) -> Self {
        self.inner.legacy_vertex_attributes = if legacy_vertex_attributes { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceLegacyVertexAttributesFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceLegacyVertexAttributesFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceLegacyVertexAttributesFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceLegacyVertexAttributesFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceLegacyVertexAttributesFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceLegacyVertexAttributesFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceLegacyVertexAttributesPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMutableDescriptorTypeFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceMutableDescriptorTypeFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceMutableDescriptorTypeFeaturesEXT {
    type Type = PhysicalDeviceMutableDescriptorTypeFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMutableDescriptorTypeFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMutableDescriptorTypeFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn mutable_descriptor_type(mut self, mutable_descriptor_type: bool) -> Self {
        self.inner.mutable_descriptor_type = if mutable_descriptor_type { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceMutableDescriptorTypeFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceMutableDescriptorTypeFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMutableDescriptorTypeFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMutableDescriptorTypeFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMutableDescriptorTypeFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceMutableDescriptorTypeFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct MutableDescriptorTypeListEXTBuilder<'a> {
    inner: vk::MutableDescriptorTypeListEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::MutableDescriptorTypeListEXT {
    type Type = MutableDescriptorTypeListEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> MutableDescriptorTypeListEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::MutableDescriptorTypeListEXT {
        &mut self.inner
    }
    pub fn p_descriptor_types(mut self, p_descriptor_types: &'a [vk::DescriptorType]) -> Self {
        self.inner.descriptor_type_count = p_descriptor_types.len() as u32;
        self.inner.p_descriptor_types = p_descriptor_types.as_ptr();
        self
    }
}
impl<'a> Deref for MutableDescriptorTypeListEXTBuilder<'a> {
    type Target = vk::MutableDescriptorTypeListEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MutableDescriptorTypeCreateInfoEXTBuilder<'a> {
    inner: vk::MutableDescriptorTypeCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::MutableDescriptorTypeCreateInfoEXT {
    type Type = MutableDescriptorTypeCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> MutableDescriptorTypeCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::MutableDescriptorTypeCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_mutable_descriptor_type_lists(
        mut self,
        p_mutable_descriptor_type_lists: &'a [vk::MutableDescriptorTypeListEXT],
    ) -> Self {
        self.inner.mutable_descriptor_type_list_count = p_mutable_descriptor_type_lists.len() as u32;
        self.inner.p_mutable_descriptor_type_lists = p_mutable_descriptor_type_lists.as_ptr();
        self
    }
}
impl<'a> Deref for MutableDescriptorTypeCreateInfoEXTBuilder<'a> {
    type Target = vk::MutableDescriptorTypeCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DescriptorSetLayoutCreateInfoNext for vk::MutableDescriptorTypeCreateInfoEXT {}
impl DescriptorSetLayoutCreateInfoNext for MutableDescriptorTypeCreateInfoEXTBuilder<'_> {}
impl DescriptorPoolCreateInfoNext for vk::MutableDescriptorTypeCreateInfoEXT {}
impl DescriptorPoolCreateInfoNext for MutableDescriptorTypeCreateInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDepthClipControlFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceDepthClipControlFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceDepthClipControlFeaturesEXT {
    type Type = PhysicalDeviceDepthClipControlFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDepthClipControlFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDepthClipControlFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn depth_clip_control(mut self, depth_clip_control: bool) -> Self {
        self.inner.depth_clip_control = if depth_clip_control { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceDepthClipControlFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceDepthClipControlFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDepthClipControlFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDepthClipControlFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDepthClipControlFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceDepthClipControlFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT {
    type Type = PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn zero_initialize_device_memory(mut self, zero_initialize_device_memory: bool) -> Self {
        self.inner.zero_initialize_device_memory = if zero_initialize_device_memory {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDeviceGeneratedCommandsFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT {
    type Type = PhysicalDeviceDeviceGeneratedCommandsFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDeviceGeneratedCommandsFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn device_generated_commands(mut self, device_generated_commands: bool) -> Self {
        self.inner.device_generated_commands = if device_generated_commands { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn dynamic_generated_pipeline_layout(mut self, dynamic_generated_pipeline_layout: bool) -> Self {
        self.inner.dynamic_generated_pipeline_layout = if dynamic_generated_pipeline_layout {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceDeviceGeneratedCommandsFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDeviceGeneratedCommandsFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceDeviceGeneratedCommandsFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceDeviceGeneratedCommandsPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct GeneratedCommandsPipelineInfoEXTBuilder {
    inner: vk::GeneratedCommandsPipelineInfoEXT,
}
impl Builder<'_> for vk::GeneratedCommandsPipelineInfoEXT {
    type Type = GeneratedCommandsPipelineInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl GeneratedCommandsPipelineInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::GeneratedCommandsPipelineInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline(mut self, pipeline: vk::Pipeline) -> Self {
        self.inner.pipeline = pipeline;
        self
    }
}
impl Deref for GeneratedCommandsPipelineInfoEXTBuilder {
    type Target = vk::GeneratedCommandsPipelineInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GeneratedCommandsInfoEXTNext for vk::GeneratedCommandsPipelineInfoEXT {}
impl GeneratedCommandsInfoEXTNext for GeneratedCommandsPipelineInfoEXTBuilder {}
impl GeneratedCommandsMemoryRequirementsInfoEXTNext for vk::GeneratedCommandsPipelineInfoEXT {}
impl GeneratedCommandsMemoryRequirementsInfoEXTNext for GeneratedCommandsPipelineInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct GeneratedCommandsShaderInfoEXTBuilder<'a> {
    inner: vk::GeneratedCommandsShaderInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::GeneratedCommandsShaderInfoEXT {
    type Type = GeneratedCommandsShaderInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> GeneratedCommandsShaderInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::GeneratedCommandsShaderInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_shaders(mut self, p_shaders: &'a [vk::ShaderEXT]) -> Self {
        self.inner.shader_count = p_shaders.len() as u32;
        self.inner.p_shaders = p_shaders.as_ptr();
        self
    }
}
impl<'a> Deref for GeneratedCommandsShaderInfoEXTBuilder<'a> {
    type Target = vk::GeneratedCommandsShaderInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GeneratedCommandsInfoEXTNext for vk::GeneratedCommandsShaderInfoEXT {}
impl GeneratedCommandsInfoEXTNext for GeneratedCommandsShaderInfoEXTBuilder<'_> {}
impl GeneratedCommandsMemoryRequirementsInfoEXTNext for vk::GeneratedCommandsShaderInfoEXT {}
impl GeneratedCommandsMemoryRequirementsInfoEXTNext for GeneratedCommandsShaderInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct GeneratedCommandsMemoryRequirementsInfoEXTBuilder<'a> {
    inner: vk::GeneratedCommandsMemoryRequirementsInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::GeneratedCommandsMemoryRequirementsInfoEXT {
    type Type = GeneratedCommandsMemoryRequirementsInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait GeneratedCommandsMemoryRequirementsInfoEXTNext {}
impl<'a> GeneratedCommandsMemoryRequirementsInfoEXTBuilder<'a> {
    pub fn insert_next<T: GeneratedCommandsMemoryRequirementsInfoEXTNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::GeneratedCommandsMemoryRequirementsInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn indirect_execution_set(mut self, indirect_execution_set: vk::IndirectExecutionSetEXT) -> Self {
        self.inner.indirect_execution_set = indirect_execution_set;
        self
    }
    pub fn indirect_commands_layout(mut self, indirect_commands_layout: vk::IndirectCommandsLayoutEXT) -> Self {
        self.inner.indirect_commands_layout = indirect_commands_layout;
        self
    }
    pub fn max_sequence_count(mut self, max_sequence_count: u32) -> Self {
        self.inner.max_sequence_count = max_sequence_count;
        self
    }
    pub fn max_draw_count(mut self, max_draw_count: u32) -> Self {
        self.inner.max_draw_count = max_draw_count;
        self
    }
}
impl<'a> Deref for GeneratedCommandsMemoryRequirementsInfoEXTBuilder<'a> {
    type Target = vk::GeneratedCommandsMemoryRequirementsInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct IndirectExecutionSetPipelineInfoEXTBuilder {
    inner: vk::IndirectExecutionSetPipelineInfoEXT,
}
impl Builder<'_> for vk::IndirectExecutionSetPipelineInfoEXT {
    type Type = IndirectExecutionSetPipelineInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl IndirectExecutionSetPipelineInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::IndirectExecutionSetPipelineInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn initial_pipeline(mut self, initial_pipeline: vk::Pipeline) -> Self {
        self.inner.initial_pipeline = initial_pipeline;
        self
    }
    pub fn max_pipeline_count(mut self, max_pipeline_count: u32) -> Self {
        self.inner.max_pipeline_count = max_pipeline_count;
        self
    }
}
impl Deref for IndirectExecutionSetPipelineInfoEXTBuilder {
    type Target = vk::IndirectExecutionSetPipelineInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct IndirectExecutionSetShaderLayoutInfoEXTBuilder<'a> {
    inner: vk::IndirectExecutionSetShaderLayoutInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::IndirectExecutionSetShaderLayoutInfoEXT {
    type Type = IndirectExecutionSetShaderLayoutInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> IndirectExecutionSetShaderLayoutInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::IndirectExecutionSetShaderLayoutInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_set_layouts(mut self, p_set_layouts: &'a [vk::DescriptorSetLayout]) -> Self {
        self.inner.set_layout_count = p_set_layouts.len() as u32;
        self.inner.p_set_layouts = p_set_layouts.as_ptr();
        self
    }
}
impl<'a> Deref for IndirectExecutionSetShaderLayoutInfoEXTBuilder<'a> {
    type Target = vk::IndirectExecutionSetShaderLayoutInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct IndirectExecutionSetShaderInfoEXTBuilder<'a> {
    inner: vk::IndirectExecutionSetShaderInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::IndirectExecutionSetShaderInfoEXT {
    type Type = IndirectExecutionSetShaderInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> IndirectExecutionSetShaderInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::IndirectExecutionSetShaderInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_initial_shaders(
        mut self,
        p_initial_shaders: &'a [vk::ShaderEXT],
        p_set_layout_infos: Option<&'a [vk::IndirectExecutionSetShaderLayoutInfoEXT]>,
    ) -> Self {
        self.inner.shader_count = p_initial_shaders.len() as u32;
        self.inner.p_initial_shaders = p_initial_shaders.as_ptr();
        self.inner.p_set_layout_infos = p_set_layout_infos.map_or(ptr::null(), |s| s.as_ptr());
        self
    }
    pub fn max_shader_count(mut self, max_shader_count: u32) -> Self {
        self.inner.max_shader_count = max_shader_count;
        self
    }
    pub fn p_push_constant_ranges(mut self, p_push_constant_ranges: &'a [vk::PushConstantRange]) -> Self {
        self.inner.push_constant_range_count = p_push_constant_ranges.len() as u32;
        self.inner.p_push_constant_ranges = p_push_constant_ranges.as_ptr();
        self
    }
}
impl<'a> Deref for IndirectExecutionSetShaderInfoEXTBuilder<'a> {
    type Target = vk::IndirectExecutionSetShaderInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct IndirectExecutionSetCreateInfoEXTBuilder {
    inner: vk::IndirectExecutionSetCreateInfoEXT,
}
impl Builder<'_> for vk::IndirectExecutionSetCreateInfoEXT {
    type Type = IndirectExecutionSetCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl IndirectExecutionSetCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::IndirectExecutionSetCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ty(mut self, ty: vk::IndirectExecutionSetInfoTypeEXT) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn info(mut self, info: vk::IndirectExecutionSetInfoEXT) -> Self {
        self.inner.info = info;
        self
    }
}
impl Deref for IndirectExecutionSetCreateInfoEXTBuilder {
    type Target = vk::IndirectExecutionSetCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct GeneratedCommandsInfoEXTBuilder<'a> {
    inner: vk::GeneratedCommandsInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::GeneratedCommandsInfoEXT {
    type Type = GeneratedCommandsInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait GeneratedCommandsInfoEXTNext {}
impl<'a> GeneratedCommandsInfoEXTBuilder<'a> {
    pub fn insert_next<T: GeneratedCommandsInfoEXTNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::GeneratedCommandsInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_stages(mut self, shader_stages: vk::ShaderStageFlags) -> Self {
        self.inner.shader_stages = shader_stages;
        self
    }
    pub fn indirect_execution_set(mut self, indirect_execution_set: vk::IndirectExecutionSetEXT) -> Self {
        self.inner.indirect_execution_set = indirect_execution_set;
        self
    }
    pub fn indirect_commands_layout(mut self, indirect_commands_layout: vk::IndirectCommandsLayoutEXT) -> Self {
        self.inner.indirect_commands_layout = indirect_commands_layout;
        self
    }
    pub fn indirect_address(mut self, indirect_address: vk::DeviceAddress) -> Self {
        self.inner.indirect_address = indirect_address;
        self
    }
    pub fn indirect_address_size(mut self, indirect_address_size: vk::DeviceSize) -> Self {
        self.inner.indirect_address_size = indirect_address_size;
        self
    }
    pub fn preprocess_address(mut self, preprocess_address: vk::DeviceAddress) -> Self {
        self.inner.preprocess_address = preprocess_address;
        self
    }
    pub fn preprocess_size(mut self, preprocess_size: vk::DeviceSize) -> Self {
        self.inner.preprocess_size = preprocess_size;
        self
    }
    pub fn max_sequence_count(mut self, max_sequence_count: u32) -> Self {
        self.inner.max_sequence_count = max_sequence_count;
        self
    }
    pub fn sequence_count_address(mut self, sequence_count_address: vk::DeviceAddress) -> Self {
        self.inner.sequence_count_address = sequence_count_address;
        self
    }
    pub fn max_draw_count(mut self, max_draw_count: u32) -> Self {
        self.inner.max_draw_count = max_draw_count;
        self
    }
}
impl<'a> Deref for GeneratedCommandsInfoEXTBuilder<'a> {
    type Target = vk::GeneratedCommandsInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct WriteIndirectExecutionSetPipelineEXTBuilder {
    inner: vk::WriteIndirectExecutionSetPipelineEXT,
}
impl Builder<'_> for vk::WriteIndirectExecutionSetPipelineEXT {
    type Type = WriteIndirectExecutionSetPipelineEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl WriteIndirectExecutionSetPipelineEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::WriteIndirectExecutionSetPipelineEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn index(mut self, index: u32) -> Self {
        self.inner.index = index;
        self
    }
    pub fn pipeline(mut self, pipeline: vk::Pipeline) -> Self {
        self.inner.pipeline = pipeline;
        self
    }
}
impl Deref for WriteIndirectExecutionSetPipelineEXTBuilder {
    type Target = vk::WriteIndirectExecutionSetPipelineEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct WriteIndirectExecutionSetShaderEXTBuilder {
    inner: vk::WriteIndirectExecutionSetShaderEXT,
}
impl Builder<'_> for vk::WriteIndirectExecutionSetShaderEXT {
    type Type = WriteIndirectExecutionSetShaderEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl WriteIndirectExecutionSetShaderEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::WriteIndirectExecutionSetShaderEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn index(mut self, index: u32) -> Self {
        self.inner.index = index;
        self
    }
    pub fn shader(mut self, shader: vk::ShaderEXT) -> Self {
        self.inner.shader = shader;
        self
    }
}
impl Deref for WriteIndirectExecutionSetShaderEXTBuilder {
    type Target = vk::WriteIndirectExecutionSetShaderEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct IndirectCommandsLayoutCreateInfoEXTBuilder<'a> {
    inner: vk::IndirectCommandsLayoutCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::IndirectCommandsLayoutCreateInfoEXT {
    type Type = IndirectCommandsLayoutCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait IndirectCommandsLayoutCreateInfoEXTNext {}
impl<'a> IndirectCommandsLayoutCreateInfoEXTBuilder<'a> {
    pub fn insert_next<T: IndirectCommandsLayoutCreateInfoEXTNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::IndirectCommandsLayoutCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::IndirectCommandsLayoutUsageFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn shader_stages(mut self, shader_stages: vk::ShaderStageFlags) -> Self {
        self.inner.shader_stages = shader_stages;
        self
    }
    pub fn indirect_stride(mut self, indirect_stride: u32) -> Self {
        self.inner.indirect_stride = indirect_stride;
        self
    }
    pub fn pipeline_layout(mut self, pipeline_layout: vk::PipelineLayout) -> Self {
        self.inner.pipeline_layout = pipeline_layout;
        self
    }
    pub fn p_tokens(mut self, p_tokens: &'a [vk::IndirectCommandsLayoutTokenEXT]) -> Self {
        self.inner.token_count = p_tokens.len() as u32;
        self.inner.p_tokens = p_tokens.as_ptr();
        self
    }
}
impl<'a> Deref for IndirectCommandsLayoutCreateInfoEXTBuilder<'a> {
    type Target = vk::IndirectCommandsLayoutCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct IndirectCommandsLayoutTokenEXTBuilder {
    inner: vk::IndirectCommandsLayoutTokenEXT,
}
impl Builder<'_> for vk::IndirectCommandsLayoutTokenEXT {
    type Type = IndirectCommandsLayoutTokenEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl IndirectCommandsLayoutTokenEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::IndirectCommandsLayoutTokenEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ty(mut self, ty: vk::IndirectCommandsTokenTypeEXT) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn data(mut self, data: vk::IndirectCommandsTokenDataEXT) -> Self {
        self.inner.data = data;
        self
    }
    pub fn offset(mut self, offset: u32) -> Self {
        self.inner.offset = offset;
        self
    }
}
impl Deref for IndirectCommandsLayoutTokenEXTBuilder {
    type Target = vk::IndirectCommandsLayoutTokenEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DrawIndirectCountIndirectCommandEXTBuilder {
    inner: vk::DrawIndirectCountIndirectCommandEXT,
}
impl Builder<'_> for vk::DrawIndirectCountIndirectCommandEXT {
    type Type = DrawIndirectCountIndirectCommandEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DrawIndirectCountIndirectCommandEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DrawIndirectCountIndirectCommandEXT {
        &mut self.inner
    }
    pub fn buffer_address(mut self, buffer_address: vk::DeviceAddress) -> Self {
        self.inner.buffer_address = buffer_address;
        self
    }
    pub fn stride(mut self, stride: u32) -> Self {
        self.inner.stride = stride;
        self
    }
    pub fn command_count(mut self, command_count: u32) -> Self {
        self.inner.command_count = command_count;
        self
    }
}
impl Deref for DrawIndirectCountIndirectCommandEXTBuilder {
    type Target = vk::DrawIndirectCountIndirectCommandEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct IndirectCommandsVertexBufferTokenEXTBuilder {
    inner: vk::IndirectCommandsVertexBufferTokenEXT,
}
impl Builder<'_> for vk::IndirectCommandsVertexBufferTokenEXT {
    type Type = IndirectCommandsVertexBufferTokenEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl IndirectCommandsVertexBufferTokenEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::IndirectCommandsVertexBufferTokenEXT {
        &mut self.inner
    }
    pub fn vertex_binding_unit(mut self, vertex_binding_unit: u32) -> Self {
        self.inner.vertex_binding_unit = vertex_binding_unit;
        self
    }
}
impl Deref for IndirectCommandsVertexBufferTokenEXTBuilder {
    type Target = vk::IndirectCommandsVertexBufferTokenEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BindVertexBufferIndirectCommandEXTBuilder {
    inner: vk::BindVertexBufferIndirectCommandEXT,
}
impl Builder<'_> for vk::BindVertexBufferIndirectCommandEXT {
    type Type = BindVertexBufferIndirectCommandEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BindVertexBufferIndirectCommandEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BindVertexBufferIndirectCommandEXT {
        &mut self.inner
    }
    pub fn buffer_address(mut self, buffer_address: vk::DeviceAddress) -> Self {
        self.inner.buffer_address = buffer_address;
        self
    }
    pub fn size(mut self, size: u32) -> Self {
        self.inner.size = size;
        self
    }
    pub fn stride(mut self, stride: u32) -> Self {
        self.inner.stride = stride;
        self
    }
}
impl Deref for BindVertexBufferIndirectCommandEXTBuilder {
    type Target = vk::BindVertexBufferIndirectCommandEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct IndirectCommandsIndexBufferTokenEXTBuilder {
    inner: vk::IndirectCommandsIndexBufferTokenEXT,
}
impl Builder<'_> for vk::IndirectCommandsIndexBufferTokenEXT {
    type Type = IndirectCommandsIndexBufferTokenEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl IndirectCommandsIndexBufferTokenEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::IndirectCommandsIndexBufferTokenEXT {
        &mut self.inner
    }
    pub fn mode(mut self, mode: vk::IndirectCommandsInputModeFlagsEXT) -> Self {
        self.inner.mode = mode;
        self
    }
}
impl Deref for IndirectCommandsIndexBufferTokenEXTBuilder {
    type Target = vk::IndirectCommandsIndexBufferTokenEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BindIndexBufferIndirectCommandEXTBuilder {
    inner: vk::BindIndexBufferIndirectCommandEXT,
}
impl Builder<'_> for vk::BindIndexBufferIndirectCommandEXT {
    type Type = BindIndexBufferIndirectCommandEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BindIndexBufferIndirectCommandEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BindIndexBufferIndirectCommandEXT {
        &mut self.inner
    }
    pub fn buffer_address(mut self, buffer_address: vk::DeviceAddress) -> Self {
        self.inner.buffer_address = buffer_address;
        self
    }
    pub fn size(mut self, size: u32) -> Self {
        self.inner.size = size;
        self
    }
    pub fn index_type(mut self, index_type: vk::IndexType) -> Self {
        self.inner.index_type = index_type;
        self
    }
}
impl Deref for BindIndexBufferIndirectCommandEXTBuilder {
    type Target = vk::BindIndexBufferIndirectCommandEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct IndirectCommandsPushConstantTokenEXTBuilder {
    inner: vk::IndirectCommandsPushConstantTokenEXT,
}
impl Builder<'_> for vk::IndirectCommandsPushConstantTokenEXT {
    type Type = IndirectCommandsPushConstantTokenEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl IndirectCommandsPushConstantTokenEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::IndirectCommandsPushConstantTokenEXT {
        &mut self.inner
    }
    pub fn update_range(mut self, update_range: vk::PushConstantRange) -> Self {
        self.inner.update_range = update_range;
        self
    }
}
impl Deref for IndirectCommandsPushConstantTokenEXTBuilder {
    type Target = vk::IndirectCommandsPushConstantTokenEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct IndirectCommandsExecutionSetTokenEXTBuilder {
    inner: vk::IndirectCommandsExecutionSetTokenEXT,
}
impl Builder<'_> for vk::IndirectCommandsExecutionSetTokenEXT {
    type Type = IndirectCommandsExecutionSetTokenEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl IndirectCommandsExecutionSetTokenEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::IndirectCommandsExecutionSetTokenEXT {
        &mut self.inner
    }
    pub fn ty(mut self, ty: vk::IndirectExecutionSetInfoTypeEXT) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn shader_stages(mut self, shader_stages: vk::ShaderStageFlags) -> Self {
        self.inner.shader_stages = shader_stages;
        self
    }
}
impl Deref for IndirectCommandsExecutionSetTokenEXTBuilder {
    type Target = vk::IndirectCommandsExecutionSetTokenEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineViewportDepthClipControlCreateInfoEXTBuilder {
    inner: vk::PipelineViewportDepthClipControlCreateInfoEXT,
}
impl Builder<'_> for vk::PipelineViewportDepthClipControlCreateInfoEXT {
    type Type = PipelineViewportDepthClipControlCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineViewportDepthClipControlCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineViewportDepthClipControlCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn negative_one_to_one(mut self, negative_one_to_one: bool) -> Self {
        self.inner.negative_one_to_one = if negative_one_to_one { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PipelineViewportDepthClipControlCreateInfoEXTBuilder {
    type Target = vk::PipelineViewportDepthClipControlCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineViewportStateCreateInfoNext for vk::PipelineViewportDepthClipControlCreateInfoEXT {}
impl PipelineViewportStateCreateInfoNext for PipelineViewportDepthClipControlCreateInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDepthClampControlFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceDepthClampControlFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceDepthClampControlFeaturesEXT {
    type Type = PhysicalDeviceDepthClampControlFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDepthClampControlFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDepthClampControlFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn depth_clamp_control(mut self, depth_clamp_control: bool) -> Self {
        self.inner.depth_clamp_control = if depth_clamp_control { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceDepthClampControlFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceDepthClampControlFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDepthClampControlFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDepthClampControlFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDepthClampControlFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceDepthClampControlFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineViewportDepthClampControlCreateInfoEXTBuilder<'a> {
    inner: vk::PipelineViewportDepthClampControlCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineViewportDepthClampControlCreateInfoEXT {
    type Type = PipelineViewportDepthClampControlCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineViewportDepthClampControlCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineViewportDepthClampControlCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn depth_clamp_mode(mut self, depth_clamp_mode: vk::DepthClampModeEXT) -> Self {
        self.inner.depth_clamp_mode = depth_clamp_mode;
        self
    }
    pub fn p_depth_clamp_range(mut self, p_depth_clamp_range: Option<&'a vk::DepthClampRangeEXT>) -> Self {
        self.inner.p_depth_clamp_range = p_depth_clamp_range.map_or(ptr::null(), |r| r);
        self
    }
}
impl<'a> Deref for PipelineViewportDepthClampControlCreateInfoEXTBuilder<'a> {
    type Target = vk::PipelineViewportDepthClampControlCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineViewportStateCreateInfoNext for vk::PipelineViewportDepthClampControlCreateInfoEXT {}
impl PipelineViewportStateCreateInfoNext for PipelineViewportDepthClampControlCreateInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceVertexInputDynamicStateFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    type Type = PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn vertex_input_dynamic_state(mut self, vertex_input_dynamic_state: bool) -> Self {
        self.inner.vertex_input_dynamic_state = if vertex_input_dynamic_state {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceVertexInputDynamicStateFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceVertexInputDynamicStateFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceVertexInputDynamicStateFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder {
    inner: vk::PhysicalDeviceExternalMemoryRDMAFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceExternalMemoryRDMAFeaturesNV {
    type Type = PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceExternalMemoryRDMAFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn external_memory_rdma(mut self, external_memory_rdma: bool) -> Self {
        self.inner.external_memory_rdma = if external_memory_rdma { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceExternalMemoryRDMAFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceExternalMemoryRDMAFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceExternalMemoryRDMAFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR {
    type Type = PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_relaxed_extended_instruction(mut self, shader_relaxed_extended_instruction: bool) -> Self {
        self.inner.shader_relaxed_extended_instruction = if shader_relaxed_extended_instruction {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct VertexInputBindingDescription2EXTBuilder {
    inner: vk::VertexInputBindingDescription2EXT,
}
impl Builder<'_> for vk::VertexInputBindingDescription2EXT {
    type Type = VertexInputBindingDescription2EXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl VertexInputBindingDescription2EXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::VertexInputBindingDescription2EXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
    pub fn stride(mut self, stride: u32) -> Self {
        self.inner.stride = stride;
        self
    }
    pub fn input_rate(mut self, input_rate: vk::VertexInputRate) -> Self {
        self.inner.input_rate = input_rate;
        self
    }
    pub fn divisor(mut self, divisor: u32) -> Self {
        self.inner.divisor = divisor;
        self
    }
}
impl Deref for VertexInputBindingDescription2EXTBuilder {
    type Target = vk::VertexInputBindingDescription2EXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct VertexInputAttributeDescription2EXTBuilder {
    inner: vk::VertexInputAttributeDescription2EXT,
}
impl Builder<'_> for vk::VertexInputAttributeDescription2EXT {
    type Type = VertexInputAttributeDescription2EXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl VertexInputAttributeDescription2EXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::VertexInputAttributeDescription2EXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn location(mut self, location: u32) -> Self {
        self.inner.location = location;
        self
    }
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
    pub fn format(mut self, format: vk::Format) -> Self {
        self.inner.format = format;
        self
    }
    pub fn offset(mut self, offset: u32) -> Self {
        self.inner.offset = offset;
        self
    }
}
impl Deref for VertexInputAttributeDescription2EXTBuilder {
    type Target = vk::VertexInputAttributeDescription2EXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceColorWriteEnableFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceColorWriteEnableFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceColorWriteEnableFeaturesEXT {
    type Type = PhysicalDeviceColorWriteEnableFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceColorWriteEnableFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceColorWriteEnableFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn color_write_enable(mut self, color_write_enable: bool) -> Self {
        self.inner.color_write_enable = if color_write_enable { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceColorWriteEnableFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceColorWriteEnableFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceColorWriteEnableFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceColorWriteEnableFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceColorWriteEnableFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceColorWriteEnableFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineColorWriteCreateInfoEXTBuilder<'a> {
    inner: vk::PipelineColorWriteCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineColorWriteCreateInfoEXT {
    type Type = PipelineColorWriteCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineColorWriteCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineColorWriteCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_color_write_enables(mut self, p_color_write_enables: &'a [vk::Bool32]) -> Self {
        self.inner.attachment_count = p_color_write_enables.len() as u32;
        self.inner.p_color_write_enables = p_color_write_enables.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineColorWriteCreateInfoEXTBuilder<'a> {
    type Target = vk::PipelineColorWriteCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineColorBlendStateCreateInfoNext for vk::PipelineColorWriteCreateInfoEXT {}
impl PipelineColorBlendStateCreateInfoNext for PipelineColorWriteCreateInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryBarrier2Builder {
    inner: vk::MemoryBarrier2,
}
impl Builder<'_> for vk::MemoryBarrier2 {
    type Type = MemoryBarrier2Builder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryBarrier2Builder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryBarrier2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_stage_mask(mut self, src_stage_mask: vk::PipelineStageFlags2) -> Self {
        self.inner.src_stage_mask = src_stage_mask;
        self
    }
    pub fn src_access_mask(mut self, src_access_mask: vk::AccessFlags2) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    pub fn dst_stage_mask(mut self, dst_stage_mask: vk::PipelineStageFlags2) -> Self {
        self.inner.dst_stage_mask = dst_stage_mask;
        self
    }
    pub fn dst_access_mask(mut self, dst_access_mask: vk::AccessFlags2) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
}
impl Deref for MemoryBarrier2Builder {
    type Target = vk::MemoryBarrier2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubpassDependency2Next for vk::MemoryBarrier2 {}
impl SubpassDependency2Next for MemoryBarrier2Builder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageMemoryBarrier2Builder<'a> {
    inner: vk::ImageMemoryBarrier2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImageMemoryBarrier2 {
    type Type = ImageMemoryBarrier2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait ImageMemoryBarrier2Next {}
impl<'a> ImageMemoryBarrier2Builder<'a> {
    pub fn insert_next<T: ImageMemoryBarrier2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::ImageMemoryBarrier2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_stage_mask(mut self, src_stage_mask: vk::PipelineStageFlags2) -> Self {
        self.inner.src_stage_mask = src_stage_mask;
        self
    }
    pub fn src_access_mask(mut self, src_access_mask: vk::AccessFlags2) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    pub fn dst_stage_mask(mut self, dst_stage_mask: vk::PipelineStageFlags2) -> Self {
        self.inner.dst_stage_mask = dst_stage_mask;
        self
    }
    pub fn dst_access_mask(mut self, dst_access_mask: vk::AccessFlags2) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    pub fn old_layout(mut self, old_layout: vk::ImageLayout) -> Self {
        self.inner.old_layout = old_layout;
        self
    }
    pub fn new_layout(mut self, new_layout: vk::ImageLayout) -> Self {
        self.inner.new_layout = new_layout;
        self
    }
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.inner.src_queue_family_index = src_queue_family_index;
        self
    }
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.inner.dst_queue_family_index = dst_queue_family_index;
        self
    }
    pub fn image(mut self, image: vk::Image) -> Self {
        self.inner.image = image;
        self
    }
    pub fn subresource_range(mut self, subresource_range: vk::ImageSubresourceRange) -> Self {
        self.inner.subresource_range = subresource_range;
        self
    }
}
impl<'a> Deref for ImageMemoryBarrier2Builder<'a> {
    type Target = vk::ImageMemoryBarrier2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferMemoryBarrier2Builder<'a> {
    inner: vk::BufferMemoryBarrier2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BufferMemoryBarrier2 {
    type Type = BufferMemoryBarrier2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait BufferMemoryBarrier2Next {}
impl<'a> BufferMemoryBarrier2Builder<'a> {
    pub fn insert_next<T: BufferMemoryBarrier2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::BufferMemoryBarrier2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_stage_mask(mut self, src_stage_mask: vk::PipelineStageFlags2) -> Self {
        self.inner.src_stage_mask = src_stage_mask;
        self
    }
    pub fn src_access_mask(mut self, src_access_mask: vk::AccessFlags2) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    pub fn dst_stage_mask(mut self, dst_stage_mask: vk::PipelineStageFlags2) -> Self {
        self.inner.dst_stage_mask = dst_stage_mask;
        self
    }
    pub fn dst_access_mask(mut self, dst_access_mask: vk::AccessFlags2) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.inner.src_queue_family_index = src_queue_family_index;
        self
    }
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.inner.dst_queue_family_index = dst_queue_family_index;
        self
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    pub fn offset(mut self, offset: vk::DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
}
impl<'a> Deref for BufferMemoryBarrier2Builder<'a> {
    type Target = vk::BufferMemoryBarrier2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryBarrierAccessFlags3KHRBuilder {
    inner: vk::MemoryBarrierAccessFlags3KHR,
}
impl Builder<'_> for vk::MemoryBarrierAccessFlags3KHR {
    type Type = MemoryBarrierAccessFlags3KHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryBarrierAccessFlags3KHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryBarrierAccessFlags3KHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_access_mask3(mut self, src_access_mask3: vk::AccessFlags3KHR) -> Self {
        self.inner.src_access_mask3 = src_access_mask3;
        self
    }
    pub fn dst_access_mask3(mut self, dst_access_mask3: vk::AccessFlags3KHR) -> Self {
        self.inner.dst_access_mask3 = dst_access_mask3;
        self
    }
}
impl Deref for MemoryBarrierAccessFlags3KHRBuilder {
    type Target = vk::MemoryBarrierAccessFlags3KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubpassDependency2Next for vk::MemoryBarrierAccessFlags3KHR {}
impl SubpassDependency2Next for MemoryBarrierAccessFlags3KHRBuilder {}
impl BufferMemoryBarrier2Next for vk::MemoryBarrierAccessFlags3KHR {}
impl BufferMemoryBarrier2Next for MemoryBarrierAccessFlags3KHRBuilder {}
impl ImageMemoryBarrier2Next for vk::MemoryBarrierAccessFlags3KHR {}
impl ImageMemoryBarrier2Next for MemoryBarrierAccessFlags3KHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DependencyInfoBuilder<'a> {
    inner: vk::DependencyInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DependencyInfo {
    type Type = DependencyInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DependencyInfoNext {}
impl<'a> DependencyInfoBuilder<'a> {
    pub fn insert_next<T: DependencyInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DependencyInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn dependency_flags(mut self, dependency_flags: vk::DependencyFlags) -> Self {
        self.inner.dependency_flags = dependency_flags;
        self
    }
    pub fn p_memory_barriers(mut self, p_memory_barriers: &'a [vk::MemoryBarrier2]) -> Self {
        self.inner.memory_barrier_count = p_memory_barriers.len() as u32;
        self.inner.p_memory_barriers = p_memory_barriers.as_ptr();
        self
    }
    pub fn p_buffer_memory_barriers(mut self, p_buffer_memory_barriers: &'a [vk::BufferMemoryBarrier2]) -> Self {
        self.inner.buffer_memory_barrier_count = p_buffer_memory_barriers.len() as u32;
        self.inner.p_buffer_memory_barriers = p_buffer_memory_barriers.as_ptr();
        self
    }
    pub fn p_image_memory_barriers(mut self, p_image_memory_barriers: &'a [vk::ImageMemoryBarrier2]) -> Self {
        self.inner.image_memory_barrier_count = p_image_memory_barriers.len() as u32;
        self.inner.p_image_memory_barriers = p_image_memory_barriers.as_ptr();
        self
    }
}
impl<'a> Deref for DependencyInfoBuilder<'a> {
    type Target = vk::DependencyInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SemaphoreSubmitInfoBuilder {
    inner: vk::SemaphoreSubmitInfo,
}
impl Builder<'_> for vk::SemaphoreSubmitInfo {
    type Type = SemaphoreSubmitInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SemaphoreSubmitInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SemaphoreSubmitInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn semaphore(mut self, semaphore: vk::Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    pub fn value(mut self, value: u64) -> Self {
        self.inner.value = value;
        self
    }
    pub fn stage_mask(mut self, stage_mask: vk::PipelineStageFlags2) -> Self {
        self.inner.stage_mask = stage_mask;
        self
    }
    pub fn device_index(mut self, device_index: u32) -> Self {
        self.inner.device_index = device_index;
        self
    }
}
impl Deref for SemaphoreSubmitInfoBuilder {
    type Target = vk::SemaphoreSubmitInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CommandBufferSubmitInfoBuilder<'a> {
    inner: vk::CommandBufferSubmitInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CommandBufferSubmitInfo {
    type Type = CommandBufferSubmitInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait CommandBufferSubmitInfoNext {}
impl<'a> CommandBufferSubmitInfoBuilder<'a> {
    pub fn insert_next<T: CommandBufferSubmitInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::CommandBufferSubmitInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn command_buffer(mut self, command_buffer: vk::CommandBuffer) -> Self {
        self.inner.command_buffer = command_buffer;
        self
    }
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.inner.device_mask = device_mask;
        self
    }
}
impl<'a> Deref for CommandBufferSubmitInfoBuilder<'a> {
    type Target = vk::CommandBufferSubmitInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SubmitInfo2Builder<'a> {
    inner: vk::SubmitInfo2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SubmitInfo2 {
    type Type = SubmitInfo2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait SubmitInfo2Next {}
impl<'a> SubmitInfo2Builder<'a> {
    pub fn insert_next<T: SubmitInfo2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::SubmitInfo2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::SubmitFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_wait_semaphore_infos(mut self, p_wait_semaphore_infos: &'a [vk::SemaphoreSubmitInfo]) -> Self {
        self.inner.wait_semaphore_info_count = p_wait_semaphore_infos.len() as u32;
        self.inner.p_wait_semaphore_infos = p_wait_semaphore_infos.as_ptr();
        self
    }
    pub fn p_command_buffer_infos(mut self, p_command_buffer_infos: &'a [vk::CommandBufferSubmitInfo]) -> Self {
        self.inner.command_buffer_info_count = p_command_buffer_infos.len() as u32;
        self.inner.p_command_buffer_infos = p_command_buffer_infos.as_ptr();
        self
    }
    pub fn p_signal_semaphore_infos(mut self, p_signal_semaphore_infos: &'a [vk::SemaphoreSubmitInfo]) -> Self {
        self.inner.signal_semaphore_info_count = p_signal_semaphore_infos.len() as u32;
        self.inner.p_signal_semaphore_infos = p_signal_semaphore_infos.as_ptr();
        self
    }
}
impl<'a> Deref for SubmitInfo2Builder<'a> {
    type Target = vk::SubmitInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl QueueFamilyProperties2Next for vk::QueueFamilyCheckpointProperties2NV {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceSynchronization2FeaturesBuilder {
    inner: vk::PhysicalDeviceSynchronization2Features,
}
impl Builder<'_> for vk::PhysicalDeviceSynchronization2Features {
    type Type = PhysicalDeviceSynchronization2FeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceSynchronization2FeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceSynchronization2Features {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn synchronization2(mut self, synchronization2: bool) -> Self {
        self.inner.synchronization2 = if synchronization2 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceSynchronization2FeaturesBuilder {
    type Target = vk::PhysicalDeviceSynchronization2Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceSynchronization2Features {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceSynchronization2FeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceSynchronization2Features {}
impl DeviceCreateInfoNext for PhysicalDeviceSynchronization2FeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceUnifiedImageLayoutsFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceUnifiedImageLayoutsFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceUnifiedImageLayoutsFeaturesKHR {
    type Type = PhysicalDeviceUnifiedImageLayoutsFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceUnifiedImageLayoutsFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceUnifiedImageLayoutsFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn unified_image_layouts(mut self, unified_image_layouts: bool) -> Self {
        self.inner.unified_image_layouts = if unified_image_layouts { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn unified_image_layouts_video(mut self, unified_image_layouts_video: bool) -> Self {
        self.inner.unified_image_layouts_video = if unified_image_layouts_video {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceUnifiedImageLayoutsFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceUnifiedImageLayoutsFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceUnifiedImageLayoutsFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceUnifiedImageLayoutsFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceUnifiedImageLayoutsFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceUnifiedImageLayoutsFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceHostImageCopyFeaturesBuilder {
    inner: vk::PhysicalDeviceHostImageCopyFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceHostImageCopyFeatures {
    type Type = PhysicalDeviceHostImageCopyFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceHostImageCopyFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceHostImageCopyFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn host_image_copy(mut self, host_image_copy: bool) -> Self {
        self.inner.host_image_copy = if host_image_copy { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceHostImageCopyFeaturesBuilder {
    type Target = vk::PhysicalDeviceHostImageCopyFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceHostImageCopyFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceHostImageCopyFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceHostImageCopyFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceHostImageCopyFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceHostImageCopyPropertiesBuilder<'a> {
    inner: vk::PhysicalDeviceHostImageCopyProperties,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PhysicalDeviceHostImageCopyProperties {
    type Type = PhysicalDeviceHostImageCopyPropertiesBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PhysicalDeviceHostImageCopyPropertiesBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceHostImageCopyProperties {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_copy_src_layouts(mut self, p_copy_src_layouts: &'a mut [vk::ImageLayout]) -> Self {
        self.inner.copy_src_layout_count = p_copy_src_layouts.len() as u32;
        self.inner.p_copy_src_layouts = p_copy_src_layouts.as_mut_ptr();
        self
    }
    pub fn p_copy_dst_layouts(mut self, p_copy_dst_layouts: &'a mut [vk::ImageLayout]) -> Self {
        self.inner.copy_dst_layout_count = p_copy_dst_layouts.len() as u32;
        self.inner.p_copy_dst_layouts = p_copy_dst_layouts.as_mut_ptr();
        self
    }
    pub fn optimal_tiling_layout_uuid(mut self, optimal_tiling_layout_uuid: [u8; vk::UUID_SIZE]) -> Self {
        self.inner.optimal_tiling_layout_uuid = optimal_tiling_layout_uuid;
        self
    }
    pub fn identical_memory_type_requirements(mut self, identical_memory_type_requirements: bool) -> Self {
        self.inner.identical_memory_type_requirements = if identical_memory_type_requirements {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl<'a> Deref for PhysicalDeviceHostImageCopyPropertiesBuilder<'a> {
    type Target = vk::PhysicalDeviceHostImageCopyProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceHostImageCopyProperties {}
impl PhysicalDeviceProperties2Next for PhysicalDeviceHostImageCopyPropertiesBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryToImageCopyBuilder<'a> {
    inner: vk::MemoryToImageCopy,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::MemoryToImageCopy {
    type Type = MemoryToImageCopyBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> MemoryToImageCopyBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::MemoryToImageCopy {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_host_pointer(mut self, p_host_pointer: *const c_void) -> Self {
        self.inner.p_host_pointer = p_host_pointer;
        self
    }
    pub fn memory_row_length(mut self, memory_row_length: u32) -> Self {
        self.inner.memory_row_length = memory_row_length;
        self
    }
    pub fn memory_image_height(mut self, memory_image_height: u32) -> Self {
        self.inner.memory_image_height = memory_image_height;
        self
    }
    pub fn image_subresource(mut self, image_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.image_subresource = image_subresource;
        self
    }
    pub fn image_offset(mut self, image_offset: vk::Offset3D) -> Self {
        self.inner.image_offset = image_offset;
        self
    }
    pub fn image_extent(mut self, image_extent: vk::Extent3D) -> Self {
        self.inner.image_extent = image_extent;
        self
    }
}
impl<'a> Deref for MemoryToImageCopyBuilder<'a> {
    type Target = vk::MemoryToImageCopy;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageToMemoryCopyBuilder<'a> {
    inner: vk::ImageToMemoryCopy,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImageToMemoryCopy {
    type Type = ImageToMemoryCopyBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ImageToMemoryCopyBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ImageToMemoryCopy {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_host_pointer(mut self, p_host_pointer: *mut c_void) -> Self {
        self.inner.p_host_pointer = p_host_pointer;
        self
    }
    pub fn memory_row_length(mut self, memory_row_length: u32) -> Self {
        self.inner.memory_row_length = memory_row_length;
        self
    }
    pub fn memory_image_height(mut self, memory_image_height: u32) -> Self {
        self.inner.memory_image_height = memory_image_height;
        self
    }
    pub fn image_subresource(mut self, image_subresource: vk::ImageSubresourceLayers) -> Self {
        self.inner.image_subresource = image_subresource;
        self
    }
    pub fn image_offset(mut self, image_offset: vk::Offset3D) -> Self {
        self.inner.image_offset = image_offset;
        self
    }
    pub fn image_extent(mut self, image_extent: vk::Extent3D) -> Self {
        self.inner.image_extent = image_extent;
        self
    }
}
impl<'a> Deref for ImageToMemoryCopyBuilder<'a> {
    type Target = vk::ImageToMemoryCopy;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyMemoryToImageInfoBuilder<'a> {
    inner: vk::CopyMemoryToImageInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CopyMemoryToImageInfo {
    type Type = CopyMemoryToImageInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CopyMemoryToImageInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CopyMemoryToImageInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::HostImageCopyFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn dst_image(mut self, dst_image: vk::Image) -> Self {
        self.inner.dst_image = dst_image;
        self
    }
    pub fn dst_image_layout(mut self, dst_image_layout: vk::ImageLayout) -> Self {
        self.inner.dst_image_layout = dst_image_layout;
        self
    }
    pub fn p_regions(mut self, p_regions: &'a [vk::MemoryToImageCopy]) -> Self {
        self.inner.region_count = p_regions.len() as u32;
        self.inner.p_regions = p_regions.as_ptr();
        self
    }
}
impl<'a> Deref for CopyMemoryToImageInfoBuilder<'a> {
    type Target = vk::CopyMemoryToImageInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyImageToMemoryInfoBuilder<'a> {
    inner: vk::CopyImageToMemoryInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CopyImageToMemoryInfo {
    type Type = CopyImageToMemoryInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CopyImageToMemoryInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CopyImageToMemoryInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::HostImageCopyFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn src_image(mut self, src_image: vk::Image) -> Self {
        self.inner.src_image = src_image;
        self
    }
    pub fn src_image_layout(mut self, src_image_layout: vk::ImageLayout) -> Self {
        self.inner.src_image_layout = src_image_layout;
        self
    }
    pub fn p_regions(mut self, p_regions: &'a [vk::ImageToMemoryCopy]) -> Self {
        self.inner.region_count = p_regions.len() as u32;
        self.inner.p_regions = p_regions.as_ptr();
        self
    }
}
impl<'a> Deref for CopyImageToMemoryInfoBuilder<'a> {
    type Target = vk::CopyImageToMemoryInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyImageToImageInfoBuilder<'a> {
    inner: vk::CopyImageToImageInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CopyImageToImageInfo {
    type Type = CopyImageToImageInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CopyImageToImageInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CopyImageToImageInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::HostImageCopyFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn src_image(mut self, src_image: vk::Image) -> Self {
        self.inner.src_image = src_image;
        self
    }
    pub fn src_image_layout(mut self, src_image_layout: vk::ImageLayout) -> Self {
        self.inner.src_image_layout = src_image_layout;
        self
    }
    pub fn dst_image(mut self, dst_image: vk::Image) -> Self {
        self.inner.dst_image = dst_image;
        self
    }
    pub fn dst_image_layout(mut self, dst_image_layout: vk::ImageLayout) -> Self {
        self.inner.dst_image_layout = dst_image_layout;
        self
    }
    pub fn p_regions(mut self, p_regions: &'a [vk::ImageCopy2]) -> Self {
        self.inner.region_count = p_regions.len() as u32;
        self.inner.p_regions = p_regions.as_ptr();
        self
    }
}
impl<'a> Deref for CopyImageToImageInfoBuilder<'a> {
    type Target = vk::CopyImageToImageInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct HostImageLayoutTransitionInfoBuilder {
    inner: vk::HostImageLayoutTransitionInfo,
}
impl Builder<'_> for vk::HostImageLayoutTransitionInfo {
    type Type = HostImageLayoutTransitionInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl HostImageLayoutTransitionInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::HostImageLayoutTransitionInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image(mut self, image: vk::Image) -> Self {
        self.inner.image = image;
        self
    }
    pub fn old_layout(mut self, old_layout: vk::ImageLayout) -> Self {
        self.inner.old_layout = old_layout;
        self
    }
    pub fn new_layout(mut self, new_layout: vk::ImageLayout) -> Self {
        self.inner.new_layout = new_layout;
        self
    }
    pub fn subresource_range(mut self, subresource_range: vk::ImageSubresourceRange) -> Self {
        self.inner.subresource_range = subresource_range;
        self
    }
}
impl Deref for HostImageLayoutTransitionInfoBuilder {
    type Target = vk::HostImageLayoutTransitionInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubresourceLayout2Next for vk::SubresourceHostMemcpySize {}
impl ImageFormatProperties2Next for vk::HostImageCopyDevicePerformanceQuery {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePrimitivesGeneratedQueryFeaturesEXTBuilder {
    inner: vk::PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
    type Type = PhysicalDevicePrimitivesGeneratedQueryFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePrimitivesGeneratedQueryFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn primitives_generated_query(mut self, primitives_generated_query: bool) -> Self {
        self.inner.primitives_generated_query = if primitives_generated_query {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn primitives_generated_query_with_rasterizer_discard(
        mut self,
        primitives_generated_query_with_rasterizer_discard: bool,
    ) -> Self {
        self.inner.primitives_generated_query_with_rasterizer_discard =
            if primitives_generated_query_with_rasterizer_discard {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn primitives_generated_query_with_non_zero_streams(
        mut self,
        primitives_generated_query_with_non_zero_streams: bool,
    ) -> Self {
        self.inner.primitives_generated_query_with_non_zero_streams =
            if primitives_generated_query_with_non_zero_streams {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
}
impl Deref for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXTBuilder {
    type Target = vk::PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceLegacyDitheringFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceLegacyDitheringFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceLegacyDitheringFeaturesEXT {
    type Type = PhysicalDeviceLegacyDitheringFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceLegacyDitheringFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceLegacyDitheringFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn legacy_dithering(mut self, legacy_dithering: bool) -> Self {
        self.inner.legacy_dithering = if legacy_dithering { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceLegacyDitheringFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceLegacyDitheringFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceLegacyDitheringFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceLegacyDitheringFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceLegacyDitheringFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceLegacyDitheringFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
    type Type = PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn multisampled_render_to_single_sampled(mut self, multisampled_render_to_single_sampled: bool) -> Self {
        self.inner.multisampled_render_to_single_sampled = if multisampled_render_to_single_sampled {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SurfaceCapabilitiesPresentId2KHRBuilder {
    inner: vk::SurfaceCapabilitiesPresentId2KHR,
}
impl Builder<'_> for vk::SurfaceCapabilitiesPresentId2KHR {
    type Type = SurfaceCapabilitiesPresentId2KHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SurfaceCapabilitiesPresentId2KHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SurfaceCapabilitiesPresentId2KHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn present_id2_supported(mut self, present_id2_supported: bool) -> Self {
        self.inner.present_id2_supported = if present_id2_supported { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for SurfaceCapabilitiesPresentId2KHRBuilder {
    type Target = vk::SurfaceCapabilitiesPresentId2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SurfaceCapabilities2KHRNext for vk::SurfaceCapabilitiesPresentId2KHR {}
impl SurfaceCapabilities2KHRNext for SurfaceCapabilitiesPresentId2KHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SurfaceCapabilitiesPresentWait2KHRBuilder {
    inner: vk::SurfaceCapabilitiesPresentWait2KHR,
}
impl Builder<'_> for vk::SurfaceCapabilitiesPresentWait2KHR {
    type Type = SurfaceCapabilitiesPresentWait2KHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SurfaceCapabilitiesPresentWait2KHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SurfaceCapabilitiesPresentWait2KHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn present_wait2_supported(mut self, present_wait2_supported: bool) -> Self {
        self.inner.present_wait2_supported = if present_wait2_supported { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for SurfaceCapabilitiesPresentWait2KHRBuilder {
    type Target = vk::SurfaceCapabilitiesPresentWait2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SurfaceCapabilities2KHRNext for vk::SurfaceCapabilitiesPresentWait2KHR {}
impl SurfaceCapabilities2KHRNext for SurfaceCapabilitiesPresentWait2KHRBuilder {}
impl FormatProperties2Next for vk::SubpassResolvePerformanceQueryEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct MultisampledRenderToSingleSampledInfoEXTBuilder {
    inner: vk::MultisampledRenderToSingleSampledInfoEXT,
}
impl Builder<'_> for vk::MultisampledRenderToSingleSampledInfoEXT {
    type Type = MultisampledRenderToSingleSampledInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MultisampledRenderToSingleSampledInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MultisampledRenderToSingleSampledInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn multisampled_render_to_single_sampled_enable(
        mut self,
        multisampled_render_to_single_sampled_enable: bool,
    ) -> Self {
        self.inner.multisampled_render_to_single_sampled_enable = if multisampled_render_to_single_sampled_enable {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn rasterization_samples(mut self, rasterization_samples: vk::SampleCountFlags) -> Self {
        self.inner.rasterization_samples = rasterization_samples;
        self
    }
}
impl Deref for MultisampledRenderToSingleSampledInfoEXTBuilder {
    type Target = vk::MultisampledRenderToSingleSampledInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubpassDescription2Next for vk::MultisampledRenderToSingleSampledInfoEXT {}
impl SubpassDescription2Next for MultisampledRenderToSingleSampledInfoEXTBuilder {}
impl RenderingInfoNext for vk::MultisampledRenderToSingleSampledInfoEXT {}
impl RenderingInfoNext for MultisampledRenderToSingleSampledInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePipelineProtectedAccessFeaturesBuilder {
    inner: vk::PhysicalDevicePipelineProtectedAccessFeatures,
}
impl Builder<'_> for vk::PhysicalDevicePipelineProtectedAccessFeatures {
    type Type = PhysicalDevicePipelineProtectedAccessFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePipelineProtectedAccessFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePipelineProtectedAccessFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline_protected_access(mut self, pipeline_protected_access: bool) -> Self {
        self.inner.pipeline_protected_access = if pipeline_protected_access { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevicePipelineProtectedAccessFeaturesBuilder {
    type Target = vk::PhysicalDevicePipelineProtectedAccessFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePipelineProtectedAccessFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePipelineProtectedAccessFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePipelineProtectedAccessFeatures {}
impl DeviceCreateInfoNext for PhysicalDevicePipelineProtectedAccessFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder {
    inner: vk::PhysicalDeviceInheritedViewportScissorFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceInheritedViewportScissorFeaturesNV {
    type Type = PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceInheritedViewportScissorFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn inherited_viewport_scissor_2d(mut self, inherited_viewport_scissor_2d: bool) -> Self {
        self.inner.inherited_viewport_scissor_2d = if inherited_viewport_scissor_2d {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceInheritedViewportScissorFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceInheritedViewportScissorFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceInheritedViewportScissorFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct CommandBufferInheritanceViewportScissorInfoNVBuilder<'a> {
    inner: vk::CommandBufferInheritanceViewportScissorInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CommandBufferInheritanceViewportScissorInfoNV {
    type Type = CommandBufferInheritanceViewportScissorInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CommandBufferInheritanceViewportScissorInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CommandBufferInheritanceViewportScissorInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn viewport_scissor_2d(mut self, viewport_scissor_2d: bool) -> Self {
        self.inner.viewport_scissor_2d = if viewport_scissor_2d { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn viewport_depth_count(mut self, viewport_depth_count: u32) -> Self {
        self.inner.viewport_depth_count = viewport_depth_count;
        self
    }
    pub fn p_viewport_depths(mut self, p_viewport_depths: &'a vk::Viewport) -> Self {
        self.inner.p_viewport_depths = p_viewport_depths;
        self
    }
}
impl<'a> Deref for CommandBufferInheritanceViewportScissorInfoNVBuilder<'a> {
    type Target = vk::CommandBufferInheritanceViewportScissorInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl CommandBufferInheritanceInfoNext for vk::CommandBufferInheritanceViewportScissorInfoNV {}
impl CommandBufferInheritanceInfoNext for CommandBufferInheritanceViewportScissorInfoNVBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    type Type = PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ycbcr2plane444_formats(mut self, ycbcr2plane444_formats: bool) -> Self {
        self.inner.ycbcr2plane444_formats = if ycbcr2plane444_formats { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceProvokingVertexFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceProvokingVertexFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceProvokingVertexFeaturesEXT {
    type Type = PhysicalDeviceProvokingVertexFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceProvokingVertexFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceProvokingVertexFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn provoking_vertex_last(mut self, provoking_vertex_last: bool) -> Self {
        self.inner.provoking_vertex_last = if provoking_vertex_last { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn transform_feedback_preserves_provoking_vertex(
        mut self,
        transform_feedback_preserves_provoking_vertex: bool,
    ) -> Self {
        self.inner.transform_feedback_preserves_provoking_vertex = if transform_feedback_preserves_provoking_vertex {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceProvokingVertexFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceProvokingVertexFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceProvokingVertexFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceProvokingVertexFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceProvokingVertexFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceProvokingVertexFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceProvokingVertexPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder {
    inner: vk::PipelineRasterizationProvokingVertexStateCreateInfoEXT,
}
impl Builder<'_> for vk::PipelineRasterizationProvokingVertexStateCreateInfoEXT {
    type Type = PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineRasterizationProvokingVertexStateCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn provoking_vertex_mode(mut self, provoking_vertex_mode: vk::ProvokingVertexModeEXT) -> Self {
        self.inner.provoking_vertex_mode = provoking_vertex_mode;
        self
    }
}
impl Deref for PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder {
    type Target = vk::PipelineRasterizationProvokingVertexStateCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineRasterizationStateCreateInfoNext for vk::PipelineRasterizationProvokingVertexStateCreateInfoEXT {}
impl PipelineRasterizationStateCreateInfoNext for PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct CuModuleCreateInfoNVXBuilder<'a> {
    inner: vk::CuModuleCreateInfoNVX,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CuModuleCreateInfoNVX {
    type Type = CuModuleCreateInfoNVXBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait CuModuleCreateInfoNVXNext {}
impl<'a> CuModuleCreateInfoNVXBuilder<'a> {
    pub fn insert_next<T: CuModuleCreateInfoNVXNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::CuModuleCreateInfoNVX {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_data(mut self, p_data: &'a [u8]) -> Self {
        self.inner.data_size = p_data.len();
        self.inner.p_data = p_data.as_ptr() as *const _;
        self
    }
}
impl<'a> Deref for CuModuleCreateInfoNVXBuilder<'a> {
    type Target = vk::CuModuleCreateInfoNVX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CuModuleTexturingModeCreateInfoNVXBuilder {
    inner: vk::CuModuleTexturingModeCreateInfoNVX,
}
impl Builder<'_> for vk::CuModuleTexturingModeCreateInfoNVX {
    type Type = CuModuleTexturingModeCreateInfoNVXBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CuModuleTexturingModeCreateInfoNVXBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CuModuleTexturingModeCreateInfoNVX {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn use64bit_texturing(mut self, use64bit_texturing: bool) -> Self {
        self.inner.use64bit_texturing = if use64bit_texturing { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for CuModuleTexturingModeCreateInfoNVXBuilder {
    type Target = vk::CuModuleTexturingModeCreateInfoNVX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl CuModuleCreateInfoNVXNext for vk::CuModuleTexturingModeCreateInfoNVX {}
impl CuModuleCreateInfoNVXNext for CuModuleTexturingModeCreateInfoNVXBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct CuFunctionCreateInfoNVXBuilder<'a> {
    inner: vk::CuFunctionCreateInfoNVX,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CuFunctionCreateInfoNVX {
    type Type = CuFunctionCreateInfoNVXBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CuFunctionCreateInfoNVXBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CuFunctionCreateInfoNVX {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn module(mut self, module: vk::CuModuleNVX) -> Self {
        self.inner.module = module;
        self
    }
    pub fn p_name(mut self, p_name: &'a CStr) -> Self {
        self.inner.p_name = p_name.as_ptr();
        self
    }
}
impl<'a> Deref for CuFunctionCreateInfoNVXBuilder<'a> {
    type Target = vk::CuFunctionCreateInfoNVX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CuLaunchInfoNVXBuilder<'a> {
    inner: vk::CuLaunchInfoNVX,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CuLaunchInfoNVX {
    type Type = CuLaunchInfoNVXBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CuLaunchInfoNVXBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CuLaunchInfoNVX {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn function(mut self, function: vk::CuFunctionNVX) -> Self {
        self.inner.function = function;
        self
    }
    pub fn grid_dim_x(mut self, grid_dim_x: u32) -> Self {
        self.inner.grid_dim_x = grid_dim_x;
        self
    }
    pub fn grid_dim_y(mut self, grid_dim_y: u32) -> Self {
        self.inner.grid_dim_y = grid_dim_y;
        self
    }
    pub fn grid_dim_z(mut self, grid_dim_z: u32) -> Self {
        self.inner.grid_dim_z = grid_dim_z;
        self
    }
    pub fn block_dim_x(mut self, block_dim_x: u32) -> Self {
        self.inner.block_dim_x = block_dim_x;
        self
    }
    pub fn block_dim_y(mut self, block_dim_y: u32) -> Self {
        self.inner.block_dim_y = block_dim_y;
        self
    }
    pub fn block_dim_z(mut self, block_dim_z: u32) -> Self {
        self.inner.block_dim_z = block_dim_z;
        self
    }
    pub fn shared_mem_bytes(mut self, shared_mem_bytes: u32) -> Self {
        self.inner.shared_mem_bytes = shared_mem_bytes;
        self
    }
    pub fn p_params(mut self, p_params: &'a [*const c_void]) -> Self {
        self.inner.param_count = p_params.len();
        self.inner.p_params = p_params.as_ptr();
        self
    }
    pub fn p_extras(mut self, p_extras: &'a [*const c_void]) -> Self {
        self.inner.extra_count = p_extras.len();
        self.inner.p_extras = p_extras.as_ptr();
        self
    }
}
impl<'a> Deref for CuLaunchInfoNVXBuilder<'a> {
    type Target = vk::CuLaunchInfoNVX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDescriptorBufferFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceDescriptorBufferFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceDescriptorBufferFeaturesEXT {
    type Type = PhysicalDeviceDescriptorBufferFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDescriptorBufferFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDescriptorBufferFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn descriptor_buffer(mut self, descriptor_buffer: bool) -> Self {
        self.inner.descriptor_buffer = if descriptor_buffer { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn descriptor_buffer_capture_replay(mut self, descriptor_buffer_capture_replay: bool) -> Self {
        self.inner.descriptor_buffer_capture_replay = if descriptor_buffer_capture_replay {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn descriptor_buffer_image_layout_ignored(mut self, descriptor_buffer_image_layout_ignored: bool) -> Self {
        self.inner.descriptor_buffer_image_layout_ignored = if descriptor_buffer_image_layout_ignored {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn descriptor_buffer_push_descriptors(mut self, descriptor_buffer_push_descriptors: bool) -> Self {
        self.inner.descriptor_buffer_push_descriptors = if descriptor_buffer_push_descriptors {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceDescriptorBufferFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceDescriptorBufferFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDescriptorBufferFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDescriptorBufferFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDescriptorBufferFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceDescriptorBufferFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceDescriptorBufferPropertiesEXT {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorAddressInfoEXTBuilder {
    inner: vk::DescriptorAddressInfoEXT,
}
impl Builder<'_> for vk::DescriptorAddressInfoEXT {
    type Type = DescriptorAddressInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DescriptorAddressInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DescriptorAddressInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn address(mut self, address: vk::DeviceAddress) -> Self {
        self.inner.address = address;
        self
    }
    pub fn range(mut self, range: vk::DeviceSize) -> Self {
        self.inner.range = range;
        self
    }
    pub fn format(mut self, format: vk::Format) -> Self {
        self.inner.format = format;
        self
    }
}
impl Deref for DescriptorAddressInfoEXTBuilder {
    type Target = vk::DescriptorAddressInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorBufferBindingInfoEXTBuilder<'a> {
    inner: vk::DescriptorBufferBindingInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DescriptorBufferBindingInfoEXT {
    type Type = DescriptorBufferBindingInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DescriptorBufferBindingInfoEXTNext {}
impl<'a> DescriptorBufferBindingInfoEXTBuilder<'a> {
    pub fn insert_next<T: DescriptorBufferBindingInfoEXTNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DescriptorBufferBindingInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn address(mut self, address: vk::DeviceAddress) -> Self {
        self.inner.address = address;
        self
    }
    pub fn usage(mut self, usage: vk::BufferUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
}
impl<'a> Deref for DescriptorBufferBindingInfoEXTBuilder<'a> {
    type Target = vk::DescriptorBufferBindingInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorBufferBindingPushDescriptorBufferHandleEXTBuilder {
    inner: vk::DescriptorBufferBindingPushDescriptorBufferHandleEXT,
}
impl Builder<'_> for vk::DescriptorBufferBindingPushDescriptorBufferHandleEXT {
    type Type = DescriptorBufferBindingPushDescriptorBufferHandleEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DescriptorBufferBindingPushDescriptorBufferHandleEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DescriptorBufferBindingPushDescriptorBufferHandleEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
}
impl Deref for DescriptorBufferBindingPushDescriptorBufferHandleEXTBuilder {
    type Target = vk::DescriptorBufferBindingPushDescriptorBufferHandleEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DescriptorBufferBindingInfoEXTNext for vk::DescriptorBufferBindingPushDescriptorBufferHandleEXT {}
impl DescriptorBufferBindingInfoEXTNext for DescriptorBufferBindingPushDescriptorBufferHandleEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorGetInfoEXTBuilder<'a> {
    inner: vk::DescriptorGetInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DescriptorGetInfoEXT {
    type Type = DescriptorGetInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DescriptorGetInfoEXTNext {}
impl<'a> DescriptorGetInfoEXTBuilder<'a> {
    pub fn insert_next<T: DescriptorGetInfoEXTNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DescriptorGetInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ty(mut self, ty: vk::DescriptorType) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn data(mut self, data: vk::DescriptorDataEXT) -> Self {
        self.inner.data = data;
        self
    }
}
impl<'a> Deref for DescriptorGetInfoEXTBuilder<'a> {
    type Target = vk::DescriptorGetInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferCaptureDescriptorDataInfoEXTBuilder {
    inner: vk::BufferCaptureDescriptorDataInfoEXT,
}
impl Builder<'_> for vk::BufferCaptureDescriptorDataInfoEXT {
    type Type = BufferCaptureDescriptorDataInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BufferCaptureDescriptorDataInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BufferCaptureDescriptorDataInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
}
impl Deref for BufferCaptureDescriptorDataInfoEXTBuilder {
    type Target = vk::BufferCaptureDescriptorDataInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageCaptureDescriptorDataInfoEXTBuilder {
    inner: vk::ImageCaptureDescriptorDataInfoEXT,
}
impl Builder<'_> for vk::ImageCaptureDescriptorDataInfoEXT {
    type Type = ImageCaptureDescriptorDataInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageCaptureDescriptorDataInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageCaptureDescriptorDataInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image(mut self, image: vk::Image) -> Self {
        self.inner.image = image;
        self
    }
}
impl Deref for ImageCaptureDescriptorDataInfoEXTBuilder {
    type Target = vk::ImageCaptureDescriptorDataInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageViewCaptureDescriptorDataInfoEXTBuilder {
    inner: vk::ImageViewCaptureDescriptorDataInfoEXT,
}
impl Builder<'_> for vk::ImageViewCaptureDescriptorDataInfoEXT {
    type Type = ImageViewCaptureDescriptorDataInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageViewCaptureDescriptorDataInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageViewCaptureDescriptorDataInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image_view(mut self, image_view: vk::ImageView) -> Self {
        self.inner.image_view = image_view;
        self
    }
}
impl Deref for ImageViewCaptureDescriptorDataInfoEXTBuilder {
    type Target = vk::ImageViewCaptureDescriptorDataInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SamplerCaptureDescriptorDataInfoEXTBuilder {
    inner: vk::SamplerCaptureDescriptorDataInfoEXT,
}
impl Builder<'_> for vk::SamplerCaptureDescriptorDataInfoEXT {
    type Type = SamplerCaptureDescriptorDataInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SamplerCaptureDescriptorDataInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SamplerCaptureDescriptorDataInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn sampler(mut self, sampler: vk::Sampler) -> Self {
        self.inner.sampler = sampler;
        self
    }
}
impl Deref for SamplerCaptureDescriptorDataInfoEXTBuilder {
    type Target = vk::SamplerCaptureDescriptorDataInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureCaptureDescriptorDataInfoEXTBuilder {
    inner: vk::AccelerationStructureCaptureDescriptorDataInfoEXT,
}
impl Builder<'_> for vk::AccelerationStructureCaptureDescriptorDataInfoEXT {
    type Type = AccelerationStructureCaptureDescriptorDataInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AccelerationStructureCaptureDescriptorDataInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureCaptureDescriptorDataInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn acceleration_structure(mut self, acceleration_structure: vk::AccelerationStructureKHR) -> Self {
        self.inner.acceleration_structure = acceleration_structure;
        self
    }
    pub fn acceleration_structure_nv(mut self, acceleration_structure_nv: vk::AccelerationStructureNV) -> Self {
        self.inner.acceleration_structure_nv = acceleration_structure_nv;
        self
    }
}
impl Deref for AccelerationStructureCaptureDescriptorDataInfoEXTBuilder {
    type Target = vk::AccelerationStructureCaptureDescriptorDataInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'a> {
    inner: vk::OpaqueCaptureDescriptorDataCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::OpaqueCaptureDescriptorDataCreateInfoEXT {
    type Type = OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::OpaqueCaptureDescriptorDataCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn opaque_capture_descriptor_data(mut self, opaque_capture_descriptor_data: *const c_void) -> Self {
        self.inner.opaque_capture_descriptor_data = opaque_capture_descriptor_data;
        self
    }
}
impl<'a> Deref for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'a> {
    type Target = vk::OpaqueCaptureDescriptorDataCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BufferCreateInfoNext for vk::OpaqueCaptureDescriptorDataCreateInfoEXT {}
impl BufferCreateInfoNext for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'_> {}
impl ImageCreateInfoNext for vk::OpaqueCaptureDescriptorDataCreateInfoEXT {}
impl ImageCreateInfoNext for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'_> {}
impl ImageViewCreateInfoNext for vk::OpaqueCaptureDescriptorDataCreateInfoEXT {}
impl ImageViewCreateInfoNext for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'_> {}
impl SamplerCreateInfoNext for vk::OpaqueCaptureDescriptorDataCreateInfoEXT {}
impl SamplerCreateInfoNext for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'_> {}
impl AccelerationStructureCreateInfoKHRNext for vk::OpaqueCaptureDescriptorDataCreateInfoEXT {}
impl AccelerationStructureCreateInfoKHRNext for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'_> {}
impl AccelerationStructureCreateInfoNVNext for vk::OpaqueCaptureDescriptorDataCreateInfoEXT {}
impl AccelerationStructureCreateInfoNVNext for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'_> {}
impl TensorCreateInfoARMNext for vk::OpaqueCaptureDescriptorDataCreateInfoEXT {}
impl TensorCreateInfoARMNext for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'_> {}
impl TensorViewCreateInfoARMNext for vk::OpaqueCaptureDescriptorDataCreateInfoEXT {}
impl TensorViewCreateInfoARMNext for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderIntegerDotProductFeaturesBuilder {
    inner: vk::PhysicalDeviceShaderIntegerDotProductFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceShaderIntegerDotProductFeatures {
    type Type = PhysicalDeviceShaderIntegerDotProductFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderIntegerDotProductFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderIntegerDotProductFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_integer_dot_product(mut self, shader_integer_dot_product: bool) -> Self {
        self.inner.shader_integer_dot_product = if shader_integer_dot_product {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderIntegerDotProductFeaturesBuilder {
    type Target = vk::PhysicalDeviceShaderIntegerDotProductFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderIntegerDotProductFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderIntegerDotProductFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderIntegerDotProductFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderIntegerDotProductFeaturesBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceShaderIntegerDotProductProperties {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceDrmPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceFragmentShaderBarycentricFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceFragmentShaderBarycentricFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
    type Type = PhysicalDeviceFragmentShaderBarycentricFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceFragmentShaderBarycentricFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn fragment_shader_barycentric(mut self, fragment_shader_barycentric: bool) -> Self {
        self.inner.fragment_shader_barycentric = if fragment_shader_barycentric {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceFragmentShaderBarycentricFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceFragmentShaderBarycentricFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceFragmentShaderBarycentricFeaturesKHRBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceFragmentShaderBarycentricPropertiesKHR {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder {
    inner: vk::PhysicalDeviceRayTracingMotionBlurFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceRayTracingMotionBlurFeaturesNV {
    type Type = PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRayTracingMotionBlurFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ray_tracing_motion_blur(mut self, ray_tracing_motion_blur: bool) -> Self {
        self.inner.ray_tracing_motion_blur = if ray_tracing_motion_blur { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn ray_tracing_motion_blur_pipeline_trace_rays_indirect(
        mut self,
        ray_tracing_motion_blur_pipeline_trace_rays_indirect: bool,
    ) -> Self {
        self.inner.ray_tracing_motion_blur_pipeline_trace_rays_indirect =
            if ray_tracing_motion_blur_pipeline_trace_rays_indirect {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
}
impl Deref for PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceRayTracingMotionBlurFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRayTracingMotionBlurFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRayTracingMotionBlurFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRayTracingValidationFeaturesNVBuilder {
    inner: vk::PhysicalDeviceRayTracingValidationFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceRayTracingValidationFeaturesNV {
    type Type = PhysicalDeviceRayTracingValidationFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRayTracingValidationFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRayTracingValidationFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ray_tracing_validation(mut self, ray_tracing_validation: bool) -> Self {
        self.inner.ray_tracing_validation = if ray_tracing_validation { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceRayTracingValidationFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceRayTracingValidationFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRayTracingValidationFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRayTracingValidationFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRayTracingValidationFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceRayTracingValidationFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNVBuilder {
    inner: vk::PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV {
    type Type = PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn spheres(mut self, spheres: bool) -> Self {
        self.inner.spheres = if spheres { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn linear_swept_spheres(mut self, linear_swept_spheres: bool) -> Self {
        self.inner.linear_swept_spheres = if linear_swept_spheres { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureGeometryMotionTrianglesDataNVBuilder {
    inner: vk::AccelerationStructureGeometryMotionTrianglesDataNV,
}
impl Builder<'_> for vk::AccelerationStructureGeometryMotionTrianglesDataNV {
    type Type = AccelerationStructureGeometryMotionTrianglesDataNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AccelerationStructureGeometryMotionTrianglesDataNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureGeometryMotionTrianglesDataNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn vertex_data(mut self, vertex_data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.vertex_data = vertex_data;
        self
    }
}
impl Deref for AccelerationStructureGeometryMotionTrianglesDataNVBuilder {
    type Target = vk::AccelerationStructureGeometryMotionTrianglesDataNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl AccelerationStructureGeometryTrianglesDataKHRNext for vk::AccelerationStructureGeometryMotionTrianglesDataNV {}
impl AccelerationStructureGeometryTrianglesDataKHRNext for AccelerationStructureGeometryMotionTrianglesDataNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureMotionInfoNVBuilder {
    inner: vk::AccelerationStructureMotionInfoNV,
}
impl Builder<'_> for vk::AccelerationStructureMotionInfoNV {
    type Type = AccelerationStructureMotionInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AccelerationStructureMotionInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureMotionInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn max_instances(mut self, max_instances: u32) -> Self {
        self.inner.max_instances = max_instances;
        self
    }
    pub fn flags(mut self, flags: vk::AccelerationStructureMotionInfoFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl Deref for AccelerationStructureMotionInfoNVBuilder {
    type Target = vk::AccelerationStructureMotionInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl AccelerationStructureCreateInfoKHRNext for vk::AccelerationStructureMotionInfoNV {}
impl AccelerationStructureCreateInfoKHRNext for AccelerationStructureMotionInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SRTDataNVBuilder {
    inner: vk::SRTDataNV,
}
impl Builder<'_> for vk::SRTDataNV {
    type Type = SRTDataNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SRTDataNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SRTDataNV {
        &mut self.inner
    }
    pub fn sx(mut self, sx: f32) -> Self {
        self.inner.sx = sx;
        self
    }
    pub fn a(mut self, a: f32) -> Self {
        self.inner.a = a;
        self
    }
    pub fn b(mut self, b: f32) -> Self {
        self.inner.b = b;
        self
    }
    pub fn pvx(mut self, pvx: f32) -> Self {
        self.inner.pvx = pvx;
        self
    }
    pub fn sy(mut self, sy: f32) -> Self {
        self.inner.sy = sy;
        self
    }
    pub fn c(mut self, c: f32) -> Self {
        self.inner.c = c;
        self
    }
    pub fn pvy(mut self, pvy: f32) -> Self {
        self.inner.pvy = pvy;
        self
    }
    pub fn sz(mut self, sz: f32) -> Self {
        self.inner.sz = sz;
        self
    }
    pub fn pvz(mut self, pvz: f32) -> Self {
        self.inner.pvz = pvz;
        self
    }
    pub fn qx(mut self, qx: f32) -> Self {
        self.inner.qx = qx;
        self
    }
    pub fn qy(mut self, qy: f32) -> Self {
        self.inner.qy = qy;
        self
    }
    pub fn qz(mut self, qz: f32) -> Self {
        self.inner.qz = qz;
        self
    }
    pub fn qw(mut self, qw: f32) -> Self {
        self.inner.qw = qw;
        self
    }
    pub fn tx(mut self, tx: f32) -> Self {
        self.inner.tx = tx;
        self
    }
    pub fn ty(mut self, ty: f32) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn tz(mut self, tz: f32) -> Self {
        self.inner.tz = tz;
        self
    }
}
impl Deref for SRTDataNVBuilder {
    type Target = vk::SRTDataNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureSRTMotionInstanceNVBuilder {
    inner: vk::AccelerationStructureSRTMotionInstanceNV,
}
impl Builder<'_> for vk::AccelerationStructureSRTMotionInstanceNV {
    type Type = AccelerationStructureSRTMotionInstanceNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AccelerationStructureSRTMotionInstanceNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureSRTMotionInstanceNV {
        &mut self.inner
    }
    pub fn transform_t0(mut self, transform_t0: vk::SRTDataNV) -> Self {
        self.inner.transform_t0 = transform_t0;
        self
    }
    pub fn transform_t1(mut self, transform_t1: vk::SRTDataNV) -> Self {
        self.inner.transform_t1 = transform_t1;
        self
    }
    pub fn instance_custom_index_and_mask(mut self, instance_custom_index_and_mask: u32) -> Self {
        self.inner.instance_custom_index_and_mask = instance_custom_index_and_mask;
        self
    }
    pub fn instance_shader_binding_table_record_offset_and_flags(
        mut self,
        instance_shader_binding_table_record_offset_and_flags: u32,
    ) -> Self {
        self.inner.instance_shader_binding_table_record_offset_and_flags =
            instance_shader_binding_table_record_offset_and_flags;
        self
    }
    pub fn acceleration_structure_reference(mut self, acceleration_structure_reference: u64) -> Self {
        self.inner.acceleration_structure_reference = acceleration_structure_reference;
        self
    }
}
impl Deref for AccelerationStructureSRTMotionInstanceNVBuilder {
    type Target = vk::AccelerationStructureSRTMotionInstanceNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureMatrixMotionInstanceNVBuilder {
    inner: vk::AccelerationStructureMatrixMotionInstanceNV,
}
impl Builder<'_> for vk::AccelerationStructureMatrixMotionInstanceNV {
    type Type = AccelerationStructureMatrixMotionInstanceNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AccelerationStructureMatrixMotionInstanceNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureMatrixMotionInstanceNV {
        &mut self.inner
    }
    pub fn transform_t0(mut self, transform_t0: vk::TransformMatrixKHR) -> Self {
        self.inner.transform_t0 = transform_t0;
        self
    }
    pub fn transform_t1(mut self, transform_t1: vk::TransformMatrixKHR) -> Self {
        self.inner.transform_t1 = transform_t1;
        self
    }
    pub fn instance_custom_index_and_mask(mut self, instance_custom_index_and_mask: u32) -> Self {
        self.inner.instance_custom_index_and_mask = instance_custom_index_and_mask;
        self
    }
    pub fn instance_shader_binding_table_record_offset_and_flags(
        mut self,
        instance_shader_binding_table_record_offset_and_flags: u32,
    ) -> Self {
        self.inner.instance_shader_binding_table_record_offset_and_flags =
            instance_shader_binding_table_record_offset_and_flags;
        self
    }
    pub fn acceleration_structure_reference(mut self, acceleration_structure_reference: u64) -> Self {
        self.inner.acceleration_structure_reference = acceleration_structure_reference;
        self
    }
}
impl Deref for AccelerationStructureMatrixMotionInstanceNVBuilder {
    type Target = vk::AccelerationStructureMatrixMotionInstanceNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureMotionInstanceNVBuilder {
    inner: vk::AccelerationStructureMotionInstanceNV,
}
impl Builder<'_> for vk::AccelerationStructureMotionInstanceNV {
    type Type = AccelerationStructureMotionInstanceNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AccelerationStructureMotionInstanceNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureMotionInstanceNV {
        &mut self.inner
    }
    pub fn ty(mut self, ty: vk::AccelerationStructureMotionInstanceTypeNV) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn flags(mut self, flags: vk::AccelerationStructureMotionInstanceFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn data(mut self, data: vk::AccelerationStructureMotionInstanceDataNV) -> Self {
        self.inner.data = data;
        self
    }
}
impl Deref for AccelerationStructureMotionInstanceNVBuilder {
    type Target = vk::AccelerationStructureMotionInstanceNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryGetRemoteAddressInfoNVBuilder {
    inner: vk::MemoryGetRemoteAddressInfoNV,
}
impl Builder<'_> for vk::MemoryGetRemoteAddressInfoNV {
    type Type = MemoryGetRemoteAddressInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryGetRemoteAddressInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryGetRemoteAddressInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl Deref for MemoryGetRemoteAddressInfoNVBuilder {
    type Target = vk::MemoryGetRemoteAddressInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportMemoryBufferCollectionFUCHSIABuilder {
    inner: vk::ImportMemoryBufferCollectionFUCHSIA,
}
impl Builder<'_> for vk::ImportMemoryBufferCollectionFUCHSIA {
    type Type = ImportMemoryBufferCollectionFUCHSIABuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImportMemoryBufferCollectionFUCHSIABuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImportMemoryBufferCollectionFUCHSIA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn collection(mut self, collection: vk::BufferCollectionFUCHSIA) -> Self {
        self.inner.collection = collection;
        self
    }
    pub fn index(mut self, index: u32) -> Self {
        self.inner.index = index;
        self
    }
}
impl Deref for ImportMemoryBufferCollectionFUCHSIABuilder {
    type Target = vk::ImportMemoryBufferCollectionFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::ImportMemoryBufferCollectionFUCHSIA {}
impl MemoryAllocateInfoNext for ImportMemoryBufferCollectionFUCHSIABuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferCollectionImageCreateInfoFUCHSIABuilder {
    inner: vk::BufferCollectionImageCreateInfoFUCHSIA,
}
impl Builder<'_> for vk::BufferCollectionImageCreateInfoFUCHSIA {
    type Type = BufferCollectionImageCreateInfoFUCHSIABuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BufferCollectionImageCreateInfoFUCHSIABuilder {
    pub fn get_mut(&mut self) -> &mut vk::BufferCollectionImageCreateInfoFUCHSIA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn collection(mut self, collection: vk::BufferCollectionFUCHSIA) -> Self {
        self.inner.collection = collection;
        self
    }
    pub fn index(mut self, index: u32) -> Self {
        self.inner.index = index;
        self
    }
}
impl Deref for BufferCollectionImageCreateInfoFUCHSIABuilder {
    type Target = vk::BufferCollectionImageCreateInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageCreateInfoNext for vk::BufferCollectionImageCreateInfoFUCHSIA {}
impl ImageCreateInfoNext for BufferCollectionImageCreateInfoFUCHSIABuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferCollectionBufferCreateInfoFUCHSIABuilder {
    inner: vk::BufferCollectionBufferCreateInfoFUCHSIA,
}
impl Builder<'_> for vk::BufferCollectionBufferCreateInfoFUCHSIA {
    type Type = BufferCollectionBufferCreateInfoFUCHSIABuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BufferCollectionBufferCreateInfoFUCHSIABuilder {
    pub fn get_mut(&mut self) -> &mut vk::BufferCollectionBufferCreateInfoFUCHSIA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn collection(mut self, collection: vk::BufferCollectionFUCHSIA) -> Self {
        self.inner.collection = collection;
        self
    }
    pub fn index(mut self, index: u32) -> Self {
        self.inner.index = index;
        self
    }
}
impl Deref for BufferCollectionBufferCreateInfoFUCHSIABuilder {
    type Target = vk::BufferCollectionBufferCreateInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BufferCreateInfoNext for vk::BufferCollectionBufferCreateInfoFUCHSIA {}
impl BufferCreateInfoNext for BufferCollectionBufferCreateInfoFUCHSIABuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferCollectionCreateInfoFUCHSIABuilder {
    inner: vk::BufferCollectionCreateInfoFUCHSIA,
}
impl Builder<'_> for vk::BufferCollectionCreateInfoFUCHSIA {
    type Type = BufferCollectionCreateInfoFUCHSIABuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BufferCollectionCreateInfoFUCHSIABuilder {
    pub fn get_mut(&mut self) -> &mut vk::BufferCollectionCreateInfoFUCHSIA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn collection_token(mut self, collection_token: vk::zx_handle_t) -> Self {
        self.inner.collection_token = collection_token;
        self
    }
}
impl Deref for BufferCollectionCreateInfoFUCHSIABuilder {
    type Target = vk::BufferCollectionCreateInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferConstraintsInfoFUCHSIABuilder {
    inner: vk::BufferConstraintsInfoFUCHSIA,
}
impl Builder<'_> for vk::BufferConstraintsInfoFUCHSIA {
    type Type = BufferConstraintsInfoFUCHSIABuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BufferConstraintsInfoFUCHSIABuilder {
    pub fn get_mut(&mut self) -> &mut vk::BufferConstraintsInfoFUCHSIA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn create_info(mut self, create_info: vk::BufferCreateInfo) -> Self {
        self.inner.create_info = create_info;
        self
    }
    pub fn required_format_features(mut self, required_format_features: vk::FormatFeatureFlags) -> Self {
        self.inner.required_format_features = required_format_features;
        self
    }
    pub fn buffer_collection_constraints(
        mut self,
        buffer_collection_constraints: vk::BufferCollectionConstraintsInfoFUCHSIA,
    ) -> Self {
        self.inner.buffer_collection_constraints = buffer_collection_constraints;
        self
    }
}
impl Deref for BufferConstraintsInfoFUCHSIABuilder {
    type Target = vk::BufferConstraintsInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SysmemColorSpaceFUCHSIABuilder {
    inner: vk::SysmemColorSpaceFUCHSIA,
}
impl Builder<'_> for vk::SysmemColorSpaceFUCHSIA {
    type Type = SysmemColorSpaceFUCHSIABuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SysmemColorSpaceFUCHSIABuilder {
    pub fn get_mut(&mut self) -> &mut vk::SysmemColorSpaceFUCHSIA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn color_space(mut self, color_space: u32) -> Self {
        self.inner.color_space = color_space;
        self
    }
}
impl Deref for SysmemColorSpaceFUCHSIABuilder {
    type Target = vk::SysmemColorSpaceFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageFormatConstraintsInfoFUCHSIABuilder<'a> {
    inner: vk::ImageFormatConstraintsInfoFUCHSIA,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImageFormatConstraintsInfoFUCHSIA {
    type Type = ImageFormatConstraintsInfoFUCHSIABuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ImageFormatConstraintsInfoFUCHSIABuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ImageFormatConstraintsInfoFUCHSIA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image_create_info(mut self, image_create_info: vk::ImageCreateInfo) -> Self {
        self.inner.image_create_info = image_create_info;
        self
    }
    pub fn required_format_features(mut self, required_format_features: vk::FormatFeatureFlags) -> Self {
        self.inner.required_format_features = required_format_features;
        self
    }
    pub fn flags(mut self, flags: vk::ImageFormatConstraintsFlagsFUCHSIA) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn sysmem_pixel_format(mut self, sysmem_pixel_format: u64) -> Self {
        self.inner.sysmem_pixel_format = sysmem_pixel_format;
        self
    }
    pub fn p_color_spaces(mut self, p_color_spaces: &'a [vk::SysmemColorSpaceFUCHSIA]) -> Self {
        self.inner.color_space_count = p_color_spaces.len() as u32;
        self.inner.p_color_spaces = p_color_spaces.as_ptr();
        self
    }
}
impl<'a> Deref for ImageFormatConstraintsInfoFUCHSIABuilder<'a> {
    type Target = vk::ImageFormatConstraintsInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageConstraintsInfoFUCHSIABuilder<'a> {
    inner: vk::ImageConstraintsInfoFUCHSIA,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImageConstraintsInfoFUCHSIA {
    type Type = ImageConstraintsInfoFUCHSIABuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ImageConstraintsInfoFUCHSIABuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ImageConstraintsInfoFUCHSIA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_format_constraints(mut self, p_format_constraints: &'a [vk::ImageFormatConstraintsInfoFUCHSIA]) -> Self {
        self.inner.format_constraints_count = p_format_constraints.len() as u32;
        self.inner.p_format_constraints = p_format_constraints.as_ptr();
        self
    }
    pub fn buffer_collection_constraints(
        mut self,
        buffer_collection_constraints: vk::BufferCollectionConstraintsInfoFUCHSIA,
    ) -> Self {
        self.inner.buffer_collection_constraints = buffer_collection_constraints;
        self
    }
    pub fn flags(mut self, flags: vk::ImageConstraintsInfoFlagsFUCHSIA) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl<'a> Deref for ImageConstraintsInfoFUCHSIABuilder<'a> {
    type Target = vk::ImageConstraintsInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BufferCollectionConstraintsInfoFUCHSIABuilder {
    inner: vk::BufferCollectionConstraintsInfoFUCHSIA,
}
impl Builder<'_> for vk::BufferCollectionConstraintsInfoFUCHSIA {
    type Type = BufferCollectionConstraintsInfoFUCHSIABuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BufferCollectionConstraintsInfoFUCHSIABuilder {
    pub fn get_mut(&mut self) -> &mut vk::BufferCollectionConstraintsInfoFUCHSIA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn min_buffer_count(mut self, min_buffer_count: u32) -> Self {
        self.inner.min_buffer_count = min_buffer_count;
        self
    }
    pub fn max_buffer_count(mut self, max_buffer_count: u32) -> Self {
        self.inner.max_buffer_count = max_buffer_count;
        self
    }
    pub fn min_buffer_count_for_camping(mut self, min_buffer_count_for_camping: u32) -> Self {
        self.inner.min_buffer_count_for_camping = min_buffer_count_for_camping;
        self
    }
    pub fn min_buffer_count_for_dedicated_slack(mut self, min_buffer_count_for_dedicated_slack: u32) -> Self {
        self.inner.min_buffer_count_for_dedicated_slack = min_buffer_count_for_dedicated_slack;
        self
    }
    pub fn min_buffer_count_for_shared_slack(mut self, min_buffer_count_for_shared_slack: u32) -> Self {
        self.inner.min_buffer_count_for_shared_slack = min_buffer_count_for_shared_slack;
        self
    }
}
impl Deref for BufferCollectionConstraintsInfoFUCHSIABuilder {
    type Target = vk::BufferCollectionConstraintsInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CudaModuleCreateInfoNVBuilder<'a> {
    inner: vk::CudaModuleCreateInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CudaModuleCreateInfoNV {
    type Type = CudaModuleCreateInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CudaModuleCreateInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CudaModuleCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_data(mut self, p_data: &'a [u8]) -> Self {
        self.inner.data_size = p_data.len();
        self.inner.p_data = p_data.as_ptr() as *const _;
        self
    }
}
impl<'a> Deref for CudaModuleCreateInfoNVBuilder<'a> {
    type Target = vk::CudaModuleCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CudaFunctionCreateInfoNVBuilder<'a> {
    inner: vk::CudaFunctionCreateInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CudaFunctionCreateInfoNV {
    type Type = CudaFunctionCreateInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CudaFunctionCreateInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CudaFunctionCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn module(mut self, module: vk::CudaModuleNV) -> Self {
        self.inner.module = module;
        self
    }
    pub fn p_name(mut self, p_name: &'a CStr) -> Self {
        self.inner.p_name = p_name.as_ptr();
        self
    }
}
impl<'a> Deref for CudaFunctionCreateInfoNVBuilder<'a> {
    type Target = vk::CudaFunctionCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CudaLaunchInfoNVBuilder<'a> {
    inner: vk::CudaLaunchInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CudaLaunchInfoNV {
    type Type = CudaLaunchInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CudaLaunchInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CudaLaunchInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn function(mut self, function: vk::CudaFunctionNV) -> Self {
        self.inner.function = function;
        self
    }
    pub fn grid_dim_x(mut self, grid_dim_x: u32) -> Self {
        self.inner.grid_dim_x = grid_dim_x;
        self
    }
    pub fn grid_dim_y(mut self, grid_dim_y: u32) -> Self {
        self.inner.grid_dim_y = grid_dim_y;
        self
    }
    pub fn grid_dim_z(mut self, grid_dim_z: u32) -> Self {
        self.inner.grid_dim_z = grid_dim_z;
        self
    }
    pub fn block_dim_x(mut self, block_dim_x: u32) -> Self {
        self.inner.block_dim_x = block_dim_x;
        self
    }
    pub fn block_dim_y(mut self, block_dim_y: u32) -> Self {
        self.inner.block_dim_y = block_dim_y;
        self
    }
    pub fn block_dim_z(mut self, block_dim_z: u32) -> Self {
        self.inner.block_dim_z = block_dim_z;
        self
    }
    pub fn shared_mem_bytes(mut self, shared_mem_bytes: u32) -> Self {
        self.inner.shared_mem_bytes = shared_mem_bytes;
        self
    }
    pub fn param_count(mut self, param_count: usize) -> Self {
        self.inner.param_count = param_count;
        self
    }
    pub fn p_params(mut self, p_params: &'a [*const c_void]) -> Self {
        self.inner.param_count = p_params.len();
        self.inner.p_params = p_params.as_ptr();
        self
    }
    pub fn extra_count(mut self, extra_count: usize) -> Self {
        self.inner.extra_count = extra_count;
        self
    }
    pub fn p_extras(mut self, p_extras: &'a [*const c_void]) -> Self {
        self.inner.extra_count = p_extras.len();
        self.inner.p_extras = p_extras.as_ptr();
        self
    }
}
impl<'a> Deref for CudaLaunchInfoNVBuilder<'a> {
    type Target = vk::CudaLaunchInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRGBA10X6FormatsFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceRGBA10X6FormatsFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
    type Type = PhysicalDeviceRGBA10X6FormatsFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRGBA10X6FormatsFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn format_rgba10x6_without_y_cb_cr_sampler(mut self, format_rgba10x6_without_y_cb_cr_sampler: bool) -> Self {
        self.inner.format_rgba10x6_without_y_cb_cr_sampler = if format_rgba10x6_without_y_cb_cr_sampler {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceRGBA10X6FormatsFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceRGBA10X6FormatsFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRGBA10X6FormatsFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRGBA10X6FormatsFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRGBA10X6FormatsFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceRGBA10X6FormatsFeaturesEXTBuilder {}
impl FormatProperties2Next for vk::FormatProperties3 {}
impl FormatProperties2Next for vk::DrmFormatModifierPropertiesList2EXT {}
impl AndroidHardwareBufferPropertiesANDROIDNext for vk::AndroidHardwareBufferFormatProperties2ANDROID {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineRenderingCreateInfoBuilder<'a> {
    inner: vk::PipelineRenderingCreateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineRenderingCreateInfo {
    type Type = PipelineRenderingCreateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineRenderingCreateInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineRenderingCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.inner.view_mask = view_mask;
        self
    }
    pub fn color_attachment_count(mut self, color_attachment_count: u32) -> Self {
        self.inner.color_attachment_count = color_attachment_count;
        self
    }
    pub fn p_color_attachment_formats(mut self, p_color_attachment_formats: &'a [vk::Format]) -> Self {
        self.inner.color_attachment_count = p_color_attachment_formats.len() as u32;
        self.inner.p_color_attachment_formats = p_color_attachment_formats.as_ptr();
        self
    }
    pub fn depth_attachment_format(mut self, depth_attachment_format: vk::Format) -> Self {
        self.inner.depth_attachment_format = depth_attachment_format;
        self
    }
    pub fn stencil_attachment_format(mut self, stencil_attachment_format: vk::Format) -> Self {
        self.inner.stencil_attachment_format = stencil_attachment_format;
        self
    }
}
impl<'a> Deref for PipelineRenderingCreateInfoBuilder<'a> {
    type Target = vk::PipelineRenderingCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::PipelineRenderingCreateInfo {}
impl GraphicsPipelineCreateInfoNext for PipelineRenderingCreateInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderingInfoBuilder<'a> {
    inner: vk::RenderingInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderingInfo {
    type Type = RenderingInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait RenderingInfoNext {}
impl<'a> RenderingInfoBuilder<'a> {
    pub fn insert_next<T: RenderingInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::RenderingInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::RenderingFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn render_area(mut self, render_area: vk::Rect2D) -> Self {
        self.inner.render_area = render_area;
        self
    }
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.inner.layer_count = layer_count;
        self
    }
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.inner.view_mask = view_mask;
        self
    }
    pub fn p_color_attachments(mut self, p_color_attachments: &'a [vk::RenderingAttachmentInfo]) -> Self {
        self.inner.color_attachment_count = p_color_attachments.len() as u32;
        self.inner.p_color_attachments = p_color_attachments.as_ptr();
        self
    }
    pub fn p_depth_attachment(mut self, p_depth_attachment: Option<&'a vk::RenderingAttachmentInfo>) -> Self {
        self.inner.p_depth_attachment = p_depth_attachment.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_stencil_attachment(mut self, p_stencil_attachment: Option<&'a vk::RenderingAttachmentInfo>) -> Self {
        self.inner.p_stencil_attachment = p_stencil_attachment.map_or(ptr::null(), |r| r);
        self
    }
}
impl<'a> Deref for RenderingInfoBuilder<'a> {
    type Target = vk::RenderingInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderingEndInfoEXTBuilder<'a> {
    inner: vk::RenderingEndInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderingEndInfoEXT {
    type Type = RenderingEndInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait RenderingEndInfoEXTNext {}
impl<'a> RenderingEndInfoEXTBuilder<'a> {
    pub fn insert_next<T: RenderingEndInfoEXTNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::RenderingEndInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
}
impl<'a> Deref for RenderingEndInfoEXTBuilder<'a> {
    type Target = vk::RenderingEndInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderingAttachmentInfoBuilder<'a> {
    inner: vk::RenderingAttachmentInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderingAttachmentInfo {
    type Type = RenderingAttachmentInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait RenderingAttachmentInfoNext {}
impl<'a> RenderingAttachmentInfoBuilder<'a> {
    pub fn insert_next<T: RenderingAttachmentInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::RenderingAttachmentInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image_view(mut self, image_view: vk::ImageView) -> Self {
        self.inner.image_view = image_view;
        self
    }
    pub fn image_layout(mut self, image_layout: vk::ImageLayout) -> Self {
        self.inner.image_layout = image_layout;
        self
    }
    pub fn resolve_mode(mut self, resolve_mode: vk::ResolveModeFlags) -> Self {
        self.inner.resolve_mode = resolve_mode;
        self
    }
    pub fn resolve_image_view(mut self, resolve_image_view: vk::ImageView) -> Self {
        self.inner.resolve_image_view = resolve_image_view;
        self
    }
    pub fn resolve_image_layout(mut self, resolve_image_layout: vk::ImageLayout) -> Self {
        self.inner.resolve_image_layout = resolve_image_layout;
        self
    }
    pub fn load_op(mut self, load_op: vk::AttachmentLoadOp) -> Self {
        self.inner.load_op = load_op;
        self
    }
    pub fn store_op(mut self, store_op: vk::AttachmentStoreOp) -> Self {
        self.inner.store_op = store_op;
        self
    }
    pub fn clear_value(mut self, clear_value: vk::ClearValue) -> Self {
        self.inner.clear_value = clear_value;
        self
    }
}
impl<'a> Deref for RenderingAttachmentInfoBuilder<'a> {
    type Target = vk::RenderingAttachmentInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderingFragmentShadingRateAttachmentInfoKHRBuilder {
    inner: vk::RenderingFragmentShadingRateAttachmentInfoKHR,
}
impl Builder<'_> for vk::RenderingFragmentShadingRateAttachmentInfoKHR {
    type Type = RenderingFragmentShadingRateAttachmentInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl RenderingFragmentShadingRateAttachmentInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::RenderingFragmentShadingRateAttachmentInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image_view(mut self, image_view: vk::ImageView) -> Self {
        self.inner.image_view = image_view;
        self
    }
    pub fn image_layout(mut self, image_layout: vk::ImageLayout) -> Self {
        self.inner.image_layout = image_layout;
        self
    }
    pub fn shading_rate_attachment_texel_size(mut self, shading_rate_attachment_texel_size: vk::Extent2D) -> Self {
        self.inner.shading_rate_attachment_texel_size = shading_rate_attachment_texel_size;
        self
    }
}
impl Deref for RenderingFragmentShadingRateAttachmentInfoKHRBuilder {
    type Target = vk::RenderingFragmentShadingRateAttachmentInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderingInfoNext for vk::RenderingFragmentShadingRateAttachmentInfoKHR {}
impl RenderingInfoNext for RenderingFragmentShadingRateAttachmentInfoKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderingFragmentDensityMapAttachmentInfoEXTBuilder {
    inner: vk::RenderingFragmentDensityMapAttachmentInfoEXT,
}
impl Builder<'_> for vk::RenderingFragmentDensityMapAttachmentInfoEXT {
    type Type = RenderingFragmentDensityMapAttachmentInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl RenderingFragmentDensityMapAttachmentInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::RenderingFragmentDensityMapAttachmentInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image_view(mut self, image_view: vk::ImageView) -> Self {
        self.inner.image_view = image_view;
        self
    }
    pub fn image_layout(mut self, image_layout: vk::ImageLayout) -> Self {
        self.inner.image_layout = image_layout;
        self
    }
}
impl Deref for RenderingFragmentDensityMapAttachmentInfoEXTBuilder {
    type Target = vk::RenderingFragmentDensityMapAttachmentInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderingInfoNext for vk::RenderingFragmentDensityMapAttachmentInfoEXT {}
impl RenderingInfoNext for RenderingFragmentDensityMapAttachmentInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDynamicRenderingFeaturesBuilder {
    inner: vk::PhysicalDeviceDynamicRenderingFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceDynamicRenderingFeatures {
    type Type = PhysicalDeviceDynamicRenderingFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDynamicRenderingFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDynamicRenderingFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn dynamic_rendering(mut self, dynamic_rendering: bool) -> Self {
        self.inner.dynamic_rendering = if dynamic_rendering { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceDynamicRenderingFeaturesBuilder {
    type Target = vk::PhysicalDeviceDynamicRenderingFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDynamicRenderingFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDynamicRenderingFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDynamicRenderingFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceDynamicRenderingFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct CommandBufferInheritanceRenderingInfoBuilder<'a> {
    inner: vk::CommandBufferInheritanceRenderingInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CommandBufferInheritanceRenderingInfo {
    type Type = CommandBufferInheritanceRenderingInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CommandBufferInheritanceRenderingInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CommandBufferInheritanceRenderingInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::RenderingFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.inner.view_mask = view_mask;
        self
    }
    pub fn p_color_attachment_formats(mut self, p_color_attachment_formats: &'a [vk::Format]) -> Self {
        self.inner.color_attachment_count = p_color_attachment_formats.len() as u32;
        self.inner.p_color_attachment_formats = p_color_attachment_formats.as_ptr();
        self
    }
    pub fn depth_attachment_format(mut self, depth_attachment_format: vk::Format) -> Self {
        self.inner.depth_attachment_format = depth_attachment_format;
        self
    }
    pub fn stencil_attachment_format(mut self, stencil_attachment_format: vk::Format) -> Self {
        self.inner.stencil_attachment_format = stencil_attachment_format;
        self
    }
    pub fn rasterization_samples(mut self, rasterization_samples: vk::SampleCountFlags) -> Self {
        self.inner.rasterization_samples = rasterization_samples;
        self
    }
}
impl<'a> Deref for CommandBufferInheritanceRenderingInfoBuilder<'a> {
    type Target = vk::CommandBufferInheritanceRenderingInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl CommandBufferInheritanceInfoNext for vk::CommandBufferInheritanceRenderingInfo {}
impl CommandBufferInheritanceInfoNext for CommandBufferInheritanceRenderingInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct AttachmentSampleCountInfoAMDBuilder<'a> {
    inner: vk::AttachmentSampleCountInfoAMD,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AttachmentSampleCountInfoAMD {
    type Type = AttachmentSampleCountInfoAMDBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> AttachmentSampleCountInfoAMDBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::AttachmentSampleCountInfoAMD {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn color_attachment_count(mut self, color_attachment_count: u32) -> Self {
        self.inner.color_attachment_count = color_attachment_count;
        self
    }
    pub fn p_color_attachment_samples(mut self, p_color_attachment_samples: &'a [vk::SampleCountFlags]) -> Self {
        self.inner.color_attachment_count = p_color_attachment_samples.len() as u32;
        self.inner.p_color_attachment_samples = p_color_attachment_samples.as_ptr();
        self
    }
    pub fn depth_stencil_attachment_samples(mut self, depth_stencil_attachment_samples: vk::SampleCountFlags) -> Self {
        self.inner.depth_stencil_attachment_samples = depth_stencil_attachment_samples;
        self
    }
}
impl<'a> Deref for AttachmentSampleCountInfoAMDBuilder<'a> {
    type Target = vk::AttachmentSampleCountInfoAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl CommandBufferInheritanceInfoNext for vk::AttachmentSampleCountInfoAMD {}
impl CommandBufferInheritanceInfoNext for AttachmentSampleCountInfoAMDBuilder<'_> {}
impl GraphicsPipelineCreateInfoNext for vk::AttachmentSampleCountInfoAMD {}
impl GraphicsPipelineCreateInfoNext for AttachmentSampleCountInfoAMDBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct MultiviewPerViewAttributesInfoNVXBuilder {
    inner: vk::MultiviewPerViewAttributesInfoNVX,
}
impl Builder<'_> for vk::MultiviewPerViewAttributesInfoNVX {
    type Type = MultiviewPerViewAttributesInfoNVXBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MultiviewPerViewAttributesInfoNVXBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MultiviewPerViewAttributesInfoNVX {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn per_view_attributes(mut self, per_view_attributes: bool) -> Self {
        self.inner.per_view_attributes = if per_view_attributes { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn per_view_attributes_position_x_only(mut self, per_view_attributes_position_x_only: bool) -> Self {
        self.inner.per_view_attributes_position_x_only = if per_view_attributes_position_x_only {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for MultiviewPerViewAttributesInfoNVXBuilder {
    type Target = vk::MultiviewPerViewAttributesInfoNVX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl CommandBufferInheritanceInfoNext for vk::MultiviewPerViewAttributesInfoNVX {}
impl CommandBufferInheritanceInfoNext for MultiviewPerViewAttributesInfoNVXBuilder {}
impl GraphicsPipelineCreateInfoNext for vk::MultiviewPerViewAttributesInfoNVX {}
impl GraphicsPipelineCreateInfoNext for MultiviewPerViewAttributesInfoNVXBuilder {}
impl RenderingInfoNext for vk::MultiviewPerViewAttributesInfoNVX {}
impl RenderingInfoNext for MultiviewPerViewAttributesInfoNVXBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceImageViewMinLodFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceImageViewMinLodFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceImageViewMinLodFeaturesEXT {
    type Type = PhysicalDeviceImageViewMinLodFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceImageViewMinLodFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceImageViewMinLodFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn min_lod(mut self, min_lod: bool) -> Self {
        self.inner.min_lod = if min_lod { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceImageViewMinLodFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceImageViewMinLodFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceImageViewMinLodFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceImageViewMinLodFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceImageViewMinLodFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceImageViewMinLodFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageViewMinLodCreateInfoEXTBuilder {
    inner: vk::ImageViewMinLodCreateInfoEXT,
}
impl Builder<'_> for vk::ImageViewMinLodCreateInfoEXT {
    type Type = ImageViewMinLodCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageViewMinLodCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageViewMinLodCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn min_lod(mut self, min_lod: f32) -> Self {
        self.inner.min_lod = min_lod;
        self
    }
}
impl Deref for ImageViewMinLodCreateInfoEXTBuilder {
    type Target = vk::ImageViewMinLodCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageViewCreateInfoNext for vk::ImageViewMinLodCreateInfoEXT {}
impl ImageViewCreateInfoNext for ImageViewMinLodCreateInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
    type Type = PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn rasterization_order_color_attachment_access(
        mut self,
        rasterization_order_color_attachment_access: bool,
    ) -> Self {
        self.inner.rasterization_order_color_attachment_access = if rasterization_order_color_attachment_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn rasterization_order_depth_attachment_access(
        mut self,
        rasterization_order_depth_attachment_access: bool,
    ) -> Self {
        self.inner.rasterization_order_depth_attachment_access = if rasterization_order_depth_attachment_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn rasterization_order_stencil_attachment_access(
        mut self,
        rasterization_order_stencil_attachment_access: bool,
    ) -> Self {
        self.inner.rasterization_order_stencil_attachment_access = if rasterization_order_stencil_attachment_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceLinearColorAttachmentFeaturesNVBuilder {
    inner: vk::PhysicalDeviceLinearColorAttachmentFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceLinearColorAttachmentFeaturesNV {
    type Type = PhysicalDeviceLinearColorAttachmentFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceLinearColorAttachmentFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceLinearColorAttachmentFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn linear_color_attachment(mut self, linear_color_attachment: bool) -> Self {
        self.inner.linear_color_attachment = if linear_color_attachment { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceLinearColorAttachmentFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceLinearColorAttachmentFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceLinearColorAttachmentFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceLinearColorAttachmentFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceLinearColorAttachmentFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceLinearColorAttachmentFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceGraphicsPipelineLibraryFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
    type Type = PhysicalDeviceGraphicsPipelineLibraryFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceGraphicsPipelineLibraryFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn graphics_pipeline_library(mut self, graphics_pipeline_library: bool) -> Self {
        self.inner.graphics_pipeline_library = if graphics_pipeline_library { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePipelineBinaryFeaturesKHRBuilder {
    inner: vk::PhysicalDevicePipelineBinaryFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDevicePipelineBinaryFeaturesKHR {
    type Type = PhysicalDevicePipelineBinaryFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePipelineBinaryFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePipelineBinaryFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline_binaries(mut self, pipeline_binaries: bool) -> Self {
        self.inner.pipeline_binaries = if pipeline_binaries { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevicePipelineBinaryFeaturesKHRBuilder {
    type Target = vk::PhysicalDevicePipelineBinaryFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePipelineBinaryFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePipelineBinaryFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePipelineBinaryFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDevicePipelineBinaryFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DevicePipelineBinaryInternalCacheControlKHRBuilder {
    inner: vk::DevicePipelineBinaryInternalCacheControlKHR,
}
impl Builder<'_> for vk::DevicePipelineBinaryInternalCacheControlKHR {
    type Type = DevicePipelineBinaryInternalCacheControlKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DevicePipelineBinaryInternalCacheControlKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DevicePipelineBinaryInternalCacheControlKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn disable_internal_cache(mut self, disable_internal_cache: bool) -> Self {
        self.inner.disable_internal_cache = if disable_internal_cache { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for DevicePipelineBinaryInternalCacheControlKHRBuilder {
    type Target = vk::DevicePipelineBinaryInternalCacheControlKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DeviceCreateInfoNext for vk::DevicePipelineBinaryInternalCacheControlKHR {}
impl DeviceCreateInfoNext for DevicePipelineBinaryInternalCacheControlKHRBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDevicePipelineBinaryPropertiesKHR {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct GraphicsPipelineLibraryCreateInfoEXTBuilder {
    inner: vk::GraphicsPipelineLibraryCreateInfoEXT,
}
impl Builder<'_> for vk::GraphicsPipelineLibraryCreateInfoEXT {
    type Type = GraphicsPipelineLibraryCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl GraphicsPipelineLibraryCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::GraphicsPipelineLibraryCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::GraphicsPipelineLibraryFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl Deref for GraphicsPipelineLibraryCreateInfoEXTBuilder {
    type Target = vk::GraphicsPipelineLibraryCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::GraphicsPipelineLibraryCreateInfoEXT {}
impl GraphicsPipelineCreateInfoNext for GraphicsPipelineLibraryCreateInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDescriptorSetHostMappingFeaturesVALVEBuilder {
    inner: vk::PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE,
}
impl Builder<'_> for vk::PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
    type Type = PhysicalDeviceDescriptorSetHostMappingFeaturesVALVEBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDescriptorSetHostMappingFeaturesVALVEBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn descriptor_set_host_mapping(mut self, descriptor_set_host_mapping: bool) -> Self {
        self.inner.descriptor_set_host_mapping = if descriptor_set_host_mapping {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVEBuilder {
    type Target = vk::PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVEBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {}
impl DeviceCreateInfoNext for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVEBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorSetBindingReferenceVALVEBuilder {
    inner: vk::DescriptorSetBindingReferenceVALVE,
}
impl Builder<'_> for vk::DescriptorSetBindingReferenceVALVE {
    type Type = DescriptorSetBindingReferenceVALVEBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DescriptorSetBindingReferenceVALVEBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DescriptorSetBindingReferenceVALVE {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn descriptor_set_layout(mut self, descriptor_set_layout: vk::DescriptorSetLayout) -> Self {
        self.inner.descriptor_set_layout = descriptor_set_layout;
        self
    }
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
}
impl Deref for DescriptorSetBindingReferenceVALVEBuilder {
    type Target = vk::DescriptorSetBindingReferenceVALVE;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorSetLayoutHostMappingInfoVALVEBuilder {
    inner: vk::DescriptorSetLayoutHostMappingInfoVALVE,
}
impl Builder<'_> for vk::DescriptorSetLayoutHostMappingInfoVALVE {
    type Type = DescriptorSetLayoutHostMappingInfoVALVEBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DescriptorSetLayoutHostMappingInfoVALVEBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DescriptorSetLayoutHostMappingInfoVALVE {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn descriptor_offset(mut self, descriptor_offset: usize) -> Self {
        self.inner.descriptor_offset = descriptor_offset;
        self
    }
    pub fn descriptor_size(mut self, descriptor_size: u32) -> Self {
        self.inner.descriptor_size = descriptor_size;
        self
    }
}
impl Deref for DescriptorSetLayoutHostMappingInfoVALVEBuilder {
    type Target = vk::DescriptorSetLayoutHostMappingInfoVALVE;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceNestedCommandBufferFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceNestedCommandBufferFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceNestedCommandBufferFeaturesEXT {
    type Type = PhysicalDeviceNestedCommandBufferFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceNestedCommandBufferFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceNestedCommandBufferFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn nested_command_buffer(mut self, nested_command_buffer: bool) -> Self {
        self.inner.nested_command_buffer = if nested_command_buffer { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn nested_command_buffer_rendering(mut self, nested_command_buffer_rendering: bool) -> Self {
        self.inner.nested_command_buffer_rendering = if nested_command_buffer_rendering {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn nested_command_buffer_simultaneous_use(mut self, nested_command_buffer_simultaneous_use: bool) -> Self {
        self.inner.nested_command_buffer_simultaneous_use = if nested_command_buffer_simultaneous_use {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceNestedCommandBufferFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceNestedCommandBufferFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceNestedCommandBufferFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceNestedCommandBufferFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceNestedCommandBufferFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceNestedCommandBufferFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceNestedCommandBufferPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderModuleIdentifierFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceShaderModuleIdentifierFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceShaderModuleIdentifierFeaturesEXT {
    type Type = PhysicalDeviceShaderModuleIdentifierFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderModuleIdentifierFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderModuleIdentifierFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_module_identifier(mut self, shader_module_identifier: bool) -> Self {
        self.inner.shader_module_identifier = if shader_module_identifier { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceShaderModuleIdentifierFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceShaderModuleIdentifierFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderModuleIdentifierFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderModuleIdentifierFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderModuleIdentifierFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderModuleIdentifierFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceShaderModuleIdentifierPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineShaderStageModuleIdentifierCreateInfoEXTBuilder<'a> {
    inner: vk::PipelineShaderStageModuleIdentifierCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineShaderStageModuleIdentifierCreateInfoEXT {
    type Type = PipelineShaderStageModuleIdentifierCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineShaderStageModuleIdentifierCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineShaderStageModuleIdentifierCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_identifier(mut self, p_identifier: &'a [u8]) -> Self {
        self.inner.identifier_size = p_identifier.len() as u32;
        self.inner.p_identifier = p_identifier.as_ptr();
        self
    }
}
impl<'a> Deref for PipelineShaderStageModuleIdentifierCreateInfoEXTBuilder<'a> {
    type Target = vk::PipelineShaderStageModuleIdentifierCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineShaderStageCreateInfoNext for vk::PipelineShaderStageModuleIdentifierCreateInfoEXT {}
impl PipelineShaderStageCreateInfoNext for PipelineShaderStageModuleIdentifierCreateInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageCompressionControlEXTBuilder<'a> {
    inner: vk::ImageCompressionControlEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ImageCompressionControlEXT {
    type Type = ImageCompressionControlEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ImageCompressionControlEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ImageCompressionControlEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::ImageCompressionFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn compression_control_plane_count(mut self, compression_control_plane_count: u32) -> Self {
        self.inner.compression_control_plane_count = compression_control_plane_count;
        self
    }
    pub fn p_fixed_rate_flags(mut self, p_fixed_rate_flags: &'a mut [vk::ImageCompressionFixedRateFlagsEXT]) -> Self {
        self.inner.compression_control_plane_count = p_fixed_rate_flags.len() as u32;
        self.inner.p_fixed_rate_flags = p_fixed_rate_flags.as_mut_ptr();
        self
    }
}
impl<'a> Deref for ImageCompressionControlEXTBuilder<'a> {
    type Target = vk::ImageCompressionControlEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageCreateInfoNext for vk::ImageCompressionControlEXT {}
impl ImageCreateInfoNext for ImageCompressionControlEXTBuilder<'_> {}
impl SwapchainCreateInfoKHRNext for vk::ImageCompressionControlEXT {}
impl SwapchainCreateInfoKHRNext for ImageCompressionControlEXTBuilder<'_> {}
impl PhysicalDeviceImageFormatInfo2Next for vk::ImageCompressionControlEXT {}
impl PhysicalDeviceImageFormatInfo2Next for ImageCompressionControlEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceImageCompressionControlFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceImageCompressionControlFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceImageCompressionControlFeaturesEXT {
    type Type = PhysicalDeviceImageCompressionControlFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceImageCompressionControlFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceImageCompressionControlFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image_compression_control(mut self, image_compression_control: bool) -> Self {
        self.inner.image_compression_control = if image_compression_control { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceImageCompressionControlFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceImageCompressionControlFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceImageCompressionControlFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceImageCompressionControlFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceImageCompressionControlFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceImageCompressionControlFeaturesEXTBuilder {}
impl ImageFormatProperties2Next for vk::ImageCompressionPropertiesEXT {}
impl SurfaceFormat2KHRNext for vk::ImageCompressionPropertiesEXT {}
impl SubresourceLayout2Next for vk::ImageCompressionPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceImageCompressionControlSwapchainFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
    type Type = PhysicalDeviceImageCompressionControlSwapchainFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceImageCompressionControlSwapchainFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image_compression_control_swapchain(mut self, image_compression_control_swapchain: bool) -> Self {
        self.inner.image_compression_control_swapchain = if image_compression_control_swapchain {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageSubresource2Builder {
    inner: vk::ImageSubresource2,
}
impl Builder<'_> for vk::ImageSubresource2 {
    type Type = ImageSubresource2Builder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageSubresource2Builder {
    pub fn get_mut(&mut self) -> &mut vk::ImageSubresource2 {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image_subresource(mut self, image_subresource: vk::ImageSubresource) -> Self {
        self.inner.image_subresource = image_subresource;
        self
    }
}
impl Deref for ImageSubresource2Builder {
    type Target = vk::ImageSubresource2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SubresourceLayout2Builder<'a> {
    inner: vk::SubresourceLayout2,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SubresourceLayout2 {
    type Type = SubresourceLayout2Builder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait SubresourceLayout2Next {}
impl<'a> SubresourceLayout2Builder<'a> {
    pub fn insert_next<T: SubresourceLayout2Next>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::SubresourceLayout2 {
        &mut self.inner
    }
}
impl<'a> Deref for SubresourceLayout2Builder<'a> {
    type Target = vk::SubresourceLayout2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassCreationControlEXTBuilder {
    inner: vk::RenderPassCreationControlEXT,
}
impl Builder<'_> for vk::RenderPassCreationControlEXT {
    type Type = RenderPassCreationControlEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl RenderPassCreationControlEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::RenderPassCreationControlEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn disallow_merging(mut self, disallow_merging: bool) -> Self {
        self.inner.disallow_merging = if disallow_merging { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for RenderPassCreationControlEXTBuilder {
    type Target = vk::RenderPassCreationControlEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderPassCreateInfo2Next for vk::RenderPassCreationControlEXT {}
impl RenderPassCreateInfo2Next for RenderPassCreationControlEXTBuilder {}
impl SubpassDescription2Next for vk::RenderPassCreationControlEXT {}
impl SubpassDescription2Next for RenderPassCreationControlEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassCreationFeedbackCreateInfoEXTBuilder<'a> {
    inner: vk::RenderPassCreationFeedbackCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderPassCreationFeedbackCreateInfoEXT {
    type Type = RenderPassCreationFeedbackCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> RenderPassCreationFeedbackCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::RenderPassCreationFeedbackCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_render_pass_feedback(
        mut self,
        p_render_pass_feedback: *mut vk::RenderPassCreationFeedbackInfoEXT,
    ) -> Self {
        self.inner.p_render_pass_feedback = p_render_pass_feedback;
        self
    }
}
impl<'a> Deref for RenderPassCreationFeedbackCreateInfoEXTBuilder<'a> {
    type Target = vk::RenderPassCreationFeedbackCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderPassCreateInfo2Next for vk::RenderPassCreationFeedbackCreateInfoEXT {}
impl RenderPassCreateInfo2Next for RenderPassCreationFeedbackCreateInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassSubpassFeedbackCreateInfoEXTBuilder<'a> {
    inner: vk::RenderPassSubpassFeedbackCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderPassSubpassFeedbackCreateInfoEXT {
    type Type = RenderPassSubpassFeedbackCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> RenderPassSubpassFeedbackCreateInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::RenderPassSubpassFeedbackCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_subpass_feedback(mut self, p_subpass_feedback: *mut vk::RenderPassSubpassFeedbackInfoEXT) -> Self {
        self.inner.p_subpass_feedback = p_subpass_feedback;
        self
    }
}
impl<'a> Deref for RenderPassSubpassFeedbackCreateInfoEXTBuilder<'a> {
    type Target = vk::RenderPassSubpassFeedbackCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubpassDescription2Next for vk::RenderPassSubpassFeedbackCreateInfoEXT {}
impl SubpassDescription2Next for RenderPassSubpassFeedbackCreateInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceSubpassMergeFeedbackFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceSubpassMergeFeedbackFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
    type Type = PhysicalDeviceSubpassMergeFeedbackFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceSubpassMergeFeedbackFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn subpass_merge_feedback(mut self, subpass_merge_feedback: bool) -> Self {
        self.inner.subpass_merge_feedback = if subpass_merge_feedback { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceSubpassMergeFeedbackFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceSubpassMergeFeedbackFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceSubpassMergeFeedbackFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceSubpassMergeFeedbackFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct MicromapBuildInfoEXTBuilder<'a> {
    inner: vk::MicromapBuildInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::MicromapBuildInfoEXT {
    type Type = MicromapBuildInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> MicromapBuildInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::MicromapBuildInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ty(mut self, ty: vk::MicromapTypeEXT) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn flags(mut self, flags: vk::BuildMicromapFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn mode(mut self, mode: vk::BuildMicromapModeEXT) -> Self {
        self.inner.mode = mode;
        self
    }
    pub fn dst_micromap(mut self, dst_micromap: vk::MicromapEXT) -> Self {
        self.inner.dst_micromap = dst_micromap;
        self
    }
    pub fn p_usage_counts(
        mut self,
        p_usage_counts: Option<&'a [vk::MicromapUsageEXT]>,
        pp_usage_counts: Option<&'a [*const vk::MicromapUsageEXT]>,
    ) -> Self {
        self.inner.usage_counts_count = p_usage_counts
            .map(|s| s.len() as u32)
            .or(pp_usage_counts.map(|s| s.len() as u32))
            .unwrap_or(0);
        if let Some(len) = p_usage_counts.map(|s| s.len()) {
            assert_eq!(self.inner.usage_counts_count, len as u32);
        }
        if let Some(len) = pp_usage_counts.map(|s| s.len()) {
            assert_eq!(self.inner.usage_counts_count, len as u32);
        }
        self.inner.p_usage_counts = p_usage_counts.map_or(ptr::null(), |s| s.as_ptr());
        self.inner.pp_usage_counts = pp_usage_counts.map_or(ptr::null(), |s| s.as_ptr());
        self
    }
    pub fn data(mut self, data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.data = data;
        self
    }
    pub fn scratch_data(mut self, scratch_data: vk::DeviceOrHostAddressKHR) -> Self {
        self.inner.scratch_data = scratch_data;
        self
    }
    pub fn triangle_array(mut self, triangle_array: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.triangle_array = triangle_array;
        self
    }
    pub fn triangle_array_stride(mut self, triangle_array_stride: vk::DeviceSize) -> Self {
        self.inner.triangle_array_stride = triangle_array_stride;
        self
    }
}
impl<'a> Deref for MicromapBuildInfoEXTBuilder<'a> {
    type Target = vk::MicromapBuildInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MicromapCreateInfoEXTBuilder {
    inner: vk::MicromapCreateInfoEXT,
}
impl Builder<'_> for vk::MicromapCreateInfoEXT {
    type Type = MicromapCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MicromapCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MicromapCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn create_flags(mut self, create_flags: vk::MicromapCreateFlagsEXT) -> Self {
        self.inner.create_flags = create_flags;
        self
    }
    pub fn buffer(mut self, buffer: vk::Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    pub fn offset(mut self, offset: vk::DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    pub fn ty(mut self, ty: vk::MicromapTypeEXT) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn device_address(mut self, device_address: vk::DeviceAddress) -> Self {
        self.inner.device_address = device_address;
        self
    }
}
impl Deref for MicromapCreateInfoEXTBuilder {
    type Target = vk::MicromapCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MicromapVersionInfoEXTBuilder<'a> {
    inner: vk::MicromapVersionInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::MicromapVersionInfoEXT {
    type Type = MicromapVersionInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> MicromapVersionInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::MicromapVersionInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_version_data(mut self, p_version_data: *const u8) -> Self {
        self.inner.p_version_data = p_version_data;
        self
    }
}
impl<'a> Deref for MicromapVersionInfoEXTBuilder<'a> {
    type Target = vk::MicromapVersionInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyMicromapInfoEXTBuilder {
    inner: vk::CopyMicromapInfoEXT,
}
impl Builder<'_> for vk::CopyMicromapInfoEXT {
    type Type = CopyMicromapInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CopyMicromapInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CopyMicromapInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src(mut self, src: vk::MicromapEXT) -> Self {
        self.inner.src = src;
        self
    }
    pub fn dst(mut self, dst: vk::MicromapEXT) -> Self {
        self.inner.dst = dst;
        self
    }
    pub fn mode(mut self, mode: vk::CopyMicromapModeEXT) -> Self {
        self.inner.mode = mode;
        self
    }
}
impl Deref for CopyMicromapInfoEXTBuilder {
    type Target = vk::CopyMicromapInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyMicromapToMemoryInfoEXTBuilder {
    inner: vk::CopyMicromapToMemoryInfoEXT,
}
impl Builder<'_> for vk::CopyMicromapToMemoryInfoEXT {
    type Type = CopyMicromapToMemoryInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CopyMicromapToMemoryInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CopyMicromapToMemoryInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src(mut self, src: vk::MicromapEXT) -> Self {
        self.inner.src = src;
        self
    }
    pub fn dst(mut self, dst: vk::DeviceOrHostAddressKHR) -> Self {
        self.inner.dst = dst;
        self
    }
    pub fn mode(mut self, mode: vk::CopyMicromapModeEXT) -> Self {
        self.inner.mode = mode;
        self
    }
}
impl Deref for CopyMicromapToMemoryInfoEXTBuilder {
    type Target = vk::CopyMicromapToMemoryInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyMemoryToMicromapInfoEXTBuilder {
    inner: vk::CopyMemoryToMicromapInfoEXT,
}
impl Builder<'_> for vk::CopyMemoryToMicromapInfoEXT {
    type Type = CopyMemoryToMicromapInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CopyMemoryToMicromapInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CopyMemoryToMicromapInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src(mut self, src: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.src = src;
        self
    }
    pub fn dst(mut self, dst: vk::MicromapEXT) -> Self {
        self.inner.dst = dst;
        self
    }
    pub fn mode(mut self, mode: vk::CopyMicromapModeEXT) -> Self {
        self.inner.mode = mode;
        self
    }
}
impl Deref for CopyMemoryToMicromapInfoEXTBuilder {
    type Target = vk::CopyMemoryToMicromapInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MicromapBuildSizesInfoEXTBuilder {
    inner: vk::MicromapBuildSizesInfoEXT,
}
impl Builder<'_> for vk::MicromapBuildSizesInfoEXT {
    type Type = MicromapBuildSizesInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MicromapBuildSizesInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MicromapBuildSizesInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn micromap_size(mut self, micromap_size: vk::DeviceSize) -> Self {
        self.inner.micromap_size = micromap_size;
        self
    }
    pub fn build_scratch_size(mut self, build_scratch_size: vk::DeviceSize) -> Self {
        self.inner.build_scratch_size = build_scratch_size;
        self
    }
    pub fn discardable(mut self, discardable: bool) -> Self {
        self.inner.discardable = if discardable { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for MicromapBuildSizesInfoEXTBuilder {
    type Target = vk::MicromapBuildSizesInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MicromapUsageEXTBuilder {
    inner: vk::MicromapUsageEXT,
}
impl Builder<'_> for vk::MicromapUsageEXT {
    type Type = MicromapUsageEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MicromapUsageEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MicromapUsageEXT {
        &mut self.inner
    }
    pub fn count(mut self, count: u32) -> Self {
        self.inner.count = count;
        self
    }
    pub fn subdivision_level(mut self, subdivision_level: u32) -> Self {
        self.inner.subdivision_level = subdivision_level;
        self
    }
    pub fn format(mut self, format: u32) -> Self {
        self.inner.format = format;
        self
    }
}
impl Deref for MicromapUsageEXTBuilder {
    type Target = vk::MicromapUsageEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MicromapTriangleEXTBuilder {
    inner: vk::MicromapTriangleEXT,
}
impl Builder<'_> for vk::MicromapTriangleEXT {
    type Type = MicromapTriangleEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MicromapTriangleEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MicromapTriangleEXT {
        &mut self.inner
    }
    pub fn data_offset(mut self, data_offset: u32) -> Self {
        self.inner.data_offset = data_offset;
        self
    }
    pub fn subdivision_level(mut self, subdivision_level: u16) -> Self {
        self.inner.subdivision_level = subdivision_level;
        self
    }
    pub fn format(mut self, format: u16) -> Self {
        self.inner.format = format;
        self
    }
}
impl Deref for MicromapTriangleEXTBuilder {
    type Target = vk::MicromapTriangleEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceOpacityMicromapFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceOpacityMicromapFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceOpacityMicromapFeaturesEXT {
    type Type = PhysicalDeviceOpacityMicromapFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceOpacityMicromapFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceOpacityMicromapFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn micromap(mut self, micromap: bool) -> Self {
        self.inner.micromap = if micromap { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn micromap_capture_replay(mut self, micromap_capture_replay: bool) -> Self {
        self.inner.micromap_capture_replay = if micromap_capture_replay { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn micromap_host_commands(mut self, micromap_host_commands: bool) -> Self {
        self.inner.micromap_host_commands = if micromap_host_commands { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceOpacityMicromapFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceOpacityMicromapFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceOpacityMicromapFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceOpacityMicromapFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceOpacityMicromapFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceOpacityMicromapFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceOpacityMicromapPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureTrianglesOpacityMicromapEXTBuilder<'a> {
    inner: vk::AccelerationStructureTrianglesOpacityMicromapEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AccelerationStructureTrianglesOpacityMicromapEXT {
    type Type = AccelerationStructureTrianglesOpacityMicromapEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> AccelerationStructureTrianglesOpacityMicromapEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureTrianglesOpacityMicromapEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn index_type(mut self, index_type: vk::IndexType) -> Self {
        self.inner.index_type = index_type;
        self
    }
    pub fn index_buffer(mut self, index_buffer: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.index_buffer = index_buffer;
        self
    }
    pub fn index_stride(mut self, index_stride: vk::DeviceSize) -> Self {
        self.inner.index_stride = index_stride;
        self
    }
    pub fn base_triangle(mut self, base_triangle: u32) -> Self {
        self.inner.base_triangle = base_triangle;
        self
    }
    pub fn p_usage_counts(
        mut self,
        p_usage_counts: Option<&'a [vk::MicromapUsageEXT]>,
        pp_usage_counts: Option<&'a [*const vk::MicromapUsageEXT]>,
    ) -> Self {
        self.inner.usage_counts_count = p_usage_counts
            .map(|s| s.len() as u32)
            .or(pp_usage_counts.map(|s| s.len() as u32))
            .unwrap_or(0);
        if let Some(len) = p_usage_counts.map(|s| s.len()) {
            assert_eq!(self.inner.usage_counts_count, len as u32);
        }
        if let Some(len) = pp_usage_counts.map(|s| s.len()) {
            assert_eq!(self.inner.usage_counts_count, len as u32);
        }
        self.inner.p_usage_counts = p_usage_counts.map_or(ptr::null(), |s| s.as_ptr());
        self.inner.pp_usage_counts = pp_usage_counts.map_or(ptr::null(), |s| s.as_ptr());
        self
    }
    pub fn micromap(mut self, micromap: vk::MicromapEXT) -> Self {
        self.inner.micromap = micromap;
        self
    }
}
impl<'a> Deref for AccelerationStructureTrianglesOpacityMicromapEXTBuilder<'a> {
    type Target = vk::AccelerationStructureTrianglesOpacityMicromapEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl AccelerationStructureGeometryTrianglesDataKHRNext for vk::AccelerationStructureTrianglesOpacityMicromapEXT {}
impl AccelerationStructureGeometryTrianglesDataKHRNext for AccelerationStructureTrianglesOpacityMicromapEXTBuilder<'_> {}
impl AccelerationStructureDenseGeometryFormatTrianglesDataAMDXNext
    for vk::AccelerationStructureTrianglesOpacityMicromapEXT
{
}
impl AccelerationStructureDenseGeometryFormatTrianglesDataAMDXNext
    for AccelerationStructureTrianglesOpacityMicromapEXTBuilder<'_>
{
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDisplacementMicromapFeaturesNVBuilder {
    inner: vk::PhysicalDeviceDisplacementMicromapFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceDisplacementMicromapFeaturesNV {
    type Type = PhysicalDeviceDisplacementMicromapFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDisplacementMicromapFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDisplacementMicromapFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn displacement_micromap(mut self, displacement_micromap: bool) -> Self {
        self.inner.displacement_micromap = if displacement_micromap { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceDisplacementMicromapFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceDisplacementMicromapFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDisplacementMicromapFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDisplacementMicromapFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDisplacementMicromapFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceDisplacementMicromapFeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceDisplacementMicromapPropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureTrianglesDisplacementMicromapNVBuilder<'a> {
    inner: vk::AccelerationStructureTrianglesDisplacementMicromapNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AccelerationStructureTrianglesDisplacementMicromapNV {
    type Type = AccelerationStructureTrianglesDisplacementMicromapNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> AccelerationStructureTrianglesDisplacementMicromapNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureTrianglesDisplacementMicromapNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn displacement_bias_and_scale_format(mut self, displacement_bias_and_scale_format: vk::Format) -> Self {
        self.inner.displacement_bias_and_scale_format = displacement_bias_and_scale_format;
        self
    }
    pub fn displacement_vector_format(mut self, displacement_vector_format: vk::Format) -> Self {
        self.inner.displacement_vector_format = displacement_vector_format;
        self
    }
    pub fn displacement_bias_and_scale_buffer(
        mut self,
        displacement_bias_and_scale_buffer: vk::DeviceOrHostAddressConstKHR,
    ) -> Self {
        self.inner.displacement_bias_and_scale_buffer = displacement_bias_and_scale_buffer;
        self
    }
    pub fn displacement_bias_and_scale_stride(mut self, displacement_bias_and_scale_stride: vk::DeviceSize) -> Self {
        self.inner.displacement_bias_and_scale_stride = displacement_bias_and_scale_stride;
        self
    }
    pub fn displacement_vector_buffer(mut self, displacement_vector_buffer: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.displacement_vector_buffer = displacement_vector_buffer;
        self
    }
    pub fn displacement_vector_stride(mut self, displacement_vector_stride: vk::DeviceSize) -> Self {
        self.inner.displacement_vector_stride = displacement_vector_stride;
        self
    }
    pub fn displaced_micromap_primitive_flags(
        mut self,
        displaced_micromap_primitive_flags: vk::DeviceOrHostAddressConstKHR,
    ) -> Self {
        self.inner.displaced_micromap_primitive_flags = displaced_micromap_primitive_flags;
        self
    }
    pub fn displaced_micromap_primitive_flags_stride(
        mut self,
        displaced_micromap_primitive_flags_stride: vk::DeviceSize,
    ) -> Self {
        self.inner.displaced_micromap_primitive_flags_stride = displaced_micromap_primitive_flags_stride;
        self
    }
    pub fn index_type(mut self, index_type: vk::IndexType) -> Self {
        self.inner.index_type = index_type;
        self
    }
    pub fn index_buffer(mut self, index_buffer: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.index_buffer = index_buffer;
        self
    }
    pub fn index_stride(mut self, index_stride: vk::DeviceSize) -> Self {
        self.inner.index_stride = index_stride;
        self
    }
    pub fn base_triangle(mut self, base_triangle: u32) -> Self {
        self.inner.base_triangle = base_triangle;
        self
    }
    pub fn p_usage_counts(
        mut self,
        p_usage_counts: Option<&'a [vk::MicromapUsageEXT]>,
        pp_usage_counts: Option<&'a [*const vk::MicromapUsageEXT]>,
    ) -> Self {
        self.inner.usage_counts_count = p_usage_counts
            .map(|s| s.len() as u32)
            .or(pp_usage_counts.map(|s| s.len() as u32))
            .unwrap_or(0);
        if let Some(len) = p_usage_counts.map(|s| s.len()) {
            assert_eq!(self.inner.usage_counts_count, len as u32);
        }
        if let Some(len) = pp_usage_counts.map(|s| s.len()) {
            assert_eq!(self.inner.usage_counts_count, len as u32);
        }
        self.inner.p_usage_counts = p_usage_counts.map_or(ptr::null(), |s| s.as_ptr());
        self.inner.pp_usage_counts = pp_usage_counts.map_or(ptr::null(), |s| s.as_ptr());
        self
    }
    pub fn micromap(mut self, micromap: vk::MicromapEXT) -> Self {
        self.inner.micromap = micromap;
        self
    }
}
impl<'a> Deref for AccelerationStructureTrianglesDisplacementMicromapNVBuilder<'a> {
    type Target = vk::AccelerationStructureTrianglesDisplacementMicromapNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl AccelerationStructureGeometryTrianglesDataKHRNext for vk::AccelerationStructureTrianglesDisplacementMicromapNV {}
impl AccelerationStructureGeometryTrianglesDataKHRNext
    for AccelerationStructureTrianglesDisplacementMicromapNVBuilder<'_>
{
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePipelinePropertiesFeaturesEXTBuilder {
    inner: vk::PhysicalDevicePipelinePropertiesFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDevicePipelinePropertiesFeaturesEXT {
    type Type = PhysicalDevicePipelinePropertiesFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePipelinePropertiesFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePipelinePropertiesFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline_properties_identifier(mut self, pipeline_properties_identifier: bool) -> Self {
        self.inner.pipeline_properties_identifier = if pipeline_properties_identifier {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDevicePipelinePropertiesFeaturesEXTBuilder {
    type Target = vk::PhysicalDevicePipelinePropertiesFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePipelinePropertiesFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePipelinePropertiesFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePipelinePropertiesFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDevicePipelinePropertiesFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMDBuilder {
    inner: vk::PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD,
}
impl Builder<'_> for vk::PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
    type Type = PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMDBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMDBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_early_and_late_fragment_tests(mut self, shader_early_and_late_fragment_tests: bool) -> Self {
        self.inner.shader_early_and_late_fragment_tests = if shader_early_and_late_fragment_tests {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMDBuilder {
    type Target = vk::PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMDBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMDBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExternalMemoryAcquireUnmodifiedEXTBuilder {
    inner: vk::ExternalMemoryAcquireUnmodifiedEXT,
}
impl Builder<'_> for vk::ExternalMemoryAcquireUnmodifiedEXT {
    type Type = ExternalMemoryAcquireUnmodifiedEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExternalMemoryAcquireUnmodifiedEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExternalMemoryAcquireUnmodifiedEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn acquire_unmodified_memory(mut self, acquire_unmodified_memory: bool) -> Self {
        self.inner.acquire_unmodified_memory = if acquire_unmodified_memory { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for ExternalMemoryAcquireUnmodifiedEXTBuilder {
    type Target = vk::ExternalMemoryAcquireUnmodifiedEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BufferMemoryBarrierNext for vk::ExternalMemoryAcquireUnmodifiedEXT {}
impl BufferMemoryBarrierNext for ExternalMemoryAcquireUnmodifiedEXTBuilder {}
impl BufferMemoryBarrier2Next for vk::ExternalMemoryAcquireUnmodifiedEXT {}
impl BufferMemoryBarrier2Next for ExternalMemoryAcquireUnmodifiedEXTBuilder {}
impl ImageMemoryBarrierNext for vk::ExternalMemoryAcquireUnmodifiedEXT {}
impl ImageMemoryBarrierNext for ExternalMemoryAcquireUnmodifiedEXTBuilder {}
impl ImageMemoryBarrier2Next for vk::ExternalMemoryAcquireUnmodifiedEXT {}
impl ImageMemoryBarrier2Next for ExternalMemoryAcquireUnmodifiedEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportMetalObjectCreateInfoEXTBuilder {
    inner: vk::ExportMetalObjectCreateInfoEXT,
}
impl Builder<'_> for vk::ExportMetalObjectCreateInfoEXT {
    type Type = ExportMetalObjectCreateInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExportMetalObjectCreateInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExportMetalObjectCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn export_object_type(mut self, export_object_type: vk::ExportMetalObjectTypeFlagsEXT) -> Self {
        self.inner.export_object_type = export_object_type;
        self
    }
}
impl Deref for ExportMetalObjectCreateInfoEXTBuilder {
    type Target = vk::ExportMetalObjectCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl InstanceCreateInfoNext for vk::ExportMetalObjectCreateInfoEXT {}
impl InstanceCreateInfoNext for ExportMetalObjectCreateInfoEXTBuilder {}
impl MemoryAllocateInfoNext for vk::ExportMetalObjectCreateInfoEXT {}
impl MemoryAllocateInfoNext for ExportMetalObjectCreateInfoEXTBuilder {}
impl ImageCreateInfoNext for vk::ExportMetalObjectCreateInfoEXT {}
impl ImageCreateInfoNext for ExportMetalObjectCreateInfoEXTBuilder {}
impl ImageViewCreateInfoNext for vk::ExportMetalObjectCreateInfoEXT {}
impl ImageViewCreateInfoNext for ExportMetalObjectCreateInfoEXTBuilder {}
impl BufferViewCreateInfoNext for vk::ExportMetalObjectCreateInfoEXT {}
impl BufferViewCreateInfoNext for ExportMetalObjectCreateInfoEXTBuilder {}
impl SemaphoreCreateInfoNext for vk::ExportMetalObjectCreateInfoEXT {}
impl SemaphoreCreateInfoNext for ExportMetalObjectCreateInfoEXTBuilder {}
impl EventCreateInfoNext for vk::ExportMetalObjectCreateInfoEXT {}
impl EventCreateInfoNext for ExportMetalObjectCreateInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportMetalObjectsInfoEXTBuilder<'a> {
    inner: vk::ExportMetalObjectsInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ExportMetalObjectsInfoEXT {
    type Type = ExportMetalObjectsInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait ExportMetalObjectsInfoEXTNext {}
impl<'a> ExportMetalObjectsInfoEXTBuilder<'a> {
    pub fn insert_next<T: ExportMetalObjectsInfoEXTNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::ExportMetalObjectsInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
}
impl<'a> Deref for ExportMetalObjectsInfoEXTBuilder<'a> {
    type Target = vk::ExportMetalObjectsInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportMetalDeviceInfoEXTBuilder {
    inner: vk::ExportMetalDeviceInfoEXT,
}
impl Builder<'_> for vk::ExportMetalDeviceInfoEXT {
    type Type = ExportMetalDeviceInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExportMetalDeviceInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExportMetalDeviceInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn mtl_device(mut self, mtl_device: vk::MTLDevice_id) -> Self {
        self.inner.mtl_device = mtl_device;
        self
    }
}
impl Deref for ExportMetalDeviceInfoEXTBuilder {
    type Target = vk::ExportMetalDeviceInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ExportMetalObjectsInfoEXTNext for vk::ExportMetalDeviceInfoEXT {}
impl ExportMetalObjectsInfoEXTNext for ExportMetalDeviceInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportMetalCommandQueueInfoEXTBuilder {
    inner: vk::ExportMetalCommandQueueInfoEXT,
}
impl Builder<'_> for vk::ExportMetalCommandQueueInfoEXT {
    type Type = ExportMetalCommandQueueInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExportMetalCommandQueueInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExportMetalCommandQueueInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn queue(mut self, queue: vk::Queue) -> Self {
        self.inner.queue = queue;
        self
    }
    pub fn mtl_command_queue(mut self, mtl_command_queue: vk::MTLCommandQueue_id) -> Self {
        self.inner.mtl_command_queue = mtl_command_queue;
        self
    }
}
impl Deref for ExportMetalCommandQueueInfoEXTBuilder {
    type Target = vk::ExportMetalCommandQueueInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ExportMetalObjectsInfoEXTNext for vk::ExportMetalCommandQueueInfoEXT {}
impl ExportMetalObjectsInfoEXTNext for ExportMetalCommandQueueInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportMetalBufferInfoEXTBuilder {
    inner: vk::ExportMetalBufferInfoEXT,
}
impl Builder<'_> for vk::ExportMetalBufferInfoEXT {
    type Type = ExportMetalBufferInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExportMetalBufferInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExportMetalBufferInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn mtl_buffer(mut self, mtl_buffer: vk::MTLBuffer_id) -> Self {
        self.inner.mtl_buffer = mtl_buffer;
        self
    }
}
impl Deref for ExportMetalBufferInfoEXTBuilder {
    type Target = vk::ExportMetalBufferInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ExportMetalObjectsInfoEXTNext for vk::ExportMetalBufferInfoEXT {}
impl ExportMetalObjectsInfoEXTNext for ExportMetalBufferInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportMetalBufferInfoEXTBuilder {
    inner: vk::ImportMetalBufferInfoEXT,
}
impl Builder<'_> for vk::ImportMetalBufferInfoEXT {
    type Type = ImportMetalBufferInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImportMetalBufferInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImportMetalBufferInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn mtl_buffer(mut self, mtl_buffer: vk::MTLBuffer_id) -> Self {
        self.inner.mtl_buffer = mtl_buffer;
        self
    }
}
impl Deref for ImportMetalBufferInfoEXTBuilder {
    type Target = vk::ImportMetalBufferInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::ImportMetalBufferInfoEXT {}
impl MemoryAllocateInfoNext for ImportMetalBufferInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportMetalTextureInfoEXTBuilder {
    inner: vk::ExportMetalTextureInfoEXT,
}
impl Builder<'_> for vk::ExportMetalTextureInfoEXT {
    type Type = ExportMetalTextureInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExportMetalTextureInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExportMetalTextureInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image(mut self, image: vk::Image) -> Self {
        self.inner.image = image;
        self
    }
    pub fn image_view(mut self, image_view: vk::ImageView) -> Self {
        self.inner.image_view = image_view;
        self
    }
    pub fn buffer_view(mut self, buffer_view: vk::BufferView) -> Self {
        self.inner.buffer_view = buffer_view;
        self
    }
    pub fn plane(mut self, plane: vk::ImageAspectFlags) -> Self {
        self.inner.plane = plane;
        self
    }
    pub fn mtl_texture(mut self, mtl_texture: vk::MTLTexture_id) -> Self {
        self.inner.mtl_texture = mtl_texture;
        self
    }
}
impl Deref for ExportMetalTextureInfoEXTBuilder {
    type Target = vk::ExportMetalTextureInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ExportMetalObjectsInfoEXTNext for vk::ExportMetalTextureInfoEXT {}
impl ExportMetalObjectsInfoEXTNext for ExportMetalTextureInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportMetalTextureInfoEXTBuilder {
    inner: vk::ImportMetalTextureInfoEXT,
}
impl Builder<'_> for vk::ImportMetalTextureInfoEXT {
    type Type = ImportMetalTextureInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImportMetalTextureInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImportMetalTextureInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn plane(mut self, plane: vk::ImageAspectFlags) -> Self {
        self.inner.plane = plane;
        self
    }
    pub fn mtl_texture(mut self, mtl_texture: vk::MTLTexture_id) -> Self {
        self.inner.mtl_texture = mtl_texture;
        self
    }
}
impl Deref for ImportMetalTextureInfoEXTBuilder {
    type Target = vk::ImportMetalTextureInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageCreateInfoNext for vk::ImportMetalTextureInfoEXT {}
impl ImageCreateInfoNext for ImportMetalTextureInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportMetalIOSurfaceInfoEXTBuilder {
    inner: vk::ExportMetalIOSurfaceInfoEXT,
}
impl Builder<'_> for vk::ExportMetalIOSurfaceInfoEXT {
    type Type = ExportMetalIOSurfaceInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExportMetalIOSurfaceInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExportMetalIOSurfaceInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image(mut self, image: vk::Image) -> Self {
        self.inner.image = image;
        self
    }
    pub fn io_surface(mut self, io_surface: vk::IOSurfaceRef) -> Self {
        self.inner.io_surface = io_surface;
        self
    }
}
impl Deref for ExportMetalIOSurfaceInfoEXTBuilder {
    type Target = vk::ExportMetalIOSurfaceInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ExportMetalObjectsInfoEXTNext for vk::ExportMetalIOSurfaceInfoEXT {}
impl ExportMetalObjectsInfoEXTNext for ExportMetalIOSurfaceInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportMetalIOSurfaceInfoEXTBuilder {
    inner: vk::ImportMetalIOSurfaceInfoEXT,
}
impl Builder<'_> for vk::ImportMetalIOSurfaceInfoEXT {
    type Type = ImportMetalIOSurfaceInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImportMetalIOSurfaceInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImportMetalIOSurfaceInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn io_surface(mut self, io_surface: vk::IOSurfaceRef) -> Self {
        self.inner.io_surface = io_surface;
        self
    }
}
impl Deref for ImportMetalIOSurfaceInfoEXTBuilder {
    type Target = vk::ImportMetalIOSurfaceInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageCreateInfoNext for vk::ImportMetalIOSurfaceInfoEXT {}
impl ImageCreateInfoNext for ImportMetalIOSurfaceInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExportMetalSharedEventInfoEXTBuilder {
    inner: vk::ExportMetalSharedEventInfoEXT,
}
impl Builder<'_> for vk::ExportMetalSharedEventInfoEXT {
    type Type = ExportMetalSharedEventInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExportMetalSharedEventInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExportMetalSharedEventInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn semaphore(mut self, semaphore: vk::Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    pub fn event(mut self, event: vk::Event) -> Self {
        self.inner.event = event;
        self
    }
    pub fn mtl_shared_event(mut self, mtl_shared_event: vk::MTLSharedEvent_id) -> Self {
        self.inner.mtl_shared_event = mtl_shared_event;
        self
    }
}
impl Deref for ExportMetalSharedEventInfoEXTBuilder {
    type Target = vk::ExportMetalSharedEventInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ExportMetalObjectsInfoEXTNext for vk::ExportMetalSharedEventInfoEXT {}
impl ExportMetalObjectsInfoEXTNext for ExportMetalSharedEventInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImportMetalSharedEventInfoEXTBuilder {
    inner: vk::ImportMetalSharedEventInfoEXT,
}
impl Builder<'_> for vk::ImportMetalSharedEventInfoEXT {
    type Type = ImportMetalSharedEventInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImportMetalSharedEventInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImportMetalSharedEventInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn mtl_shared_event(mut self, mtl_shared_event: vk::MTLSharedEvent_id) -> Self {
        self.inner.mtl_shared_event = mtl_shared_event;
        self
    }
}
impl Deref for ImportMetalSharedEventInfoEXTBuilder {
    type Target = vk::ImportMetalSharedEventInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SemaphoreCreateInfoNext for vk::ImportMetalSharedEventInfoEXT {}
impl SemaphoreCreateInfoNext for ImportMetalSharedEventInfoEXTBuilder {}
impl EventCreateInfoNext for vk::ImportMetalSharedEventInfoEXT {}
impl EventCreateInfoNext for ImportMetalSharedEventInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceNonSeamlessCubeMapFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceNonSeamlessCubeMapFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
    type Type = PhysicalDeviceNonSeamlessCubeMapFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceNonSeamlessCubeMapFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn non_seamless_cube_map(mut self, non_seamless_cube_map: bool) -> Self {
        self.inner.non_seamless_cube_map = if non_seamless_cube_map { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceNonSeamlessCubeMapFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceNonSeamlessCubeMapFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceNonSeamlessCubeMapFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceNonSeamlessCubeMapFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePipelineRobustnessFeaturesBuilder {
    inner: vk::PhysicalDevicePipelineRobustnessFeatures,
}
impl Builder<'_> for vk::PhysicalDevicePipelineRobustnessFeatures {
    type Type = PhysicalDevicePipelineRobustnessFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePipelineRobustnessFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePipelineRobustnessFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline_robustness(mut self, pipeline_robustness: bool) -> Self {
        self.inner.pipeline_robustness = if pipeline_robustness { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevicePipelineRobustnessFeaturesBuilder {
    type Target = vk::PhysicalDevicePipelineRobustnessFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePipelineRobustnessFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePipelineRobustnessFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePipelineRobustnessFeatures {}
impl DeviceCreateInfoNext for PhysicalDevicePipelineRobustnessFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineRobustnessCreateInfoBuilder {
    inner: vk::PipelineRobustnessCreateInfo,
}
impl Builder<'_> for vk::PipelineRobustnessCreateInfo {
    type Type = PipelineRobustnessCreateInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineRobustnessCreateInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineRobustnessCreateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn storage_buffers(mut self, storage_buffers: vk::PipelineRobustnessBufferBehavior) -> Self {
        self.inner.storage_buffers = storage_buffers;
        self
    }
    pub fn uniform_buffers(mut self, uniform_buffers: vk::PipelineRobustnessBufferBehavior) -> Self {
        self.inner.uniform_buffers = uniform_buffers;
        self
    }
    pub fn vertex_inputs(mut self, vertex_inputs: vk::PipelineRobustnessBufferBehavior) -> Self {
        self.inner.vertex_inputs = vertex_inputs;
        self
    }
    pub fn images(mut self, images: vk::PipelineRobustnessImageBehavior) -> Self {
        self.inner.images = images;
        self
    }
}
impl Deref for PipelineRobustnessCreateInfoBuilder {
    type Target = vk::PipelineRobustnessCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::PipelineRobustnessCreateInfo {}
impl GraphicsPipelineCreateInfoNext for PipelineRobustnessCreateInfoBuilder {}
impl ComputePipelineCreateInfoNext for vk::PipelineRobustnessCreateInfo {}
impl ComputePipelineCreateInfoNext for PipelineRobustnessCreateInfoBuilder {}
impl PipelineShaderStageCreateInfoNext for vk::PipelineRobustnessCreateInfo {}
impl PipelineShaderStageCreateInfoNext for PipelineRobustnessCreateInfoBuilder {}
impl RayTracingPipelineCreateInfoKHRNext for vk::PipelineRobustnessCreateInfo {}
impl RayTracingPipelineCreateInfoKHRNext for PipelineRobustnessCreateInfoBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDevicePipelineRobustnessProperties {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageViewSampleWeightCreateInfoQCOMBuilder {
    inner: vk::ImageViewSampleWeightCreateInfoQCOM,
}
impl Builder<'_> for vk::ImageViewSampleWeightCreateInfoQCOM {
    type Type = ImageViewSampleWeightCreateInfoQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageViewSampleWeightCreateInfoQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageViewSampleWeightCreateInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn filter_center(mut self, filter_center: vk::Offset2D) -> Self {
        self.inner.filter_center = filter_center;
        self
    }
    pub fn filter_size(mut self, filter_size: vk::Extent2D) -> Self {
        self.inner.filter_size = filter_size;
        self
    }
    pub fn num_phases(mut self, num_phases: u32) -> Self {
        self.inner.num_phases = num_phases;
        self
    }
}
impl Deref for ImageViewSampleWeightCreateInfoQCOMBuilder {
    type Target = vk::ImageViewSampleWeightCreateInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageViewCreateInfoNext for vk::ImageViewSampleWeightCreateInfoQCOM {}
impl ImageViewCreateInfoNext for ImageViewSampleWeightCreateInfoQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceImageProcessingFeaturesQCOMBuilder {
    inner: vk::PhysicalDeviceImageProcessingFeaturesQCOM,
}
impl Builder<'_> for vk::PhysicalDeviceImageProcessingFeaturesQCOM {
    type Type = PhysicalDeviceImageProcessingFeaturesQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceImageProcessingFeaturesQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceImageProcessingFeaturesQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn texture_sample_weighted(mut self, texture_sample_weighted: bool) -> Self {
        self.inner.texture_sample_weighted = if texture_sample_weighted { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn texture_box_filter(mut self, texture_box_filter: bool) -> Self {
        self.inner.texture_box_filter = if texture_box_filter { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn texture_block_match(mut self, texture_block_match: bool) -> Self {
        self.inner.texture_block_match = if texture_block_match { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceImageProcessingFeaturesQCOMBuilder {
    type Target = vk::PhysicalDeviceImageProcessingFeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceImageProcessingFeaturesQCOM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceImageProcessingFeaturesQCOMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceImageProcessingFeaturesQCOM {}
impl DeviceCreateInfoNext for PhysicalDeviceImageProcessingFeaturesQCOMBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceImageProcessingPropertiesQCOM {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceTilePropertiesFeaturesQCOMBuilder {
    inner: vk::PhysicalDeviceTilePropertiesFeaturesQCOM,
}
impl Builder<'_> for vk::PhysicalDeviceTilePropertiesFeaturesQCOM {
    type Type = PhysicalDeviceTilePropertiesFeaturesQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceTilePropertiesFeaturesQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceTilePropertiesFeaturesQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn tile_properties(mut self, tile_properties: bool) -> Self {
        self.inner.tile_properties = if tile_properties { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceTilePropertiesFeaturesQCOMBuilder {
    type Target = vk::PhysicalDeviceTilePropertiesFeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceTilePropertiesFeaturesQCOM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceTilePropertiesFeaturesQCOMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceTilePropertiesFeaturesQCOM {}
impl DeviceCreateInfoNext for PhysicalDeviceTilePropertiesFeaturesQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct TilePropertiesQCOMBuilder {
    inner: vk::TilePropertiesQCOM,
}
impl Builder<'_> for vk::TilePropertiesQCOM {
    type Type = TilePropertiesQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl TilePropertiesQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::TilePropertiesQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn tile_size(mut self, tile_size: vk::Extent3D) -> Self {
        self.inner.tile_size = tile_size;
        self
    }
    pub fn apron_size(mut self, apron_size: vk::Extent2D) -> Self {
        self.inner.apron_size = apron_size;
        self
    }
    pub fn origin(mut self, origin: vk::Offset2D) -> Self {
        self.inner.origin = origin;
        self
    }
}
impl Deref for TilePropertiesQCOMBuilder {
    type Target = vk::TilePropertiesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct TileMemoryBindInfoQCOMBuilder {
    inner: vk::TileMemoryBindInfoQCOM,
}
impl Builder<'_> for vk::TileMemoryBindInfoQCOM {
    type Type = TileMemoryBindInfoQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl TileMemoryBindInfoQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::TileMemoryBindInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
}
impl Deref for TileMemoryBindInfoQCOMBuilder {
    type Target = vk::TileMemoryBindInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl CommandBufferInheritanceInfoNext for vk::TileMemoryBindInfoQCOM {}
impl CommandBufferInheritanceInfoNext for TileMemoryBindInfoQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceAmigoProfilingFeaturesSECBuilder {
    inner: vk::PhysicalDeviceAmigoProfilingFeaturesSEC,
}
impl Builder<'_> for vk::PhysicalDeviceAmigoProfilingFeaturesSEC {
    type Type = PhysicalDeviceAmigoProfilingFeaturesSECBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceAmigoProfilingFeaturesSECBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceAmigoProfilingFeaturesSEC {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn amigo_profiling(mut self, amigo_profiling: bool) -> Self {
        self.inner.amigo_profiling = if amigo_profiling { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceAmigoProfilingFeaturesSECBuilder {
    type Target = vk::PhysicalDeviceAmigoProfilingFeaturesSEC;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceAmigoProfilingFeaturesSEC {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceAmigoProfilingFeaturesSECBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceAmigoProfilingFeaturesSEC {}
impl DeviceCreateInfoNext for PhysicalDeviceAmigoProfilingFeaturesSECBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct AmigoProfilingSubmitInfoSECBuilder {
    inner: vk::AmigoProfilingSubmitInfoSEC,
}
impl Builder<'_> for vk::AmigoProfilingSubmitInfoSEC {
    type Type = AmigoProfilingSubmitInfoSECBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AmigoProfilingSubmitInfoSECBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AmigoProfilingSubmitInfoSEC {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn first_draw_timestamp(mut self, first_draw_timestamp: u64) -> Self {
        self.inner.first_draw_timestamp = first_draw_timestamp;
        self
    }
    pub fn swap_buffer_timestamp(mut self, swap_buffer_timestamp: u64) -> Self {
        self.inner.swap_buffer_timestamp = swap_buffer_timestamp;
        self
    }
}
impl Deref for AmigoProfilingSubmitInfoSECBuilder {
    type Target = vk::AmigoProfilingSubmitInfoSEC;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubmitInfoNext for vk::AmigoProfilingSubmitInfoSEC {}
impl SubmitInfoNext for AmigoProfilingSubmitInfoSECBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
    type Type = PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn attachment_feedback_loop_layout(mut self, attachment_feedback_loop_layout: bool) -> Self {
        self.inner.attachment_feedback_loop_layout = if attachment_feedback_loop_layout {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct AttachmentFeedbackLoopInfoEXTBuilder {
    inner: vk::AttachmentFeedbackLoopInfoEXT,
}
impl Builder<'_> for vk::AttachmentFeedbackLoopInfoEXT {
    type Type = AttachmentFeedbackLoopInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AttachmentFeedbackLoopInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AttachmentFeedbackLoopInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn feedback_loop_enable(mut self, feedback_loop_enable: bool) -> Self {
        self.inner.feedback_loop_enable = if feedback_loop_enable { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for AttachmentFeedbackLoopInfoEXTBuilder {
    type Target = vk::AttachmentFeedbackLoopInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderingAttachmentInfoNext for vk::AttachmentFeedbackLoopInfoEXT {}
impl RenderingAttachmentInfoNext for AttachmentFeedbackLoopInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceAddressBindingReportFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceAddressBindingReportFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceAddressBindingReportFeaturesEXT {
    type Type = PhysicalDeviceAddressBindingReportFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceAddressBindingReportFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceAddressBindingReportFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn report_address_binding(mut self, report_address_binding: bool) -> Self {
        self.inner.report_address_binding = if report_address_binding { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceAddressBindingReportFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceAddressBindingReportFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceAddressBindingReportFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceAddressBindingReportFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceAddressBindingReportFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceAddressBindingReportFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceAddressBindingCallbackDataEXTBuilder {
    inner: vk::DeviceAddressBindingCallbackDataEXT,
}
impl Builder<'_> for vk::DeviceAddressBindingCallbackDataEXT {
    type Type = DeviceAddressBindingCallbackDataEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceAddressBindingCallbackDataEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceAddressBindingCallbackDataEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DeviceAddressBindingFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn base_address(mut self, base_address: vk::DeviceAddress) -> Self {
        self.inner.base_address = base_address;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    pub fn binding_type(mut self, binding_type: vk::DeviceAddressBindingTypeEXT) -> Self {
        self.inner.binding_type = binding_type;
        self
    }
}
impl Deref for DeviceAddressBindingCallbackDataEXTBuilder {
    type Target = vk::DeviceAddressBindingCallbackDataEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DebugUtilsMessengerCallbackDataEXTNext for vk::DeviceAddressBindingCallbackDataEXT {}
impl DebugUtilsMessengerCallbackDataEXTNext for DeviceAddressBindingCallbackDataEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceOpticalFlowFeaturesNVBuilder {
    inner: vk::PhysicalDeviceOpticalFlowFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceOpticalFlowFeaturesNV {
    type Type = PhysicalDeviceOpticalFlowFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceOpticalFlowFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceOpticalFlowFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn optical_flow(mut self, optical_flow: bool) -> Self {
        self.inner.optical_flow = if optical_flow { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceOpticalFlowFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceOpticalFlowFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceOpticalFlowFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceOpticalFlowFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceOpticalFlowFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceOpticalFlowFeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceOpticalFlowPropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct OpticalFlowImageFormatInfoNVBuilder {
    inner: vk::OpticalFlowImageFormatInfoNV,
}
impl Builder<'_> for vk::OpticalFlowImageFormatInfoNV {
    type Type = OpticalFlowImageFormatInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl OpticalFlowImageFormatInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::OpticalFlowImageFormatInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn usage(mut self, usage: vk::OpticalFlowUsageFlagsNV) -> Self {
        self.inner.usage = usage;
        self
    }
}
impl Deref for OpticalFlowImageFormatInfoNVBuilder {
    type Target = vk::OpticalFlowImageFormatInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceImageFormatInfo2Next for vk::OpticalFlowImageFormatInfoNV {}
impl PhysicalDeviceImageFormatInfo2Next for OpticalFlowImageFormatInfoNVBuilder {}
impl ImageCreateInfoNext for vk::OpticalFlowImageFormatInfoNV {}
impl ImageCreateInfoNext for OpticalFlowImageFormatInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct OpticalFlowSessionCreateInfoNVBuilder<'a> {
    inner: vk::OpticalFlowSessionCreateInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::OpticalFlowSessionCreateInfoNV {
    type Type = OpticalFlowSessionCreateInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait OpticalFlowSessionCreateInfoNVNext {}
impl<'a> OpticalFlowSessionCreateInfoNVBuilder<'a> {
    pub fn insert_next<T: OpticalFlowSessionCreateInfoNVNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::OpticalFlowSessionCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn width(mut self, width: u32) -> Self {
        self.inner.width = width;
        self
    }
    pub fn height(mut self, height: u32) -> Self {
        self.inner.height = height;
        self
    }
    pub fn image_format(mut self, image_format: vk::Format) -> Self {
        self.inner.image_format = image_format;
        self
    }
    pub fn flow_vector_format(mut self, flow_vector_format: vk::Format) -> Self {
        self.inner.flow_vector_format = flow_vector_format;
        self
    }
    pub fn cost_format(mut self, cost_format: vk::Format) -> Self {
        self.inner.cost_format = cost_format;
        self
    }
    pub fn output_grid_size(mut self, output_grid_size: vk::OpticalFlowGridSizeFlagsNV) -> Self {
        self.inner.output_grid_size = output_grid_size;
        self
    }
    pub fn hint_grid_size(mut self, hint_grid_size: vk::OpticalFlowGridSizeFlagsNV) -> Self {
        self.inner.hint_grid_size = hint_grid_size;
        self
    }
    pub fn performance_level(mut self, performance_level: vk::OpticalFlowPerformanceLevelNV) -> Self {
        self.inner.performance_level = performance_level;
        self
    }
    pub fn flags(mut self, flags: vk::OpticalFlowSessionCreateFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl<'a> Deref for OpticalFlowSessionCreateInfoNVBuilder<'a> {
    type Target = vk::OpticalFlowSessionCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct OpticalFlowSessionCreatePrivateDataInfoNVBuilder<'a> {
    inner: vk::OpticalFlowSessionCreatePrivateDataInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::OpticalFlowSessionCreatePrivateDataInfoNV {
    type Type = OpticalFlowSessionCreatePrivateDataInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> OpticalFlowSessionCreatePrivateDataInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::OpticalFlowSessionCreatePrivateDataInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn id(mut self, id: u32) -> Self {
        self.inner.id = id;
        self
    }
    pub fn size(mut self, size: u32) -> Self {
        self.inner.size = size;
        self
    }
    pub fn p_private_data(mut self, p_private_data: *const c_void) -> Self {
        self.inner.p_private_data = p_private_data;
        self
    }
}
impl<'a> Deref for OpticalFlowSessionCreatePrivateDataInfoNVBuilder<'a> {
    type Target = vk::OpticalFlowSessionCreatePrivateDataInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl OpticalFlowSessionCreateInfoNVNext for vk::OpticalFlowSessionCreatePrivateDataInfoNV {}
impl OpticalFlowSessionCreateInfoNVNext for OpticalFlowSessionCreatePrivateDataInfoNVBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct OpticalFlowExecuteInfoNVBuilder<'a> {
    inner: vk::OpticalFlowExecuteInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::OpticalFlowExecuteInfoNV {
    type Type = OpticalFlowExecuteInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> OpticalFlowExecuteInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::OpticalFlowExecuteInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::OpticalFlowExecuteFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_regions(mut self, p_regions: &'a [vk::Rect2D]) -> Self {
        self.inner.region_count = p_regions.len() as u32;
        self.inner.p_regions = p_regions.as_ptr();
        self
    }
}
impl<'a> Deref for OpticalFlowExecuteInfoNVBuilder<'a> {
    type Target = vk::OpticalFlowExecuteInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceFaultFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceFaultFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceFaultFeaturesEXT {
    type Type = PhysicalDeviceFaultFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceFaultFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceFaultFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn device_fault(mut self, device_fault: bool) -> Self {
        self.inner.device_fault = if device_fault { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn device_fault_vendor_binary(mut self, device_fault_vendor_binary: bool) -> Self {
        self.inner.device_fault_vendor_binary = if device_fault_vendor_binary {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceFaultFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceFaultFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceFaultFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceFaultFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceFaultFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceFaultFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceFaultAddressInfoEXTBuilder {
    inner: vk::DeviceFaultAddressInfoEXT,
}
impl Builder<'_> for vk::DeviceFaultAddressInfoEXT {
    type Type = DeviceFaultAddressInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceFaultAddressInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceFaultAddressInfoEXT {
        &mut self.inner
    }
    pub fn address_type(mut self, address_type: vk::DeviceFaultAddressTypeEXT) -> Self {
        self.inner.address_type = address_type;
        self
    }
    pub fn reported_address(mut self, reported_address: vk::DeviceAddress) -> Self {
        self.inner.reported_address = reported_address;
        self
    }
    pub fn address_precision(mut self, address_precision: vk::DeviceSize) -> Self {
        self.inner.address_precision = address_precision;
        self
    }
}
impl Deref for DeviceFaultAddressInfoEXTBuilder {
    type Target = vk::DeviceFaultAddressInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceFaultVendorInfoEXTBuilder {
    inner: vk::DeviceFaultVendorInfoEXT,
}
impl Builder<'_> for vk::DeviceFaultVendorInfoEXT {
    type Type = DeviceFaultVendorInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceFaultVendorInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceFaultVendorInfoEXT {
        &mut self.inner
    }
    pub fn description(mut self, description: [c_char; vk::MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.description = description;
        self
    }
    pub fn vendor_fault_code(mut self, vendor_fault_code: u64) -> Self {
        self.inner.vendor_fault_code = vendor_fault_code;
        self
    }
    pub fn vendor_fault_data(mut self, vendor_fault_data: u64) -> Self {
        self.inner.vendor_fault_data = vendor_fault_data;
        self
    }
}
impl Deref for DeviceFaultVendorInfoEXTBuilder {
    type Target = vk::DeviceFaultVendorInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceFaultCountsEXTBuilder {
    inner: vk::DeviceFaultCountsEXT,
}
impl Builder<'_> for vk::DeviceFaultCountsEXT {
    type Type = DeviceFaultCountsEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceFaultCountsEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceFaultCountsEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn address_info_count(mut self, address_info_count: u32) -> Self {
        self.inner.address_info_count = address_info_count;
        self
    }
    pub fn vendor_info_count(mut self, vendor_info_count: u32) -> Self {
        self.inner.vendor_info_count = vendor_info_count;
        self
    }
    pub fn vendor_binary_size(mut self, vendor_binary_size: vk::DeviceSize) -> Self {
        self.inner.vendor_binary_size = vendor_binary_size;
        self
    }
}
impl Deref for DeviceFaultCountsEXTBuilder {
    type Target = vk::DeviceFaultCountsEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceFaultVendorBinaryHeaderVersionOneEXTBuilder {
    inner: vk::DeviceFaultVendorBinaryHeaderVersionOneEXT,
}
impl Builder<'_> for vk::DeviceFaultVendorBinaryHeaderVersionOneEXT {
    type Type = DeviceFaultVendorBinaryHeaderVersionOneEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceFaultVendorBinaryHeaderVersionOneEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceFaultVendorBinaryHeaderVersionOneEXT {
        &mut self.inner
    }
    pub fn header_size(mut self, header_size: u32) -> Self {
        self.inner.header_size = header_size;
        self
    }
    pub fn header_version(mut self, header_version: vk::DeviceFaultVendorBinaryHeaderVersionEXT) -> Self {
        self.inner.header_version = header_version;
        self
    }
    pub fn vendor_id(mut self, vendor_id: u32) -> Self {
        self.inner.vendor_id = vendor_id;
        self
    }
    pub fn device_id(mut self, device_id: u32) -> Self {
        self.inner.device_id = device_id;
        self
    }
    pub fn driver_version(mut self, driver_version: u32) -> Self {
        self.inner.driver_version = driver_version;
        self
    }
    pub fn pipeline_cache_uuid(mut self, pipeline_cache_uuid: [u8; vk::UUID_SIZE]) -> Self {
        self.inner.pipeline_cache_uuid = pipeline_cache_uuid;
        self
    }
    pub fn application_name_offset(mut self, application_name_offset: u32) -> Self {
        self.inner.application_name_offset = application_name_offset;
        self
    }
    pub fn application_version(mut self, application_version: u32) -> Self {
        self.inner.application_version = application_version;
        self
    }
    pub fn engine_name_offset(mut self, engine_name_offset: u32) -> Self {
        self.inner.engine_name_offset = engine_name_offset;
        self
    }
    pub fn engine_version(mut self, engine_version: u32) -> Self {
        self.inner.engine_version = engine_version;
        self
    }
    pub fn api_version(mut self, api_version: vk::Version) -> Self {
        self.inner.api_version = api_version;
        self
    }
}
impl Deref for DeviceFaultVendorBinaryHeaderVersionOneEXTBuilder {
    type Target = vk::DeviceFaultVendorBinaryHeaderVersionOneEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXTBuilder {
    inner: vk::PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {
    type Type = PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline_library_group_handles(mut self, pipeline_library_group_handles: bool) -> Self {
        self.inner.pipeline_library_group_handles = if pipeline_library_group_handles {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXTBuilder {
    type Target = vk::PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DepthBiasInfoEXTBuilder<'a> {
    inner: vk::DepthBiasInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DepthBiasInfoEXT {
    type Type = DepthBiasInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DepthBiasInfoEXTNext {}
impl<'a> DepthBiasInfoEXTBuilder<'a> {
    pub fn insert_next<T: DepthBiasInfoEXTNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DepthBiasInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn depth_bias_constant_factor(mut self, depth_bias_constant_factor: f32) -> Self {
        self.inner.depth_bias_constant_factor = depth_bias_constant_factor;
        self
    }
    pub fn depth_bias_clamp(mut self, depth_bias_clamp: f32) -> Self {
        self.inner.depth_bias_clamp = depth_bias_clamp;
        self
    }
    pub fn depth_bias_slope_factor(mut self, depth_bias_slope_factor: f32) -> Self {
        self.inner.depth_bias_slope_factor = depth_bias_slope_factor;
        self
    }
}
impl<'a> Deref for DepthBiasInfoEXTBuilder<'a> {
    type Target = vk::DepthBiasInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DepthBiasRepresentationInfoEXTBuilder {
    inner: vk::DepthBiasRepresentationInfoEXT,
}
impl Builder<'_> for vk::DepthBiasRepresentationInfoEXT {
    type Type = DepthBiasRepresentationInfoEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DepthBiasRepresentationInfoEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DepthBiasRepresentationInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn depth_bias_representation(mut self, depth_bias_representation: vk::DepthBiasRepresentationEXT) -> Self {
        self.inner.depth_bias_representation = depth_bias_representation;
        self
    }
    pub fn depth_bias_exact(mut self, depth_bias_exact: bool) -> Self {
        self.inner.depth_bias_exact = if depth_bias_exact { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for DepthBiasRepresentationInfoEXTBuilder {
    type Target = vk::DepthBiasRepresentationInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DepthBiasInfoEXTNext for vk::DepthBiasRepresentationInfoEXT {}
impl DepthBiasInfoEXTNext for DepthBiasRepresentationInfoEXTBuilder {}
impl PipelineRasterizationStateCreateInfoNext for vk::DepthBiasRepresentationInfoEXT {}
impl PipelineRasterizationStateCreateInfoNext for DepthBiasRepresentationInfoEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DecompressMemoryRegionNVBuilder {
    inner: vk::DecompressMemoryRegionNV,
}
impl Builder<'_> for vk::DecompressMemoryRegionNV {
    type Type = DecompressMemoryRegionNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DecompressMemoryRegionNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DecompressMemoryRegionNV {
        &mut self.inner
    }
    pub fn src_address(mut self, src_address: vk::DeviceAddress) -> Self {
        self.inner.src_address = src_address;
        self
    }
    pub fn dst_address(mut self, dst_address: vk::DeviceAddress) -> Self {
        self.inner.dst_address = dst_address;
        self
    }
    pub fn compressed_size(mut self, compressed_size: vk::DeviceSize) -> Self {
        self.inner.compressed_size = compressed_size;
        self
    }
    pub fn decompressed_size(mut self, decompressed_size: vk::DeviceSize) -> Self {
        self.inner.decompressed_size = decompressed_size;
        self
    }
    pub fn decompression_method(mut self, decompression_method: vk::MemoryDecompressionMethodFlagsNV) -> Self {
        self.inner.decompression_method = decompression_method;
        self
    }
}
impl Deref for DecompressMemoryRegionNVBuilder {
    type Target = vk::DecompressMemoryRegionNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceShaderCoreBuiltinsPropertiesARM {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderCoreBuiltinsFeaturesARMBuilder {
    inner: vk::PhysicalDeviceShaderCoreBuiltinsFeaturesARM,
}
impl Builder<'_> for vk::PhysicalDeviceShaderCoreBuiltinsFeaturesARM {
    type Type = PhysicalDeviceShaderCoreBuiltinsFeaturesARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderCoreBuiltinsFeaturesARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderCoreBuiltinsFeaturesARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_core_builtins(mut self, shader_core_builtins: bool) -> Self {
        self.inner.shader_core_builtins = if shader_core_builtins { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceShaderCoreBuiltinsFeaturesARMBuilder {
    type Target = vk::PhysicalDeviceShaderCoreBuiltinsFeaturesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderCoreBuiltinsFeaturesARM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderCoreBuiltinsFeaturesARMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderCoreBuiltinsFeaturesARM {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderCoreBuiltinsFeaturesARMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct FrameBoundaryEXTBuilder<'a> {
    inner: vk::FrameBoundaryEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::FrameBoundaryEXT {
    type Type = FrameBoundaryEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> FrameBoundaryEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::FrameBoundaryEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::FrameBoundaryFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn frame_id(mut self, frame_id: u64) -> Self {
        self.inner.frame_id = frame_id;
        self
    }
    pub fn p_images(mut self, p_images: &'a [vk::Image]) -> Self {
        self.inner.image_count = p_images.len() as u32;
        self.inner.p_images = p_images.as_ptr();
        self
    }
    pub fn p_buffers(mut self, p_buffers: &'a [vk::Buffer]) -> Self {
        self.inner.buffer_count = p_buffers.len() as u32;
        self.inner.p_buffers = p_buffers.as_ptr();
        self
    }
    pub fn tag_name(mut self, tag_name: u64) -> Self {
        self.inner.tag_name = tag_name;
        self
    }
    pub fn p_tag(mut self, p_tag: &'a [u8]) -> Self {
        self.inner.tag_size = p_tag.len();
        self.inner.p_tag = p_tag.as_ptr() as *const _;
        self
    }
}
impl<'a> Deref for FrameBoundaryEXTBuilder<'a> {
    type Target = vk::FrameBoundaryEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubmitInfoNext for vk::FrameBoundaryEXT {}
impl SubmitInfoNext for FrameBoundaryEXTBuilder<'_> {}
impl SubmitInfo2Next for vk::FrameBoundaryEXT {}
impl SubmitInfo2Next for FrameBoundaryEXTBuilder<'_> {}
impl PresentInfoKHRNext for vk::FrameBoundaryEXT {}
impl PresentInfoKHRNext for FrameBoundaryEXTBuilder<'_> {}
impl BindSparseInfoNext for vk::FrameBoundaryEXT {}
impl BindSparseInfoNext for FrameBoundaryEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceFrameBoundaryFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceFrameBoundaryFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceFrameBoundaryFeaturesEXT {
    type Type = PhysicalDeviceFrameBoundaryFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceFrameBoundaryFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceFrameBoundaryFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn frame_boundary(mut self, frame_boundary: bool) -> Self {
        self.inner.frame_boundary = if frame_boundary { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceFrameBoundaryFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceFrameBoundaryFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceFrameBoundaryFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceFrameBoundaryFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceFrameBoundaryFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceFrameBoundaryFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {
    type Type = PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn dynamic_rendering_unused_attachments(mut self, dynamic_rendering_unused_attachments: bool) -> Self {
        self.inner.dynamic_rendering_unused_attachments = if dynamic_rendering_unused_attachments {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SurfacePresentModeKHRBuilder {
    inner: vk::SurfacePresentModeKHR,
}
impl Builder<'_> for vk::SurfacePresentModeKHR {
    type Type = SurfacePresentModeKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SurfacePresentModeKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SurfacePresentModeKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn present_mode(mut self, present_mode: vk::PresentModeKHR) -> Self {
        self.inner.present_mode = present_mode;
        self
    }
}
impl Deref for SurfacePresentModeKHRBuilder {
    type Target = vk::SurfacePresentModeKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceSurfaceInfo2KHRNext for vk::SurfacePresentModeKHR {}
impl PhysicalDeviceSurfaceInfo2KHRNext for SurfacePresentModeKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SurfacePresentScalingCapabilitiesKHRBuilder {
    inner: vk::SurfacePresentScalingCapabilitiesKHR,
}
impl Builder<'_> for vk::SurfacePresentScalingCapabilitiesKHR {
    type Type = SurfacePresentScalingCapabilitiesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SurfacePresentScalingCapabilitiesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SurfacePresentScalingCapabilitiesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn supported_present_scaling(mut self, supported_present_scaling: vk::PresentScalingFlagsKHR) -> Self {
        self.inner.supported_present_scaling = supported_present_scaling;
        self
    }
    pub fn supported_present_gravity_x(mut self, supported_present_gravity_x: vk::PresentGravityFlagsKHR) -> Self {
        self.inner.supported_present_gravity_x = supported_present_gravity_x;
        self
    }
    pub fn supported_present_gravity_y(mut self, supported_present_gravity_y: vk::PresentGravityFlagsKHR) -> Self {
        self.inner.supported_present_gravity_y = supported_present_gravity_y;
        self
    }
    pub fn min_scaled_image_extent(mut self, min_scaled_image_extent: vk::Extent2D) -> Self {
        self.inner.min_scaled_image_extent = min_scaled_image_extent;
        self
    }
    pub fn max_scaled_image_extent(mut self, max_scaled_image_extent: vk::Extent2D) -> Self {
        self.inner.max_scaled_image_extent = max_scaled_image_extent;
        self
    }
}
impl Deref for SurfacePresentScalingCapabilitiesKHRBuilder {
    type Target = vk::SurfacePresentScalingCapabilitiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SurfaceCapabilities2KHRNext for vk::SurfacePresentScalingCapabilitiesKHR {}
impl SurfaceCapabilities2KHRNext for SurfacePresentScalingCapabilitiesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SurfacePresentModeCompatibilityKHRBuilder<'a> {
    inner: vk::SurfacePresentModeCompatibilityKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SurfacePresentModeCompatibilityKHR {
    type Type = SurfacePresentModeCompatibilityKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> SurfacePresentModeCompatibilityKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::SurfacePresentModeCompatibilityKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_present_modes(mut self, p_present_modes: &'a mut [vk::PresentModeKHR]) -> Self {
        self.inner.present_mode_count = p_present_modes.len() as u32;
        self.inner.p_present_modes = p_present_modes.as_mut_ptr();
        self
    }
}
impl<'a> Deref for SurfacePresentModeCompatibilityKHRBuilder<'a> {
    type Target = vk::SurfacePresentModeCompatibilityKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SurfaceCapabilities2KHRNext for vk::SurfacePresentModeCompatibilityKHR {}
impl SurfaceCapabilities2KHRNext for SurfacePresentModeCompatibilityKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceSwapchainMaintenance1FeaturesKHRBuilder {
    inner: vk::PhysicalDeviceSwapchainMaintenance1FeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceSwapchainMaintenance1FeaturesKHR {
    type Type = PhysicalDeviceSwapchainMaintenance1FeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceSwapchainMaintenance1FeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceSwapchainMaintenance1FeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn swapchain_maintenance1(mut self, swapchain_maintenance1: bool) -> Self {
        self.inner.swapchain_maintenance1 = if swapchain_maintenance1 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceSwapchainMaintenance1FeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceSwapchainMaintenance1FeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceSwapchainMaintenance1FeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceSwapchainMaintenance1FeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceSwapchainMaintenance1FeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceSwapchainMaintenance1FeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SwapchainPresentFenceInfoKHRBuilder<'a> {
    inner: vk::SwapchainPresentFenceInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SwapchainPresentFenceInfoKHR {
    type Type = SwapchainPresentFenceInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> SwapchainPresentFenceInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::SwapchainPresentFenceInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_fences(mut self, p_fences: &'a [vk::Fence]) -> Self {
        self.inner.swapchain_count = p_fences.len() as u32;
        self.inner.p_fences = p_fences.as_ptr();
        self
    }
}
impl<'a> Deref for SwapchainPresentFenceInfoKHRBuilder<'a> {
    type Target = vk::SwapchainPresentFenceInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PresentInfoKHRNext for vk::SwapchainPresentFenceInfoKHR {}
impl PresentInfoKHRNext for SwapchainPresentFenceInfoKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct SwapchainPresentModesCreateInfoKHRBuilder<'a> {
    inner: vk::SwapchainPresentModesCreateInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SwapchainPresentModesCreateInfoKHR {
    type Type = SwapchainPresentModesCreateInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> SwapchainPresentModesCreateInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::SwapchainPresentModesCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_present_modes(mut self, p_present_modes: &'a [vk::PresentModeKHR]) -> Self {
        self.inner.present_mode_count = p_present_modes.len() as u32;
        self.inner.p_present_modes = p_present_modes.as_ptr();
        self
    }
}
impl<'a> Deref for SwapchainPresentModesCreateInfoKHRBuilder<'a> {
    type Target = vk::SwapchainPresentModesCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SwapchainCreateInfoKHRNext for vk::SwapchainPresentModesCreateInfoKHR {}
impl SwapchainCreateInfoKHRNext for SwapchainPresentModesCreateInfoKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct SwapchainPresentModeInfoKHRBuilder<'a> {
    inner: vk::SwapchainPresentModeInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SwapchainPresentModeInfoKHR {
    type Type = SwapchainPresentModeInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> SwapchainPresentModeInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::SwapchainPresentModeInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_present_modes(mut self, p_present_modes: &'a [vk::PresentModeKHR]) -> Self {
        self.inner.swapchain_count = p_present_modes.len() as u32;
        self.inner.p_present_modes = p_present_modes.as_ptr();
        self
    }
}
impl<'a> Deref for SwapchainPresentModeInfoKHRBuilder<'a> {
    type Target = vk::SwapchainPresentModeInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PresentInfoKHRNext for vk::SwapchainPresentModeInfoKHR {}
impl PresentInfoKHRNext for SwapchainPresentModeInfoKHRBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct SwapchainPresentScalingCreateInfoKHRBuilder {
    inner: vk::SwapchainPresentScalingCreateInfoKHR,
}
impl Builder<'_> for vk::SwapchainPresentScalingCreateInfoKHR {
    type Type = SwapchainPresentScalingCreateInfoKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SwapchainPresentScalingCreateInfoKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SwapchainPresentScalingCreateInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn scaling_behavior(mut self, scaling_behavior: vk::PresentScalingFlagsKHR) -> Self {
        self.inner.scaling_behavior = scaling_behavior;
        self
    }
    pub fn present_gravity_x(mut self, present_gravity_x: vk::PresentGravityFlagsKHR) -> Self {
        self.inner.present_gravity_x = present_gravity_x;
        self
    }
    pub fn present_gravity_y(mut self, present_gravity_y: vk::PresentGravityFlagsKHR) -> Self {
        self.inner.present_gravity_y = present_gravity_y;
        self
    }
}
impl Deref for SwapchainPresentScalingCreateInfoKHRBuilder {
    type Target = vk::SwapchainPresentScalingCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SwapchainCreateInfoKHRNext for vk::SwapchainPresentScalingCreateInfoKHR {}
impl SwapchainCreateInfoKHRNext for SwapchainPresentScalingCreateInfoKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ReleaseSwapchainImagesInfoKHRBuilder<'a> {
    inner: vk::ReleaseSwapchainImagesInfoKHR,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ReleaseSwapchainImagesInfoKHR {
    type Type = ReleaseSwapchainImagesInfoKHRBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ReleaseSwapchainImagesInfoKHRBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ReleaseSwapchainImagesInfoKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn swapchain(mut self, swapchain: vk::SwapchainKHR) -> Self {
        self.inner.swapchain = swapchain;
        self
    }
    pub fn p_image_indices(mut self, p_image_indices: &'a [u32]) -> Self {
        self.inner.image_index_count = p_image_indices.len() as u32;
        self.inner.p_image_indices = p_image_indices.as_ptr();
        self
    }
}
impl<'a> Deref for ReleaseSwapchainImagesInfoKHRBuilder<'a> {
    type Target = vk::ReleaseSwapchainImagesInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDepthBiasControlFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceDepthBiasControlFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceDepthBiasControlFeaturesEXT {
    type Type = PhysicalDeviceDepthBiasControlFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDepthBiasControlFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDepthBiasControlFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn depth_bias_control(mut self, depth_bias_control: bool) -> Self {
        self.inner.depth_bias_control = if depth_bias_control { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn least_representable_value_force_unorm_representation(
        mut self,
        least_representable_value_force_unorm_representation: bool,
    ) -> Self {
        self.inner.least_representable_value_force_unorm_representation =
            if least_representable_value_force_unorm_representation {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn float_representation(mut self, float_representation: bool) -> Self {
        self.inner.float_representation = if float_representation { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn depth_bias_exact(mut self, depth_bias_exact: bool) -> Self {
        self.inner.depth_bias_exact = if depth_bias_exact { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceDepthBiasControlFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceDepthBiasControlFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDepthBiasControlFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDepthBiasControlFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDepthBiasControlFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceDepthBiasControlFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRayTracingInvocationReorderFeaturesNVBuilder {
    inner: vk::PhysicalDeviceRayTracingInvocationReorderFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceRayTracingInvocationReorderFeaturesNV {
    type Type = PhysicalDeviceRayTracingInvocationReorderFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRayTracingInvocationReorderFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRayTracingInvocationReorderFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ray_tracing_invocation_reorder(mut self, ray_tracing_invocation_reorder: bool) -> Self {
        self.inner.ray_tracing_invocation_reorder = if ray_tracing_invocation_reorder {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceRayTracingInvocationReorderFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceRayTracingInvocationReorderFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRayTracingInvocationReorderFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRayTracingInvocationReorderFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRayTracingInvocationReorderFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceRayTracingInvocationReorderFeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceRayTracingInvocationReorderPropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceExtendedSparseAddressSpaceFeaturesNVBuilder {
    inner: vk::PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV {
    type Type = PhysicalDeviceExtendedSparseAddressSpaceFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceExtendedSparseAddressSpaceFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn extended_sparse_address_space(mut self, extended_sparse_address_space: bool) -> Self {
        self.inner.extended_sparse_address_space = if extended_sparse_address_space {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceExtendedSparseAddressSpaceFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceExtendedSparseAddressSpaceFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceExtendedSparseAddressSpaceFeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceExtendedSparseAddressSpacePropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct DirectDriverLoadingInfoLUNARGBuilder {
    inner: vk::DirectDriverLoadingInfoLUNARG,
}
impl Builder<'_> for vk::DirectDriverLoadingInfoLUNARG {
    type Type = DirectDriverLoadingInfoLUNARGBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DirectDriverLoadingInfoLUNARGBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DirectDriverLoadingInfoLUNARG {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DirectDriverLoadingFlagsLUNARG) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn pfn_get_instance_proc_addr(mut self, pfn_get_instance_proc_addr: vk::FnGetInstanceProcAddrLUNARG) -> Self {
        self.inner.pfn_get_instance_proc_addr = Some(pfn_get_instance_proc_addr);
        self
    }
}
impl Deref for DirectDriverLoadingInfoLUNARGBuilder {
    type Target = vk::DirectDriverLoadingInfoLUNARG;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DirectDriverLoadingListLUNARGBuilder<'a> {
    inner: vk::DirectDriverLoadingListLUNARG,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DirectDriverLoadingListLUNARG {
    type Type = DirectDriverLoadingListLUNARGBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DirectDriverLoadingListLUNARGBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DirectDriverLoadingListLUNARG {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn mode(mut self, mode: vk::DirectDriverLoadingModeLUNARG) -> Self {
        self.inner.mode = mode;
        self
    }
    pub fn p_drivers(mut self, p_drivers: &'a [vk::DirectDriverLoadingInfoLUNARG]) -> Self {
        self.inner.driver_count = p_drivers.len() as u32;
        self.inner.p_drivers = p_drivers.as_ptr();
        self
    }
}
impl<'a> Deref for DirectDriverLoadingListLUNARGBuilder<'a> {
    type Target = vk::DirectDriverLoadingListLUNARG;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl InstanceCreateInfoNext for vk::DirectDriverLoadingListLUNARG {}
impl InstanceCreateInfoNext for DirectDriverLoadingListLUNARGBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOMBuilder {
    inner: vk::PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM,
}
impl Builder<'_> for vk::PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
    type Type = PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn multiview_per_view_viewports(mut self, multiview_per_view_viewports: bool) -> Self {
        self.inner.multiview_per_view_viewports = if multiview_per_view_viewports {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOMBuilder {
    type Target = vk::PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {}
impl DeviceCreateInfoNext for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRayTracingPositionFetchFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceRayTracingPositionFetchFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceRayTracingPositionFetchFeaturesKHR {
    type Type = PhysicalDeviceRayTracingPositionFetchFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRayTracingPositionFetchFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRayTracingPositionFetchFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ray_tracing_position_fetch(mut self, ray_tracing_position_fetch: bool) -> Self {
        self.inner.ray_tracing_position_fetch = if ray_tracing_position_fetch {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceRayTracingPositionFetchFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceRayTracingPositionFetchFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRayTracingPositionFetchFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRayTracingPositionFetchFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRayTracingPositionFetchFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceRayTracingPositionFetchFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceImageSubresourceInfoBuilder<'a> {
    inner: vk::DeviceImageSubresourceInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DeviceImageSubresourceInfo {
    type Type = DeviceImageSubresourceInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DeviceImageSubresourceInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DeviceImageSubresourceInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_create_info(mut self, p_create_info: &'a vk::ImageCreateInfo) -> Self {
        self.inner.p_create_info = p_create_info;
        self
    }
    pub fn p_subresource(mut self, p_subresource: &'a vk::ImageSubresource2) -> Self {
        self.inner.p_subresource = p_subresource;
        self
    }
}
impl<'a> Deref for DeviceImageSubresourceInfoBuilder<'a> {
    type Target = vk::DeviceImageSubresourceInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceShaderCorePropertiesARM {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOMBuilder {
    inner: vk::PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM,
}
impl Builder<'_> for vk::PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {
    type Type = PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn multiview_per_view_render_areas(mut self, multiview_per_view_render_areas: bool) -> Self {
        self.inner.multiview_per_view_render_areas = if multiview_per_view_render_areas {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOMBuilder {
    type Target = vk::PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {}
impl DeviceCreateInfoNext for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct MultiviewPerViewRenderAreasRenderPassBeginInfoQCOMBuilder<'a> {
    inner: vk::MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {
    type Type = MultiviewPerViewRenderAreasRenderPassBeginInfoQCOMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> MultiviewPerViewRenderAreasRenderPassBeginInfoQCOMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_per_view_render_areas(mut self, p_per_view_render_areas: &'a [vk::Rect2D]) -> Self {
        self.inner.per_view_render_area_count = p_per_view_render_areas.len() as u32;
        self.inner.p_per_view_render_areas = p_per_view_render_areas.as_ptr();
        self
    }
}
impl<'a> Deref for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOMBuilder<'a> {
    type Target = vk::MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderPassBeginInfoNext for vk::MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {}
impl RenderPassBeginInfoNext for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOMBuilder<'_> {}
impl RenderingInfoNext for vk::MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {}
impl RenderingInfoNext for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOMBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct QueryLowLatencySupportNVBuilder<'a> {
    inner: vk::QueryLowLatencySupportNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::QueryLowLatencySupportNV {
    type Type = QueryLowLatencySupportNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> QueryLowLatencySupportNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::QueryLowLatencySupportNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_queried_low_latency_data(mut self, p_queried_low_latency_data: *mut c_void) -> Self {
        self.inner.p_queried_low_latency_data = p_queried_low_latency_data;
        self
    }
}
impl<'a> Deref for QueryLowLatencySupportNVBuilder<'a> {
    type Target = vk::QueryLowLatencySupportNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SemaphoreCreateInfoNext for vk::QueryLowLatencySupportNV {}
impl SemaphoreCreateInfoNext for QueryLowLatencySupportNVBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryMapInfoBuilder<'a> {
    inner: vk::MemoryMapInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::MemoryMapInfo {
    type Type = MemoryMapInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait MemoryMapInfoNext {}
impl<'a> MemoryMapInfoBuilder<'a> {
    pub fn insert_next<T: MemoryMapInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::MemoryMapInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::MemoryMapFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn offset(mut self, offset: vk::DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
}
impl<'a> Deref for MemoryMapInfoBuilder<'a> {
    type Target = vk::MemoryMapInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryUnmapInfoBuilder {
    inner: vk::MemoryUnmapInfo,
}
impl Builder<'_> for vk::MemoryUnmapInfo {
    type Type = MemoryUnmapInfoBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryUnmapInfoBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryUnmapInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::MemoryUnmapFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
}
impl Deref for MemoryUnmapInfoBuilder {
    type Target = vk::MemoryUnmapInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderObjectFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceShaderObjectFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceShaderObjectFeaturesEXT {
    type Type = PhysicalDeviceShaderObjectFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderObjectFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderObjectFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_object(mut self, shader_object: bool) -> Self {
        self.inner.shader_object = if shader_object { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceShaderObjectFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceShaderObjectFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderObjectFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderObjectFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderObjectFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderObjectFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceShaderObjectPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct ShaderCreateInfoEXTBuilder<'a> {
    inner: vk::ShaderCreateInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ShaderCreateInfoEXT {
    type Type = ShaderCreateInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait ShaderCreateInfoEXTNext {}
impl<'a> ShaderCreateInfoEXTBuilder<'a> {
    pub fn insert_next<T: ShaderCreateInfoEXTNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::ShaderCreateInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::ShaderCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn stage(mut self, stage: vk::ShaderStageFlags) -> Self {
        self.inner.stage = stage;
        self
    }
    pub fn next_stage(mut self, next_stage: vk::ShaderStageFlags) -> Self {
        self.inner.next_stage = next_stage;
        self
    }
    pub fn code_type(mut self, code_type: vk::ShaderCodeTypeEXT) -> Self {
        self.inner.code_type = code_type;
        self
    }
    pub fn p_code(mut self, p_code: &'a [u8]) -> Self {
        self.inner.code_size = p_code.len();
        self.inner.p_code = p_code.as_ptr() as *const _;
        self
    }
    pub fn p_name(mut self, p_name: Option<&'a CStr>) -> Self {
        self.inner.p_name = p_name.map_or(ptr::null(), |r| r.as_ptr());
        self
    }
    pub fn p_set_layouts(mut self, p_set_layouts: &'a [vk::DescriptorSetLayout]) -> Self {
        self.inner.set_layout_count = p_set_layouts.len() as u32;
        self.inner.p_set_layouts = p_set_layouts.as_ptr();
        self
    }
    pub fn p_push_constant_ranges(mut self, p_push_constant_ranges: &'a [vk::PushConstantRange]) -> Self {
        self.inner.push_constant_range_count = p_push_constant_ranges.len() as u32;
        self.inner.p_push_constant_ranges = p_push_constant_ranges.as_ptr();
        self
    }
    pub fn p_specialization_info(mut self, p_specialization_info: Option<&'a vk::SpecializationInfo>) -> Self {
        self.inner.p_specialization_info = p_specialization_info.map_or(ptr::null(), |r| r);
        self
    }
}
impl<'a> Deref for ShaderCreateInfoEXTBuilder<'a> {
    type Target = vk::ShaderCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderTileImageFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceShaderTileImageFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceShaderTileImageFeaturesEXT {
    type Type = PhysicalDeviceShaderTileImageFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderTileImageFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderTileImageFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_tile_image_color_read_access(mut self, shader_tile_image_color_read_access: bool) -> Self {
        self.inner.shader_tile_image_color_read_access = if shader_tile_image_color_read_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_tile_image_depth_read_access(mut self, shader_tile_image_depth_read_access: bool) -> Self {
        self.inner.shader_tile_image_depth_read_access = if shader_tile_image_depth_read_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_tile_image_stencil_read_access(mut self, shader_tile_image_stencil_read_access: bool) -> Self {
        self.inner.shader_tile_image_stencil_read_access = if shader_tile_image_stencil_read_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderTileImageFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceShaderTileImageFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderTileImageFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderTileImageFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderTileImageFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderTileImageFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceShaderTileImagePropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceCooperativeMatrixFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceCooperativeMatrixFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceCooperativeMatrixFeaturesKHR {
    type Type = PhysicalDeviceCooperativeMatrixFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceCooperativeMatrixFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceCooperativeMatrixFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn cooperative_matrix(mut self, cooperative_matrix: bool) -> Self {
        self.inner.cooperative_matrix = if cooperative_matrix { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn cooperative_matrix_robust_buffer_access(mut self, cooperative_matrix_robust_buffer_access: bool) -> Self {
        self.inner.cooperative_matrix_robust_buffer_access = if cooperative_matrix_robust_buffer_access {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceCooperativeMatrixFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceCooperativeMatrixFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceCooperativeMatrixFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceCooperativeMatrixFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceCooperativeMatrixFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceCooperativeMatrixFeaturesKHRBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceCooperativeMatrixPropertiesKHR {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceShaderEnqueuePropertiesAMDX {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderEnqueueFeaturesAMDXBuilder {
    inner: vk::PhysicalDeviceShaderEnqueueFeaturesAMDX,
}
impl Builder<'_> for vk::PhysicalDeviceShaderEnqueueFeaturesAMDX {
    type Type = PhysicalDeviceShaderEnqueueFeaturesAMDXBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderEnqueueFeaturesAMDXBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderEnqueueFeaturesAMDX {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_enqueue(mut self, shader_enqueue: bool) -> Self {
        self.inner.shader_enqueue = if shader_enqueue { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_mesh_enqueue(mut self, shader_mesh_enqueue: bool) -> Self {
        self.inner.shader_mesh_enqueue = if shader_mesh_enqueue { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceShaderEnqueueFeaturesAMDXBuilder {
    type Target = vk::PhysicalDeviceShaderEnqueueFeaturesAMDX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderEnqueueFeaturesAMDX {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderEnqueueFeaturesAMDXBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderEnqueueFeaturesAMDX {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderEnqueueFeaturesAMDXBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExecutionGraphPipelineCreateInfoAMDXBuilder<'a> {
    inner: vk::ExecutionGraphPipelineCreateInfoAMDX,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ExecutionGraphPipelineCreateInfoAMDX {
    type Type = ExecutionGraphPipelineCreateInfoAMDXBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait ExecutionGraphPipelineCreateInfoAMDXNext {}
impl<'a> ExecutionGraphPipelineCreateInfoAMDXBuilder<'a> {
    pub fn insert_next<T: ExecutionGraphPipelineCreateInfoAMDXNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::ExecutionGraphPipelineCreateInfoAMDX {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_stages(mut self, p_stages: &'a [vk::PipelineShaderStageCreateInfo]) -> Self {
        self.inner.stage_count = p_stages.len() as u32;
        self.inner.p_stages = p_stages.as_ptr();
        self
    }
    pub fn p_library_info(mut self, p_library_info: Option<&'a vk::PipelineLibraryCreateInfoKHR>) -> Self {
        self.inner.p_library_info = p_library_info.map_or(ptr::null(), |r| r);
        self
    }
    pub fn layout(mut self, layout: vk::PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    pub fn base_pipeline_handle(mut self, base_pipeline_handle: vk::Pipeline) -> Self {
        self.inner.base_pipeline_handle = base_pipeline_handle;
        self
    }
    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.inner.base_pipeline_index = base_pipeline_index;
        self
    }
}
impl<'a> Deref for ExecutionGraphPipelineCreateInfoAMDXBuilder<'a> {
    type Target = vk::ExecutionGraphPipelineCreateInfoAMDX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineShaderStageNodeCreateInfoAMDXBuilder<'a> {
    inner: vk::PipelineShaderStageNodeCreateInfoAMDX,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PipelineShaderStageNodeCreateInfoAMDX {
    type Type = PipelineShaderStageNodeCreateInfoAMDXBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PipelineShaderStageNodeCreateInfoAMDXBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PipelineShaderStageNodeCreateInfoAMDX {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_name(mut self, p_name: Option<&'a CStr>) -> Self {
        self.inner.p_name = p_name.map_or(ptr::null(), |r| r.as_ptr());
        self
    }
    pub fn index(mut self, index: u32) -> Self {
        self.inner.index = index;
        self
    }
}
impl<'a> Deref for PipelineShaderStageNodeCreateInfoAMDXBuilder<'a> {
    type Target = vk::PipelineShaderStageNodeCreateInfoAMDX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PipelineShaderStageCreateInfoNext for vk::PipelineShaderStageNodeCreateInfoAMDX {}
impl PipelineShaderStageCreateInfoNext for PipelineShaderStageNodeCreateInfoAMDXBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExecutionGraphPipelineScratchSizeAMDXBuilder {
    inner: vk::ExecutionGraphPipelineScratchSizeAMDX,
}
impl Builder<'_> for vk::ExecutionGraphPipelineScratchSizeAMDX {
    type Type = ExecutionGraphPipelineScratchSizeAMDXBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExecutionGraphPipelineScratchSizeAMDXBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExecutionGraphPipelineScratchSizeAMDX {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn min_size(mut self, min_size: vk::DeviceSize) -> Self {
        self.inner.min_size = min_size;
        self
    }
    pub fn max_size(mut self, max_size: vk::DeviceSize) -> Self {
        self.inner.max_size = max_size;
        self
    }
    pub fn size_granularity(mut self, size_granularity: vk::DeviceSize) -> Self {
        self.inner.size_granularity = size_granularity;
        self
    }
}
impl Deref for ExecutionGraphPipelineScratchSizeAMDXBuilder {
    type Target = vk::ExecutionGraphPipelineScratchSizeAMDX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DispatchGraphInfoAMDXBuilder {
    inner: vk::DispatchGraphInfoAMDX,
}
impl Builder<'_> for vk::DispatchGraphInfoAMDX {
    type Type = DispatchGraphInfoAMDXBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DispatchGraphInfoAMDXBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DispatchGraphInfoAMDX {
        &mut self.inner
    }
    pub fn node_index(mut self, node_index: u32) -> Self {
        self.inner.node_index = node_index;
        self
    }
    pub fn payload_count(mut self, payload_count: u32) -> Self {
        self.inner.payload_count = payload_count;
        self
    }
    pub fn payloads(mut self, payloads: vk::DeviceOrHostAddressConstAMDX) -> Self {
        self.inner.payloads = payloads;
        self
    }
    pub fn payload_stride(mut self, payload_stride: u64) -> Self {
        self.inner.payload_stride = payload_stride;
        self
    }
}
impl Deref for DispatchGraphInfoAMDXBuilder {
    type Target = vk::DispatchGraphInfoAMDX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DispatchGraphCountInfoAMDXBuilder {
    inner: vk::DispatchGraphCountInfoAMDX,
}
impl Builder<'_> for vk::DispatchGraphCountInfoAMDX {
    type Type = DispatchGraphCountInfoAMDXBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DispatchGraphCountInfoAMDXBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DispatchGraphCountInfoAMDX {
        &mut self.inner
    }
    pub fn count(mut self, count: u32) -> Self {
        self.inner.count = count;
        self
    }
    pub fn infos(mut self, infos: vk::DeviceOrHostAddressConstAMDX) -> Self {
        self.inner.infos = infos;
        self
    }
    pub fn stride(mut self, stride: u64) -> Self {
        self.inner.stride = stride;
        self
    }
}
impl Deref for DispatchGraphCountInfoAMDXBuilder {
    type Target = vk::DispatchGraphCountInfoAMDX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceAntiLagFeaturesAMDBuilder {
    inner: vk::PhysicalDeviceAntiLagFeaturesAMD,
}
impl Builder<'_> for vk::PhysicalDeviceAntiLagFeaturesAMD {
    type Type = PhysicalDeviceAntiLagFeaturesAMDBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceAntiLagFeaturesAMDBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceAntiLagFeaturesAMD {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn anti_lag(mut self, anti_lag: bool) -> Self {
        self.inner.anti_lag = if anti_lag { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceAntiLagFeaturesAMDBuilder {
    type Target = vk::PhysicalDeviceAntiLagFeaturesAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceAntiLagFeaturesAMD {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceAntiLagFeaturesAMDBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceAntiLagFeaturesAMD {}
impl DeviceCreateInfoNext for PhysicalDeviceAntiLagFeaturesAMDBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct AntiLagDataAMDBuilder<'a> {
    inner: vk::AntiLagDataAMD,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AntiLagDataAMD {
    type Type = AntiLagDataAMDBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> AntiLagDataAMDBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::AntiLagDataAMD {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn mode(mut self, mode: vk::AntiLagModeAMD) -> Self {
        self.inner.mode = mode;
        self
    }
    pub fn max_fps(mut self, max_fps: u32) -> Self {
        self.inner.max_fps = max_fps;
        self
    }
    pub fn p_presentation_info(mut self, p_presentation_info: Option<&'a vk::AntiLagPresentationInfoAMD>) -> Self {
        self.inner.p_presentation_info = p_presentation_info.map_or(ptr::null(), |r| r);
        self
    }
}
impl<'a> Deref for AntiLagDataAMDBuilder<'a> {
    type Target = vk::AntiLagDataAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct AntiLagPresentationInfoAMDBuilder {
    inner: vk::AntiLagPresentationInfoAMD,
}
impl Builder<'_> for vk::AntiLagPresentationInfoAMD {
    type Type = AntiLagPresentationInfoAMDBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl AntiLagPresentationInfoAMDBuilder {
    pub fn get_mut(&mut self) -> &mut vk::AntiLagPresentationInfoAMD {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn stage(mut self, stage: vk::AntiLagStageAMD) -> Self {
        self.inner.stage = stage;
        self
    }
    pub fn frame_index(mut self, frame_index: u64) -> Self {
        self.inner.frame_index = frame_index;
        self
    }
}
impl Deref for AntiLagPresentationInfoAMDBuilder {
    type Target = vk::AntiLagPresentationInfoAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BindMemoryStatusBuilder<'a> {
    inner: vk::BindMemoryStatus,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BindMemoryStatus {
    type Type = BindMemoryStatusBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> BindMemoryStatusBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::BindMemoryStatus {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_result(mut self, p_result: *mut vk::Result) -> Self {
        self.inner.p_result = p_result;
        self
    }
}
impl<'a> Deref for BindMemoryStatusBuilder<'a> {
    type Target = vk::BindMemoryStatus;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BindBufferMemoryInfoNext for vk::BindMemoryStatus {}
impl BindBufferMemoryInfoNext for BindMemoryStatusBuilder<'_> {}
impl BindImageMemoryInfoNext for vk::BindMemoryStatus {}
impl BindImageMemoryInfoNext for BindMemoryStatusBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceTileMemoryHeapFeaturesQCOMBuilder {
    inner: vk::PhysicalDeviceTileMemoryHeapFeaturesQCOM,
}
impl Builder<'_> for vk::PhysicalDeviceTileMemoryHeapFeaturesQCOM {
    type Type = PhysicalDeviceTileMemoryHeapFeaturesQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceTileMemoryHeapFeaturesQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceTileMemoryHeapFeaturesQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn tile_memory_heap(mut self, tile_memory_heap: bool) -> Self {
        self.inner.tile_memory_heap = if tile_memory_heap { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceTileMemoryHeapFeaturesQCOMBuilder {
    type Target = vk::PhysicalDeviceTileMemoryHeapFeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceTileMemoryHeapFeaturesQCOM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceTileMemoryHeapFeaturesQCOMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceTileMemoryHeapFeaturesQCOM {}
impl DeviceCreateInfoNext for PhysicalDeviceTileMemoryHeapFeaturesQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceTileMemoryHeapPropertiesQCOMBuilder {
    inner: vk::PhysicalDeviceTileMemoryHeapPropertiesQCOM,
}
impl Builder<'_> for vk::PhysicalDeviceTileMemoryHeapPropertiesQCOM {
    type Type = PhysicalDeviceTileMemoryHeapPropertiesQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceTileMemoryHeapPropertiesQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceTileMemoryHeapPropertiesQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn queue_submit_boundary(mut self, queue_submit_boundary: bool) -> Self {
        self.inner.queue_submit_boundary = if queue_submit_boundary { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn tile_buffer_transfers(mut self, tile_buffer_transfers: bool) -> Self {
        self.inner.tile_buffer_transfers = if tile_buffer_transfers { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceTileMemoryHeapPropertiesQCOMBuilder {
    type Target = vk::PhysicalDeviceTileMemoryHeapPropertiesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceTileMemoryHeapPropertiesQCOM {}
impl PhysicalDeviceProperties2Next for PhysicalDeviceTileMemoryHeapPropertiesQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct TileMemorySizeInfoQCOMBuilder {
    inner: vk::TileMemorySizeInfoQCOM,
}
impl Builder<'_> for vk::TileMemorySizeInfoQCOM {
    type Type = TileMemorySizeInfoQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl TileMemorySizeInfoQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::TileMemorySizeInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
}
impl Deref for TileMemorySizeInfoQCOMBuilder {
    type Target = vk::TileMemorySizeInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderPassCreateInfoNext for vk::TileMemorySizeInfoQCOM {}
impl RenderPassCreateInfoNext for TileMemorySizeInfoQCOMBuilder {}
impl RenderPassCreateInfo2Next for vk::TileMemorySizeInfoQCOM {}
impl RenderPassCreateInfo2Next for TileMemorySizeInfoQCOMBuilder {}
impl RenderingInfoNext for vk::TileMemorySizeInfoQCOM {}
impl RenderingInfoNext for TileMemorySizeInfoQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct TileMemoryRequirementsQCOMBuilder {
    inner: vk::TileMemoryRequirementsQCOM,
}
impl Builder<'_> for vk::TileMemoryRequirementsQCOM {
    type Type = TileMemoryRequirementsQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl TileMemoryRequirementsQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::TileMemoryRequirementsQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn size(mut self, size: vk::DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    pub fn alignment(mut self, alignment: vk::DeviceSize) -> Self {
        self.inner.alignment = alignment;
        self
    }
}
impl Deref for TileMemoryRequirementsQCOMBuilder {
    type Target = vk::TileMemoryRequirementsQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryRequirements2Next for vk::TileMemoryRequirementsQCOM {}
impl MemoryRequirements2Next for TileMemoryRequirementsQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct BindDescriptorSetsInfoBuilder<'a> {
    inner: vk::BindDescriptorSetsInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BindDescriptorSetsInfo {
    type Type = BindDescriptorSetsInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait BindDescriptorSetsInfoNext {}
impl<'a> BindDescriptorSetsInfoBuilder<'a> {
    pub fn insert_next<T: BindDescriptorSetsInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::BindDescriptorSetsInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn stage_flags(mut self, stage_flags: vk::ShaderStageFlags) -> Self {
        self.inner.stage_flags = stage_flags;
        self
    }
    pub fn layout(mut self, layout: vk::PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    pub fn first_set(mut self, first_set: u32) -> Self {
        self.inner.first_set = first_set;
        self
    }
    pub fn p_descriptor_sets(mut self, p_descriptor_sets: &'a [vk::DescriptorSet]) -> Self {
        self.inner.descriptor_set_count = p_descriptor_sets.len() as u32;
        self.inner.p_descriptor_sets = p_descriptor_sets.as_ptr();
        self
    }
    pub fn p_dynamic_offsets(mut self, p_dynamic_offsets: &'a [u32]) -> Self {
        self.inner.dynamic_offset_count = p_dynamic_offsets.len() as u32;
        self.inner.p_dynamic_offsets = p_dynamic_offsets.as_ptr();
        self
    }
}
impl<'a> Deref for BindDescriptorSetsInfoBuilder<'a> {
    type Target = vk::BindDescriptorSetsInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PushConstantsInfoBuilder<'a> {
    inner: vk::PushConstantsInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PushConstantsInfo {
    type Type = PushConstantsInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PushConstantsInfoNext {}
impl<'a> PushConstantsInfoBuilder<'a> {
    pub fn insert_next<T: PushConstantsInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PushConstantsInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn layout(mut self, layout: vk::PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    pub fn stage_flags(mut self, stage_flags: vk::ShaderStageFlags) -> Self {
        self.inner.stage_flags = stage_flags;
        self
    }
    pub fn offset(mut self, offset: u32) -> Self {
        self.inner.offset = offset;
        self
    }
    pub fn p_values(mut self, p_values: &'a [u8]) -> Self {
        self.inner.size = p_values.len() as u32;
        self.inner.p_values = p_values.as_ptr() as *const _;
        self
    }
}
impl<'a> Deref for PushConstantsInfoBuilder<'a> {
    type Target = vk::PushConstantsInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PushDescriptorSetInfoBuilder<'a> {
    inner: vk::PushDescriptorSetInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PushDescriptorSetInfo {
    type Type = PushDescriptorSetInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PushDescriptorSetInfoNext {}
impl<'a> PushDescriptorSetInfoBuilder<'a> {
    pub fn insert_next<T: PushDescriptorSetInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PushDescriptorSetInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn stage_flags(mut self, stage_flags: vk::ShaderStageFlags) -> Self {
        self.inner.stage_flags = stage_flags;
        self
    }
    pub fn layout(mut self, layout: vk::PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    pub fn set(mut self, set: u32) -> Self {
        self.inner.set = set;
        self
    }
    pub fn p_descriptor_writes(mut self, p_descriptor_writes: &'a [vk::WriteDescriptorSet]) -> Self {
        self.inner.descriptor_write_count = p_descriptor_writes.len() as u32;
        self.inner.p_descriptor_writes = p_descriptor_writes.as_ptr();
        self
    }
}
impl<'a> Deref for PushDescriptorSetInfoBuilder<'a> {
    type Target = vk::PushDescriptorSetInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PushDescriptorSetWithTemplateInfoBuilder<'a> {
    inner: vk::PushDescriptorSetWithTemplateInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PushDescriptorSetWithTemplateInfo {
    type Type = PushDescriptorSetWithTemplateInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait PushDescriptorSetWithTemplateInfoNext {}
impl<'a> PushDescriptorSetWithTemplateInfoBuilder<'a> {
    pub fn insert_next<T: PushDescriptorSetWithTemplateInfoNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::PushDescriptorSetWithTemplateInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn descriptor_update_template(mut self, descriptor_update_template: vk::DescriptorUpdateTemplate) -> Self {
        self.inner.descriptor_update_template = descriptor_update_template;
        self
    }
    pub fn layout(mut self, layout: vk::PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    pub fn set(mut self, set: u32) -> Self {
        self.inner.set = set;
        self
    }
    pub fn p_data(mut self, p_data: *const c_void) -> Self {
        self.inner.p_data = p_data;
        self
    }
}
impl<'a> Deref for PushDescriptorSetWithTemplateInfoBuilder<'a> {
    type Target = vk::PushDescriptorSetWithTemplateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SetDescriptorBufferOffsetsInfoEXTBuilder<'a> {
    inner: vk::SetDescriptorBufferOffsetsInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SetDescriptorBufferOffsetsInfoEXT {
    type Type = SetDescriptorBufferOffsetsInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait SetDescriptorBufferOffsetsInfoEXTNext {}
impl<'a> SetDescriptorBufferOffsetsInfoEXTBuilder<'a> {
    pub fn insert_next<T: SetDescriptorBufferOffsetsInfoEXTNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::SetDescriptorBufferOffsetsInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn stage_flags(mut self, stage_flags: vk::ShaderStageFlags) -> Self {
        self.inner.stage_flags = stage_flags;
        self
    }
    pub fn layout(mut self, layout: vk::PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    pub fn first_set(mut self, first_set: u32) -> Self {
        self.inner.first_set = first_set;
        self
    }
    pub fn p_buffer_indices(mut self, p_buffer_indices: &'a [u32], p_offsets: &'a [vk::DeviceSize]) -> Self {
        self.inner.set_count = p_buffer_indices.len() as u32;
        assert_eq!(self.inner.set_count, p_offsets.len() as u32);
        self.inner.p_buffer_indices = p_buffer_indices.as_ptr();
        self.inner.p_offsets = p_offsets.as_ptr();
        self
    }
}
impl<'a> Deref for SetDescriptorBufferOffsetsInfoEXTBuilder<'a> {
    type Target = vk::SetDescriptorBufferOffsetsInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BindDescriptorBufferEmbeddedSamplersInfoEXTBuilder<'a> {
    inner: vk::BindDescriptorBufferEmbeddedSamplersInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::BindDescriptorBufferEmbeddedSamplersInfoEXT {
    type Type = BindDescriptorBufferEmbeddedSamplersInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait BindDescriptorBufferEmbeddedSamplersInfoEXTNext {}
impl<'a> BindDescriptorBufferEmbeddedSamplersInfoEXTBuilder<'a> {
    pub fn insert_next<T: BindDescriptorBufferEmbeddedSamplersInfoEXTNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::BindDescriptorBufferEmbeddedSamplersInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn stage_flags(mut self, stage_flags: vk::ShaderStageFlags) -> Self {
        self.inner.stage_flags = stage_flags;
        self
    }
    pub fn layout(mut self, layout: vk::PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    pub fn set(mut self, set: u32) -> Self {
        self.inner.set = set;
        self
    }
}
impl<'a> Deref for BindDescriptorBufferEmbeddedSamplersInfoEXTBuilder<'a> {
    type Target = vk::BindDescriptorBufferEmbeddedSamplersInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceCubicClampFeaturesQCOMBuilder {
    inner: vk::PhysicalDeviceCubicClampFeaturesQCOM,
}
impl Builder<'_> for vk::PhysicalDeviceCubicClampFeaturesQCOM {
    type Type = PhysicalDeviceCubicClampFeaturesQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceCubicClampFeaturesQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceCubicClampFeaturesQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn cubic_range_clamp(mut self, cubic_range_clamp: bool) -> Self {
        self.inner.cubic_range_clamp = if cubic_range_clamp { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceCubicClampFeaturesQCOMBuilder {
    type Target = vk::PhysicalDeviceCubicClampFeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceCubicClampFeaturesQCOM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceCubicClampFeaturesQCOMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceCubicClampFeaturesQCOM {}
impl DeviceCreateInfoNext for PhysicalDeviceCubicClampFeaturesQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceYcbcrDegammaFeaturesQCOMBuilder {
    inner: vk::PhysicalDeviceYcbcrDegammaFeaturesQCOM,
}
impl Builder<'_> for vk::PhysicalDeviceYcbcrDegammaFeaturesQCOM {
    type Type = PhysicalDeviceYcbcrDegammaFeaturesQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceYcbcrDegammaFeaturesQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceYcbcrDegammaFeaturesQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn ycbcr_degamma(mut self, ycbcr_degamma: bool) -> Self {
        self.inner.ycbcr_degamma = if ycbcr_degamma { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceYcbcrDegammaFeaturesQCOMBuilder {
    type Target = vk::PhysicalDeviceYcbcrDegammaFeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceYcbcrDegammaFeaturesQCOM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceYcbcrDegammaFeaturesQCOMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceYcbcrDegammaFeaturesQCOM {}
impl DeviceCreateInfoNext for PhysicalDeviceYcbcrDegammaFeaturesQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOMBuilder {
    inner: vk::SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM,
}
impl Builder<'_> for vk::SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM {
    type Type = SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn enable_y_degamma(mut self, enable_y_degamma: bool) -> Self {
        self.inner.enable_y_degamma = if enable_y_degamma { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn enable_cb_cr_degamma(mut self, enable_cb_cr_degamma: bool) -> Self {
        self.inner.enable_cb_cr_degamma = if enable_cb_cr_degamma { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOMBuilder {
    type Target = vk::SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SamplerYcbcrConversionCreateInfoNext for vk::SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM {}
impl SamplerYcbcrConversionCreateInfoNext for SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceCubicWeightsFeaturesQCOMBuilder {
    inner: vk::PhysicalDeviceCubicWeightsFeaturesQCOM,
}
impl Builder<'_> for vk::PhysicalDeviceCubicWeightsFeaturesQCOM {
    type Type = PhysicalDeviceCubicWeightsFeaturesQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceCubicWeightsFeaturesQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceCubicWeightsFeaturesQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn selectable_cubic_weights(mut self, selectable_cubic_weights: bool) -> Self {
        self.inner.selectable_cubic_weights = if selectable_cubic_weights { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceCubicWeightsFeaturesQCOMBuilder {
    type Target = vk::PhysicalDeviceCubicWeightsFeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceCubicWeightsFeaturesQCOM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceCubicWeightsFeaturesQCOMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceCubicWeightsFeaturesQCOM {}
impl DeviceCreateInfoNext for PhysicalDeviceCubicWeightsFeaturesQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SamplerCubicWeightsCreateInfoQCOMBuilder {
    inner: vk::SamplerCubicWeightsCreateInfoQCOM,
}
impl Builder<'_> for vk::SamplerCubicWeightsCreateInfoQCOM {
    type Type = SamplerCubicWeightsCreateInfoQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SamplerCubicWeightsCreateInfoQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SamplerCubicWeightsCreateInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn cubic_weights(mut self, cubic_weights: vk::CubicFilterWeightsQCOM) -> Self {
        self.inner.cubic_weights = cubic_weights;
        self
    }
}
impl Deref for SamplerCubicWeightsCreateInfoQCOMBuilder {
    type Target = vk::SamplerCubicWeightsCreateInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SamplerCreateInfoNext for vk::SamplerCubicWeightsCreateInfoQCOM {}
impl SamplerCreateInfoNext for SamplerCubicWeightsCreateInfoQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct BlitImageCubicWeightsInfoQCOMBuilder {
    inner: vk::BlitImageCubicWeightsInfoQCOM,
}
impl Builder<'_> for vk::BlitImageCubicWeightsInfoQCOM {
    type Type = BlitImageCubicWeightsInfoQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BlitImageCubicWeightsInfoQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BlitImageCubicWeightsInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn cubic_weights(mut self, cubic_weights: vk::CubicFilterWeightsQCOM) -> Self {
        self.inner.cubic_weights = cubic_weights;
        self
    }
}
impl Deref for BlitImageCubicWeightsInfoQCOMBuilder {
    type Target = vk::BlitImageCubicWeightsInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl BlitImageInfo2Next for vk::BlitImageCubicWeightsInfoQCOM {}
impl BlitImageInfo2Next for BlitImageCubicWeightsInfoQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceImageProcessing2FeaturesQCOMBuilder {
    inner: vk::PhysicalDeviceImageProcessing2FeaturesQCOM,
}
impl Builder<'_> for vk::PhysicalDeviceImageProcessing2FeaturesQCOM {
    type Type = PhysicalDeviceImageProcessing2FeaturesQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceImageProcessing2FeaturesQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceImageProcessing2FeaturesQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn texture_block_match2(mut self, texture_block_match2: bool) -> Self {
        self.inner.texture_block_match2 = if texture_block_match2 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceImageProcessing2FeaturesQCOMBuilder {
    type Target = vk::PhysicalDeviceImageProcessing2FeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceImageProcessing2FeaturesQCOM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceImageProcessing2FeaturesQCOMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceImageProcessing2FeaturesQCOM {}
impl DeviceCreateInfoNext for PhysicalDeviceImageProcessing2FeaturesQCOMBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceImageProcessing2PropertiesQCOM {}

#[repr(transparent)]
#[derive(Default)]
pub struct SamplerBlockMatchWindowCreateInfoQCOMBuilder {
    inner: vk::SamplerBlockMatchWindowCreateInfoQCOM,
}
impl Builder<'_> for vk::SamplerBlockMatchWindowCreateInfoQCOM {
    type Type = SamplerBlockMatchWindowCreateInfoQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SamplerBlockMatchWindowCreateInfoQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SamplerBlockMatchWindowCreateInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn window_extent(mut self, window_extent: vk::Extent2D) -> Self {
        self.inner.window_extent = window_extent;
        self
    }
    pub fn window_compare_mode(mut self, window_compare_mode: vk::BlockMatchWindowCompareModeQCOM) -> Self {
        self.inner.window_compare_mode = window_compare_mode;
        self
    }
}
impl Deref for SamplerBlockMatchWindowCreateInfoQCOMBuilder {
    type Target = vk::SamplerBlockMatchWindowCreateInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SamplerCreateInfoNext for vk::SamplerBlockMatchWindowCreateInfoQCOM {}
impl SamplerCreateInfoNext for SamplerBlockMatchWindowCreateInfoQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDescriptorPoolOverallocationFeaturesNVBuilder {
    inner: vk::PhysicalDeviceDescriptorPoolOverallocationFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceDescriptorPoolOverallocationFeaturesNV {
    type Type = PhysicalDeviceDescriptorPoolOverallocationFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDescriptorPoolOverallocationFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDescriptorPoolOverallocationFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn descriptor_pool_overallocation(mut self, descriptor_pool_overallocation: bool) -> Self {
        self.inner.descriptor_pool_overallocation = if descriptor_pool_overallocation {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceDescriptorPoolOverallocationFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceDescriptorPoolOverallocationFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDescriptorPoolOverallocationFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDescriptorPoolOverallocationFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDescriptorPoolOverallocationFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceDescriptorPoolOverallocationFeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceLayeredDriverPropertiesMSFT {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePerStageDescriptorSetFeaturesNVBuilder {
    inner: vk::PhysicalDevicePerStageDescriptorSetFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDevicePerStageDescriptorSetFeaturesNV {
    type Type = PhysicalDevicePerStageDescriptorSetFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePerStageDescriptorSetFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePerStageDescriptorSetFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn per_stage_descriptor_set(mut self, per_stage_descriptor_set: bool) -> Self {
        self.inner.per_stage_descriptor_set = if per_stage_descriptor_set { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn dynamic_pipeline_layout(mut self, dynamic_pipeline_layout: bool) -> Self {
        self.inner.dynamic_pipeline_layout = if dynamic_pipeline_layout { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevicePerStageDescriptorSetFeaturesNVBuilder {
    type Target = vk::PhysicalDevicePerStageDescriptorSetFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePerStageDescriptorSetFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePerStageDescriptorSetFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePerStageDescriptorSetFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDevicePerStageDescriptorSetFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceExternalFormatResolveFeaturesANDROIDBuilder {
    inner: vk::PhysicalDeviceExternalFormatResolveFeaturesANDROID,
}
impl Builder<'_> for vk::PhysicalDeviceExternalFormatResolveFeaturesANDROID {
    type Type = PhysicalDeviceExternalFormatResolveFeaturesANDROIDBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceExternalFormatResolveFeaturesANDROIDBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceExternalFormatResolveFeaturesANDROID {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn external_format_resolve(mut self, external_format_resolve: bool) -> Self {
        self.inner.external_format_resolve = if external_format_resolve { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceExternalFormatResolveFeaturesANDROIDBuilder {
    type Target = vk::PhysicalDeviceExternalFormatResolveFeaturesANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceExternalFormatResolveFeaturesANDROID {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceExternalFormatResolveFeaturesANDROIDBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceExternalFormatResolveFeaturesANDROID {}
impl DeviceCreateInfoNext for PhysicalDeviceExternalFormatResolveFeaturesANDROIDBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceExternalFormatResolvePropertiesANDROID {}
impl AndroidHardwareBufferPropertiesANDROIDNext for vk::AndroidHardwareBufferFormatResolvePropertiesANDROID {}

#[repr(transparent)]
#[derive(Default)]
pub struct LatencySleepModeInfoNVBuilder {
    inner: vk::LatencySleepModeInfoNV,
}
impl Builder<'_> for vk::LatencySleepModeInfoNV {
    type Type = LatencySleepModeInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl LatencySleepModeInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::LatencySleepModeInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn low_latency_mode(mut self, low_latency_mode: bool) -> Self {
        self.inner.low_latency_mode = if low_latency_mode { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn low_latency_boost(mut self, low_latency_boost: bool) -> Self {
        self.inner.low_latency_boost = if low_latency_boost { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn minimum_interval_us(mut self, minimum_interval_us: u32) -> Self {
        self.inner.minimum_interval_us = minimum_interval_us;
        self
    }
}
impl Deref for LatencySleepModeInfoNVBuilder {
    type Target = vk::LatencySleepModeInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct LatencySleepInfoNVBuilder {
    inner: vk::LatencySleepInfoNV,
}
impl Builder<'_> for vk::LatencySleepInfoNV {
    type Type = LatencySleepInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl LatencySleepInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::LatencySleepInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn signal_semaphore(mut self, signal_semaphore: vk::Semaphore) -> Self {
        self.inner.signal_semaphore = signal_semaphore;
        self
    }
    pub fn value(mut self, value: u64) -> Self {
        self.inner.value = value;
        self
    }
}
impl Deref for LatencySleepInfoNVBuilder {
    type Target = vk::LatencySleepInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct SetLatencyMarkerInfoNVBuilder {
    inner: vk::SetLatencyMarkerInfoNV,
}
impl Builder<'_> for vk::SetLatencyMarkerInfoNV {
    type Type = SetLatencyMarkerInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SetLatencyMarkerInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SetLatencyMarkerInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn present_id(mut self, present_id: u64) -> Self {
        self.inner.present_id = present_id;
        self
    }
    pub fn marker(mut self, marker: vk::LatencyMarkerNV) -> Self {
        self.inner.marker = marker;
        self
    }
}
impl Deref for SetLatencyMarkerInfoNVBuilder {
    type Target = vk::SetLatencyMarkerInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct GetLatencyMarkerInfoNVBuilder<'a> {
    inner: vk::GetLatencyMarkerInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::GetLatencyMarkerInfoNV {
    type Type = GetLatencyMarkerInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> GetLatencyMarkerInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::GetLatencyMarkerInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_timings(mut self, p_timings: &'a mut [vk::LatencyTimingsFrameReportNV]) -> Self {
        self.inner.timing_count = p_timings.len() as u32;
        self.inner.p_timings = p_timings.as_mut_ptr();
        self
    }
}
impl<'a> Deref for GetLatencyMarkerInfoNVBuilder<'a> {
    type Target = vk::GetLatencyMarkerInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct OutOfBandQueueTypeInfoNVBuilder {
    inner: vk::OutOfBandQueueTypeInfoNV,
}
impl Builder<'_> for vk::OutOfBandQueueTypeInfoNV {
    type Type = OutOfBandQueueTypeInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl OutOfBandQueueTypeInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::OutOfBandQueueTypeInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn queue_type(mut self, queue_type: vk::OutOfBandQueueTypeNV) -> Self {
        self.inner.queue_type = queue_type;
        self
    }
}
impl Deref for OutOfBandQueueTypeInfoNVBuilder {
    type Target = vk::OutOfBandQueueTypeInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct LatencySubmissionPresentIdNVBuilder {
    inner: vk::LatencySubmissionPresentIdNV,
}
impl Builder<'_> for vk::LatencySubmissionPresentIdNV {
    type Type = LatencySubmissionPresentIdNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl LatencySubmissionPresentIdNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::LatencySubmissionPresentIdNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn present_id(mut self, present_id: u64) -> Self {
        self.inner.present_id = present_id;
        self
    }
}
impl Deref for LatencySubmissionPresentIdNVBuilder {
    type Target = vk::LatencySubmissionPresentIdNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubmitInfoNext for vk::LatencySubmissionPresentIdNV {}
impl SubmitInfoNext for LatencySubmissionPresentIdNVBuilder {}
impl SubmitInfo2Next for vk::LatencySubmissionPresentIdNV {}
impl SubmitInfo2Next for LatencySubmissionPresentIdNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SwapchainLatencyCreateInfoNVBuilder {
    inner: vk::SwapchainLatencyCreateInfoNV,
}
impl Builder<'_> for vk::SwapchainLatencyCreateInfoNV {
    type Type = SwapchainLatencyCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SwapchainLatencyCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SwapchainLatencyCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn latency_mode_enable(mut self, latency_mode_enable: bool) -> Self {
        self.inner.latency_mode_enable = if latency_mode_enable { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for SwapchainLatencyCreateInfoNVBuilder {
    type Target = vk::SwapchainLatencyCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SwapchainCreateInfoKHRNext for vk::SwapchainLatencyCreateInfoNV {}
impl SwapchainCreateInfoKHRNext for SwapchainLatencyCreateInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct LatencySurfaceCapabilitiesNVBuilder<'a> {
    inner: vk::LatencySurfaceCapabilitiesNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::LatencySurfaceCapabilitiesNV {
    type Type = LatencySurfaceCapabilitiesNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> LatencySurfaceCapabilitiesNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::LatencySurfaceCapabilitiesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_present_modes(mut self, p_present_modes: &'a mut [vk::PresentModeKHR]) -> Self {
        self.inner.present_mode_count = p_present_modes.len() as u32;
        self.inner.p_present_modes = p_present_modes.as_mut_ptr();
        self
    }
}
impl<'a> Deref for LatencySurfaceCapabilitiesNVBuilder<'a> {
    type Target = vk::LatencySurfaceCapabilitiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SurfaceCapabilities2KHRNext for vk::LatencySurfaceCapabilitiesNV {}
impl SurfaceCapabilities2KHRNext for LatencySurfaceCapabilitiesNVBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceCudaKernelLaunchFeaturesNVBuilder {
    inner: vk::PhysicalDeviceCudaKernelLaunchFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceCudaKernelLaunchFeaturesNV {
    type Type = PhysicalDeviceCudaKernelLaunchFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceCudaKernelLaunchFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceCudaKernelLaunchFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn cuda_kernel_launch_features(mut self, cuda_kernel_launch_features: bool) -> Self {
        self.inner.cuda_kernel_launch_features = if cuda_kernel_launch_features {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceCudaKernelLaunchFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceCudaKernelLaunchFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceCudaKernelLaunchFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceCudaKernelLaunchFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceCudaKernelLaunchFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceCudaKernelLaunchFeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceCudaKernelLaunchPropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceQueueShaderCoreControlCreateInfoARMBuilder {
    inner: vk::DeviceQueueShaderCoreControlCreateInfoARM,
}
impl Builder<'_> for vk::DeviceQueueShaderCoreControlCreateInfoARM {
    type Type = DeviceQueueShaderCoreControlCreateInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DeviceQueueShaderCoreControlCreateInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DeviceQueueShaderCoreControlCreateInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_core_count(mut self, shader_core_count: u32) -> Self {
        self.inner.shader_core_count = shader_core_count;
        self
    }
}
impl Deref for DeviceQueueShaderCoreControlCreateInfoARMBuilder {
    type Target = vk::DeviceQueueShaderCoreControlCreateInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DeviceQueueCreateInfoNext for vk::DeviceQueueShaderCoreControlCreateInfoARM {}
impl DeviceQueueCreateInfoNext for DeviceQueueShaderCoreControlCreateInfoARMBuilder {}
impl DeviceCreateInfoNext for vk::DeviceQueueShaderCoreControlCreateInfoARM {}
impl DeviceCreateInfoNext for DeviceQueueShaderCoreControlCreateInfoARMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceSchedulingControlsFeaturesARMBuilder {
    inner: vk::PhysicalDeviceSchedulingControlsFeaturesARM,
}
impl Builder<'_> for vk::PhysicalDeviceSchedulingControlsFeaturesARM {
    type Type = PhysicalDeviceSchedulingControlsFeaturesARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceSchedulingControlsFeaturesARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceSchedulingControlsFeaturesARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn scheduling_controls(mut self, scheduling_controls: bool) -> Self {
        self.inner.scheduling_controls = if scheduling_controls { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceSchedulingControlsFeaturesARMBuilder {
    type Target = vk::PhysicalDeviceSchedulingControlsFeaturesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceSchedulingControlsFeaturesARM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceSchedulingControlsFeaturesARMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceSchedulingControlsFeaturesARM {}
impl DeviceCreateInfoNext for PhysicalDeviceSchedulingControlsFeaturesARMBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceSchedulingControlsPropertiesARM {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRelaxedLineRasterizationFeaturesIMGBuilder {
    inner: vk::PhysicalDeviceRelaxedLineRasterizationFeaturesIMG,
}
impl Builder<'_> for vk::PhysicalDeviceRelaxedLineRasterizationFeaturesIMG {
    type Type = PhysicalDeviceRelaxedLineRasterizationFeaturesIMGBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRelaxedLineRasterizationFeaturesIMGBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRelaxedLineRasterizationFeaturesIMG {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn relaxed_line_rasterization(mut self, relaxed_line_rasterization: bool) -> Self {
        self.inner.relaxed_line_rasterization = if relaxed_line_rasterization {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceRelaxedLineRasterizationFeaturesIMGBuilder {
    type Target = vk::PhysicalDeviceRelaxedLineRasterizationFeaturesIMG;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRelaxedLineRasterizationFeaturesIMG {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRelaxedLineRasterizationFeaturesIMGBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRelaxedLineRasterizationFeaturesIMG {}
impl DeviceCreateInfoNext for PhysicalDeviceRelaxedLineRasterizationFeaturesIMGBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRenderPassStripedFeaturesARMBuilder {
    inner: vk::PhysicalDeviceRenderPassStripedFeaturesARM,
}
impl Builder<'_> for vk::PhysicalDeviceRenderPassStripedFeaturesARM {
    type Type = PhysicalDeviceRenderPassStripedFeaturesARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRenderPassStripedFeaturesARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRenderPassStripedFeaturesARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn render_pass_striped(mut self, render_pass_striped: bool) -> Self {
        self.inner.render_pass_striped = if render_pass_striped { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceRenderPassStripedFeaturesARMBuilder {
    type Target = vk::PhysicalDeviceRenderPassStripedFeaturesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRenderPassStripedFeaturesARM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRenderPassStripedFeaturesARMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRenderPassStripedFeaturesARM {}
impl DeviceCreateInfoNext for PhysicalDeviceRenderPassStripedFeaturesARMBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceRenderPassStripedPropertiesARM {}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassStripeInfoARMBuilder {
    inner: vk::RenderPassStripeInfoARM,
}
impl Builder<'_> for vk::RenderPassStripeInfoARM {
    type Type = RenderPassStripeInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl RenderPassStripeInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::RenderPassStripeInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn stripe_area(mut self, stripe_area: vk::Rect2D) -> Self {
        self.inner.stripe_area = stripe_area;
        self
    }
}
impl Deref for RenderPassStripeInfoARMBuilder {
    type Target = vk::RenderPassStripeInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassStripeBeginInfoARMBuilder<'a> {
    inner: vk::RenderPassStripeBeginInfoARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderPassStripeBeginInfoARM {
    type Type = RenderPassStripeBeginInfoARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> RenderPassStripeBeginInfoARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::RenderPassStripeBeginInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_stripe_infos(mut self, p_stripe_infos: &'a [vk::RenderPassStripeInfoARM]) -> Self {
        self.inner.stripe_info_count = p_stripe_infos.len() as u32;
        self.inner.p_stripe_infos = p_stripe_infos.as_ptr();
        self
    }
}
impl<'a> Deref for RenderPassStripeBeginInfoARMBuilder<'a> {
    type Target = vk::RenderPassStripeBeginInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderingInfoNext for vk::RenderPassStripeBeginInfoARM {}
impl RenderingInfoNext for RenderPassStripeBeginInfoARMBuilder<'_> {}
impl RenderPassBeginInfoNext for vk::RenderPassStripeBeginInfoARM {}
impl RenderPassBeginInfoNext for RenderPassStripeBeginInfoARMBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassStripeSubmitInfoARMBuilder<'a> {
    inner: vk::RenderPassStripeSubmitInfoARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderPassStripeSubmitInfoARM {
    type Type = RenderPassStripeSubmitInfoARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> RenderPassStripeSubmitInfoARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::RenderPassStripeSubmitInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_stripe_semaphore_infos(mut self, p_stripe_semaphore_infos: &'a [vk::SemaphoreSubmitInfo]) -> Self {
        self.inner.stripe_semaphore_info_count = p_stripe_semaphore_infos.len() as u32;
        self.inner.p_stripe_semaphore_infos = p_stripe_semaphore_infos.as_ptr();
        self
    }
}
impl<'a> Deref for RenderPassStripeSubmitInfoARMBuilder<'a> {
    type Target = vk::RenderPassStripeSubmitInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl CommandBufferSubmitInfoNext for vk::RenderPassStripeSubmitInfoARM {}
impl CommandBufferSubmitInfoNext for RenderPassStripeSubmitInfoARMBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePipelineOpacityMicromapFeaturesARMBuilder {
    inner: vk::PhysicalDevicePipelineOpacityMicromapFeaturesARM,
}
impl Builder<'_> for vk::PhysicalDevicePipelineOpacityMicromapFeaturesARM {
    type Type = PhysicalDevicePipelineOpacityMicromapFeaturesARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePipelineOpacityMicromapFeaturesARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePipelineOpacityMicromapFeaturesARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline_opacity_micromap(mut self, pipeline_opacity_micromap: bool) -> Self {
        self.inner.pipeline_opacity_micromap = if pipeline_opacity_micromap { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevicePipelineOpacityMicromapFeaturesARMBuilder {
    type Target = vk::PhysicalDevicePipelineOpacityMicromapFeaturesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePipelineOpacityMicromapFeaturesARM {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePipelineOpacityMicromapFeaturesARMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePipelineOpacityMicromapFeaturesARM {}
impl DeviceCreateInfoNext for PhysicalDevicePipelineOpacityMicromapFeaturesARMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderMaximalReconvergenceFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR {
    type Type = PhysicalDeviceShaderMaximalReconvergenceFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderMaximalReconvergenceFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_maximal_reconvergence(mut self, shader_maximal_reconvergence: bool) -> Self {
        self.inner.shader_maximal_reconvergence = if shader_maximal_reconvergence {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderMaximalReconvergenceFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderMaximalReconvergenceFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderMaximalReconvergenceFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderSubgroupRotateFeaturesBuilder {
    inner: vk::PhysicalDeviceShaderSubgroupRotateFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceShaderSubgroupRotateFeatures {
    type Type = PhysicalDeviceShaderSubgroupRotateFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderSubgroupRotateFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderSubgroupRotateFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_subgroup_rotate(mut self, shader_subgroup_rotate: bool) -> Self {
        self.inner.shader_subgroup_rotate = if shader_subgroup_rotate { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_subgroup_rotate_clustered(mut self, shader_subgroup_rotate_clustered: bool) -> Self {
        self.inner.shader_subgroup_rotate_clustered = if shader_subgroup_rotate_clustered {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderSubgroupRotateFeaturesBuilder {
    type Target = vk::PhysicalDeviceShaderSubgroupRotateFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderSubgroupRotateFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderSubgroupRotateFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderSubgroupRotateFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderSubgroupRotateFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderExpectAssumeFeaturesBuilder {
    inner: vk::PhysicalDeviceShaderExpectAssumeFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceShaderExpectAssumeFeatures {
    type Type = PhysicalDeviceShaderExpectAssumeFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderExpectAssumeFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderExpectAssumeFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_expect_assume(mut self, shader_expect_assume: bool) -> Self {
        self.inner.shader_expect_assume = if shader_expect_assume { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceShaderExpectAssumeFeaturesBuilder {
    type Target = vk::PhysicalDeviceShaderExpectAssumeFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderExpectAssumeFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderExpectAssumeFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderExpectAssumeFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderExpectAssumeFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderFloatControls2FeaturesBuilder {
    inner: vk::PhysicalDeviceShaderFloatControls2Features,
}
impl Builder<'_> for vk::PhysicalDeviceShaderFloatControls2Features {
    type Type = PhysicalDeviceShaderFloatControls2FeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderFloatControls2FeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderFloatControls2Features {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_float_controls2(mut self, shader_float_controls2: bool) -> Self {
        self.inner.shader_float_controls2 = if shader_float_controls2 { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceShaderFloatControls2FeaturesBuilder {
    type Target = vk::PhysicalDeviceShaderFloatControls2Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderFloatControls2Features {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderFloatControls2FeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderFloatControls2Features {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderFloatControls2FeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDynamicRenderingLocalReadFeaturesBuilder {
    inner: vk::PhysicalDeviceDynamicRenderingLocalReadFeatures,
}
impl Builder<'_> for vk::PhysicalDeviceDynamicRenderingLocalReadFeatures {
    type Type = PhysicalDeviceDynamicRenderingLocalReadFeaturesBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDynamicRenderingLocalReadFeaturesBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDynamicRenderingLocalReadFeatures {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn dynamic_rendering_local_read(mut self, dynamic_rendering_local_read: bool) -> Self {
        self.inner.dynamic_rendering_local_read = if dynamic_rendering_local_read {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceDynamicRenderingLocalReadFeaturesBuilder {
    type Target = vk::PhysicalDeviceDynamicRenderingLocalReadFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDynamicRenderingLocalReadFeatures {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDynamicRenderingLocalReadFeaturesBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDynamicRenderingLocalReadFeatures {}
impl DeviceCreateInfoNext for PhysicalDeviceDynamicRenderingLocalReadFeaturesBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderingAttachmentLocationInfoBuilder<'a> {
    inner: vk::RenderingAttachmentLocationInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderingAttachmentLocationInfo {
    type Type = RenderingAttachmentLocationInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> RenderingAttachmentLocationInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::RenderingAttachmentLocationInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn color_attachment_count(mut self, color_attachment_count: u32) -> Self {
        self.inner.color_attachment_count = color_attachment_count;
        self
    }
    pub fn p_color_attachment_locations(mut self, p_color_attachment_locations: &'a [u32]) -> Self {
        self.inner.color_attachment_count = p_color_attachment_locations.len() as u32;
        self.inner.p_color_attachment_locations = p_color_attachment_locations.as_ptr();
        self
    }
}
impl<'a> Deref for RenderingAttachmentLocationInfoBuilder<'a> {
    type Target = vk::RenderingAttachmentLocationInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::RenderingAttachmentLocationInfo {}
impl GraphicsPipelineCreateInfoNext for RenderingAttachmentLocationInfoBuilder<'_> {}
impl CommandBufferInheritanceInfoNext for vk::RenderingAttachmentLocationInfo {}
impl CommandBufferInheritanceInfoNext for RenderingAttachmentLocationInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderingInputAttachmentIndexInfoBuilder<'a> {
    inner: vk::RenderingInputAttachmentIndexInfo,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::RenderingInputAttachmentIndexInfo {
    type Type = RenderingInputAttachmentIndexInfoBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> RenderingInputAttachmentIndexInfoBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::RenderingInputAttachmentIndexInfo {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_color_attachment_input_indices(mut self, p_color_attachment_input_indices: &'a [u32]) -> Self {
        self.inner.color_attachment_count = p_color_attachment_input_indices.len() as u32;
        self.inner.p_color_attachment_input_indices = p_color_attachment_input_indices.as_ptr();
        self
    }
    pub fn p_depth_input_attachment_index(mut self, p_depth_input_attachment_index: Option<&'a u32>) -> Self {
        self.inner.p_depth_input_attachment_index = p_depth_input_attachment_index.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_stencil_input_attachment_index(mut self, p_stencil_input_attachment_index: Option<&'a u32>) -> Self {
        self.inner.p_stencil_input_attachment_index = p_stencil_input_attachment_index.map_or(ptr::null(), |r| r);
        self
    }
}
impl<'a> Deref for RenderingInputAttachmentIndexInfoBuilder<'a> {
    type Target = vk::RenderingInputAttachmentIndexInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::RenderingInputAttachmentIndexInfo {}
impl GraphicsPipelineCreateInfoNext for RenderingInputAttachmentIndexInfoBuilder<'_> {}
impl CommandBufferInheritanceInfoNext for vk::RenderingInputAttachmentIndexInfo {}
impl CommandBufferInheritanceInfoNext for RenderingInputAttachmentIndexInfoBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderQuadControlFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceShaderQuadControlFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceShaderQuadControlFeaturesKHR {
    type Type = PhysicalDeviceShaderQuadControlFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderQuadControlFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderQuadControlFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_quad_control(mut self, shader_quad_control: bool) -> Self {
        self.inner.shader_quad_control = if shader_quad_control { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceShaderQuadControlFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceShaderQuadControlFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderQuadControlFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderQuadControlFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderQuadControlFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderQuadControlFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderAtomicFloat16VectorFeaturesNVBuilder {
    inner: vk::PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV {
    type Type = PhysicalDeviceShaderAtomicFloat16VectorFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderAtomicFloat16VectorFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_float16_vector_atomics(mut self, shader_float16_vector_atomics: bool) -> Self {
        self.inner.shader_float16_vector_atomics = if shader_float16_vector_atomics {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderAtomicFloat16VectorFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderAtomicFloat16VectorFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderAtomicFloat16VectorFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceMapMemoryPlacedFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceMapMemoryPlacedFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceMapMemoryPlacedFeaturesEXT {
    type Type = PhysicalDeviceMapMemoryPlacedFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceMapMemoryPlacedFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceMapMemoryPlacedFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn memory_map_placed(mut self, memory_map_placed: bool) -> Self {
        self.inner.memory_map_placed = if memory_map_placed { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn memory_map_range_placed(mut self, memory_map_range_placed: bool) -> Self {
        self.inner.memory_map_range_placed = if memory_map_range_placed { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn memory_unmap_reserve(mut self, memory_unmap_reserve: bool) -> Self {
        self.inner.memory_unmap_reserve = if memory_unmap_reserve { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceMapMemoryPlacedFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceMapMemoryPlacedFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceMapMemoryPlacedFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceMapMemoryPlacedFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceMapMemoryPlacedFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceMapMemoryPlacedFeaturesEXTBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceMapMemoryPlacedPropertiesEXT {}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryMapPlacedInfoEXTBuilder<'a> {
    inner: vk::MemoryMapPlacedInfoEXT,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::MemoryMapPlacedInfoEXT {
    type Type = MemoryMapPlacedInfoEXTBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> MemoryMapPlacedInfoEXTBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::MemoryMapPlacedInfoEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_placed_address(mut self, p_placed_address: *mut c_void) -> Self {
        self.inner.p_placed_address = p_placed_address;
        self
    }
}
impl<'a> Deref for MemoryMapPlacedInfoEXTBuilder<'a> {
    type Target = vk::MemoryMapPlacedInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryMapInfoNext for vk::MemoryMapPlacedInfoEXT {}
impl MemoryMapInfoNext for MemoryMapPlacedInfoEXTBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderBfloat16FeaturesKHRBuilder {
    inner: vk::PhysicalDeviceShaderBfloat16FeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceShaderBfloat16FeaturesKHR {
    type Type = PhysicalDeviceShaderBfloat16FeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderBfloat16FeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderBfloat16FeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_b_float16_type(mut self, shader_b_float16_type: bool) -> Self {
        self.inner.shader_b_float16_type = if shader_b_float16_type { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_b_float16_dot_product(mut self, shader_b_float16_dot_product: bool) -> Self {
        self.inner.shader_b_float16_dot_product = if shader_b_float16_dot_product {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_b_float16_cooperative_matrix(mut self, shader_b_float16_cooperative_matrix: bool) -> Self {
        self.inner.shader_b_float16_cooperative_matrix = if shader_b_float16_cooperative_matrix {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderBfloat16FeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceShaderBfloat16FeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderBfloat16FeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderBfloat16FeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderBfloat16FeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderBfloat16FeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceRawAccessChainsFeaturesNVBuilder {
    inner: vk::PhysicalDeviceRawAccessChainsFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceRawAccessChainsFeaturesNV {
    type Type = PhysicalDeviceRawAccessChainsFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceRawAccessChainsFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceRawAccessChainsFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_raw_access_chains(mut self, shader_raw_access_chains: bool) -> Self {
        self.inner.shader_raw_access_chains = if shader_raw_access_chains { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceRawAccessChainsFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceRawAccessChainsFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceRawAccessChainsFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceRawAccessChainsFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceRawAccessChainsFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceRawAccessChainsFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceCommandBufferInheritanceFeaturesNVBuilder {
    inner: vk::PhysicalDeviceCommandBufferInheritanceFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceCommandBufferInheritanceFeaturesNV {
    type Type = PhysicalDeviceCommandBufferInheritanceFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceCommandBufferInheritanceFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceCommandBufferInheritanceFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn command_buffer_inheritance(mut self, command_buffer_inheritance: bool) -> Self {
        self.inner.command_buffer_inheritance = if command_buffer_inheritance {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceCommandBufferInheritanceFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceCommandBufferInheritanceFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceCommandBufferInheritanceFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceCommandBufferInheritanceFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceCommandBufferInheritanceFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceCommandBufferInheritanceFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceImageAlignmentControlFeaturesMESABuilder {
    inner: vk::PhysicalDeviceImageAlignmentControlFeaturesMESA,
}
impl Builder<'_> for vk::PhysicalDeviceImageAlignmentControlFeaturesMESA {
    type Type = PhysicalDeviceImageAlignmentControlFeaturesMESABuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceImageAlignmentControlFeaturesMESABuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceImageAlignmentControlFeaturesMESA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn image_alignment_control(mut self, image_alignment_control: bool) -> Self {
        self.inner.image_alignment_control = if image_alignment_control { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceImageAlignmentControlFeaturesMESABuilder {
    type Target = vk::PhysicalDeviceImageAlignmentControlFeaturesMESA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceImageAlignmentControlFeaturesMESA {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceImageAlignmentControlFeaturesMESABuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceImageAlignmentControlFeaturesMESA {}
impl DeviceCreateInfoNext for PhysicalDeviceImageAlignmentControlFeaturesMESABuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceImageAlignmentControlPropertiesMESA {}

#[repr(transparent)]
#[derive(Default)]
pub struct ImageAlignmentControlCreateInfoMESABuilder {
    inner: vk::ImageAlignmentControlCreateInfoMESA,
}
impl Builder<'_> for vk::ImageAlignmentControlCreateInfoMESA {
    type Type = ImageAlignmentControlCreateInfoMESABuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ImageAlignmentControlCreateInfoMESABuilder {
    pub fn get_mut(&mut self) -> &mut vk::ImageAlignmentControlCreateInfoMESA {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn maximum_requested_alignment(mut self, maximum_requested_alignment: u32) -> Self {
        self.inner.maximum_requested_alignment = maximum_requested_alignment;
        self
    }
}
impl Deref for ImageAlignmentControlCreateInfoMESABuilder {
    type Target = vk::ImageAlignmentControlCreateInfoMESA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl ImageCreateInfoNext for vk::ImageAlignmentControlCreateInfoMESA {}
impl ImageCreateInfoNext for ImageAlignmentControlCreateInfoMESABuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderReplicatedCompositesFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceShaderReplicatedCompositesFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceShaderReplicatedCompositesFeaturesEXT {
    type Type = PhysicalDeviceShaderReplicatedCompositesFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderReplicatedCompositesFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderReplicatedCompositesFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_replicated_composites(mut self, shader_replicated_composites: bool) -> Self {
        self.inner.shader_replicated_composites = if shader_replicated_composites {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderReplicatedCompositesFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceShaderReplicatedCompositesFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderReplicatedCompositesFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderReplicatedCompositesFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderReplicatedCompositesFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderReplicatedCompositesFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePresentModeFifoLatestReadyFeaturesKHRBuilder {
    inner: vk::PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR {
    type Type = PhysicalDevicePresentModeFifoLatestReadyFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePresentModeFifoLatestReadyFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn present_mode_fifo_latest_ready(mut self, present_mode_fifo_latest_ready: bool) -> Self {
        self.inner.present_mode_fifo_latest_ready = if present_mode_fifo_latest_ready {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDevicePresentModeFifoLatestReadyFeaturesKHRBuilder {
    type Target = vk::PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePresentModeFifoLatestReadyFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDevicePresentModeFifoLatestReadyFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DepthClampRangeEXTBuilder {
    inner: vk::DepthClampRangeEXT,
}
impl Builder<'_> for vk::DepthClampRangeEXT {
    type Type = DepthClampRangeEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DepthClampRangeEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DepthClampRangeEXT {
        &mut self.inner
    }
    pub fn min_depth_clamp(mut self, min_depth_clamp: f32) -> Self {
        self.inner.min_depth_clamp = min_depth_clamp;
        self
    }
    pub fn max_depth_clamp(mut self, max_depth_clamp: f32) -> Self {
        self.inner.max_depth_clamp = max_depth_clamp;
        self
    }
}
impl Deref for DepthClampRangeEXTBuilder {
    type Target = vk::DepthClampRangeEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceCooperativeMatrix2FeaturesNVBuilder {
    inner: vk::PhysicalDeviceCooperativeMatrix2FeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceCooperativeMatrix2FeaturesNV {
    type Type = PhysicalDeviceCooperativeMatrix2FeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceCooperativeMatrix2FeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceCooperativeMatrix2FeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn cooperative_matrix_workgroup_scope(mut self, cooperative_matrix_workgroup_scope: bool) -> Self {
        self.inner.cooperative_matrix_workgroup_scope = if cooperative_matrix_workgroup_scope {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn cooperative_matrix_flexible_dimensions(mut self, cooperative_matrix_flexible_dimensions: bool) -> Self {
        self.inner.cooperative_matrix_flexible_dimensions = if cooperative_matrix_flexible_dimensions {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn cooperative_matrix_reductions(mut self, cooperative_matrix_reductions: bool) -> Self {
        self.inner.cooperative_matrix_reductions = if cooperative_matrix_reductions {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn cooperative_matrix_conversions(mut self, cooperative_matrix_conversions: bool) -> Self {
        self.inner.cooperative_matrix_conversions = if cooperative_matrix_conversions {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn cooperative_matrix_per_element_operations(
        mut self,
        cooperative_matrix_per_element_operations: bool,
    ) -> Self {
        self.inner.cooperative_matrix_per_element_operations = if cooperative_matrix_per_element_operations {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn cooperative_matrix_tensor_addressing(mut self, cooperative_matrix_tensor_addressing: bool) -> Self {
        self.inner.cooperative_matrix_tensor_addressing = if cooperative_matrix_tensor_addressing {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn cooperative_matrix_block_loads(mut self, cooperative_matrix_block_loads: bool) -> Self {
        self.inner.cooperative_matrix_block_loads = if cooperative_matrix_block_loads {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceCooperativeMatrix2FeaturesNVBuilder {
    type Target = vk::PhysicalDeviceCooperativeMatrix2FeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceCooperativeMatrix2FeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceCooperativeMatrix2FeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceCooperativeMatrix2FeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceCooperativeMatrix2FeaturesNVBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceCooperativeMatrix2PropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceHdrVividFeaturesHUAWEIBuilder {
    inner: vk::PhysicalDeviceHdrVividFeaturesHUAWEI,
}
impl Builder<'_> for vk::PhysicalDeviceHdrVividFeaturesHUAWEI {
    type Type = PhysicalDeviceHdrVividFeaturesHUAWEIBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceHdrVividFeaturesHUAWEIBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceHdrVividFeaturesHUAWEI {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn hdr_vivid(mut self, hdr_vivid: bool) -> Self {
        self.inner.hdr_vivid = if hdr_vivid { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceHdrVividFeaturesHUAWEIBuilder {
    type Target = vk::PhysicalDeviceHdrVividFeaturesHUAWEI;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceHdrVividFeaturesHUAWEI {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceHdrVividFeaturesHUAWEIBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceHdrVividFeaturesHUAWEI {}
impl DeviceCreateInfoNext for PhysicalDeviceHdrVividFeaturesHUAWEIBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceVertexAttributeRobustnessFeaturesEXTBuilder {
    inner: vk::PhysicalDeviceVertexAttributeRobustnessFeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceVertexAttributeRobustnessFeaturesEXT {
    type Type = PhysicalDeviceVertexAttributeRobustnessFeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceVertexAttributeRobustnessFeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceVertexAttributeRobustnessFeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn vertex_attribute_robustness(mut self, vertex_attribute_robustness: bool) -> Self {
        self.inner.vertex_attribute_robustness = if vertex_attribute_robustness {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceVertexAttributeRobustnessFeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceVertexAttributeRobustnessFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceVertexAttributeRobustnessFeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceVertexAttributeRobustnessFeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceVertexAttributeRobustnessFeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceVertexAttributeRobustnessFeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDenseGeometryFormatFeaturesAMDXBuilder {
    inner: vk::PhysicalDeviceDenseGeometryFormatFeaturesAMDX,
}
impl Builder<'_> for vk::PhysicalDeviceDenseGeometryFormatFeaturesAMDX {
    type Type = PhysicalDeviceDenseGeometryFormatFeaturesAMDXBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDenseGeometryFormatFeaturesAMDXBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDenseGeometryFormatFeaturesAMDX {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn dense_geometry_format(mut self, dense_geometry_format: bool) -> Self {
        self.inner.dense_geometry_format = if dense_geometry_format { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceDenseGeometryFormatFeaturesAMDXBuilder {
    type Target = vk::PhysicalDeviceDenseGeometryFormatFeaturesAMDX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDenseGeometryFormatFeaturesAMDX {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDenseGeometryFormatFeaturesAMDXBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDenseGeometryFormatFeaturesAMDX {}
impl DeviceCreateInfoNext for PhysicalDeviceDenseGeometryFormatFeaturesAMDXBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct AccelerationStructureDenseGeometryFormatTrianglesDataAMDXBuilder<'a> {
    inner: vk::AccelerationStructureDenseGeometryFormatTrianglesDataAMDX,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::AccelerationStructureDenseGeometryFormatTrianglesDataAMDX {
    type Type = AccelerationStructureDenseGeometryFormatTrianglesDataAMDXBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait AccelerationStructureDenseGeometryFormatTrianglesDataAMDXNext {}
impl<'a> AccelerationStructureDenseGeometryFormatTrianglesDataAMDXBuilder<'a> {
    pub fn insert_next<T: AccelerationStructureDenseGeometryFormatTrianglesDataAMDXNext>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::AccelerationStructureDenseGeometryFormatTrianglesDataAMDX {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn compressed_data(mut self, compressed_data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.compressed_data = compressed_data;
        self
    }
    pub fn data_size(mut self, data_size: vk::DeviceSize) -> Self {
        self.inner.data_size = data_size;
        self
    }
    pub fn num_triangles(mut self, num_triangles: u32) -> Self {
        self.inner.num_triangles = num_triangles;
        self
    }
    pub fn num_vertices(mut self, num_vertices: u32) -> Self {
        self.inner.num_vertices = num_vertices;
        self
    }
    pub fn max_primitive_index(mut self, max_primitive_index: u32) -> Self {
        self.inner.max_primitive_index = max_primitive_index;
        self
    }
    pub fn max_geometry_index(mut self, max_geometry_index: u32) -> Self {
        self.inner.max_geometry_index = max_geometry_index;
        self
    }
    pub fn format(mut self, format: vk::CompressedTriangleFormatAMDX) -> Self {
        self.inner.format = format;
        self
    }
}
impl<'a> Deref for AccelerationStructureDenseGeometryFormatTrianglesDataAMDXBuilder<'a> {
    type Target = vk::AccelerationStructureDenseGeometryFormatTrianglesDataAMDX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl AccelerationStructureGeometryKHRNext for vk::AccelerationStructureDenseGeometryFormatTrianglesDataAMDX {}
impl AccelerationStructureGeometryKHRNext for AccelerationStructureDenseGeometryFormatTrianglesDataAMDXBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDepthClampZeroOneFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceDepthClampZeroOneFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceDepthClampZeroOneFeaturesKHR {
    type Type = PhysicalDeviceDepthClampZeroOneFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDepthClampZeroOneFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDepthClampZeroOneFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn depth_clamp_zero_one(mut self, depth_clamp_zero_one: bool) -> Self {
        self.inner.depth_clamp_zero_one = if depth_clamp_zero_one { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceDepthClampZeroOneFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceDepthClampZeroOneFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDepthClampZeroOneFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDepthClampZeroOneFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDepthClampZeroOneFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceDepthClampZeroOneFeaturesKHRBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceCooperativeVectorFeaturesNVBuilder {
    inner: vk::PhysicalDeviceCooperativeVectorFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDeviceCooperativeVectorFeaturesNV {
    type Type = PhysicalDeviceCooperativeVectorFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceCooperativeVectorFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceCooperativeVectorFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn cooperative_vector(mut self, cooperative_vector: bool) -> Self {
        self.inner.cooperative_vector = if cooperative_vector { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn cooperative_vector_training(mut self, cooperative_vector_training: bool) -> Self {
        self.inner.cooperative_vector_training = if cooperative_vector_training {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceCooperativeVectorFeaturesNVBuilder {
    type Target = vk::PhysicalDeviceCooperativeVectorFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceCooperativeVectorFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceCooperativeVectorFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceCooperativeVectorFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDeviceCooperativeVectorFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct CooperativeVectorPropertiesNVBuilder {
    inner: vk::CooperativeVectorPropertiesNV,
}
impl Builder<'_> for vk::CooperativeVectorPropertiesNV {
    type Type = CooperativeVectorPropertiesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl CooperativeVectorPropertiesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::CooperativeVectorPropertiesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn input_type(mut self, input_type: vk::ComponentTypeKHR) -> Self {
        self.inner.input_type = input_type;
        self
    }
    pub fn input_interpretation(mut self, input_interpretation: vk::ComponentTypeKHR) -> Self {
        self.inner.input_interpretation = input_interpretation;
        self
    }
    pub fn matrix_interpretation(mut self, matrix_interpretation: vk::ComponentTypeKHR) -> Self {
        self.inner.matrix_interpretation = matrix_interpretation;
        self
    }
    pub fn bias_interpretation(mut self, bias_interpretation: vk::ComponentTypeKHR) -> Self {
        self.inner.bias_interpretation = bias_interpretation;
        self
    }
    pub fn result_type(mut self, result_type: vk::ComponentTypeKHR) -> Self {
        self.inner.result_type = result_type;
        self
    }
    pub fn transpose(mut self, transpose: bool) -> Self {
        self.inner.transpose = if transpose { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for CooperativeVectorPropertiesNVBuilder {
    type Target = vk::CooperativeVectorPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceCooperativeVectorPropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct ConvertCooperativeVectorMatrixInfoNVBuilder<'a> {
    inner: vk::ConvertCooperativeVectorMatrixInfoNV,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::ConvertCooperativeVectorMatrixInfoNV {
    type Type = ConvertCooperativeVectorMatrixInfoNVBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> ConvertCooperativeVectorMatrixInfoNVBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::ConvertCooperativeVectorMatrixInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_size(mut self, src_size: usize) -> Self {
        self.inner.src_size = src_size;
        self
    }
    pub fn src_data(mut self, src_data: vk::DeviceOrHostAddressConstKHR) -> Self {
        self.inner.src_data = src_data;
        self
    }
    pub fn p_dst_size(mut self, p_dst_size: *mut usize) -> Self {
        self.inner.p_dst_size = p_dst_size;
        self
    }
    pub fn dst_data(mut self, dst_data: vk::DeviceOrHostAddressKHR) -> Self {
        self.inner.dst_data = dst_data;
        self
    }
    pub fn src_component_type(mut self, src_component_type: vk::ComponentTypeKHR) -> Self {
        self.inner.src_component_type = src_component_type;
        self
    }
    pub fn dst_component_type(mut self, dst_component_type: vk::ComponentTypeKHR) -> Self {
        self.inner.dst_component_type = dst_component_type;
        self
    }
    pub fn num_rows(mut self, num_rows: u32) -> Self {
        self.inner.num_rows = num_rows;
        self
    }
    pub fn num_columns(mut self, num_columns: u32) -> Self {
        self.inner.num_columns = num_columns;
        self
    }
    pub fn src_layout(mut self, src_layout: vk::CooperativeVectorMatrixLayoutNV) -> Self {
        self.inner.src_layout = src_layout;
        self
    }
    pub fn src_stride(mut self, src_stride: usize) -> Self {
        self.inner.src_stride = src_stride;
        self
    }
    pub fn dst_layout(mut self, dst_layout: vk::CooperativeVectorMatrixLayoutNV) -> Self {
        self.inner.dst_layout = dst_layout;
        self
    }
    pub fn dst_stride(mut self, dst_stride: usize) -> Self {
        self.inner.dst_stride = dst_stride;
        self
    }
}
impl<'a> Deref for ConvertCooperativeVectorMatrixInfoNVBuilder<'a> {
    type Target = vk::ConvertCooperativeVectorMatrixInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceTileShadingFeaturesQCOMBuilder {
    inner: vk::PhysicalDeviceTileShadingFeaturesQCOM,
}
impl Builder<'_> for vk::PhysicalDeviceTileShadingFeaturesQCOM {
    type Type = PhysicalDeviceTileShadingFeaturesQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceTileShadingFeaturesQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceTileShadingFeaturesQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn tile_shading(mut self, tile_shading: bool) -> Self {
        self.inner.tile_shading = if tile_shading { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn tile_shading_fragment_stage(mut self, tile_shading_fragment_stage: bool) -> Self {
        self.inner.tile_shading_fragment_stage = if tile_shading_fragment_stage {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn tile_shading_color_attachments(mut self, tile_shading_color_attachments: bool) -> Self {
        self.inner.tile_shading_color_attachments = if tile_shading_color_attachments {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn tile_shading_depth_attachments(mut self, tile_shading_depth_attachments: bool) -> Self {
        self.inner.tile_shading_depth_attachments = if tile_shading_depth_attachments {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn tile_shading_stencil_attachments(mut self, tile_shading_stencil_attachments: bool) -> Self {
        self.inner.tile_shading_stencil_attachments = if tile_shading_stencil_attachments {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn tile_shading_input_attachments(mut self, tile_shading_input_attachments: bool) -> Self {
        self.inner.tile_shading_input_attachments = if tile_shading_input_attachments {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn tile_shading_sampled_attachments(mut self, tile_shading_sampled_attachments: bool) -> Self {
        self.inner.tile_shading_sampled_attachments = if tile_shading_sampled_attachments {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn tile_shading_per_tile_draw(mut self, tile_shading_per_tile_draw: bool) -> Self {
        self.inner.tile_shading_per_tile_draw = if tile_shading_per_tile_draw {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn tile_shading_per_tile_dispatch(mut self, tile_shading_per_tile_dispatch: bool) -> Self {
        self.inner.tile_shading_per_tile_dispatch = if tile_shading_per_tile_dispatch {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn tile_shading_dispatch_tile(mut self, tile_shading_dispatch_tile: bool) -> Self {
        self.inner.tile_shading_dispatch_tile = if tile_shading_dispatch_tile {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn tile_shading_apron(mut self, tile_shading_apron: bool) -> Self {
        self.inner.tile_shading_apron = if tile_shading_apron { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn tile_shading_anisotropic_apron(mut self, tile_shading_anisotropic_apron: bool) -> Self {
        self.inner.tile_shading_anisotropic_apron = if tile_shading_anisotropic_apron {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn tile_shading_atomic_ops(mut self, tile_shading_atomic_ops: bool) -> Self {
        self.inner.tile_shading_atomic_ops = if tile_shading_atomic_ops { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn tile_shading_image_processing(mut self, tile_shading_image_processing: bool) -> Self {
        self.inner.tile_shading_image_processing = if tile_shading_image_processing {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceTileShadingFeaturesQCOMBuilder {
    type Target = vk::PhysicalDeviceTileShadingFeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceTileShadingFeaturesQCOM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceTileShadingFeaturesQCOMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceTileShadingFeaturesQCOM {}
impl DeviceCreateInfoNext for PhysicalDeviceTileShadingFeaturesQCOMBuilder {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceTileShadingPropertiesQCOM {}

#[repr(transparent)]
#[derive(Default)]
pub struct RenderPassTileShadingCreateInfoQCOMBuilder {
    inner: vk::RenderPassTileShadingCreateInfoQCOM,
}
impl Builder<'_> for vk::RenderPassTileShadingCreateInfoQCOM {
    type Type = RenderPassTileShadingCreateInfoQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl RenderPassTileShadingCreateInfoQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::RenderPassTileShadingCreateInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::TileShadingRenderPassFlagsQCOM) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn tile_apron_size(mut self, tile_apron_size: vk::Extent2D) -> Self {
        self.inner.tile_apron_size = tile_apron_size;
        self
    }
}
impl Deref for RenderPassTileShadingCreateInfoQCOMBuilder {
    type Target = vk::RenderPassTileShadingCreateInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl RenderPassCreateInfoNext for vk::RenderPassTileShadingCreateInfoQCOM {}
impl RenderPassCreateInfoNext for RenderPassTileShadingCreateInfoQCOMBuilder {}
impl RenderPassCreateInfo2Next for vk::RenderPassTileShadingCreateInfoQCOM {}
impl RenderPassCreateInfo2Next for RenderPassTileShadingCreateInfoQCOMBuilder {}
impl RenderingInfoNext for vk::RenderPassTileShadingCreateInfoQCOM {}
impl RenderingInfoNext for RenderPassTileShadingCreateInfoQCOMBuilder {}
impl CommandBufferInheritanceInfoNext for vk::RenderPassTileShadingCreateInfoQCOM {}
impl CommandBufferInheritanceInfoNext for RenderPassTileShadingCreateInfoQCOMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PerTileBeginInfoQCOMBuilder {
    inner: vk::PerTileBeginInfoQCOM,
}
impl Builder<'_> for vk::PerTileBeginInfoQCOM {
    type Type = PerTileBeginInfoQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PerTileBeginInfoQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PerTileBeginInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
}
impl Deref for PerTileBeginInfoQCOMBuilder {
    type Target = vk::PerTileBeginInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PerTileEndInfoQCOMBuilder {
    inner: vk::PerTileEndInfoQCOM,
}
impl Builder<'_> for vk::PerTileEndInfoQCOM {
    type Type = PerTileEndInfoQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PerTileEndInfoQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PerTileEndInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
}
impl Deref for PerTileEndInfoQCOMBuilder {
    type Target = vk::PerTileEndInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DispatchTileInfoQCOMBuilder {
    inner: vk::DispatchTileInfoQCOM,
}
impl Builder<'_> for vk::DispatchTileInfoQCOM {
    type Type = DispatchTileInfoQCOMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DispatchTileInfoQCOMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DispatchTileInfoQCOM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
}
impl Deref for DispatchTileInfoQCOMBuilder {
    type Target = vk::DispatchTileInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE {}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE {}

#[repr(transparent)]
#[derive(Default)]
pub struct PipelineFragmentDensityMapLayeredCreateInfoVALVEBuilder {
    inner: vk::PipelineFragmentDensityMapLayeredCreateInfoVALVE,
}
impl Builder<'_> for vk::PipelineFragmentDensityMapLayeredCreateInfoVALVE {
    type Type = PipelineFragmentDensityMapLayeredCreateInfoVALVEBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PipelineFragmentDensityMapLayeredCreateInfoVALVEBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PipelineFragmentDensityMapLayeredCreateInfoVALVE {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn max_fragment_density_map_layers(mut self, max_fragment_density_map_layers: u32) -> Self {
        self.inner.max_fragment_density_map_layers = max_fragment_density_map_layers;
        self
    }
}
impl Deref for PipelineFragmentDensityMapLayeredCreateInfoVALVEBuilder {
    type Target = vk::PipelineFragmentDensityMapLayeredCreateInfoVALVE;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl GraphicsPipelineCreateInfoNext for vk::PipelineFragmentDensityMapLayeredCreateInfoVALVE {}
impl GraphicsPipelineCreateInfoNext for PipelineFragmentDensityMapLayeredCreateInfoVALVEBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SetPresentConfigNVBuilder {
    inner: vk::SetPresentConfigNV,
}
impl Builder<'_> for vk::SetPresentConfigNV {
    type Type = SetPresentConfigNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl SetPresentConfigNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::SetPresentConfigNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn num_frames_per_batch(mut self, num_frames_per_batch: u32) -> Self {
        self.inner.num_frames_per_batch = num_frames_per_batch;
        self
    }
    pub fn present_config_feedback(mut self, present_config_feedback: u32) -> Self {
        self.inner.present_config_feedback = present_config_feedback;
        self
    }
}
impl Deref for SetPresentConfigNVBuilder {
    type Target = vk::SetPresentConfigNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PresentInfoKHRNext for vk::SetPresentConfigNV {}
impl PresentInfoKHRNext for SetPresentConfigNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePresentMeteringFeaturesNVBuilder {
    inner: vk::PhysicalDevicePresentMeteringFeaturesNV,
}
impl Builder<'_> for vk::PhysicalDevicePresentMeteringFeaturesNV {
    type Type = PhysicalDevicePresentMeteringFeaturesNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePresentMeteringFeaturesNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePresentMeteringFeaturesNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn present_metering(mut self, present_metering: bool) -> Self {
        self.inner.present_metering = if present_metering { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDevicePresentMeteringFeaturesNVBuilder {
    type Target = vk::PhysicalDevicePresentMeteringFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePresentMeteringFeaturesNV {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePresentMeteringFeaturesNVBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePresentMeteringFeaturesNV {}
impl DeviceCreateInfoNext for PhysicalDevicePresentMeteringFeaturesNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExternalComputeQueueDeviceCreateInfoNVBuilder {
    inner: vk::ExternalComputeQueueDeviceCreateInfoNV,
}
impl Builder<'_> for vk::ExternalComputeQueueDeviceCreateInfoNV {
    type Type = ExternalComputeQueueDeviceCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExternalComputeQueueDeviceCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExternalComputeQueueDeviceCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn reserved_external_queues(mut self, reserved_external_queues: u32) -> Self {
        self.inner.reserved_external_queues = reserved_external_queues;
        self
    }
}
impl Deref for ExternalComputeQueueDeviceCreateInfoNVBuilder {
    type Target = vk::ExternalComputeQueueDeviceCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DeviceCreateInfoNext for vk::ExternalComputeQueueDeviceCreateInfoNV {}
impl DeviceCreateInfoNext for ExternalComputeQueueDeviceCreateInfoNVBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct ExternalComputeQueueCreateInfoNVBuilder {
    inner: vk::ExternalComputeQueueCreateInfoNV,
}
impl Builder<'_> for vk::ExternalComputeQueueCreateInfoNV {
    type Type = ExternalComputeQueueCreateInfoNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExternalComputeQueueCreateInfoNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExternalComputeQueueCreateInfoNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn preferred_queue(mut self, preferred_queue: vk::Queue) -> Self {
        self.inner.preferred_queue = preferred_queue;
        self
    }
}
impl Deref for ExternalComputeQueueCreateInfoNVBuilder {
    type Target = vk::ExternalComputeQueueCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ExternalComputeQueueDataParamsNVBuilder {
    inner: vk::ExternalComputeQueueDataParamsNV,
}
impl Builder<'_> for vk::ExternalComputeQueueDataParamsNV {
    type Type = ExternalComputeQueueDataParamsNVBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExternalComputeQueueDataParamsNVBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExternalComputeQueueDataParamsNV {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn device_index(mut self, device_index: u32) -> Self {
        self.inner.device_index = device_index;
        self
    }
}
impl Deref for ExternalComputeQueueDataParamsNVBuilder {
    type Target = vk::ExternalComputeQueueDataParamsNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceExternalComputeQueuePropertiesNV {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceFormatPackFeaturesARMBuilder {
    inner: vk::PhysicalDeviceFormatPackFeaturesARM,
}
impl Builder<'_> for vk::PhysicalDeviceFormatPackFeaturesARM {
    type Type = PhysicalDeviceFormatPackFeaturesARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceFormatPackFeaturesARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceFormatPackFeaturesARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn format_pack(mut self, format_pack: bool) -> Self {
        self.inner.format_pack = if format_pack { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceFormatPackFeaturesARMBuilder {
    type Target = vk::PhysicalDeviceFormatPackFeaturesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceFormatPackFeaturesARM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceFormatPackFeaturesARMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceFormatPackFeaturesARM {}
impl DeviceCreateInfoNext for PhysicalDeviceFormatPackFeaturesARMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct TensorDescriptionARMBuilder<'a> {
    inner: vk::TensorDescriptionARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::TensorDescriptionARM {
    type Type = TensorDescriptionARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> TensorDescriptionARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::TensorDescriptionARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn tiling(mut self, tiling: vk::TensorTilingARM) -> Self {
        self.inner.tiling = tiling;
        self
    }
    pub fn format(mut self, format: vk::Format) -> Self {
        self.inner.format = format;
        self
    }
    pub fn p_dimensions(mut self, p_dimensions: &'a [i64], p_strides: Option<&'a [i64]>) -> Self {
        self.inner.dimension_count = p_dimensions.len() as u32;
        self.inner.p_dimensions = p_dimensions.as_ptr();
        self.inner.p_strides = p_strides.map_or(ptr::null(), |s| s.as_ptr());
        self
    }
    pub fn usage(mut self, usage: vk::TensorUsageFlagsARM) -> Self {
        self.inner.usage = usage;
        self
    }
}
impl<'a> Deref for TensorDescriptionARMBuilder<'a> {
    type Target = vk::TensorDescriptionARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DataGraphPipelineResourceInfoARMNext for vk::TensorDescriptionARM {}
impl DataGraphPipelineResourceInfoARMNext for TensorDescriptionARMBuilder<'_> {}
impl DataGraphPipelineConstantARMNext for vk::TensorDescriptionARM {}
impl DataGraphPipelineConstantARMNext for TensorDescriptionARMBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct TensorCreateInfoARMBuilder<'a> {
    inner: vk::TensorCreateInfoARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::TensorCreateInfoARM {
    type Type = TensorCreateInfoARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait TensorCreateInfoARMNext {}
impl<'a> TensorCreateInfoARMBuilder<'a> {
    pub fn insert_next<T: TensorCreateInfoARMNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::TensorCreateInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::TensorCreateFlagsARM) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_description(mut self, p_description: &'a vk::TensorDescriptionARM) -> Self {
        self.inner.p_description = p_description;
        self
    }
    pub fn sharing_mode(mut self, sharing_mode: vk::SharingMode) -> Self {
        self.inner.sharing_mode = sharing_mode;
        self
    }
    pub fn queue_family_index_count(mut self, queue_family_index_count: u32) -> Self {
        self.inner.queue_family_index_count = queue_family_index_count;
        self
    }
    pub fn p_queue_family_indices(mut self, p_queue_family_indices: &'a [u32]) -> Self {
        self.inner.queue_family_index_count = p_queue_family_indices.len() as u32;
        self.inner.p_queue_family_indices = p_queue_family_indices.as_ptr();
        self
    }
}
impl<'a> Deref for TensorCreateInfoARMBuilder<'a> {
    type Target = vk::TensorCreateInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct TensorViewCreateInfoARMBuilder<'a> {
    inner: vk::TensorViewCreateInfoARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::TensorViewCreateInfoARM {
    type Type = TensorViewCreateInfoARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait TensorViewCreateInfoARMNext {}
impl<'a> TensorViewCreateInfoARMBuilder<'a> {
    pub fn insert_next<T: TensorViewCreateInfoARMNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::TensorViewCreateInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::TensorViewCreateFlagsARM) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn tensor(mut self, tensor: vk::TensorARM) -> Self {
        self.inner.tensor = tensor;
        self
    }
    pub fn format(mut self, format: vk::Format) -> Self {
        self.inner.format = format;
        self
    }
}
impl<'a> Deref for TensorViewCreateInfoARMBuilder<'a> {
    type Target = vk::TensorViewCreateInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct TensorMemoryRequirementsInfoARMBuilder {
    inner: vk::TensorMemoryRequirementsInfoARM,
}
impl Builder<'_> for vk::TensorMemoryRequirementsInfoARM {
    type Type = TensorMemoryRequirementsInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl TensorMemoryRequirementsInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::TensorMemoryRequirementsInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn tensor(mut self, tensor: vk::TensorARM) -> Self {
        self.inner.tensor = tensor;
        self
    }
}
impl Deref for TensorMemoryRequirementsInfoARMBuilder {
    type Target = vk::TensorMemoryRequirementsInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BindTensorMemoryInfoARMBuilder {
    inner: vk::BindTensorMemoryInfoARM,
}
impl Builder<'_> for vk::BindTensorMemoryInfoARM {
    type Type = BindTensorMemoryInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BindTensorMemoryInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BindTensorMemoryInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn tensor(mut self, tensor: vk::TensorARM) -> Self {
        self.inner.tensor = tensor;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn memory_offset(mut self, memory_offset: vk::DeviceSize) -> Self {
        self.inner.memory_offset = memory_offset;
        self
    }
}
impl Deref for BindTensorMemoryInfoARMBuilder {
    type Target = vk::BindTensorMemoryInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct WriteDescriptorSetTensorARMBuilder<'a> {
    inner: vk::WriteDescriptorSetTensorARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::WriteDescriptorSetTensorARM {
    type Type = WriteDescriptorSetTensorARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> WriteDescriptorSetTensorARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::WriteDescriptorSetTensorARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_tensor_views(mut self, p_tensor_views: &'a [vk::TensorViewARM]) -> Self {
        self.inner.tensor_view_count = p_tensor_views.len() as u32;
        self.inner.p_tensor_views = p_tensor_views.as_ptr();
        self
    }
}
impl<'a> Deref for WriteDescriptorSetTensorARMBuilder<'a> {
    type Target = vk::WriteDescriptorSetTensorARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl WriteDescriptorSetNext for vk::WriteDescriptorSetTensorARM {}
impl WriteDescriptorSetNext for WriteDescriptorSetTensorARMBuilder<'_> {}
impl FormatProperties2Next for vk::TensorFormatPropertiesARM {}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceTensorPropertiesARM {}

#[repr(transparent)]
#[derive(Default)]
pub struct TensorMemoryBarrierARMBuilder {
    inner: vk::TensorMemoryBarrierARM,
}
impl Builder<'_> for vk::TensorMemoryBarrierARM {
    type Type = TensorMemoryBarrierARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl TensorMemoryBarrierARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::TensorMemoryBarrierARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_stage_mask(mut self, src_stage_mask: vk::PipelineStageFlags2) -> Self {
        self.inner.src_stage_mask = src_stage_mask;
        self
    }
    pub fn src_access_mask(mut self, src_access_mask: vk::AccessFlags2) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    pub fn dst_stage_mask(mut self, dst_stage_mask: vk::PipelineStageFlags2) -> Self {
        self.inner.dst_stage_mask = dst_stage_mask;
        self
    }
    pub fn dst_access_mask(mut self, dst_access_mask: vk::AccessFlags2) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.inner.src_queue_family_index = src_queue_family_index;
        self
    }
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.inner.dst_queue_family_index = dst_queue_family_index;
        self
    }
    pub fn tensor(mut self, tensor: vk::TensorARM) -> Self {
        self.inner.tensor = tensor;
        self
    }
}
impl Deref for TensorMemoryBarrierARMBuilder {
    type Target = vk::TensorMemoryBarrierARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DependencyInfoNext for vk::TensorMemoryBarrierARM {}
impl DependencyInfoNext for TensorMemoryBarrierARMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct TensorDependencyInfoARMBuilder<'a> {
    inner: vk::TensorDependencyInfoARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::TensorDependencyInfoARM {
    type Type = TensorDependencyInfoARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> TensorDependencyInfoARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::TensorDependencyInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn tensor_memory_barrier_count(mut self, tensor_memory_barrier_count: u32) -> Self {
        self.inner.tensor_memory_barrier_count = tensor_memory_barrier_count;
        self
    }
    pub fn p_tensor_memory_barriers(mut self, p_tensor_memory_barriers: &'a vk::TensorMemoryBarrierARM) -> Self {
        self.inner.p_tensor_memory_barriers = p_tensor_memory_barriers;
        self
    }
}
impl<'a> Deref for TensorDependencyInfoARMBuilder<'a> {
    type Target = vk::TensorDependencyInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DependencyInfoNext for vk::TensorDependencyInfoARM {}
impl DependencyInfoNext for TensorDependencyInfoARMBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceTensorFeaturesARMBuilder {
    inner: vk::PhysicalDeviceTensorFeaturesARM,
}
impl Builder<'_> for vk::PhysicalDeviceTensorFeaturesARM {
    type Type = PhysicalDeviceTensorFeaturesARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceTensorFeaturesARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceTensorFeaturesARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn tensor_non_packed(mut self, tensor_non_packed: bool) -> Self {
        self.inner.tensor_non_packed = if tensor_non_packed { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_tensor_access(mut self, shader_tensor_access: bool) -> Self {
        self.inner.shader_tensor_access = if shader_tensor_access { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_storage_tensor_array_dynamic_indexing(
        mut self,
        shader_storage_tensor_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_tensor_array_dynamic_indexing = if shader_storage_tensor_array_dynamic_indexing {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn shader_storage_tensor_array_non_uniform_indexing(
        mut self,
        shader_storage_tensor_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_tensor_array_non_uniform_indexing =
            if shader_storage_tensor_array_non_uniform_indexing {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn descriptor_binding_storage_tensor_update_after_bind(
        mut self,
        descriptor_binding_storage_tensor_update_after_bind: bool,
    ) -> Self {
        self.inner.descriptor_binding_storage_tensor_update_after_bind =
            if descriptor_binding_storage_tensor_update_after_bind {
                vk::TRUE
            } else {
                vk::FALSE
            };
        self
    }
    pub fn tensors(mut self, tensors: bool) -> Self {
        self.inner.tensors = if tensors { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceTensorFeaturesARMBuilder {
    type Target = vk::PhysicalDeviceTensorFeaturesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceTensorFeaturesARM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceTensorFeaturesARMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceTensorFeaturesARM {}
impl DeviceCreateInfoNext for PhysicalDeviceTensorFeaturesARMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DeviceTensorMemoryRequirementsARMBuilder<'a> {
    inner: vk::DeviceTensorMemoryRequirementsARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DeviceTensorMemoryRequirementsARM {
    type Type = DeviceTensorMemoryRequirementsARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DeviceTensorMemoryRequirementsARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DeviceTensorMemoryRequirementsARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_create_info(mut self, p_create_info: &'a vk::TensorCreateInfoARM) -> Self {
        self.inner.p_create_info = p_create_info;
        self
    }
}
impl<'a> Deref for DeviceTensorMemoryRequirementsARMBuilder<'a> {
    type Target = vk::DeviceTensorMemoryRequirementsARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct CopyTensorInfoARMBuilder<'a> {
    inner: vk::CopyTensorInfoARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::CopyTensorInfoARM {
    type Type = CopyTensorInfoARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> CopyTensorInfoARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::CopyTensorInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn src_tensor(mut self, src_tensor: vk::TensorARM) -> Self {
        self.inner.src_tensor = src_tensor;
        self
    }
    pub fn dst_tensor(mut self, dst_tensor: vk::TensorARM) -> Self {
        self.inner.dst_tensor = dst_tensor;
        self
    }
    pub fn p_regions(mut self, p_regions: &'a [vk::TensorCopyARM]) -> Self {
        self.inner.region_count = p_regions.len() as u32;
        self.inner.p_regions = p_regions.as_ptr();
        self
    }
}
impl<'a> Deref for CopyTensorInfoARMBuilder<'a> {
    type Target = vk::CopyTensorInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct TensorCopyARMBuilder<'a> {
    inner: vk::TensorCopyARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::TensorCopyARM {
    type Type = TensorCopyARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> TensorCopyARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::TensorCopyARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_src_offset(
        mut self,
        p_src_offset: Option<&'a [u64]>,
        p_dst_offset: Option<&'a [u64]>,
        p_extent: Option<&'a [u64]>,
    ) -> Self {
        self.inner.dimension_count = p_src_offset
            .map(|s| s.len() as u32)
            .or(p_dst_offset.map(|s| s.len() as u32))
            .or(p_extent.map(|s| s.len() as u32))
            .unwrap_or(0);
        if let Some(len) = p_src_offset.map(|s| s.len()) {
            assert_eq!(self.inner.dimension_count, len as u32);
        }
        if let Some(len) = p_dst_offset.map(|s| s.len()) {
            assert_eq!(self.inner.dimension_count, len as u32);
        }
        if let Some(len) = p_extent.map(|s| s.len()) {
            assert_eq!(self.inner.dimension_count, len as u32);
        }
        self.inner.p_src_offset = p_src_offset.map_or(ptr::null(), |s| s.as_ptr());
        self.inner.p_dst_offset = p_dst_offset.map_or(ptr::null(), |s| s.as_ptr());
        self.inner.p_extent = p_extent.map_or(ptr::null(), |s| s.as_ptr());
        self
    }
}
impl<'a> Deref for TensorCopyARMBuilder<'a> {
    type Target = vk::TensorCopyARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct MemoryDedicatedAllocateInfoTensorARMBuilder {
    inner: vk::MemoryDedicatedAllocateInfoTensorARM,
}
impl Builder<'_> for vk::MemoryDedicatedAllocateInfoTensorARM {
    type Type = MemoryDedicatedAllocateInfoTensorARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl MemoryDedicatedAllocateInfoTensorARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::MemoryDedicatedAllocateInfoTensorARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn tensor(mut self, tensor: vk::TensorARM) -> Self {
        self.inner.tensor = tensor;
        self
    }
}
impl Deref for MemoryDedicatedAllocateInfoTensorARMBuilder {
    type Target = vk::MemoryDedicatedAllocateInfoTensorARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl MemoryAllocateInfoNext for vk::MemoryDedicatedAllocateInfoTensorARM {}
impl MemoryAllocateInfoNext for MemoryDedicatedAllocateInfoTensorARMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDescriptorBufferTensorPropertiesARMBuilder {
    inner: vk::PhysicalDeviceDescriptorBufferTensorPropertiesARM,
}
impl Builder<'_> for vk::PhysicalDeviceDescriptorBufferTensorPropertiesARM {
    type Type = PhysicalDeviceDescriptorBufferTensorPropertiesARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDescriptorBufferTensorPropertiesARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDescriptorBufferTensorPropertiesARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn tensor_capture_replay_descriptor_data_size(
        mut self,
        tensor_capture_replay_descriptor_data_size: usize,
    ) -> Self {
        self.inner.tensor_capture_replay_descriptor_data_size = tensor_capture_replay_descriptor_data_size;
        self
    }
    pub fn tensor_view_capture_replay_descriptor_data_size(
        mut self,
        tensor_view_capture_replay_descriptor_data_size: usize,
    ) -> Self {
        self.inner.tensor_view_capture_replay_descriptor_data_size = tensor_view_capture_replay_descriptor_data_size;
        self
    }
    pub fn tensor_descriptor_size(mut self, tensor_descriptor_size: usize) -> Self {
        self.inner.tensor_descriptor_size = tensor_descriptor_size;
        self
    }
}
impl Deref for PhysicalDeviceDescriptorBufferTensorPropertiesARMBuilder {
    type Target = vk::PhysicalDeviceDescriptorBufferTensorPropertiesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceProperties2Next for vk::PhysicalDeviceDescriptorBufferTensorPropertiesARM {}
impl PhysicalDeviceProperties2Next for PhysicalDeviceDescriptorBufferTensorPropertiesARMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDescriptorBufferTensorFeaturesARMBuilder {
    inner: vk::PhysicalDeviceDescriptorBufferTensorFeaturesARM,
}
impl Builder<'_> for vk::PhysicalDeviceDescriptorBufferTensorFeaturesARM {
    type Type = PhysicalDeviceDescriptorBufferTensorFeaturesARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDescriptorBufferTensorFeaturesARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDescriptorBufferTensorFeaturesARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn descriptor_buffer_tensor_descriptors(mut self, descriptor_buffer_tensor_descriptors: bool) -> Self {
        self.inner.descriptor_buffer_tensor_descriptors = if descriptor_buffer_tensor_descriptors {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceDescriptorBufferTensorFeaturesARMBuilder {
    type Target = vk::PhysicalDeviceDescriptorBufferTensorFeaturesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDescriptorBufferTensorFeaturesARM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDescriptorBufferTensorFeaturesARMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDescriptorBufferTensorFeaturesARM {}
impl DeviceCreateInfoNext for PhysicalDeviceDescriptorBufferTensorFeaturesARMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct TensorCaptureDescriptorDataInfoARMBuilder {
    inner: vk::TensorCaptureDescriptorDataInfoARM,
}
impl Builder<'_> for vk::TensorCaptureDescriptorDataInfoARM {
    type Type = TensorCaptureDescriptorDataInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl TensorCaptureDescriptorDataInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::TensorCaptureDescriptorDataInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn tensor(mut self, tensor: vk::TensorARM) -> Self {
        self.inner.tensor = tensor;
        self
    }
}
impl Deref for TensorCaptureDescriptorDataInfoARMBuilder {
    type Target = vk::TensorCaptureDescriptorDataInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct TensorViewCaptureDescriptorDataInfoARMBuilder {
    inner: vk::TensorViewCaptureDescriptorDataInfoARM,
}
impl Builder<'_> for vk::TensorViewCaptureDescriptorDataInfoARM {
    type Type = TensorViewCaptureDescriptorDataInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl TensorViewCaptureDescriptorDataInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::TensorViewCaptureDescriptorDataInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn tensor_view(mut self, tensor_view: vk::TensorViewARM) -> Self {
        self.inner.tensor_view = tensor_view;
        self
    }
}
impl Deref for TensorViewCaptureDescriptorDataInfoARMBuilder {
    type Target = vk::TensorViewCaptureDescriptorDataInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DescriptorGetTensorInfoARMBuilder {
    inner: vk::DescriptorGetTensorInfoARM,
}
impl Builder<'_> for vk::DescriptorGetTensorInfoARM {
    type Type = DescriptorGetTensorInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DescriptorGetTensorInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DescriptorGetTensorInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn tensor_view(mut self, tensor_view: vk::TensorViewARM) -> Self {
        self.inner.tensor_view = tensor_view;
        self
    }
}
impl Deref for DescriptorGetTensorInfoARMBuilder {
    type Target = vk::DescriptorGetTensorInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DescriptorGetInfoEXTNext for vk::DescriptorGetTensorInfoARM {}
impl DescriptorGetInfoEXTNext for DescriptorGetTensorInfoARMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct FrameBoundaryTensorsARMBuilder<'a> {
    inner: vk::FrameBoundaryTensorsARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::FrameBoundaryTensorsARM {
    type Type = FrameBoundaryTensorsARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> FrameBoundaryTensorsARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::FrameBoundaryTensorsARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_tensors(mut self, p_tensors: &'a [vk::TensorARM]) -> Self {
        self.inner.tensor_count = p_tensors.len() as u32;
        self.inner.p_tensors = p_tensors.as_ptr();
        self
    }
}
impl<'a> Deref for FrameBoundaryTensorsARMBuilder<'a> {
    type Target = vk::FrameBoundaryTensorsARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl SubmitInfoNext for vk::FrameBoundaryTensorsARM {}
impl SubmitInfoNext for FrameBoundaryTensorsARMBuilder<'_> {}
impl SubmitInfo2Next for vk::FrameBoundaryTensorsARM {}
impl SubmitInfo2Next for FrameBoundaryTensorsARMBuilder<'_> {}
impl PresentInfoKHRNext for vk::FrameBoundaryTensorsARM {}
impl PresentInfoKHRNext for FrameBoundaryTensorsARMBuilder<'_> {}
impl BindSparseInfoNext for vk::FrameBoundaryTensorsARM {}
impl BindSparseInfoNext for FrameBoundaryTensorsARMBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceExternalTensorInfoARMBuilder<'a> {
    inner: vk::PhysicalDeviceExternalTensorInfoARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::PhysicalDeviceExternalTensorInfoARM {
    type Type = PhysicalDeviceExternalTensorInfoARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> PhysicalDeviceExternalTensorInfoARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceExternalTensorInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::TensorCreateFlagsARM) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn p_description(mut self, p_description: &'a vk::TensorDescriptionARM) -> Self {
        self.inner.p_description = p_description;
        self
    }
    pub fn handle_type(mut self, handle_type: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
}
impl<'a> Deref for PhysicalDeviceExternalTensorInfoARMBuilder<'a> {
    type Target = vk::PhysicalDeviceExternalTensorInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ExternalTensorPropertiesARMBuilder {
    inner: vk::ExternalTensorPropertiesARM,
}
impl Builder<'_> for vk::ExternalTensorPropertiesARM {
    type Type = ExternalTensorPropertiesARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExternalTensorPropertiesARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExternalTensorPropertiesARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn external_memory_properties(mut self, external_memory_properties: vk::ExternalMemoryProperties) -> Self {
        self.inner.external_memory_properties = external_memory_properties;
        self
    }
}
impl Deref for ExternalTensorPropertiesARMBuilder {
    type Target = vk::ExternalTensorPropertiesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct ExternalMemoryTensorCreateInfoARMBuilder {
    inner: vk::ExternalMemoryTensorCreateInfoARM,
}
impl Builder<'_> for vk::ExternalMemoryTensorCreateInfoARM {
    type Type = ExternalMemoryTensorCreateInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl ExternalMemoryTensorCreateInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::ExternalMemoryTensorCreateInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn handle_types(mut self, handle_types: vk::ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
}
impl Deref for ExternalMemoryTensorCreateInfoARMBuilder {
    type Target = vk::ExternalMemoryTensorCreateInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl TensorCreateInfoARMNext for vk::ExternalMemoryTensorCreateInfoARM {}
impl TensorCreateInfoARMNext for ExternalMemoryTensorCreateInfoARMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderFloat8FeaturesEXTBuilder {
    inner: vk::PhysicalDeviceShaderFloat8FeaturesEXT,
}
impl Builder<'_> for vk::PhysicalDeviceShaderFloat8FeaturesEXT {
    type Type = PhysicalDeviceShaderFloat8FeaturesEXTBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderFloat8FeaturesEXTBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderFloat8FeaturesEXT {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_float8(mut self, shader_float8: bool) -> Self {
        self.inner.shader_float8 = if shader_float8 { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn shader_float8_cooperative_matrix(mut self, shader_float8_cooperative_matrix: bool) -> Self {
        self.inner.shader_float8_cooperative_matrix = if shader_float8_cooperative_matrix {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDeviceShaderFloat8FeaturesEXTBuilder {
    type Target = vk::PhysicalDeviceShaderFloat8FeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderFloat8FeaturesEXT {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderFloat8FeaturesEXTBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderFloat8FeaturesEXT {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderFloat8FeaturesEXTBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct SurfaceCreateInfoOHOSBuilder<'a> {
    inner: vk::SurfaceCreateInfoOHOS,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::SurfaceCreateInfoOHOS {
    type Type = SurfaceCreateInfoOHOSBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> SurfaceCreateInfoOHOSBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::SurfaceCreateInfoOHOS {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::SurfaceCreateFlagsOHOS) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn window(mut self, window: *mut vk::OHNativeWindow) -> Self {
        self.inner.window = window;
        self
    }
}
impl<'a> Deref for SurfaceCreateInfoOHOSBuilder<'a> {
    type Target = vk::SurfaceCreateInfoOHOS;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDataGraphFeaturesARMBuilder {
    inner: vk::PhysicalDeviceDataGraphFeaturesARM,
}
impl Builder<'_> for vk::PhysicalDeviceDataGraphFeaturesARM {
    type Type = PhysicalDeviceDataGraphFeaturesARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDataGraphFeaturesARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDataGraphFeaturesARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn data_graph(mut self, data_graph: bool) -> Self {
        self.inner.data_graph = if data_graph { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn data_graph_update_after_bind(mut self, data_graph_update_after_bind: bool) -> Self {
        self.inner.data_graph_update_after_bind = if data_graph_update_after_bind {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn data_graph_specialization_constants(mut self, data_graph_specialization_constants: bool) -> Self {
        self.inner.data_graph_specialization_constants = if data_graph_specialization_constants {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn data_graph_descriptor_buffer(mut self, data_graph_descriptor_buffer: bool) -> Self {
        self.inner.data_graph_descriptor_buffer = if data_graph_descriptor_buffer {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
    pub fn data_graph_shader_module(mut self, data_graph_shader_module: bool) -> Self {
        self.inner.data_graph_shader_module = if data_graph_shader_module { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceDataGraphFeaturesARMBuilder {
    type Target = vk::PhysicalDeviceDataGraphFeaturesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceDataGraphFeaturesARM {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceDataGraphFeaturesARMBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceDataGraphFeaturesARM {}
impl DeviceCreateInfoNext for PhysicalDeviceDataGraphFeaturesARMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARMBuilder {
    inner: vk::DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM,
}
impl Builder<'_> for vk::DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM {
    type Type = DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn dimension(mut self, dimension: u32) -> Self {
        self.inner.dimension = dimension;
        self
    }
    pub fn zero_count(mut self, zero_count: u32) -> Self {
        self.inner.zero_count = zero_count;
        self
    }
    pub fn group_size(mut self, group_size: u32) -> Self {
        self.inner.group_size = group_size;
        self
    }
}
impl Deref for DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARMBuilder {
    type Target = vk::DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DataGraphPipelineConstantARMNext for vk::DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM {}
impl DataGraphPipelineConstantARMNext for DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARMBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphPipelineConstantARMBuilder<'a> {
    inner: vk::DataGraphPipelineConstantARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DataGraphPipelineConstantARM {
    type Type = DataGraphPipelineConstantARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DataGraphPipelineConstantARMNext {}
impl<'a> DataGraphPipelineConstantARMBuilder<'a> {
    pub fn insert_next<T: DataGraphPipelineConstantARMNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DataGraphPipelineConstantARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn id(mut self, id: u32) -> Self {
        self.inner.id = id;
        self
    }
    pub fn p_constant_data(mut self, p_constant_data: *const c_void) -> Self {
        self.inner.p_constant_data = p_constant_data;
        self
    }
}
impl<'a> Deref for DataGraphPipelineConstantARMBuilder<'a> {
    type Target = vk::DataGraphPipelineConstantARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphPipelineResourceInfoARMBuilder<'a> {
    inner: vk::DataGraphPipelineResourceInfoARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DataGraphPipelineResourceInfoARM {
    type Type = DataGraphPipelineResourceInfoARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DataGraphPipelineResourceInfoARMNext {}
impl<'a> DataGraphPipelineResourceInfoARMBuilder<'a> {
    pub fn insert_next<T: DataGraphPipelineResourceInfoARMNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DataGraphPipelineResourceInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn descriptor_set(mut self, descriptor_set: u32) -> Self {
        self.inner.descriptor_set = descriptor_set;
        self
    }
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
    pub fn array_element(mut self, array_element: u32) -> Self {
        self.inner.array_element = array_element;
        self
    }
}
impl<'a> Deref for DataGraphPipelineResourceInfoARMBuilder<'a> {
    type Target = vk::DataGraphPipelineResourceInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphPipelineCompilerControlCreateInfoARMBuilder<'a> {
    inner: vk::DataGraphPipelineCompilerControlCreateInfoARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DataGraphPipelineCompilerControlCreateInfoARM {
    type Type = DataGraphPipelineCompilerControlCreateInfoARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DataGraphPipelineCompilerControlCreateInfoARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DataGraphPipelineCompilerControlCreateInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_vendor_options(mut self, p_vendor_options: &'a CStr) -> Self {
        self.inner.p_vendor_options = p_vendor_options.as_ptr();
        self
    }
}
impl<'a> Deref for DataGraphPipelineCompilerControlCreateInfoARMBuilder<'a> {
    type Target = vk::DataGraphPipelineCompilerControlCreateInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DataGraphPipelineCreateInfoARMNext for vk::DataGraphPipelineCompilerControlCreateInfoARM {}
impl DataGraphPipelineCreateInfoARMNext for DataGraphPipelineCompilerControlCreateInfoARMBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphPipelineCreateInfoARMBuilder<'a> {
    inner: vk::DataGraphPipelineCreateInfoARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DataGraphPipelineCreateInfoARM {
    type Type = DataGraphPipelineCreateInfoARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
pub trait DataGraphPipelineCreateInfoARMNext {}
impl<'a> DataGraphPipelineCreateInfoARMBuilder<'a> {
    pub fn insert_next<T: DataGraphPipelineCreateInfoARMNext>(mut self, next: &'a mut T) -> Self {
        unsafe {
            insert_next(&mut self as *mut Self as *mut _, next as *mut T as *mut _);
        }
        self
    }
    pub fn get_mut(&mut self) -> &mut vk::DataGraphPipelineCreateInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::PipelineCreateFlags2KHR) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn layout(mut self, layout: vk::PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    pub fn p_resource_infos(mut self, p_resource_infos: &'a [vk::DataGraphPipelineResourceInfoARM]) -> Self {
        self.inner.resource_info_count = p_resource_infos.len() as u32;
        self.inner.p_resource_infos = p_resource_infos.as_ptr();
        self
    }
}
impl<'a> Deref for DataGraphPipelineCreateInfoARMBuilder<'a> {
    type Target = vk::DataGraphPipelineCreateInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphPipelineShaderModuleCreateInfoARMBuilder<'a> {
    inner: vk::DataGraphPipelineShaderModuleCreateInfoARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DataGraphPipelineShaderModuleCreateInfoARM {
    type Type = DataGraphPipelineShaderModuleCreateInfoARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DataGraphPipelineShaderModuleCreateInfoARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DataGraphPipelineShaderModuleCreateInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn module(mut self, module: vk::ShaderModule) -> Self {
        self.inner.module = module;
        self
    }
    pub fn p_name(mut self, p_name: &'a CStr) -> Self {
        self.inner.p_name = p_name.as_ptr();
        self
    }
    pub fn p_specialization_info(mut self, p_specialization_info: Option<&'a vk::SpecializationInfo>) -> Self {
        self.inner.p_specialization_info = p_specialization_info.map_or(ptr::null(), |r| r);
        self
    }
    pub fn p_constants(mut self, p_constants: &'a [vk::DataGraphPipelineConstantARM]) -> Self {
        self.inner.constant_count = p_constants.len() as u32;
        self.inner.p_constants = p_constants.as_ptr();
        self
    }
}
impl<'a> Deref for DataGraphPipelineShaderModuleCreateInfoARMBuilder<'a> {
    type Target = vk::DataGraphPipelineShaderModuleCreateInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DataGraphPipelineCreateInfoARMNext for vk::DataGraphPipelineShaderModuleCreateInfoARM {}
impl DataGraphPipelineCreateInfoARMNext for DataGraphPipelineShaderModuleCreateInfoARMBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphPipelineSessionCreateInfoARMBuilder {
    inner: vk::DataGraphPipelineSessionCreateInfoARM,
}
impl Builder<'_> for vk::DataGraphPipelineSessionCreateInfoARM {
    type Type = DataGraphPipelineSessionCreateInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DataGraphPipelineSessionCreateInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DataGraphPipelineSessionCreateInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DataGraphPipelineSessionCreateFlagsARM) -> Self {
        self.inner.flags = flags;
        self
    }
    pub fn data_graph_pipeline(mut self, data_graph_pipeline: vk::Pipeline) -> Self {
        self.inner.data_graph_pipeline = data_graph_pipeline;
        self
    }
}
impl Deref for DataGraphPipelineSessionCreateInfoARMBuilder {
    type Target = vk::DataGraphPipelineSessionCreateInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphPipelineSessionBindPointRequirementsInfoARMBuilder {
    inner: vk::DataGraphPipelineSessionBindPointRequirementsInfoARM,
}
impl Builder<'_> for vk::DataGraphPipelineSessionBindPointRequirementsInfoARM {
    type Type = DataGraphPipelineSessionBindPointRequirementsInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DataGraphPipelineSessionBindPointRequirementsInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DataGraphPipelineSessionBindPointRequirementsInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn session(mut self, session: vk::DataGraphPipelineSessionARM) -> Self {
        self.inner.session = session;
        self
    }
}
impl Deref for DataGraphPipelineSessionBindPointRequirementsInfoARMBuilder {
    type Target = vk::DataGraphPipelineSessionBindPointRequirementsInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphPipelineSessionBindPointRequirementARMBuilder {
    inner: vk::DataGraphPipelineSessionBindPointRequirementARM,
}
impl Builder<'_> for vk::DataGraphPipelineSessionBindPointRequirementARM {
    type Type = DataGraphPipelineSessionBindPointRequirementARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DataGraphPipelineSessionBindPointRequirementARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DataGraphPipelineSessionBindPointRequirementARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn bind_point(mut self, bind_point: vk::DataGraphPipelineSessionBindPointARM) -> Self {
        self.inner.bind_point = bind_point;
        self
    }
    pub fn bind_point_type(mut self, bind_point_type: vk::DataGraphPipelineSessionBindPointTypeARM) -> Self {
        self.inner.bind_point_type = bind_point_type;
        self
    }
    pub fn num_objects(mut self, num_objects: u32) -> Self {
        self.inner.num_objects = num_objects;
        self
    }
}
impl Deref for DataGraphPipelineSessionBindPointRequirementARMBuilder {
    type Target = vk::DataGraphPipelineSessionBindPointRequirementARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphPipelineSessionMemoryRequirementsInfoARMBuilder {
    inner: vk::DataGraphPipelineSessionMemoryRequirementsInfoARM,
}
impl Builder<'_> for vk::DataGraphPipelineSessionMemoryRequirementsInfoARM {
    type Type = DataGraphPipelineSessionMemoryRequirementsInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DataGraphPipelineSessionMemoryRequirementsInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DataGraphPipelineSessionMemoryRequirementsInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn session(mut self, session: vk::DataGraphPipelineSessionARM) -> Self {
        self.inner.session = session;
        self
    }
    pub fn bind_point(mut self, bind_point: vk::DataGraphPipelineSessionBindPointARM) -> Self {
        self.inner.bind_point = bind_point;
        self
    }
    pub fn object_index(mut self, object_index: u32) -> Self {
        self.inner.object_index = object_index;
        self
    }
}
impl Deref for DataGraphPipelineSessionMemoryRequirementsInfoARMBuilder {
    type Target = vk::DataGraphPipelineSessionMemoryRequirementsInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct BindDataGraphPipelineSessionMemoryInfoARMBuilder {
    inner: vk::BindDataGraphPipelineSessionMemoryInfoARM,
}
impl Builder<'_> for vk::BindDataGraphPipelineSessionMemoryInfoARM {
    type Type = BindDataGraphPipelineSessionMemoryInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl BindDataGraphPipelineSessionMemoryInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::BindDataGraphPipelineSessionMemoryInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn session(mut self, session: vk::DataGraphPipelineSessionARM) -> Self {
        self.inner.session = session;
        self
    }
    pub fn bind_point(mut self, bind_point: vk::DataGraphPipelineSessionBindPointARM) -> Self {
        self.inner.bind_point = bind_point;
        self
    }
    pub fn object_index(mut self, object_index: u32) -> Self {
        self.inner.object_index = object_index;
        self
    }
    pub fn memory(mut self, memory: vk::DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    pub fn memory_offset(mut self, memory_offset: vk::DeviceSize) -> Self {
        self.inner.memory_offset = memory_offset;
        self
    }
}
impl Deref for BindDataGraphPipelineSessionMemoryInfoARMBuilder {
    type Target = vk::BindDataGraphPipelineSessionMemoryInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphPipelineInfoARMBuilder {
    inner: vk::DataGraphPipelineInfoARM,
}
impl Builder<'_> for vk::DataGraphPipelineInfoARM {
    type Type = DataGraphPipelineInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DataGraphPipelineInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DataGraphPipelineInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn data_graph_pipeline(mut self, data_graph_pipeline: vk::Pipeline) -> Self {
        self.inner.data_graph_pipeline = data_graph_pipeline;
        self
    }
}
impl Deref for DataGraphPipelineInfoARMBuilder {
    type Target = vk::DataGraphPipelineInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphPipelinePropertyQueryResultARMBuilder<'a> {
    inner: vk::DataGraphPipelinePropertyQueryResultARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DataGraphPipelinePropertyQueryResultARM {
    type Type = DataGraphPipelinePropertyQueryResultARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DataGraphPipelinePropertyQueryResultARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DataGraphPipelinePropertyQueryResultARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn property(mut self, property: vk::DataGraphPipelinePropertyARM) -> Self {
        self.inner.property = property;
        self
    }
    pub fn is_text(mut self, is_text: bool) -> Self {
        self.inner.is_text = if is_text { vk::TRUE } else { vk::FALSE };
        self
    }
    pub fn p_data(mut self, p_data: &'a mut [u8]) -> Self {
        self.inner.data_size = p_data.len();
        self.inner.p_data = p_data.as_mut_ptr() as *mut _;
        self
    }
}
impl<'a> Deref for DataGraphPipelinePropertyQueryResultARMBuilder<'a> {
    type Target = vk::DataGraphPipelinePropertyQueryResultARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphPipelineIdentifierCreateInfoARMBuilder<'a> {
    inner: vk::DataGraphPipelineIdentifierCreateInfoARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DataGraphPipelineIdentifierCreateInfoARM {
    type Type = DataGraphPipelineIdentifierCreateInfoARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DataGraphPipelineIdentifierCreateInfoARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DataGraphPipelineIdentifierCreateInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_identifier(mut self, p_identifier: &'a [u8]) -> Self {
        self.inner.identifier_size = p_identifier.len() as u32;
        self.inner.p_identifier = p_identifier.as_ptr();
        self
    }
}
impl<'a> Deref for DataGraphPipelineIdentifierCreateInfoARMBuilder<'a> {
    type Target = vk::DataGraphPipelineIdentifierCreateInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DataGraphPipelineCreateInfoARMNext for vk::DataGraphPipelineIdentifierCreateInfoARM {}
impl DataGraphPipelineCreateInfoARMNext for DataGraphPipelineIdentifierCreateInfoARMBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphPipelineDispatchInfoARMBuilder {
    inner: vk::DataGraphPipelineDispatchInfoARM,
}
impl Builder<'_> for vk::DataGraphPipelineDispatchInfoARM {
    type Type = DataGraphPipelineDispatchInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl DataGraphPipelineDispatchInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::DataGraphPipelineDispatchInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn flags(mut self, flags: vk::DataGraphPipelineDispatchFlagsARM) -> Self {
        self.inner.flags = flags;
        self
    }
}
impl Deref for DataGraphPipelineDispatchInfoARMBuilder {
    type Target = vk::DataGraphPipelineDispatchInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDataGraphProcessingEngineARMBuilder {
    inner: vk::PhysicalDeviceDataGraphProcessingEngineARM,
}
impl Builder<'_> for vk::PhysicalDeviceDataGraphProcessingEngineARM {
    type Type = PhysicalDeviceDataGraphProcessingEngineARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDataGraphProcessingEngineARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDataGraphProcessingEngineARM {
        &mut self.inner
    }
    pub fn ty(mut self, ty: vk::PhysicalDeviceDataGraphProcessingEngineTypeARM) -> Self {
        self.inner.ty = ty;
        self
    }
    pub fn is_foreign(mut self, is_foreign: bool) -> Self {
        self.inner.is_foreign = if is_foreign { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceDataGraphProcessingEngineARMBuilder {
    type Target = vk::PhysicalDeviceDataGraphProcessingEngineARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceDataGraphOperationSupportARMBuilder {
    inner: vk::PhysicalDeviceDataGraphOperationSupportARM,
}
impl Builder<'_> for vk::PhysicalDeviceDataGraphOperationSupportARM {
    type Type = PhysicalDeviceDataGraphOperationSupportARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceDataGraphOperationSupportARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceDataGraphOperationSupportARM {
        &mut self.inner
    }
    pub fn operation_type(mut self, operation_type: vk::PhysicalDeviceDataGraphOperationTypeARM) -> Self {
        self.inner.operation_type = operation_type;
        self
    }
    pub fn name(mut self, name: [c_char; vk::MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM]) -> Self {
        self.inner.name = name;
        self
    }
    pub fn version(mut self, version: u32) -> Self {
        self.inner.version = version;
        self
    }
}
impl Deref for PhysicalDeviceDataGraphOperationSupportARMBuilder {
    type Target = vk::PhysicalDeviceDataGraphOperationSupportARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct QueueFamilyDataGraphPropertiesARMBuilder {
    inner: vk::QueueFamilyDataGraphPropertiesARM,
}
impl Builder<'_> for vk::QueueFamilyDataGraphPropertiesARM {
    type Type = QueueFamilyDataGraphPropertiesARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl QueueFamilyDataGraphPropertiesARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::QueueFamilyDataGraphPropertiesARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn engine(mut self, engine: vk::PhysicalDeviceDataGraphProcessingEngineARM) -> Self {
        self.inner.engine = engine;
        self
    }
    pub fn operation(mut self, operation: vk::PhysicalDeviceDataGraphOperationSupportARM) -> Self {
        self.inner.operation = operation;
        self
    }
}
impl Deref for QueueFamilyDataGraphPropertiesARMBuilder {
    type Target = vk::QueueFamilyDataGraphPropertiesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARMBuilder {
    inner: vk::PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM,
}
impl Builder<'_> for vk::PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM {
    type Type = PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.inner.queue_family_index = queue_family_index;
        self
    }
    pub fn engine_type(mut self, engine_type: vk::PhysicalDeviceDataGraphProcessingEngineTypeARM) -> Self {
        self.inner.engine_type = engine_type;
        self
    }
}
impl Deref for PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARMBuilder {
    type Target = vk::PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct QueueFamilyDataGraphProcessingEnginePropertiesARMBuilder {
    inner: vk::QueueFamilyDataGraphProcessingEnginePropertiesARM,
}
impl Builder<'_> for vk::QueueFamilyDataGraphProcessingEnginePropertiesARM {
    type Type = QueueFamilyDataGraphProcessingEnginePropertiesARMBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl QueueFamilyDataGraphProcessingEnginePropertiesARMBuilder {
    pub fn get_mut(&mut self) -> &mut vk::QueueFamilyDataGraphProcessingEnginePropertiesARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn foreign_semaphore_handle_types(
        mut self,
        foreign_semaphore_handle_types: vk::ExternalSemaphoreHandleTypeFlags,
    ) -> Self {
        self.inner.foreign_semaphore_handle_types = foreign_semaphore_handle_types;
        self
    }
    pub fn foreign_memory_handle_types(
        mut self,
        foreign_memory_handle_types: vk::ExternalMemoryHandleTypeFlags,
    ) -> Self {
        self.inner.foreign_memory_handle_types = foreign_memory_handle_types;
        self
    }
}
impl Deref for QueueFamilyDataGraphProcessingEnginePropertiesARMBuilder {
    type Target = vk::QueueFamilyDataGraphProcessingEnginePropertiesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[repr(transparent)]
#[derive(Default)]
pub struct DataGraphProcessingEngineCreateInfoARMBuilder<'a> {
    inner: vk::DataGraphProcessingEngineCreateInfoARM,
    phantom: PhantomData<&'a ()>,
}
impl<'a> Builder<'a> for vk::DataGraphProcessingEngineCreateInfoARM {
    type Type = DataGraphProcessingEngineCreateInfoARMBuilder<'a>;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl<'a> DataGraphProcessingEngineCreateInfoARMBuilder<'a> {
    pub fn get_mut(&mut self) -> &mut vk::DataGraphProcessingEngineCreateInfoARM {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *const c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn p_processing_engines(
        mut self,
        p_processing_engines: &'a mut [vk::PhysicalDeviceDataGraphProcessingEngineARM],
    ) -> Self {
        self.inner.processing_engine_count = p_processing_engines.len() as u32;
        self.inner.p_processing_engines = p_processing_engines.as_mut_ptr();
        self
    }
}
impl<'a> Deref for DataGraphProcessingEngineCreateInfoARMBuilder<'a> {
    type Target = vk::DataGraphProcessingEngineCreateInfoARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl DataGraphPipelineCreateInfoARMNext for vk::DataGraphProcessingEngineCreateInfoARM {}
impl DataGraphPipelineCreateInfoARMNext for DataGraphProcessingEngineCreateInfoARMBuilder<'_> {}
impl DescriptorPoolCreateInfoNext for vk::DataGraphProcessingEngineCreateInfoARM {}
impl DescriptorPoolCreateInfoNext for DataGraphProcessingEngineCreateInfoARMBuilder<'_> {}
impl CommandPoolCreateInfoNext for vk::DataGraphProcessingEngineCreateInfoARM {}
impl CommandPoolCreateInfoNext for DataGraphProcessingEngineCreateInfoARMBuilder<'_> {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDevicePipelineCacheIncrementalModeFeaturesSECBuilder {
    inner: vk::PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC,
}
impl Builder<'_> for vk::PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC {
    type Type = PhysicalDevicePipelineCacheIncrementalModeFeaturesSECBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDevicePipelineCacheIncrementalModeFeaturesSECBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn pipeline_cache_incremental_mode(mut self, pipeline_cache_incremental_mode: bool) -> Self {
        self.inner.pipeline_cache_incremental_mode = if pipeline_cache_incremental_mode {
            vk::TRUE
        } else {
            vk::FALSE
        };
        self
    }
}
impl Deref for PhysicalDevicePipelineCacheIncrementalModeFeaturesSECBuilder {
    type Target = vk::PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC {}
impl PhysicalDeviceFeatures2Next for PhysicalDevicePipelineCacheIncrementalModeFeaturesSECBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC {}
impl DeviceCreateInfoNext for PhysicalDevicePipelineCacheIncrementalModeFeaturesSECBuilder {}

#[repr(transparent)]
#[derive(Default)]
pub struct PhysicalDeviceShaderUntypedPointersFeaturesKHRBuilder {
    inner: vk::PhysicalDeviceShaderUntypedPointersFeaturesKHR,
}
impl Builder<'_> for vk::PhysicalDeviceShaderUntypedPointersFeaturesKHR {
    type Type = PhysicalDeviceShaderUntypedPointersFeaturesKHRBuilder;
    fn builder() -> Self::Type {
        Default::default()
    }
}
impl PhysicalDeviceShaderUntypedPointersFeaturesKHRBuilder {
    pub fn get_mut(&mut self) -> &mut vk::PhysicalDeviceShaderUntypedPointersFeaturesKHR {
        &mut self.inner
    }
    pub fn p_next(mut self, p_next: *mut c_void) -> Self {
        self.inner.p_next = p_next;
        self
    }
    pub fn shader_untyped_pointers(mut self, shader_untyped_pointers: bool) -> Self {
        self.inner.shader_untyped_pointers = if shader_untyped_pointers { vk::TRUE } else { vk::FALSE };
        self
    }
}
impl Deref for PhysicalDeviceShaderUntypedPointersFeaturesKHRBuilder {
    type Target = vk::PhysicalDeviceShaderUntypedPointersFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl PhysicalDeviceFeatures2Next for vk::PhysicalDeviceShaderUntypedPointersFeaturesKHR {}
impl PhysicalDeviceFeatures2Next for PhysicalDeviceShaderUntypedPointersFeaturesKHRBuilder {}
impl DeviceCreateInfoNext for vk::PhysicalDeviceShaderUntypedPointersFeaturesKHR {}
impl DeviceCreateInfoNext for PhysicalDeviceShaderUntypedPointersFeaturesKHRBuilder {}
