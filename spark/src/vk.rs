#![allow(clippy::too_many_arguments, clippy::unreadable_literal)]

use std::{
    default::Default,
    ffi::CStr,
    fmt, mem, num, ops,
    os::raw::{c_char, c_int, c_ulong, c_void},
    ptr,
};

/// Wrapper around Vulkan API version number
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct Version(u32);
impl Version {
    /// Forms a version number from major, minor and patch numbers
    ///
    /// ```
    /// # use spark::vk;
    /// let v = vk::Version::from_raw_parts(1, 2, 0);
    /// assert_eq!(v.to_raw(), (1 << 22) | (2 << 12));
    /// ```
    pub const fn from_raw_parts(major: u32, minor: u32, patch: u32) -> Self {
        Self((major << 22) | ((minor & 0x3ff) << 12) | (patch & 0xfff))
    }

    pub const fn from_raw(version: u32) -> Self {
        Self(version)
    }
    pub fn to_raw(self) -> u32 {
        self.0
    }

    pub fn get_major(self) -> u32 {
        self.0 >> 22
    }
    pub fn get_minor(self) -> u32 {
        (self.0 >> 12) & 0x3ff
    }
    pub fn get_patch(self) -> u32 {
        self.0 & 0xfff
    }
}
impl Default for Version {
    fn default() -> Self {
        Self::from_raw_parts(1, 0, 0)
    }
}
impl fmt::Display for Version {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}.{}.{}", self.get_major(), self.get_minor(), self.get_patch())
    }
}

// TODO: replace with ! type when stable
#[doc(hidden)]
pub enum Never {}

// X11
pub type Display = Never;
pub type VisualID = c_ulong;
pub type Window = c_ulong;
pub type RROutput = c_ulong;

// MIR
pub type MirConnection = Never;
pub type MirSurface = Never;

// wayland
#[allow(non_camel_case_types)]
pub type wl_display = Never;
#[allow(non_camel_case_types)]
pub type wl_surface = Never;

// windows
pub type HINSTANCE = *mut c_void;
pub type HWND = *mut c_void;
pub type HANDLE = *mut c_void;
pub type HMONITOR = *mut c_void;
#[allow(non_camel_case_types)]
pub type SECURITY_ATTRIBUTES = Never;
pub type DWORD = c_ulong;
pub type LPCWSTR = *const u16;

#[allow(non_camel_case_types)]
pub type xcb_connection_t = Never;
#[allow(non_camel_case_types)]
pub type xcb_window_t = u32;
#[allow(non_camel_case_types)]
pub type xcb_visualid_t = Never;

pub type IDirectFB = Never;
pub type IDirectFBSurface = Never;

// Android
pub type ANativeWindow = Never;
pub type AHardwareBuffer = Never;

// Metal
pub type CAMetalLayer = Never;
#[allow(non_camel_case_types)]
pub type MTLDevice_id = *mut c_void;
#[allow(non_camel_case_types)]
pub type MTLCommandQueue_id = *mut c_void;
#[allow(non_camel_case_types)]
pub type MTLBuffer_id = *mut c_void;
#[allow(non_camel_case_types)]
pub type MTLTexture_id = *mut c_void;
#[allow(non_camel_case_types)]
pub type MTLSharedEvent_id = *mut c_void;
#[allow(non_camel_case_types)]
pub type __IOSurface = Never;
pub type IOSurfaceRef = *mut __IOSurface;

// Zircon
#[allow(non_camel_case_types)]
pub type zx_handle_t = u32;

fn display_bitmask(bits: u64, bit_names: &[(u64, &str)], f: &mut fmt::Formatter) -> fmt::Result {
    let mut has_output = false;
    let mut remain = bits;
    for (bit, name) in bit_names.iter().copied() {
        if (remain & bit) == bit {
            if has_output {
                f.write_str(" | ")?;
            }
            write!(f, "{}", name)?;
            has_output = true;
            remain &= !bit;
        }
    }
    if remain != 0 {
        if has_output {
            f.write_str(" | ")?;
        }
        write!(f, "{:#x}", remain)?;
        has_output = true;
    }
    if !has_output {
        f.write_str("0")?;
    }
    Ok(())
}

macro_rules! impl_bitmask {
    ($name:ident, $all_bits:literal) => {
        impl $name {
            pub fn empty() -> Self {
                Self(0)
            }
            pub fn all() -> Self {
                Self($all_bits)
            }
            pub fn is_empty(self) -> bool {
                self.0 == 0
            }
            pub fn is_all(self) -> bool {
                self.0 == $all_bits
            }
            pub fn intersects(self, other: Self) -> bool {
                (self.0 & other.0) != 0
            }
            pub fn contains(self, other: Self) -> bool {
                (self.0 & other.0) == other.0
            }
        }
        impl ops::BitOr for $name {
            type Output = Self;
            fn bitor(self, rhs: Self) -> Self {
                Self(self.0 | rhs.0)
            }
        }
        impl ops::BitOrAssign for $name {
            fn bitor_assign(&mut self, rhs: Self) {
                self.0 |= rhs.0;
            }
        }
        impl ops::BitAnd for $name {
            type Output = Self;
            fn bitand(self, rhs: Self) -> Self {
                Self(self.0 & rhs.0)
            }
        }
        impl ops::BitAndAssign for $name {
            fn bitand_assign(&mut self, rhs: Self) {
                self.0 &= rhs.0;
            }
        }
        impl ops::BitXor for $name {
            type Output = Self;
            fn bitxor(self, rhs: Self) -> Self {
                Self(self.0 ^ rhs.0)
            }
        }
        impl ops::BitXorAssign for $name {
            fn bitxor_assign(&mut self, rhs: Self) {
                self.0 ^= rhs.0;
            }
        }
    };
}
pub const MAX_PHYSICAL_DEVICE_NAME_SIZE: usize = 256;
pub const UUID_SIZE: usize = 16;
pub const LUID_SIZE: usize = 8;
pub const LUID_SIZE_KHR: usize = LUID_SIZE;
pub const MAX_EXTENSION_NAME_SIZE: usize = 256;
pub const MAX_DESCRIPTION_SIZE: usize = 256;
pub const MAX_MEMORY_TYPES: usize = 32;
pub const MAX_MEMORY_HEAPS: usize = 16;
pub const LOD_CLAMP_NONE: f32 = 1000_f32;
pub const REMAINING_MIP_LEVELS: u32 = 0xffffffff;
pub const REMAINING_ARRAY_LAYERS: u32 = 0xffffffff;
pub const WHOLE_SIZE: u64 = 0xffffffffffffffff;
pub const ATTACHMENT_UNUSED: u32 = 0xffffffff;
pub const TRUE: Bool32 = 1;
pub const FALSE: Bool32 = 0;
pub const QUEUE_FAMILY_IGNORED: u32 = 0xffffffff;
pub const QUEUE_FAMILY_EXTERNAL: u32 = 0xfffffffe;
pub const QUEUE_FAMILY_EXTERNAL_KHR: u32 = QUEUE_FAMILY_EXTERNAL;
pub const QUEUE_FAMILY_FOREIGN_EXT: u32 = 0xfffffffd;
pub const SUBPASS_EXTERNAL: u32 = 0xffffffff;
pub const MAX_DEVICE_GROUP_SIZE: usize = 32;
pub const MAX_DEVICE_GROUP_SIZE_KHR: usize = MAX_DEVICE_GROUP_SIZE;
pub const MAX_DRIVER_NAME_SIZE: usize = 256;
pub const MAX_DRIVER_NAME_SIZE_KHR: usize = MAX_DRIVER_NAME_SIZE;
pub const MAX_DRIVER_INFO_SIZE: usize = 256;
pub const MAX_DRIVER_INFO_SIZE_KHR: usize = MAX_DRIVER_INFO_SIZE;
pub const SHADER_UNUSED_KHR: u32 = 0xffffffff;
pub const SHADER_UNUSED_NV: u32 = SHADER_UNUSED_KHR;
pub const MAX_GLOBAL_PRIORITY_SIZE_KHR: usize = 16;
pub const MAX_GLOBAL_PRIORITY_SIZE_EXT: usize = MAX_GLOBAL_PRIORITY_SIZE_KHR;
pub type SampleMask = u32;
pub type Bool32 = u32;
pub type Flags = u32;
pub type Flags64 = u64;
pub type DeviceSize = u64;
pub type DeviceAddress = u64;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct FramebufferCreateFlags(u32);
impl FramebufferCreateFlags {
    pub const IMAGELESS: Self = Self(0x1);
    pub const IMAGELESS_KHR: Self = Self::IMAGELESS;
}
impl_bitmask!(FramebufferCreateFlags, 0x1);
impl fmt::Display for FramebufferCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "IMAGELESS")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct QueryPoolCreateFlags(u32);
impl QueryPoolCreateFlags {}
impl_bitmask!(QueryPoolCreateFlags, 0x0);
impl fmt::Display for QueryPoolCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct RenderPassCreateFlags(u32);
impl RenderPassCreateFlags {
    /// Added by extension VK_QCOM_render_pass_transform.
    pub const TRANSFORM_QCOM: Self = Self(0x2);
}
impl_bitmask!(RenderPassCreateFlags, 0x2);
impl fmt::Display for RenderPassCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x2, "TRANSFORM_QCOM")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SamplerCreateFlags(u32);
impl SamplerCreateFlags {
    /// Added by extension VK_EXT_fragment_density_map.
    pub const SUBSAMPLED_EXT: Self = Self(0x1);
    /// Added by extension VK_EXT_fragment_density_map.
    pub const SUBSAMPLED_COARSE_RECONSTRUCTION_EXT: Self = Self(0x2);
    /// Added by extension VK_EXT_non_seamless_cube_map.
    pub const NON_SEAMLESS_CUBE_MAP_EXT: Self = Self(0x4);
}
impl_bitmask!(SamplerCreateFlags, 0x7);
impl fmt::Display for SamplerCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "SUBSAMPLED_EXT"),
                (0x2, "SUBSAMPLED_COARSE_RECONSTRUCTION_EXT"),
                (0x4, "NON_SEAMLESS_CUBE_MAP_EXT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineLayoutCreateFlags(u32);
impl PipelineLayoutCreateFlags {
    /// Added by extension VK_EXT_graphics_pipeline_library.
    pub const INDEPENDENT_SETS_EXT: Self = Self(0x2);
}
impl_bitmask!(PipelineLayoutCreateFlags, 0x2);
impl fmt::Display for PipelineLayoutCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x2, "INDEPENDENT_SETS_EXT")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineCacheCreateFlags(u32);
impl PipelineCacheCreateFlags {
    pub const EXTERNALLY_SYNCHRONIZED: Self = Self(0x1);
    pub const EXTERNALLY_SYNCHRONIZED_EXT: Self = Self::EXTERNALLY_SYNCHRONIZED;
}
impl_bitmask!(PipelineCacheCreateFlags, 0x1);
impl fmt::Display for PipelineCacheCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "EXTERNALLY_SYNCHRONIZED")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineDepthStencilStateCreateFlags(u32);
impl PipelineDepthStencilStateCreateFlags {
    /// Added by extension VK_ARM_rasterization_order_attachment_access.
    pub const RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM: Self = Self(0x1);
    /// Added by extension VK_ARM_rasterization_order_attachment_access.
    pub const RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM: Self = Self(0x2);
}
impl_bitmask!(PipelineDepthStencilStateCreateFlags, 0x3);
impl fmt::Display for PipelineDepthStencilStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM"),
                (0x2, "RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineDynamicStateCreateFlags(u32);
impl PipelineDynamicStateCreateFlags {}
impl_bitmask!(PipelineDynamicStateCreateFlags, 0x0);
impl fmt::Display for PipelineDynamicStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineColorBlendStateCreateFlags(u32);
impl PipelineColorBlendStateCreateFlags {
    /// Added by extension VK_ARM_rasterization_order_attachment_access.
    pub const RASTERIZATION_ORDER_ATTACHMENT_ACCESS_ARM: Self = Self(0x1);
}
impl_bitmask!(PipelineColorBlendStateCreateFlags, 0x1);
impl fmt::Display for PipelineColorBlendStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "RASTERIZATION_ORDER_ATTACHMENT_ACCESS_ARM")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineMultisampleStateCreateFlags(u32);
impl PipelineMultisampleStateCreateFlags {}
impl_bitmask!(PipelineMultisampleStateCreateFlags, 0x0);
impl fmt::Display for PipelineMultisampleStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineRasterizationStateCreateFlags(u32);
impl PipelineRasterizationStateCreateFlags {}
impl_bitmask!(PipelineRasterizationStateCreateFlags, 0x0);
impl fmt::Display for PipelineRasterizationStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineViewportStateCreateFlags(u32);
impl PipelineViewportStateCreateFlags {}
impl_bitmask!(PipelineViewportStateCreateFlags, 0x0);
impl fmt::Display for PipelineViewportStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineTessellationStateCreateFlags(u32);
impl PipelineTessellationStateCreateFlags {}
impl_bitmask!(PipelineTessellationStateCreateFlags, 0x0);
impl fmt::Display for PipelineTessellationStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineInputAssemblyStateCreateFlags(u32);
impl PipelineInputAssemblyStateCreateFlags {}
impl_bitmask!(PipelineInputAssemblyStateCreateFlags, 0x0);
impl fmt::Display for PipelineInputAssemblyStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineVertexInputStateCreateFlags(u32);
impl PipelineVertexInputStateCreateFlags {}
impl_bitmask!(PipelineVertexInputStateCreateFlags, 0x0);
impl fmt::Display for PipelineVertexInputStateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineShaderStageCreateFlags(u32);
impl PipelineShaderStageCreateFlags {
    pub const ALLOW_VARYING_SUBGROUP_SIZE: Self = Self(0x1);
    pub const REQUIRE_FULL_SUBGROUPS: Self = Self(0x2);
    pub const ALLOW_VARYING_SUBGROUP_SIZE_EXT: Self = Self::ALLOW_VARYING_SUBGROUP_SIZE;
    pub const REQUIRE_FULL_SUBGROUPS_EXT: Self = Self::REQUIRE_FULL_SUBGROUPS;
}
impl_bitmask!(PipelineShaderStageCreateFlags, 0x3);
impl fmt::Display for PipelineShaderStageCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "ALLOW_VARYING_SUBGROUP_SIZE"), (0x2, "REQUIRE_FULL_SUBGROUPS")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DescriptorSetLayoutCreateFlags(u32);
impl DescriptorSetLayoutCreateFlags {
    pub const UPDATE_AFTER_BIND_POOL: Self = Self(0x2);
    /// Descriptors are pushed via flink:vkCmdPushDescriptorSetKHR
    /// Added by extension VK_KHR_push_descriptor.
    pub const PUSH_DESCRIPTOR_KHR: Self = Self(0x1);
    pub const UPDATE_AFTER_BIND_POOL_EXT: Self = Self::UPDATE_AFTER_BIND_POOL;
    /// Added by extension VK_VALVE_mutable_descriptor_type.
    pub const HOST_ONLY_POOL_VALVE: Self = Self(0x4);
}
impl_bitmask!(DescriptorSetLayoutCreateFlags, 0x7);
impl fmt::Display for DescriptorSetLayoutCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x2, "UPDATE_AFTER_BIND_POOL"),
                (0x1, "PUSH_DESCRIPTOR_KHR"),
                (0x4, "HOST_ONLY_POOL_VALVE"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct BufferViewCreateFlags(u32);
impl BufferViewCreateFlags {}
impl_bitmask!(BufferViewCreateFlags, 0x0);
impl fmt::Display for BufferViewCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct InstanceCreateFlags(u32);
impl InstanceCreateFlags {
    /// Added by extension VK_KHR_portability_enumeration.
    pub const ENUMERATE_PORTABILITY_KHR: Self = Self(0x1);
}
impl_bitmask!(InstanceCreateFlags, 0x1);
impl fmt::Display for InstanceCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "ENUMERATE_PORTABILITY_KHR")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DeviceCreateFlags(u32);
impl DeviceCreateFlags {}
impl_bitmask!(DeviceCreateFlags, 0x0);
impl fmt::Display for DeviceCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DeviceQueueCreateFlags(u32);
impl DeviceQueueCreateFlags {
    /// Queue is a protected-capable device queue
    pub const PROTECTED: Self = Self(0x1);
}
impl_bitmask!(DeviceQueueCreateFlags, 0x1);
impl fmt::Display for DeviceQueueCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "PROTECTED")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct QueueFlags(u32);
impl QueueFlags {
    /// Queue supports graphics operations
    pub const GRAPHICS: Self = Self(0x1);
    /// Queue supports compute operations
    pub const COMPUTE: Self = Self(0x2);
    /// Queue supports transfer operations
    pub const TRANSFER: Self = Self(0x4);
    /// Queue supports sparse resource memory management operations
    pub const SPARSE_BINDING: Self = Self(0x8);
    /// Queues may support protected operations
    pub const PROTECTED: Self = Self(0x10);
}
impl_bitmask!(QueueFlags, 0x1f);
impl fmt::Display for QueueFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "GRAPHICS"),
                (0x2, "COMPUTE"),
                (0x4, "TRANSFER"),
                (0x8, "SPARSE_BINDING"),
                (0x10, "PROTECTED"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct MemoryPropertyFlags(u32);
impl MemoryPropertyFlags {
    /// If otherwise stated, then allocate memory on device
    pub const DEVICE_LOCAL: Self = Self(0x1);
    /// Memory is mappable by host
    pub const HOST_VISIBLE: Self = Self(0x2);
    /// Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache
    pub const HOST_COHERENT: Self = Self(0x4);
    /// Memory will be cached by the host
    pub const HOST_CACHED: Self = Self(0x8);
    /// Memory may be allocated by the driver when it is required
    pub const LAZILY_ALLOCATED: Self = Self(0x10);
    /// Memory is protected
    pub const PROTECTED: Self = Self(0x20);
    /// Added by extension VK_AMD_device_coherent_memory.
    pub const DEVICE_COHERENT_AMD: Self = Self(0x40);
    /// Added by extension VK_AMD_device_coherent_memory.
    pub const DEVICE_UNCACHED_AMD: Self = Self(0x80);
    /// Added by extension VK_NV_external_memory_rdma.
    pub const RDMA_CAPABLE_NV: Self = Self(0x100);
}
impl_bitmask!(MemoryPropertyFlags, 0x1ff);
impl fmt::Display for MemoryPropertyFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "DEVICE_LOCAL"),
                (0x2, "HOST_VISIBLE"),
                (0x4, "HOST_COHERENT"),
                (0x8, "HOST_CACHED"),
                (0x10, "LAZILY_ALLOCATED"),
                (0x20, "PROTECTED"),
                (0x40, "DEVICE_COHERENT_AMD"),
                (0x80, "DEVICE_UNCACHED_AMD"),
                (0x100, "RDMA_CAPABLE_NV"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct MemoryHeapFlags(u32);
impl MemoryHeapFlags {
    /// If set, heap represents device memory
    pub const DEVICE_LOCAL: Self = Self(0x1);
    /// If set, heap allocations allocate multiple instances by default
    pub const MULTI_INSTANCE: Self = Self(0x2);
    pub const MULTI_INSTANCE_KHR: Self = Self::MULTI_INSTANCE;
}
impl_bitmask!(MemoryHeapFlags, 0x3);
impl fmt::Display for MemoryHeapFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "DEVICE_LOCAL"), (0x2, "MULTI_INSTANCE")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct AccessFlags(u32);
impl AccessFlags {
    /// Controls coherency of indirect command reads
    pub const INDIRECT_COMMAND_READ: Self = Self(0x1);
    /// Controls coherency of index reads
    pub const INDEX_READ: Self = Self(0x2);
    /// Controls coherency of vertex attribute reads
    pub const VERTEX_ATTRIBUTE_READ: Self = Self(0x4);
    /// Controls coherency of uniform buffer reads
    pub const UNIFORM_READ: Self = Self(0x8);
    /// Controls coherency of input attachment reads
    pub const INPUT_ATTACHMENT_READ: Self = Self(0x10);
    /// Controls coherency of shader reads
    pub const SHADER_READ: Self = Self(0x20);
    /// Controls coherency of shader writes
    pub const SHADER_WRITE: Self = Self(0x40);
    /// Controls coherency of color attachment reads
    pub const COLOR_ATTACHMENT_READ: Self = Self(0x80);
    /// Controls coherency of color attachment writes
    pub const COLOR_ATTACHMENT_WRITE: Self = Self(0x100);
    /// Controls coherency of depth/stencil attachment reads
    pub const DEPTH_STENCIL_ATTACHMENT_READ: Self = Self(0x200);
    /// Controls coherency of depth/stencil attachment writes
    pub const DEPTH_STENCIL_ATTACHMENT_WRITE: Self = Self(0x400);
    /// Controls coherency of transfer reads
    pub const TRANSFER_READ: Self = Self(0x800);
    /// Controls coherency of transfer writes
    pub const TRANSFER_WRITE: Self = Self(0x1000);
    /// Controls coherency of host reads
    pub const HOST_READ: Self = Self(0x2000);
    /// Controls coherency of host writes
    pub const HOST_WRITE: Self = Self(0x4000);
    /// Controls coherency of memory reads
    pub const MEMORY_READ: Self = Self(0x8000);
    /// Controls coherency of memory writes
    pub const MEMORY_WRITE: Self = Self(0x10000);
    pub const NONE: Self = Self(0x0);
    /// Added by extension VK_EXT_transform_feedback.
    pub const TRANSFORM_FEEDBACK_WRITE_EXT: Self = Self(0x2000000);
    /// Added by extension VK_EXT_transform_feedback.
    pub const TRANSFORM_FEEDBACK_COUNTER_READ_EXT: Self = Self(0x4000000);
    /// Added by extension VK_EXT_transform_feedback.
    pub const TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT: Self = Self(0x8000000);
    /// read access flag for reading conditional rendering predicate
    /// Added by extension VK_EXT_conditional_rendering.
    pub const CONDITIONAL_RENDERING_READ_EXT: Self = Self(0x100000);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const COLOR_ATTACHMENT_READ_NONCOHERENT_EXT: Self = Self(0x80000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_READ_KHR: Self = Self(0x200000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_WRITE_KHR: Self = Self(0x400000);
    pub const SHADING_RATE_IMAGE_READ_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR;
    pub const ACCELERATION_STRUCTURE_READ_NV: Self = Self::ACCELERATION_STRUCTURE_READ_KHR;
    pub const ACCELERATION_STRUCTURE_WRITE_NV: Self = Self::ACCELERATION_STRUCTURE_WRITE_KHR;
    /// Added by extension VK_EXT_fragment_density_map.
    pub const FRAGMENT_DENSITY_MAP_READ_EXT: Self = Self(0x1000000);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR: Self = Self(0x800000);
    /// Added by extension VK_NV_device_generated_commands.
    pub const COMMAND_PREPROCESS_READ_NV: Self = Self(0x20000);
    /// Added by extension VK_NV_device_generated_commands.
    pub const COMMAND_PREPROCESS_WRITE_NV: Self = Self(0x40000);
    pub const NONE_KHR: Self = Self::NONE;
}
impl_bitmask!(AccessFlags, 0xfffffff);
impl fmt::Display for AccessFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "INDIRECT_COMMAND_READ"),
                (0x2, "INDEX_READ"),
                (0x4, "VERTEX_ATTRIBUTE_READ"),
                (0x8, "UNIFORM_READ"),
                (0x10, "INPUT_ATTACHMENT_READ"),
                (0x20, "SHADER_READ"),
                (0x40, "SHADER_WRITE"),
                (0x80, "COLOR_ATTACHMENT_READ"),
                (0x100, "COLOR_ATTACHMENT_WRITE"),
                (0x200, "DEPTH_STENCIL_ATTACHMENT_READ"),
                (0x400, "DEPTH_STENCIL_ATTACHMENT_WRITE"),
                (0x800, "TRANSFER_READ"),
                (0x1000, "TRANSFER_WRITE"),
                (0x2000, "HOST_READ"),
                (0x4000, "HOST_WRITE"),
                (0x8000, "MEMORY_READ"),
                (0x10000, "MEMORY_WRITE"),
                (0x2000000, "TRANSFORM_FEEDBACK_WRITE_EXT"),
                (0x4000000, "TRANSFORM_FEEDBACK_COUNTER_READ_EXT"),
                (0x8000000, "TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT"),
                (0x100000, "CONDITIONAL_RENDERING_READ_EXT"),
                (0x80000, "COLOR_ATTACHMENT_READ_NONCOHERENT_EXT"),
                (0x200000, "ACCELERATION_STRUCTURE_READ_KHR"),
                (0x400000, "ACCELERATION_STRUCTURE_WRITE_KHR"),
                (0x1000000, "FRAGMENT_DENSITY_MAP_READ_EXT"),
                (0x800000, "FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR"),
                (0x20000, "COMMAND_PREPROCESS_READ_NV"),
                (0x40000, "COMMAND_PREPROCESS_WRITE_NV"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct BufferUsageFlags(u32);
impl BufferUsageFlags {
    /// Can be used as a source of transfer operations
    pub const TRANSFER_SRC: Self = Self(0x1);
    /// Can be used as a destination of transfer operations
    pub const TRANSFER_DST: Self = Self(0x2);
    /// Can be used as TBO
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(0x4);
    /// Can be used as IBO
    pub const STORAGE_TEXEL_BUFFER: Self = Self(0x8);
    /// Can be used as UBO
    pub const UNIFORM_BUFFER: Self = Self(0x10);
    /// Can be used as SSBO
    pub const STORAGE_BUFFER: Self = Self(0x20);
    /// Can be used as source of fixed-function index fetch (index buffer)
    pub const INDEX_BUFFER: Self = Self(0x40);
    /// Can be used as source of fixed-function vertex fetch (VBO)
    pub const VERTEX_BUFFER: Self = Self(0x80);
    /// Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)
    pub const INDIRECT_BUFFER: Self = Self(0x100);
    pub const SHADER_DEVICE_ADDRESS: Self = Self(0x20000);
    /// Added by extension VK_EXT_transform_feedback.
    pub const TRANSFORM_FEEDBACK_BUFFER_EXT: Self = Self(0x800);
    /// Added by extension VK_EXT_transform_feedback.
    pub const TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT: Self = Self(0x1000);
    /// Specifies the buffer can be used as predicate in conditional rendering
    /// Added by extension VK_EXT_conditional_rendering.
    pub const CONDITIONAL_RENDERING_EXT: Self = Self(0x200);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR: Self = Self(0x80000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_STORAGE_KHR: Self = Self(0x100000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const SHADER_BINDING_TABLE_KHR: Self = Self(0x400);
    pub const RAY_TRACING_NV: Self = Self::SHADER_BINDING_TABLE_KHR;
    pub const SHADER_DEVICE_ADDRESS_EXT: Self = Self::SHADER_DEVICE_ADDRESS;
    pub const SHADER_DEVICE_ADDRESS_KHR: Self = Self::SHADER_DEVICE_ADDRESS;
}
impl_bitmask!(BufferUsageFlags, 0x1a1fff);
impl fmt::Display for BufferUsageFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "TRANSFER_SRC"),
                (0x2, "TRANSFER_DST"),
                (0x4, "UNIFORM_TEXEL_BUFFER"),
                (0x8, "STORAGE_TEXEL_BUFFER"),
                (0x10, "UNIFORM_BUFFER"),
                (0x20, "STORAGE_BUFFER"),
                (0x40, "INDEX_BUFFER"),
                (0x80, "VERTEX_BUFFER"),
                (0x100, "INDIRECT_BUFFER"),
                (0x20000, "SHADER_DEVICE_ADDRESS"),
                (0x800, "TRANSFORM_FEEDBACK_BUFFER_EXT"),
                (0x1000, "TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT"),
                (0x200, "CONDITIONAL_RENDERING_EXT"),
                (0x80000, "ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR"),
                (0x100000, "ACCELERATION_STRUCTURE_STORAGE_KHR"),
                (0x400, "SHADER_BINDING_TABLE_KHR"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct BufferCreateFlags(u32);
impl BufferCreateFlags {
    /// Buffer should support sparse backing
    pub const SPARSE_BINDING: Self = Self(0x1);
    /// Buffer should support sparse backing with partial residency
    pub const SPARSE_RESIDENCY: Self = Self(0x2);
    /// Buffer should support constant data access to physical memory ranges mapped into multiple locations of sparse buffers
    pub const SPARSE_ALIASED: Self = Self(0x4);
    /// Buffer requires protected memory
    pub const PROTECTED: Self = Self(0x8);
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY: Self = Self(0x10);
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_EXT: Self = Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_KHR: Self = Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
}
impl_bitmask!(BufferCreateFlags, 0x1f);
impl fmt::Display for BufferCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "SPARSE_BINDING"),
                (0x2, "SPARSE_RESIDENCY"),
                (0x4, "SPARSE_ALIASED"),
                (0x8, "PROTECTED"),
                (0x10, "DEVICE_ADDRESS_CAPTURE_REPLAY"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ShaderStageFlags(u32);
impl ShaderStageFlags {
    pub const VERTEX: Self = Self(0x1);
    pub const TESSELLATION_CONTROL: Self = Self(0x2);
    pub const TESSELLATION_EVALUATION: Self = Self(0x4);
    pub const GEOMETRY: Self = Self(0x8);
    pub const FRAGMENT: Self = Self(0x10);
    pub const COMPUTE: Self = Self(0x20);
    pub const ALL_GRAPHICS: Self = Self(0x1f);
    pub const ALL: Self = Self(0x7fffffff);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAYGEN_KHR: Self = Self(0x100);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const ANY_HIT_KHR: Self = Self(0x200);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const CLOSEST_HIT_KHR: Self = Self(0x400);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const MISS_KHR: Self = Self(0x800);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const INTERSECTION_KHR: Self = Self(0x1000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const CALLABLE_KHR: Self = Self(0x2000);
    pub const RAYGEN_NV: Self = Self::RAYGEN_KHR;
    pub const ANY_HIT_NV: Self = Self::ANY_HIT_KHR;
    pub const CLOSEST_HIT_NV: Self = Self::CLOSEST_HIT_KHR;
    pub const MISS_NV: Self = Self::MISS_KHR;
    pub const INTERSECTION_NV: Self = Self::INTERSECTION_KHR;
    pub const CALLABLE_NV: Self = Self::CALLABLE_KHR;
    /// Added by extension VK_NV_mesh_shader.
    pub const TASK_NV: Self = Self(0x40);
    /// Added by extension VK_NV_mesh_shader.
    pub const MESH_NV: Self = Self(0x80);
    /// Added by extension VK_HUAWEI_subpass_shading.
    pub const SUBPASS_SHADING_HUAWEI: Self = Self(0x4000);
}
impl_bitmask!(ShaderStageFlags, 0x7fffffff);
impl fmt::Display for ShaderStageFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "VERTEX"),
                (0x2, "TESSELLATION_CONTROL"),
                (0x4, "TESSELLATION_EVALUATION"),
                (0x8, "GEOMETRY"),
                (0x10, "FRAGMENT"),
                (0x20, "COMPUTE"),
                (0x1f, "ALL_GRAPHICS"),
                (0x7fffffff, "ALL"),
                (0x100, "RAYGEN_KHR"),
                (0x200, "ANY_HIT_KHR"),
                (0x400, "CLOSEST_HIT_KHR"),
                (0x800, "MISS_KHR"),
                (0x1000, "INTERSECTION_KHR"),
                (0x2000, "CALLABLE_KHR"),
                (0x40, "TASK_NV"),
                (0x80, "MESH_NV"),
                (0x4000, "SUBPASS_SHADING_HUAWEI"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImageUsageFlags(u32);
impl ImageUsageFlags {
    /// Can be used as a source of transfer operations
    pub const TRANSFER_SRC: Self = Self(0x1);
    /// Can be used as a destination of transfer operations
    pub const TRANSFER_DST: Self = Self(0x2);
    /// Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
    pub const SAMPLED: Self = Self(0x4);
    /// Can be used as storage image (STORAGE_IMAGE descriptor type)
    pub const STORAGE: Self = Self(0x8);
    /// Can be used as framebuffer color attachment
    pub const COLOR_ATTACHMENT: Self = Self(0x10);
    /// Can be used as framebuffer depth/stencil attachment
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(0x20);
    /// Image data not needed outside of rendering
    pub const TRANSIENT_ATTACHMENT: Self = Self(0x40);
    /// Can be used as framebuffer input attachment
    pub const INPUT_ATTACHMENT: Self = Self(0x80);
    pub const SHADING_RATE_IMAGE_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    /// Added by extension VK_EXT_fragment_density_map.
    pub const FRAGMENT_DENSITY_MAP_EXT: Self = Self(0x200);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(0x100);
    /// Added by extension VK_HUAWEI_invocation_mask.
    pub const INVOCATION_MASK_HUAWEI: Self = Self(0x40000);
}
impl_bitmask!(ImageUsageFlags, 0x403ff);
impl fmt::Display for ImageUsageFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "TRANSFER_SRC"),
                (0x2, "TRANSFER_DST"),
                (0x4, "SAMPLED"),
                (0x8, "STORAGE"),
                (0x10, "COLOR_ATTACHMENT"),
                (0x20, "DEPTH_STENCIL_ATTACHMENT"),
                (0x40, "TRANSIENT_ATTACHMENT"),
                (0x80, "INPUT_ATTACHMENT"),
                (0x200, "FRAGMENT_DENSITY_MAP_EXT"),
                (0x100, "FRAGMENT_SHADING_RATE_ATTACHMENT_KHR"),
                (0x40000, "INVOCATION_MASK_HUAWEI"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImageCreateFlags(u32);
impl ImageCreateFlags {
    /// Image should support sparse backing
    pub const SPARSE_BINDING: Self = Self(0x1);
    /// Image should support sparse backing with partial residency
    pub const SPARSE_RESIDENCY: Self = Self(0x2);
    /// Image should support constant data access to physical memory ranges mapped into multiple locations of sparse images
    pub const SPARSE_ALIASED: Self = Self(0x4);
    /// Allows image views to have different format than the base image
    pub const MUTABLE_FORMAT: Self = Self(0x8);
    /// Allows creating image views with cube type from the created image
    pub const CUBE_COMPATIBLE: Self = Self(0x10);
    pub const ALIAS: Self = Self(0x400);
    /// Allows using VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions when binding memory to the image
    pub const SPLIT_INSTANCE_BIND_REGIONS: Self = Self(0x40);
    /// The 3D image can be viewed as a 2D or 2D array image
    pub const N2D_ARRAY_COMPATIBLE: Self = Self(0x20);
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE: Self = Self(0x80);
    pub const EXTENDED_USAGE: Self = Self(0x100);
    /// Image requires protected memory
    pub const PROTECTED: Self = Self(0x800);
    pub const DISJOINT: Self = Self(0x200);
    /// Added by extension VK_NV_corner_sampled_image.
    pub const CORNER_SAMPLED_NV: Self = Self(0x2000);
    pub const SPLIT_INSTANCE_BIND_REGIONS_KHR: Self = Self::SPLIT_INSTANCE_BIND_REGIONS;
    pub const N2D_ARRAY_COMPATIBLE_KHR: Self = Self::N2D_ARRAY_COMPATIBLE;
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE_KHR: Self = Self::BLOCK_TEXEL_VIEW_COMPATIBLE;
    pub const EXTENDED_USAGE_KHR: Self = Self::EXTENDED_USAGE;
    /// Added by extension VK_EXT_sample_locations.
    pub const SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT: Self = Self(0x1000);
    pub const DISJOINT_KHR: Self = Self::DISJOINT;
    pub const ALIAS_KHR: Self = Self::ALIAS;
    /// Added by extension VK_EXT_fragment_density_map.
    pub const SUBSAMPLED_EXT: Self = Self(0x4000);
    /// Image is created with a layout where individual slices are capable of being used as 2D images
    /// Added by extension VK_EXT_image_2d_view_of_3d.
    pub const N2D_VIEW_COMPATIBLE_EXT: Self = Self(0x20000);
    /// Added by extension VK_QCOM_fragment_density_map_offset.
    pub const FRAGMENT_DENSITY_MAP_OFFSET_QCOM: Self = Self(0x8000);
}
impl_bitmask!(ImageCreateFlags, 0x2ffff);
impl fmt::Display for ImageCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "SPARSE_BINDING"),
                (0x2, "SPARSE_RESIDENCY"),
                (0x4, "SPARSE_ALIASED"),
                (0x8, "MUTABLE_FORMAT"),
                (0x10, "CUBE_COMPATIBLE"),
                (0x400, "ALIAS"),
                (0x40, "SPLIT_INSTANCE_BIND_REGIONS"),
                (0x20, "N2D_ARRAY_COMPATIBLE"),
                (0x80, "BLOCK_TEXEL_VIEW_COMPATIBLE"),
                (0x100, "EXTENDED_USAGE"),
                (0x800, "PROTECTED"),
                (0x200, "DISJOINT"),
                (0x2000, "CORNER_SAMPLED_NV"),
                (0x1000, "SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT"),
                (0x4000, "SUBSAMPLED_EXT"),
                (0x20000, "N2D_VIEW_COMPATIBLE_EXT"),
                (0x8000, "FRAGMENT_DENSITY_MAP_OFFSET_QCOM"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImageViewCreateFlags(u32);
impl ImageViewCreateFlags {
    /// Added by extension VK_EXT_fragment_density_map.
    pub const FRAGMENT_DENSITY_MAP_DYNAMIC_EXT: Self = Self(0x1);
    /// Added by extension VK_EXT_fragment_density_map2.
    pub const FRAGMENT_DENSITY_MAP_DEFERRED_EXT: Self = Self(0x2);
}
impl_bitmask!(ImageViewCreateFlags, 0x3);
impl fmt::Display for ImageViewCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "FRAGMENT_DENSITY_MAP_DYNAMIC_EXT"),
                (0x2, "FRAGMENT_DENSITY_MAP_DEFERRED_EXT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineCreateFlags(u32);
impl PipelineCreateFlags {
    pub const DISABLE_OPTIMIZATION: Self = Self(0x1);
    pub const ALLOW_DERIVATIVES: Self = Self(0x2);
    pub const DERIVATIVE: Self = Self(0x4);
    pub const VIEW_INDEX_FROM_DEVICE_INDEX: Self = Self(0x8);
    pub const DISPATCH_BASE: Self = Self(0x10);
    pub const FAIL_ON_PIPELINE_COMPILE_REQUIRED: Self = Self(0x100);
    pub const EARLY_RETURN_ON_FAILURE: Self = Self(0x200);
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(0x200000);
    pub const RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self =
        Self::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT: Self = Self(0x400000);
    pub const RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT: Self =
        Self::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT;
    pub const VIEW_INDEX_FROM_DEVICE_INDEX_KHR: Self = Self::VIEW_INDEX_FROM_DEVICE_INDEX;
    pub const DISPATCH_BASE_KHR: Self = Self::DISPATCH_BASE;
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR: Self = Self(0x4000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR: Self = Self(0x8000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_NO_NULL_MISS_SHADERS_KHR: Self = Self(0x10000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR: Self = Self(0x20000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_SKIP_TRIANGLES_KHR: Self = Self(0x1000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_SKIP_AABBS_KHR: Self = Self(0x2000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR: Self = Self(0x80000);
    /// Added by extension VK_NV_ray_tracing.
    pub const DEFER_COMPILE_NV: Self = Self(0x20);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const CAPTURE_STATISTICS_KHR: Self = Self(0x40);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const CAPTURE_INTERNAL_REPRESENTATIONS_KHR: Self = Self(0x80);
    /// Added by extension VK_NV_device_generated_commands.
    pub const INDIRECT_BINDABLE_NV: Self = Self(0x40000);
    /// Added by extension VK_KHR_pipeline_library.
    pub const LIBRARY_KHR: Self = Self(0x800);
    pub const FAIL_ON_PIPELINE_COMPILE_REQUIRED_EXT: Self = Self::FAIL_ON_PIPELINE_COMPILE_REQUIRED;
    pub const EARLY_RETURN_ON_FAILURE_EXT: Self = Self::EARLY_RETURN_ON_FAILURE;
    /// Added by extension VK_EXT_graphics_pipeline_library.
    pub const RETAIN_LINK_TIME_OPTIMIZATION_INFO_EXT: Self = Self(0x800000);
    /// Added by extension VK_EXT_graphics_pipeline_library.
    pub const LINK_TIME_OPTIMIZATION_EXT: Self = Self(0x400);
    /// Added by extension VK_NV_ray_tracing_motion_blur.
    pub const RAY_TRACING_ALLOW_MOTION_NV: Self = Self(0x100000);
}
impl_bitmask!(PipelineCreateFlags, 0xffffff);
impl fmt::Display for PipelineCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "DISABLE_OPTIMIZATION"),
                (0x2, "ALLOW_DERIVATIVES"),
                (0x4, "DERIVATIVE"),
                (0x8, "VIEW_INDEX_FROM_DEVICE_INDEX"),
                (0x10, "DISPATCH_BASE"),
                (0x100, "FAIL_ON_PIPELINE_COMPILE_REQUIRED"),
                (0x200, "EARLY_RETURN_ON_FAILURE"),
                (0x200000, "RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR"),
                (0x400000, "RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT"),
                (0x4000, "RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR"),
                (0x8000, "RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR"),
                (0x10000, "RAY_TRACING_NO_NULL_MISS_SHADERS_KHR"),
                (0x20000, "RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR"),
                (0x1000, "RAY_TRACING_SKIP_TRIANGLES_KHR"),
                (0x2000, "RAY_TRACING_SKIP_AABBS_KHR"),
                (0x80000, "RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR"),
                (0x20, "DEFER_COMPILE_NV"),
                (0x40, "CAPTURE_STATISTICS_KHR"),
                (0x80, "CAPTURE_INTERNAL_REPRESENTATIONS_KHR"),
                (0x40000, "INDIRECT_BINDABLE_NV"),
                (0x800, "LIBRARY_KHR"),
                (0x800000, "RETAIN_LINK_TIME_OPTIMIZATION_INFO_EXT"),
                (0x400, "LINK_TIME_OPTIMIZATION_EXT"),
                (0x100000, "RAY_TRACING_ALLOW_MOTION_NV"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ColorComponentFlags(u32);
impl ColorComponentFlags {
    pub const R: Self = Self(0x1);
    pub const G: Self = Self(0x2);
    pub const B: Self = Self(0x4);
    pub const A: Self = Self(0x8);
}
impl_bitmask!(ColorComponentFlags, 0xf);
impl fmt::Display for ColorComponentFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "R"), (0x2, "G"), (0x4, "B"), (0x8, "A")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct FenceCreateFlags(u32);
impl FenceCreateFlags {
    pub const SIGNALED: Self = Self(0x1);
}
impl_bitmask!(FenceCreateFlags, 0x1);
impl fmt::Display for FenceCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "SIGNALED")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SemaphoreCreateFlags(u32);
impl SemaphoreCreateFlags {}
impl_bitmask!(SemaphoreCreateFlags, 0x0);
impl fmt::Display for SemaphoreCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct FormatFeatureFlags(u32);
impl FormatFeatureFlags {
    /// Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
    pub const SAMPLED_IMAGE: Self = Self(0x1);
    /// Format can be used for storage images (STORAGE_IMAGE descriptor type)
    pub const STORAGE_IMAGE: Self = Self(0x2);
    /// Format supports atomic operations in case it is used for storage images
    pub const STORAGE_IMAGE_ATOMIC: Self = Self(0x4);
    /// Format can be used for uniform texel buffers (TBOs)
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(0x8);
    /// Format can be used for storage texel buffers (IBOs)
    pub const STORAGE_TEXEL_BUFFER: Self = Self(0x10);
    /// Format supports atomic operations in case it is used for storage texel buffers
    pub const STORAGE_TEXEL_BUFFER_ATOMIC: Self = Self(0x20);
    /// Format can be used for vertex buffers (VBOs)
    pub const VERTEX_BUFFER: Self = Self(0x40);
    /// Format can be used for color attachment images
    pub const COLOR_ATTACHMENT: Self = Self(0x80);
    /// Format supports blending in case it is used for color attachment images
    pub const COLOR_ATTACHMENT_BLEND: Self = Self(0x100);
    /// Format can be used for depth/stencil attachment images
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(0x200);
    /// Format can be used as the source image of blits with vkCmdBlitImage
    pub const BLIT_SRC: Self = Self(0x400);
    /// Format can be used as the destination image of blits with vkCmdBlitImage
    pub const BLIT_DST: Self = Self(0x800);
    /// Format can be filtered with VK_FILTER_LINEAR when being sampled
    pub const SAMPLED_IMAGE_FILTER_LINEAR: Self = Self(0x1000);
    /// Format can be used as the source image of image transfer commands
    pub const TRANSFER_SRC: Self = Self(0x4000);
    /// Format can be used as the destination image of image transfer commands
    pub const TRANSFER_DST: Self = Self(0x8000);
    /// Format can have midpoint rather than cosited chroma samples
    pub const MIDPOINT_CHROMA_SAMPLES: Self = Self(0x20000);
    /// Format can be used with linear filtering whilst color conversion is enabled
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER: Self = Self(0x40000);
    /// Format can have different chroma, min and mag filters
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER: Self = Self(0x80000);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT: Self = Self(0x100000);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE: Self = Self(0x200000);
    /// Format supports disjoint planes
    pub const DISJOINT: Self = Self(0x400000);
    /// Format can have cosited rather than midpoint chroma samples
    pub const COSITED_CHROMA_SAMPLES: Self = Self(0x800000);
    /// Format can be used with min/max reduction filtering
    pub const SAMPLED_IMAGE_FILTER_MINMAX: Self = Self(0x10000);
    /// Format can be filtered with VK_FILTER_CUBIC_IMG when being sampled
    /// Added by extension VK_IMG_filter_cubic.
    pub const SAMPLED_IMAGE_FILTER_CUBIC_IMG: Self = Self(0x2000);
    pub const TRANSFER_SRC_KHR: Self = Self::TRANSFER_SRC;
    pub const TRANSFER_DST_KHR: Self = Self::TRANSFER_DST;
    pub const SAMPLED_IMAGE_FILTER_MINMAX_EXT: Self = Self::SAMPLED_IMAGE_FILTER_MINMAX;
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR: Self = Self(0x20000000);
    pub const MIDPOINT_CHROMA_SAMPLES_KHR: Self = Self::MIDPOINT_CHROMA_SAMPLES;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE;
    pub const DISJOINT_KHR: Self = Self::DISJOINT;
    pub const COSITED_CHROMA_SAMPLES_KHR: Self = Self::COSITED_CHROMA_SAMPLES;
    pub const SAMPLED_IMAGE_FILTER_CUBIC_EXT: Self = Self::SAMPLED_IMAGE_FILTER_CUBIC_IMG;
    /// Added by extension VK_EXT_fragment_density_map.
    pub const FRAGMENT_DENSITY_MAP_EXT: Self = Self(0x1000000);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(0x40000000);
}
impl_bitmask!(FormatFeatureFlags, 0x61ffffff);
impl fmt::Display for FormatFeatureFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "SAMPLED_IMAGE"),
                (0x2, "STORAGE_IMAGE"),
                (0x4, "STORAGE_IMAGE_ATOMIC"),
                (0x8, "UNIFORM_TEXEL_BUFFER"),
                (0x10, "STORAGE_TEXEL_BUFFER"),
                (0x20, "STORAGE_TEXEL_BUFFER_ATOMIC"),
                (0x40, "VERTEX_BUFFER"),
                (0x80, "COLOR_ATTACHMENT"),
                (0x100, "COLOR_ATTACHMENT_BLEND"),
                (0x200, "DEPTH_STENCIL_ATTACHMENT"),
                (0x400, "BLIT_SRC"),
                (0x800, "BLIT_DST"),
                (0x1000, "SAMPLED_IMAGE_FILTER_LINEAR"),
                (0x4000, "TRANSFER_SRC"),
                (0x8000, "TRANSFER_DST"),
                (0x20000, "MIDPOINT_CHROMA_SAMPLES"),
                (0x40000, "SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER"),
                (0x80000, "SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER"),
                (
                    0x100000,
                    "SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT",
                ),
                (
                    0x200000,
                    "SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE",
                ),
                (0x400000, "DISJOINT"),
                (0x800000, "COSITED_CHROMA_SAMPLES"),
                (0x10000, "SAMPLED_IMAGE_FILTER_MINMAX"),
                (0x2000, "SAMPLED_IMAGE_FILTER_CUBIC_IMG"),
                (0x20000000, "ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR"),
                (0x1000000, "FRAGMENT_DENSITY_MAP_EXT"),
                (0x40000000, "FRAGMENT_SHADING_RATE_ATTACHMENT_KHR"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct QueryControlFlags(u32);
impl QueryControlFlags {
    /// Require precise results to be collected by the query
    pub const PRECISE: Self = Self(0x1);
}
impl_bitmask!(QueryControlFlags, 0x1);
impl fmt::Display for QueryControlFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "PRECISE")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct QueryResultFlags(u32);
impl QueryResultFlags {
    /// Results of the queries are written to the destination buffer as 64-bit values
    pub const N64: Self = Self(0x1);
    /// Results of the queries are waited on before proceeding with the result copy
    pub const WAIT: Self = Self(0x2);
    /// Besides the results of the query, the availability of the results is also written
    pub const WITH_AVAILABILITY: Self = Self(0x4);
    /// Copy the partial results of the query even if the final results are not available
    pub const PARTIAL: Self = Self(0x8);
}
impl_bitmask!(QueryResultFlags, 0xf);
impl fmt::Display for QueryResultFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "N64"),
                (0x2, "WAIT"),
                (0x4, "WITH_AVAILABILITY"),
                (0x8, "PARTIAL"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ShaderModuleCreateFlags(u32);
impl ShaderModuleCreateFlags {}
impl_bitmask!(ShaderModuleCreateFlags, 0x0);
impl fmt::Display for ShaderModuleCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct EventCreateFlags(u32);
impl EventCreateFlags {
    pub const DEVICE_ONLY: Self = Self(0x1);
    pub const DEVICE_ONLY_KHR: Self = Self::DEVICE_ONLY;
}
impl_bitmask!(EventCreateFlags, 0x1);
impl fmt::Display for EventCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "DEVICE_ONLY")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct CommandPoolCreateFlags(u32);
impl CommandPoolCreateFlags {
    /// Command buffers have a short lifetime
    pub const TRANSIENT: Self = Self(0x1);
    /// Command buffers may release their memory individually
    pub const RESET_COMMAND_BUFFER: Self = Self(0x2);
    /// Command buffers allocated from pool are protected command buffers
    pub const PROTECTED: Self = Self(0x4);
}
impl_bitmask!(CommandPoolCreateFlags, 0x7);
impl fmt::Display for CommandPoolCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "TRANSIENT"), (0x2, "RESET_COMMAND_BUFFER"), (0x4, "PROTECTED")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct CommandPoolResetFlags(u32);
impl CommandPoolResetFlags {
    /// Release resources owned by the pool
    pub const RELEASE_RESOURCES: Self = Self(0x1);
}
impl_bitmask!(CommandPoolResetFlags, 0x1);
impl fmt::Display for CommandPoolResetFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "RELEASE_RESOURCES")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct CommandBufferResetFlags(u32);
impl CommandBufferResetFlags {
    /// Release resources owned by the buffer
    pub const RELEASE_RESOURCES: Self = Self(0x1);
}
impl_bitmask!(CommandBufferResetFlags, 0x1);
impl fmt::Display for CommandBufferResetFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "RELEASE_RESOURCES")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct CommandBufferUsageFlags(u32);
impl CommandBufferUsageFlags {
    pub const ONE_TIME_SUBMIT: Self = Self(0x1);
    pub const RENDER_PASS_CONTINUE: Self = Self(0x2);
    /// Command buffer may be submitted/executed more than once simultaneously
    pub const SIMULTANEOUS_USE: Self = Self(0x4);
}
impl_bitmask!(CommandBufferUsageFlags, 0x7);
impl fmt::Display for CommandBufferUsageFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "ONE_TIME_SUBMIT"),
                (0x2, "RENDER_PASS_CONTINUE"),
                (0x4, "SIMULTANEOUS_USE"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct QueryPipelineStatisticFlags(u32);
impl QueryPipelineStatisticFlags {
    /// Optional
    pub const INPUT_ASSEMBLY_VERTICES: Self = Self(0x1);
    /// Optional
    pub const INPUT_ASSEMBLY_PRIMITIVES: Self = Self(0x2);
    /// Optional
    pub const VERTEX_SHADER_INVOCATIONS: Self = Self(0x4);
    /// Optional
    pub const GEOMETRY_SHADER_INVOCATIONS: Self = Self(0x8);
    /// Optional
    pub const GEOMETRY_SHADER_PRIMITIVES: Self = Self(0x10);
    /// Optional
    pub const CLIPPING_INVOCATIONS: Self = Self(0x20);
    /// Optional
    pub const CLIPPING_PRIMITIVES: Self = Self(0x40);
    /// Optional
    pub const FRAGMENT_SHADER_INVOCATIONS: Self = Self(0x80);
    /// Optional
    pub const TESSELLATION_CONTROL_SHADER_PATCHES: Self = Self(0x100);
    /// Optional
    pub const TESSELLATION_EVALUATION_SHADER_INVOCATIONS: Self = Self(0x200);
    /// Optional
    pub const COMPUTE_SHADER_INVOCATIONS: Self = Self(0x400);
}
impl_bitmask!(QueryPipelineStatisticFlags, 0x7ff);
impl fmt::Display for QueryPipelineStatisticFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "INPUT_ASSEMBLY_VERTICES"),
                (0x2, "INPUT_ASSEMBLY_PRIMITIVES"),
                (0x4, "VERTEX_SHADER_INVOCATIONS"),
                (0x8, "GEOMETRY_SHADER_INVOCATIONS"),
                (0x10, "GEOMETRY_SHADER_PRIMITIVES"),
                (0x20, "CLIPPING_INVOCATIONS"),
                (0x40, "CLIPPING_PRIMITIVES"),
                (0x80, "FRAGMENT_SHADER_INVOCATIONS"),
                (0x100, "TESSELLATION_CONTROL_SHADER_PATCHES"),
                (0x200, "TESSELLATION_EVALUATION_SHADER_INVOCATIONS"),
                (0x400, "COMPUTE_SHADER_INVOCATIONS"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct MemoryMapFlags(u32);
impl MemoryMapFlags {}
impl_bitmask!(MemoryMapFlags, 0x0);
impl fmt::Display for MemoryMapFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImageAspectFlags(u32);
impl ImageAspectFlags {
    pub const COLOR: Self = Self(0x1);
    pub const DEPTH: Self = Self(0x2);
    pub const STENCIL: Self = Self(0x4);
    pub const METADATA: Self = Self(0x8);
    pub const PLANE_0: Self = Self(0x10);
    pub const PLANE_1: Self = Self(0x20);
    pub const PLANE_2: Self = Self(0x40);
    pub const NONE: Self = Self(0x0);
    pub const PLANE_0_KHR: Self = Self::PLANE_0;
    pub const PLANE_1_KHR: Self = Self::PLANE_1;
    pub const PLANE_2_KHR: Self = Self::PLANE_2;
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const MEMORY_PLANE_0_EXT: Self = Self(0x80);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const MEMORY_PLANE_1_EXT: Self = Self(0x100);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const MEMORY_PLANE_2_EXT: Self = Self(0x200);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const MEMORY_PLANE_3_EXT: Self = Self(0x400);
    pub const NONE_KHR: Self = Self::NONE;
}
impl_bitmask!(ImageAspectFlags, 0x7ff);
impl fmt::Display for ImageAspectFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "COLOR"),
                (0x2, "DEPTH"),
                (0x4, "STENCIL"),
                (0x8, "METADATA"),
                (0x10, "PLANE_0"),
                (0x20, "PLANE_1"),
                (0x40, "PLANE_2"),
                (0x80, "MEMORY_PLANE_0_EXT"),
                (0x100, "MEMORY_PLANE_1_EXT"),
                (0x200, "MEMORY_PLANE_2_EXT"),
                (0x400, "MEMORY_PLANE_3_EXT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SparseMemoryBindFlags(u32);
impl SparseMemoryBindFlags {
    /// Operation binds resource metadata to memory
    pub const METADATA: Self = Self(0x1);
}
impl_bitmask!(SparseMemoryBindFlags, 0x1);
impl fmt::Display for SparseMemoryBindFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "METADATA")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SparseImageFormatFlags(u32);
impl SparseImageFormatFlags {
    /// Image uses a single mip tail region for all array layers
    pub const SINGLE_MIPTAIL: Self = Self(0x1);
    /// Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels.
    pub const ALIGNED_MIP_SIZE: Self = Self(0x2);
    /// Image uses a non-standard sparse image block dimensions
    pub const NONSTANDARD_BLOCK_SIZE: Self = Self(0x4);
}
impl_bitmask!(SparseImageFormatFlags, 0x7);
impl fmt::Display for SparseImageFormatFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "SINGLE_MIPTAIL"),
                (0x2, "ALIGNED_MIP_SIZE"),
                (0x4, "NONSTANDARD_BLOCK_SIZE"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SubpassDescriptionFlags(u32);
impl SubpassDescriptionFlags {
    /// Added by extension VK_NVX_multiview_per_view_attributes.
    pub const PER_VIEW_ATTRIBUTES_NVX: Self = Self(0x1);
    /// Added by extension VK_NVX_multiview_per_view_attributes.
    pub const PER_VIEW_POSITION_X_ONLY_NVX: Self = Self(0x2);
    /// Added by extension VK_QCOM_render_pass_shader_resolve.
    pub const FRAGMENT_REGION_QCOM: Self = Self(0x4);
    /// Added by extension VK_QCOM_render_pass_shader_resolve.
    pub const SHADER_RESOLVE_QCOM: Self = Self(0x8);
    /// Added by extension VK_ARM_rasterization_order_attachment_access.
    pub const RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM: Self = Self(0x10);
    /// Added by extension VK_ARM_rasterization_order_attachment_access.
    pub const RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM: Self = Self(0x20);
    /// Added by extension VK_ARM_rasterization_order_attachment_access.
    pub const RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM: Self = Self(0x40);
}
impl_bitmask!(SubpassDescriptionFlags, 0x7f);
impl fmt::Display for SubpassDescriptionFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "PER_VIEW_ATTRIBUTES_NVX"),
                (0x2, "PER_VIEW_POSITION_X_ONLY_NVX"),
                (0x4, "FRAGMENT_REGION_QCOM"),
                (0x8, "SHADER_RESOLVE_QCOM"),
                (0x10, "RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM"),
                (0x20, "RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM"),
                (0x40, "RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineStageFlags(u32);
impl PipelineStageFlags {
    /// Before subsequent commands are processed
    pub const TOP_OF_PIPE: Self = Self(0x1);
    /// Draw/DispatchIndirect command fetch
    pub const DRAW_INDIRECT: Self = Self(0x2);
    /// Vertex/index fetch
    pub const VERTEX_INPUT: Self = Self(0x4);
    /// Vertex shading
    pub const VERTEX_SHADER: Self = Self(0x8);
    /// Tessellation control shading
    pub const TESSELLATION_CONTROL_SHADER: Self = Self(0x10);
    /// Tessellation evaluation shading
    pub const TESSELLATION_EVALUATION_SHADER: Self = Self(0x20);
    /// Geometry shading
    pub const GEOMETRY_SHADER: Self = Self(0x40);
    /// Fragment shading
    pub const FRAGMENT_SHADER: Self = Self(0x80);
    /// Early fragment (depth and stencil) tests
    pub const EARLY_FRAGMENT_TESTS: Self = Self(0x100);
    /// Late fragment (depth and stencil) tests
    pub const LATE_FRAGMENT_TESTS: Self = Self(0x200);
    /// Color attachment writes
    pub const COLOR_ATTACHMENT_OUTPUT: Self = Self(0x400);
    /// Compute shading
    pub const COMPUTE_SHADER: Self = Self(0x800);
    /// Transfer/copy operations
    pub const TRANSFER: Self = Self(0x1000);
    /// After previous commands have completed
    pub const BOTTOM_OF_PIPE: Self = Self(0x2000);
    /// Indicates host (CPU) is a source/sink of the dependency
    pub const HOST: Self = Self(0x4000);
    /// All stages of the graphics pipeline
    pub const ALL_GRAPHICS: Self = Self(0x8000);
    /// All stages supported on the queue
    pub const ALL_COMMANDS: Self = Self(0x10000);
    pub const NONE: Self = Self(0x0);
    /// Added by extension VK_EXT_transform_feedback.
    pub const TRANSFORM_FEEDBACK_EXT: Self = Self(0x1000000);
    /// A pipeline stage for conditional rendering predicate fetch
    /// Added by extension VK_EXT_conditional_rendering.
    pub const CONDITIONAL_RENDERING_EXT: Self = Self(0x40000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_BUILD_KHR: Self = Self(0x2000000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_SHADER_KHR: Self = Self(0x200000);
    pub const SHADING_RATE_IMAGE_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    pub const RAY_TRACING_SHADER_NV: Self = Self::RAY_TRACING_SHADER_KHR;
    pub const ACCELERATION_STRUCTURE_BUILD_NV: Self = Self::ACCELERATION_STRUCTURE_BUILD_KHR;
    /// Added by extension VK_NV_mesh_shader.
    pub const TASK_SHADER_NV: Self = Self(0x80000);
    /// Added by extension VK_NV_mesh_shader.
    pub const MESH_SHADER_NV: Self = Self(0x100000);
    /// Added by extension VK_EXT_fragment_density_map.
    pub const FRAGMENT_DENSITY_PROCESS_EXT: Self = Self(0x800000);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(0x400000);
    /// Added by extension VK_NV_device_generated_commands.
    pub const COMMAND_PREPROCESS_NV: Self = Self(0x20000);
    pub const NONE_KHR: Self = Self::NONE;
}
impl_bitmask!(PipelineStageFlags, 0x3ffffff);
impl fmt::Display for PipelineStageFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "TOP_OF_PIPE"),
                (0x2, "DRAW_INDIRECT"),
                (0x4, "VERTEX_INPUT"),
                (0x8, "VERTEX_SHADER"),
                (0x10, "TESSELLATION_CONTROL_SHADER"),
                (0x20, "TESSELLATION_EVALUATION_SHADER"),
                (0x40, "GEOMETRY_SHADER"),
                (0x80, "FRAGMENT_SHADER"),
                (0x100, "EARLY_FRAGMENT_TESTS"),
                (0x200, "LATE_FRAGMENT_TESTS"),
                (0x400, "COLOR_ATTACHMENT_OUTPUT"),
                (0x800, "COMPUTE_SHADER"),
                (0x1000, "TRANSFER"),
                (0x2000, "BOTTOM_OF_PIPE"),
                (0x4000, "HOST"),
                (0x8000, "ALL_GRAPHICS"),
                (0x10000, "ALL_COMMANDS"),
                (0x1000000, "TRANSFORM_FEEDBACK_EXT"),
                (0x40000, "CONDITIONAL_RENDERING_EXT"),
                (0x2000000, "ACCELERATION_STRUCTURE_BUILD_KHR"),
                (0x200000, "RAY_TRACING_SHADER_KHR"),
                (0x80000, "TASK_SHADER_NV"),
                (0x100000, "MESH_SHADER_NV"),
                (0x800000, "FRAGMENT_DENSITY_PROCESS_EXT"),
                (0x400000, "FRAGMENT_SHADING_RATE_ATTACHMENT_KHR"),
                (0x20000, "COMMAND_PREPROCESS_NV"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SampleCountFlags(u32);
impl SampleCountFlags {
    /// Sample count 1 supported
    pub const N1: Self = Self(0x1);
    /// Sample count 2 supported
    pub const N2: Self = Self(0x2);
    /// Sample count 4 supported
    pub const N4: Self = Self(0x4);
    /// Sample count 8 supported
    pub const N8: Self = Self(0x8);
    /// Sample count 16 supported
    pub const N16: Self = Self(0x10);
    /// Sample count 32 supported
    pub const N32: Self = Self(0x20);
    /// Sample count 64 supported
    pub const N64: Self = Self(0x40);
}
impl_bitmask!(SampleCountFlags, 0x7f);
impl fmt::Display for SampleCountFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "N1"),
                (0x2, "N2"),
                (0x4, "N4"),
                (0x8, "N8"),
                (0x10, "N16"),
                (0x20, "N32"),
                (0x40, "N64"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct AttachmentDescriptionFlags(u32);
impl AttachmentDescriptionFlags {
    /// The attachment may alias physical memory of another attachment in the same render pass
    pub const MAY_ALIAS: Self = Self(0x1);
}
impl_bitmask!(AttachmentDescriptionFlags, 0x1);
impl fmt::Display for AttachmentDescriptionFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "MAY_ALIAS")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct StencilFaceFlags(u32);
impl StencilFaceFlags {
    /// Front face
    pub const FRONT: Self = Self(0x1);
    /// Back face
    pub const BACK: Self = Self(0x2);
    /// Front and back faces
    pub const FRONT_AND_BACK: Self = Self(0x3);
}
impl_bitmask!(StencilFaceFlags, 0x3);
impl fmt::Display for StencilFaceFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "FRONT"), (0x2, "BACK"), (0x3, "FRONT_AND_BACK")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct CullModeFlags(u32);
impl CullModeFlags {
    pub const NONE: Self = Self(0x0);
    pub const FRONT: Self = Self(0x1);
    pub const BACK: Self = Self(0x2);
    pub const FRONT_AND_BACK: Self = Self(0x3);
}
impl_bitmask!(CullModeFlags, 0x3);
impl fmt::Display for CullModeFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "FRONT"), (0x2, "BACK"), (0x3, "FRONT_AND_BACK")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DescriptorPoolCreateFlags(u32);
impl DescriptorPoolCreateFlags {
    /// Descriptor sets may be freed individually
    pub const FREE_DESCRIPTOR_SET: Self = Self(0x1);
    pub const UPDATE_AFTER_BIND: Self = Self(0x2);
    pub const UPDATE_AFTER_BIND_EXT: Self = Self::UPDATE_AFTER_BIND;
    /// Added by extension VK_VALVE_mutable_descriptor_type.
    pub const HOST_ONLY_VALVE: Self = Self(0x4);
}
impl_bitmask!(DescriptorPoolCreateFlags, 0x7);
impl fmt::Display for DescriptorPoolCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "FREE_DESCRIPTOR_SET"),
                (0x2, "UPDATE_AFTER_BIND"),
                (0x4, "HOST_ONLY_VALVE"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DescriptorPoolResetFlags(u32);
impl DescriptorPoolResetFlags {}
impl_bitmask!(DescriptorPoolResetFlags, 0x0);
impl fmt::Display for DescriptorPoolResetFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DependencyFlags(u32);
impl DependencyFlags {
    /// Dependency is per pixel region
    pub const BY_REGION: Self = Self(0x1);
    /// Dependency is across devices
    pub const DEVICE_GROUP: Self = Self(0x4);
    pub const VIEW_LOCAL: Self = Self(0x2);
    pub const VIEW_LOCAL_KHR: Self = Self::VIEW_LOCAL;
    pub const DEVICE_GROUP_KHR: Self = Self::DEVICE_GROUP;
}
impl_bitmask!(DependencyFlags, 0x7);
impl fmt::Display for DependencyFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "BY_REGION"), (0x4, "DEVICE_GROUP"), (0x2, "VIEW_LOCAL")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SubgroupFeatureFlags(u32);
impl SubgroupFeatureFlags {
    /// Basic subgroup operations
    pub const BASIC: Self = Self(0x1);
    /// Vote subgroup operations
    pub const VOTE: Self = Self(0x2);
    /// Arithmetic subgroup operations
    pub const ARITHMETIC: Self = Self(0x4);
    /// Ballot subgroup operations
    pub const BALLOT: Self = Self(0x8);
    /// Shuffle subgroup operations
    pub const SHUFFLE: Self = Self(0x10);
    /// Shuffle relative subgroup operations
    pub const SHUFFLE_RELATIVE: Self = Self(0x20);
    /// Clustered subgroup operations
    pub const CLUSTERED: Self = Self(0x40);
    /// Quad subgroup operations
    pub const QUAD: Self = Self(0x80);
    /// Added by extension VK_NV_shader_subgroup_partitioned.
    pub const PARTITIONED_NV: Self = Self(0x100);
}
impl_bitmask!(SubgroupFeatureFlags, 0x1ff);
impl fmt::Display for SubgroupFeatureFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "BASIC"),
                (0x2, "VOTE"),
                (0x4, "ARITHMETIC"),
                (0x8, "BALLOT"),
                (0x10, "SHUFFLE"),
                (0x20, "SHUFFLE_RELATIVE"),
                (0x40, "CLUSTERED"),
                (0x80, "QUAD"),
                (0x100, "PARTITIONED_NV"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct IndirectCommandsLayoutUsageFlagsNV(u32);
impl IndirectCommandsLayoutUsageFlagsNV {
    pub const EXPLICIT_PREPROCESS: Self = Self(0x1);
    pub const INDEXED_SEQUENCES: Self = Self(0x2);
    pub const UNORDERED_SEQUENCES: Self = Self(0x4);
}
impl_bitmask!(IndirectCommandsLayoutUsageFlagsNV, 0x7);
impl fmt::Display for IndirectCommandsLayoutUsageFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "EXPLICIT_PREPROCESS"),
                (0x2, "INDEXED_SEQUENCES"),
                (0x4, "UNORDERED_SEQUENCES"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct IndirectStateFlagsNV(u32);
impl IndirectStateFlagsNV {
    pub const FRONTFACE: Self = Self(0x1);
}
impl_bitmask!(IndirectStateFlagsNV, 0x1);
impl fmt::Display for IndirectStateFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "FRONTFACE")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct GeometryFlagsKHR(u32);
impl GeometryFlagsKHR {
    pub const OPAQUE: Self = Self(0x1);
    pub const NO_DUPLICATE_ANY_HIT_INVOCATION: Self = Self(0x2);
    pub const OPAQUE_NV: Self = Self::OPAQUE;
    pub const NO_DUPLICATE_ANY_HIT_INVOCATION_NV: Self = Self::NO_DUPLICATE_ANY_HIT_INVOCATION;
}
impl_bitmask!(GeometryFlagsKHR, 0x3);
impl fmt::Display for GeometryFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "OPAQUE"), (0x2, "NO_DUPLICATE_ANY_HIT_INVOCATION")],
            f,
        )
    }
}
pub type GeometryFlagsNV = GeometryFlagsKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct GeometryInstanceFlagsKHR(u32);
impl GeometryInstanceFlagsKHR {
    pub const TRIANGLE_FACING_CULL_DISABLE: Self = Self(0x1);
    pub const TRIANGLE_FLIP_FACING: Self = Self(0x2);
    pub const FORCE_OPAQUE: Self = Self(0x4);
    pub const FORCE_NO_OPAQUE: Self = Self(0x8);
    pub const TRIANGLE_FRONT_COUNTERCLOCKWISE: Self = Self::TRIANGLE_FLIP_FACING;
    pub const TRIANGLE_CULL_DISABLE_NV: Self = Self::TRIANGLE_FACING_CULL_DISABLE;
    pub const TRIANGLE_FRONT_COUNTERCLOCKWISE_NV: Self = Self::TRIANGLE_FRONT_COUNTERCLOCKWISE;
    pub const FORCE_OPAQUE_NV: Self = Self::FORCE_OPAQUE;
    pub const FORCE_NO_OPAQUE_NV: Self = Self::FORCE_NO_OPAQUE;
}
impl_bitmask!(GeometryInstanceFlagsKHR, 0xf);
impl fmt::Display for GeometryInstanceFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "TRIANGLE_FACING_CULL_DISABLE"),
                (0x2, "TRIANGLE_FLIP_FACING"),
                (0x4, "FORCE_OPAQUE"),
                (0x8, "FORCE_NO_OPAQUE"),
            ],
            f,
        )
    }
}
pub type GeometryInstanceFlagsNV = GeometryInstanceFlagsKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct BuildAccelerationStructureFlagsKHR(u32);
impl BuildAccelerationStructureFlagsKHR {
    pub const ALLOW_UPDATE: Self = Self(0x1);
    pub const ALLOW_COMPACTION: Self = Self(0x2);
    pub const PREFER_FAST_TRACE: Self = Self(0x4);
    pub const PREFER_FAST_BUILD: Self = Self(0x8);
    pub const LOW_MEMORY: Self = Self(0x10);
    pub const ALLOW_UPDATE_NV: Self = Self::ALLOW_UPDATE;
    pub const ALLOW_COMPACTION_NV: Self = Self::ALLOW_COMPACTION;
    pub const PREFER_FAST_TRACE_NV: Self = Self::PREFER_FAST_TRACE;
    pub const PREFER_FAST_BUILD_NV: Self = Self::PREFER_FAST_BUILD;
    pub const LOW_MEMORY_NV: Self = Self::LOW_MEMORY;
    /// Added by extension VK_NV_ray_tracing_motion_blur.
    pub const MOTION_NV: Self = Self(0x20);
}
impl_bitmask!(BuildAccelerationStructureFlagsKHR, 0x3f);
impl fmt::Display for BuildAccelerationStructureFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "ALLOW_UPDATE"),
                (0x2, "ALLOW_COMPACTION"),
                (0x4, "PREFER_FAST_TRACE"),
                (0x8, "PREFER_FAST_BUILD"),
                (0x10, "LOW_MEMORY"),
                (0x20, "MOTION_NV"),
            ],
            f,
        )
    }
}
pub type BuildAccelerationStructureFlagsNV = BuildAccelerationStructureFlagsKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PrivateDataSlotCreateFlags(u32);
impl PrivateDataSlotCreateFlags {}
impl_bitmask!(PrivateDataSlotCreateFlags, 0x0);
impl fmt::Display for PrivateDataSlotCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
pub type PrivateDataSlotCreateFlagsEXT = PrivateDataSlotCreateFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct AccelerationStructureCreateFlagsKHR(u32);
impl AccelerationStructureCreateFlagsKHR {
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY: Self = Self(0x1);
    /// Added by extension VK_NV_ray_tracing_motion_blur.
    pub const MOTION_NV: Self = Self(0x4);
}
impl_bitmask!(AccelerationStructureCreateFlagsKHR, 0x5);
impl fmt::Display for AccelerationStructureCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "DEVICE_ADDRESS_CAPTURE_REPLAY"), (0x4, "MOTION_NV")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DescriptorUpdateTemplateCreateFlags(u32);
impl DescriptorUpdateTemplateCreateFlags {}
impl_bitmask!(DescriptorUpdateTemplateCreateFlags, 0x0);
impl fmt::Display for DescriptorUpdateTemplateCreateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
pub type DescriptorUpdateTemplateCreateFlagsKHR = DescriptorUpdateTemplateCreateFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineCreationFeedbackFlags(u32);
impl PipelineCreationFeedbackFlags {
    pub const VALID: Self = Self(0x1);
    pub const VALID_EXT: Self = Self::VALID;
    pub const APPLICATION_PIPELINE_CACHE_HIT: Self = Self(0x2);
    pub const APPLICATION_PIPELINE_CACHE_HIT_EXT: Self = Self::APPLICATION_PIPELINE_CACHE_HIT;
    pub const BASE_PIPELINE_ACCELERATION: Self = Self(0x4);
    pub const BASE_PIPELINE_ACCELERATION_EXT: Self = Self::BASE_PIPELINE_ACCELERATION;
}
impl_bitmask!(PipelineCreationFeedbackFlags, 0x7);
impl fmt::Display for PipelineCreationFeedbackFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "VALID"),
                (0x2, "APPLICATION_PIPELINE_CACHE_HIT"),
                (0x4, "BASE_PIPELINE_ACCELERATION"),
            ],
            f,
        )
    }
}
pub type PipelineCreationFeedbackFlagsEXT = PipelineCreationFeedbackFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PerformanceCounterDescriptionFlagsKHR(u32);
impl PerformanceCounterDescriptionFlagsKHR {
    pub const PERFORMANCE_IMPACTING: Self = Self(0x1);
    pub const CONCURRENTLY_IMPACTED: Self = Self(0x2);
}
impl_bitmask!(PerformanceCounterDescriptionFlagsKHR, 0x3);
impl fmt::Display for PerformanceCounterDescriptionFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "PERFORMANCE_IMPACTING"), (0x2, "CONCURRENTLY_IMPACTED")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct AcquireProfilingLockFlagsKHR(u32);
impl AcquireProfilingLockFlagsKHR {}
impl_bitmask!(AcquireProfilingLockFlagsKHR, 0x0);
impl fmt::Display for AcquireProfilingLockFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SemaphoreWaitFlags(u32);
impl SemaphoreWaitFlags {
    pub const ANY: Self = Self(0x1);
    pub const ANY_KHR: Self = Self::ANY;
}
impl_bitmask!(SemaphoreWaitFlags, 0x1);
impl fmt::Display for SemaphoreWaitFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "ANY")], f)
    }
}
pub type SemaphoreWaitFlagsKHR = SemaphoreWaitFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineCompilerControlFlagsAMD(u32);
impl PipelineCompilerControlFlagsAMD {}
impl_bitmask!(PipelineCompilerControlFlagsAMD, 0x0);
impl fmt::Display for PipelineCompilerControlFlagsAMD {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ShaderCorePropertiesFlagsAMD(u32);
impl ShaderCorePropertiesFlagsAMD {}
impl_bitmask!(ShaderCorePropertiesFlagsAMD, 0x0);
impl fmt::Display for ShaderCorePropertiesFlagsAMD {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DeviceDiagnosticsConfigFlagsNV(u32);
impl DeviceDiagnosticsConfigFlagsNV {
    pub const ENABLE_SHADER_DEBUG_INFO: Self = Self(0x1);
    pub const ENABLE_RESOURCE_TRACKING: Self = Self(0x2);
    pub const ENABLE_AUTOMATIC_CHECKPOINTS: Self = Self(0x4);
    pub const ENABLE_SHADER_ERROR_REPORTING: Self = Self(0x8);
}
impl_bitmask!(DeviceDiagnosticsConfigFlagsNV, 0xf);
impl fmt::Display for DeviceDiagnosticsConfigFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "ENABLE_SHADER_DEBUG_INFO"),
                (0x2, "ENABLE_RESOURCE_TRACKING"),
                (0x4, "ENABLE_AUTOMATIC_CHECKPOINTS"),
                (0x8, "ENABLE_SHADER_ERROR_REPORTING"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct AccessFlags2(u64);
impl AccessFlags2 {
    pub const NONE: Self = Self(0x0);
    pub const NONE_KHR: Self = Self::NONE;
    pub const INDIRECT_COMMAND_READ: Self = Self(0x1);
    pub const INDIRECT_COMMAND_READ_KHR: Self = Self::INDIRECT_COMMAND_READ;
    pub const INDEX_READ: Self = Self(0x2);
    pub const INDEX_READ_KHR: Self = Self::INDEX_READ;
    pub const VERTEX_ATTRIBUTE_READ: Self = Self(0x4);
    pub const VERTEX_ATTRIBUTE_READ_KHR: Self = Self::VERTEX_ATTRIBUTE_READ;
    pub const UNIFORM_READ: Self = Self(0x8);
    pub const UNIFORM_READ_KHR: Self = Self::UNIFORM_READ;
    pub const INPUT_ATTACHMENT_READ: Self = Self(0x10);
    pub const INPUT_ATTACHMENT_READ_KHR: Self = Self::INPUT_ATTACHMENT_READ;
    pub const SHADER_READ: Self = Self(0x20);
    pub const SHADER_READ_KHR: Self = Self::SHADER_READ;
    pub const SHADER_WRITE: Self = Self(0x40);
    pub const SHADER_WRITE_KHR: Self = Self::SHADER_WRITE;
    pub const COLOR_ATTACHMENT_READ: Self = Self(0x80);
    pub const COLOR_ATTACHMENT_READ_KHR: Self = Self::COLOR_ATTACHMENT_READ;
    pub const COLOR_ATTACHMENT_WRITE: Self = Self(0x100);
    pub const COLOR_ATTACHMENT_WRITE_KHR: Self = Self::COLOR_ATTACHMENT_WRITE;
    pub const DEPTH_STENCIL_ATTACHMENT_READ: Self = Self(0x200);
    pub const DEPTH_STENCIL_ATTACHMENT_READ_KHR: Self = Self::DEPTH_STENCIL_ATTACHMENT_READ;
    pub const DEPTH_STENCIL_ATTACHMENT_WRITE: Self = Self(0x400);
    pub const DEPTH_STENCIL_ATTACHMENT_WRITE_KHR: Self = Self::DEPTH_STENCIL_ATTACHMENT_WRITE;
    pub const TRANSFER_READ: Self = Self(0x800);
    pub const TRANSFER_READ_KHR: Self = Self::TRANSFER_READ;
    pub const TRANSFER_WRITE: Self = Self(0x1000);
    pub const TRANSFER_WRITE_KHR: Self = Self::TRANSFER_WRITE;
    pub const HOST_READ: Self = Self(0x2000);
    pub const HOST_READ_KHR: Self = Self::HOST_READ;
    pub const HOST_WRITE: Self = Self(0x4000);
    pub const HOST_WRITE_KHR: Self = Self::HOST_WRITE;
    pub const MEMORY_READ: Self = Self(0x8000);
    pub const MEMORY_READ_KHR: Self = Self::MEMORY_READ;
    pub const MEMORY_WRITE: Self = Self(0x10000);
    pub const MEMORY_WRITE_KHR: Self = Self::MEMORY_WRITE;
    pub const SHADER_SAMPLED_READ: Self = Self(0x100000000);
    pub const SHADER_SAMPLED_READ_KHR: Self = Self::SHADER_SAMPLED_READ;
    pub const SHADER_STORAGE_READ: Self = Self(0x200000000);
    pub const SHADER_STORAGE_READ_KHR: Self = Self::SHADER_STORAGE_READ;
    pub const SHADER_STORAGE_WRITE: Self = Self(0x400000000);
    pub const SHADER_STORAGE_WRITE_KHR: Self = Self::SHADER_STORAGE_WRITE;
    /// Added by extension VK_KHR_synchronization2.
    pub const TRANSFORM_FEEDBACK_WRITE_EXT: Self = Self(0x2000000);
    /// Added by extension VK_KHR_synchronization2.
    pub const TRANSFORM_FEEDBACK_COUNTER_READ_EXT: Self = Self(0x4000000);
    /// Added by extension VK_KHR_synchronization2.
    pub const TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT: Self = Self(0x8000000);
    /// read access flag for reading conditional rendering predicate
    /// Added by extension VK_KHR_synchronization2.
    pub const CONDITIONAL_RENDERING_READ_EXT: Self = Self(0x100000);
    /// Added by extension VK_KHR_synchronization2.
    pub const COMMAND_PREPROCESS_READ_NV: Self = Self(0x20000);
    /// Added by extension VK_KHR_synchronization2.
    pub const COMMAND_PREPROCESS_WRITE_NV: Self = Self(0x40000);
    /// Added by extension VK_KHR_synchronization2.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR: Self = Self(0x800000);
    pub const SHADING_RATE_IMAGE_READ_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR;
    /// Added by extension VK_KHR_synchronization2.
    pub const ACCELERATION_STRUCTURE_READ_KHR: Self = Self(0x200000);
    /// Added by extension VK_KHR_synchronization2.
    pub const ACCELERATION_STRUCTURE_WRITE_KHR: Self = Self(0x400000);
    pub const ACCELERATION_STRUCTURE_READ_NV: Self = Self::ACCELERATION_STRUCTURE_READ_KHR;
    pub const ACCELERATION_STRUCTURE_WRITE_NV: Self = Self::ACCELERATION_STRUCTURE_WRITE_KHR;
    /// Added by extension VK_KHR_synchronization2.
    pub const FRAGMENT_DENSITY_MAP_READ_EXT: Self = Self(0x1000000);
    /// Added by extension VK_KHR_synchronization2.
    pub const COLOR_ATTACHMENT_READ_NONCOHERENT_EXT: Self = Self(0x80000);
    /// Added by extension VK_HUAWEI_invocation_mask.
    pub const INVOCATION_MASK_READ_HUAWEI: Self = Self(0x8000000000);
    /// Added by extension VK_KHR_ray_tracing_maintenance1.
    pub const SHADER_BINDING_TABLE_READ_KHR: Self = Self(0x10000000000);
}
impl_bitmask!(AccessFlags2, 0x1870fffffff);
impl fmt::Display for AccessFlags2 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "INDIRECT_COMMAND_READ"),
                (0x2, "INDEX_READ"),
                (0x4, "VERTEX_ATTRIBUTE_READ"),
                (0x8, "UNIFORM_READ"),
                (0x10, "INPUT_ATTACHMENT_READ"),
                (0x20, "SHADER_READ"),
                (0x40, "SHADER_WRITE"),
                (0x80, "COLOR_ATTACHMENT_READ"),
                (0x100, "COLOR_ATTACHMENT_WRITE"),
                (0x200, "DEPTH_STENCIL_ATTACHMENT_READ"),
                (0x400, "DEPTH_STENCIL_ATTACHMENT_WRITE"),
                (0x800, "TRANSFER_READ"),
                (0x1000, "TRANSFER_WRITE"),
                (0x2000, "HOST_READ"),
                (0x4000, "HOST_WRITE"),
                (0x8000, "MEMORY_READ"),
                (0x10000, "MEMORY_WRITE"),
                (0x100000000, "SHADER_SAMPLED_READ"),
                (0x200000000, "SHADER_STORAGE_READ"),
                (0x400000000, "SHADER_STORAGE_WRITE"),
                (0x2000000, "TRANSFORM_FEEDBACK_WRITE_EXT"),
                (0x4000000, "TRANSFORM_FEEDBACK_COUNTER_READ_EXT"),
                (0x8000000, "TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT"),
                (0x100000, "CONDITIONAL_RENDERING_READ_EXT"),
                (0x20000, "COMMAND_PREPROCESS_READ_NV"),
                (0x40000, "COMMAND_PREPROCESS_WRITE_NV"),
                (0x800000, "FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR"),
                (0x200000, "ACCELERATION_STRUCTURE_READ_KHR"),
                (0x400000, "ACCELERATION_STRUCTURE_WRITE_KHR"),
                (0x1000000, "FRAGMENT_DENSITY_MAP_READ_EXT"),
                (0x80000, "COLOR_ATTACHMENT_READ_NONCOHERENT_EXT"),
                (0x8000000000, "INVOCATION_MASK_READ_HUAWEI"),
                (0x10000000000, "SHADER_BINDING_TABLE_READ_KHR"),
            ],
            f,
        )
    }
}
pub type AccessFlags2KHR = AccessFlags2;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineStageFlags2(u64);
impl PipelineStageFlags2 {
    pub const NONE: Self = Self(0x0);
    pub const NONE_KHR: Self = Self::NONE;
    pub const TOP_OF_PIPE: Self = Self(0x1);
    pub const TOP_OF_PIPE_KHR: Self = Self::TOP_OF_PIPE;
    pub const DRAW_INDIRECT: Self = Self(0x2);
    pub const DRAW_INDIRECT_KHR: Self = Self::DRAW_INDIRECT;
    pub const VERTEX_INPUT: Self = Self(0x4);
    pub const VERTEX_INPUT_KHR: Self = Self::VERTEX_INPUT;
    pub const VERTEX_SHADER: Self = Self(0x8);
    pub const VERTEX_SHADER_KHR: Self = Self::VERTEX_SHADER;
    pub const TESSELLATION_CONTROL_SHADER: Self = Self(0x10);
    pub const TESSELLATION_CONTROL_SHADER_KHR: Self = Self::TESSELLATION_CONTROL_SHADER;
    pub const TESSELLATION_EVALUATION_SHADER: Self = Self(0x20);
    pub const TESSELLATION_EVALUATION_SHADER_KHR: Self = Self::TESSELLATION_EVALUATION_SHADER;
    pub const GEOMETRY_SHADER: Self = Self(0x40);
    pub const GEOMETRY_SHADER_KHR: Self = Self::GEOMETRY_SHADER;
    pub const FRAGMENT_SHADER: Self = Self(0x80);
    pub const FRAGMENT_SHADER_KHR: Self = Self::FRAGMENT_SHADER;
    pub const EARLY_FRAGMENT_TESTS: Self = Self(0x100);
    pub const EARLY_FRAGMENT_TESTS_KHR: Self = Self::EARLY_FRAGMENT_TESTS;
    pub const LATE_FRAGMENT_TESTS: Self = Self(0x200);
    pub const LATE_FRAGMENT_TESTS_KHR: Self = Self::LATE_FRAGMENT_TESTS;
    pub const COLOR_ATTACHMENT_OUTPUT: Self = Self(0x400);
    pub const COLOR_ATTACHMENT_OUTPUT_KHR: Self = Self::COLOR_ATTACHMENT_OUTPUT;
    pub const COMPUTE_SHADER: Self = Self(0x800);
    pub const COMPUTE_SHADER_KHR: Self = Self::COMPUTE_SHADER;
    pub const ALL_TRANSFER: Self = Self(0x1000);
    pub const ALL_TRANSFER_KHR: Self = Self::ALL_TRANSFER;
    pub const TRANSFER: Self = Self::ALL_TRANSFER_KHR;
    pub const TRANSFER_KHR: Self = Self::ALL_TRANSFER;
    pub const BOTTOM_OF_PIPE: Self = Self(0x2000);
    pub const BOTTOM_OF_PIPE_KHR: Self = Self::BOTTOM_OF_PIPE;
    pub const HOST: Self = Self(0x4000);
    pub const HOST_KHR: Self = Self::HOST;
    pub const ALL_GRAPHICS: Self = Self(0x8000);
    pub const ALL_GRAPHICS_KHR: Self = Self::ALL_GRAPHICS;
    pub const ALL_COMMANDS: Self = Self(0x10000);
    pub const ALL_COMMANDS_KHR: Self = Self::ALL_COMMANDS;
    pub const COPY: Self = Self(0x100000000);
    pub const COPY_KHR: Self = Self::COPY;
    pub const RESOLVE: Self = Self(0x200000000);
    pub const RESOLVE_KHR: Self = Self::RESOLVE;
    pub const BLIT: Self = Self(0x400000000);
    pub const BLIT_KHR: Self = Self::BLIT;
    pub const CLEAR: Self = Self(0x800000000);
    pub const CLEAR_KHR: Self = Self::CLEAR;
    pub const INDEX_INPUT: Self = Self(0x1000000000);
    pub const INDEX_INPUT_KHR: Self = Self::INDEX_INPUT;
    pub const VERTEX_ATTRIBUTE_INPUT: Self = Self(0x2000000000);
    pub const VERTEX_ATTRIBUTE_INPUT_KHR: Self = Self::VERTEX_ATTRIBUTE_INPUT;
    pub const PRE_RASTERIZATION_SHADERS: Self = Self(0x4000000000);
    pub const PRE_RASTERIZATION_SHADERS_KHR: Self = Self::PRE_RASTERIZATION_SHADERS;
    /// Added by extension VK_KHR_synchronization2.
    pub const TRANSFORM_FEEDBACK_EXT: Self = Self(0x1000000);
    /// A pipeline stage for conditional rendering predicate fetch
    /// Added by extension VK_KHR_synchronization2.
    pub const CONDITIONAL_RENDERING_EXT: Self = Self(0x40000);
    /// Added by extension VK_KHR_synchronization2.
    pub const COMMAND_PREPROCESS_NV: Self = Self(0x20000);
    /// Added by extension VK_KHR_synchronization2.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(0x400000);
    pub const SHADING_RATE_IMAGE_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    /// Added by extension VK_KHR_synchronization2.
    pub const ACCELERATION_STRUCTURE_BUILD_KHR: Self = Self(0x2000000);
    /// Added by extension VK_KHR_synchronization2.
    pub const RAY_TRACING_SHADER_KHR: Self = Self(0x200000);
    pub const RAY_TRACING_SHADER_NV: Self = Self::RAY_TRACING_SHADER_KHR;
    pub const ACCELERATION_STRUCTURE_BUILD_NV: Self = Self::ACCELERATION_STRUCTURE_BUILD_KHR;
    /// Added by extension VK_KHR_synchronization2.
    pub const FRAGMENT_DENSITY_PROCESS_EXT: Self = Self(0x800000);
    /// Added by extension VK_KHR_synchronization2.
    pub const TASK_SHADER_NV: Self = Self(0x80000);
    /// Added by extension VK_KHR_synchronization2.
    pub const MESH_SHADER_NV: Self = Self(0x100000);
    /// Added by extension VK_HUAWEI_subpass_shading.
    pub const SUBPASS_SHADING_HUAWEI: Self = Self(0x8000000000);
    /// Added by extension VK_HUAWEI_invocation_mask.
    pub const INVOCATION_MASK_HUAWEI: Self = Self(0x10000000000);
    /// Added by extension VK_KHR_ray_tracing_maintenance1.
    pub const ACCELERATION_STRUCTURE_COPY_KHR: Self = Self(0x10000000);
}
impl_bitmask!(PipelineStageFlags2, 0x1ff13ffffff);
impl fmt::Display for PipelineStageFlags2 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "TOP_OF_PIPE"),
                (0x2, "DRAW_INDIRECT"),
                (0x4, "VERTEX_INPUT"),
                (0x8, "VERTEX_SHADER"),
                (0x10, "TESSELLATION_CONTROL_SHADER"),
                (0x20, "TESSELLATION_EVALUATION_SHADER"),
                (0x40, "GEOMETRY_SHADER"),
                (0x80, "FRAGMENT_SHADER"),
                (0x100, "EARLY_FRAGMENT_TESTS"),
                (0x200, "LATE_FRAGMENT_TESTS"),
                (0x400, "COLOR_ATTACHMENT_OUTPUT"),
                (0x800, "COMPUTE_SHADER"),
                (0x1000, "ALL_TRANSFER"),
                (0x2000, "BOTTOM_OF_PIPE"),
                (0x4000, "HOST"),
                (0x8000, "ALL_GRAPHICS"),
                (0x10000, "ALL_COMMANDS"),
                (0x100000000, "COPY"),
                (0x200000000, "RESOLVE"),
                (0x400000000, "BLIT"),
                (0x800000000, "CLEAR"),
                (0x1000000000, "INDEX_INPUT"),
                (0x2000000000, "VERTEX_ATTRIBUTE_INPUT"),
                (0x4000000000, "PRE_RASTERIZATION_SHADERS"),
                (0x1000000, "TRANSFORM_FEEDBACK_EXT"),
                (0x40000, "CONDITIONAL_RENDERING_EXT"),
                (0x20000, "COMMAND_PREPROCESS_NV"),
                (0x400000, "FRAGMENT_SHADING_RATE_ATTACHMENT_KHR"),
                (0x2000000, "ACCELERATION_STRUCTURE_BUILD_KHR"),
                (0x200000, "RAY_TRACING_SHADER_KHR"),
                (0x800000, "FRAGMENT_DENSITY_PROCESS_EXT"),
                (0x80000, "TASK_SHADER_NV"),
                (0x100000, "MESH_SHADER_NV"),
                (0x8000000000, "SUBPASS_SHADING_HUAWEI"),
                (0x10000000000, "INVOCATION_MASK_HUAWEI"),
                (0x10000000, "ACCELERATION_STRUCTURE_COPY_KHR"),
            ],
            f,
        )
    }
}
pub type PipelineStageFlags2KHR = PipelineStageFlags2;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct AccelerationStructureMotionInfoFlagsNV(u32);
impl AccelerationStructureMotionInfoFlagsNV {}
impl_bitmask!(AccelerationStructureMotionInfoFlagsNV, 0x0);
impl fmt::Display for AccelerationStructureMotionInfoFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct AccelerationStructureMotionInstanceFlagsNV(u32);
impl AccelerationStructureMotionInstanceFlagsNV {}
impl_bitmask!(AccelerationStructureMotionInstanceFlagsNV, 0x0);
impl fmt::Display for AccelerationStructureMotionInstanceFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct FormatFeatureFlags2(u64);
impl FormatFeatureFlags2 {
    pub const SAMPLED_IMAGE: Self = Self(0x1);
    pub const SAMPLED_IMAGE_KHR: Self = Self::SAMPLED_IMAGE;
    pub const STORAGE_IMAGE: Self = Self(0x2);
    pub const STORAGE_IMAGE_KHR: Self = Self::STORAGE_IMAGE;
    pub const STORAGE_IMAGE_ATOMIC: Self = Self(0x4);
    pub const STORAGE_IMAGE_ATOMIC_KHR: Self = Self::STORAGE_IMAGE_ATOMIC;
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(0x8);
    pub const UNIFORM_TEXEL_BUFFER_KHR: Self = Self::UNIFORM_TEXEL_BUFFER;
    pub const STORAGE_TEXEL_BUFFER: Self = Self(0x10);
    pub const STORAGE_TEXEL_BUFFER_KHR: Self = Self::STORAGE_TEXEL_BUFFER;
    pub const STORAGE_TEXEL_BUFFER_ATOMIC: Self = Self(0x20);
    pub const STORAGE_TEXEL_BUFFER_ATOMIC_KHR: Self = Self::STORAGE_TEXEL_BUFFER_ATOMIC;
    pub const VERTEX_BUFFER: Self = Self(0x40);
    pub const VERTEX_BUFFER_KHR: Self = Self::VERTEX_BUFFER;
    pub const COLOR_ATTACHMENT: Self = Self(0x80);
    pub const COLOR_ATTACHMENT_KHR: Self = Self::COLOR_ATTACHMENT;
    pub const COLOR_ATTACHMENT_BLEND: Self = Self(0x100);
    pub const COLOR_ATTACHMENT_BLEND_KHR: Self = Self::COLOR_ATTACHMENT_BLEND;
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(0x200);
    pub const DEPTH_STENCIL_ATTACHMENT_KHR: Self = Self::DEPTH_STENCIL_ATTACHMENT;
    pub const BLIT_SRC: Self = Self(0x400);
    pub const BLIT_SRC_KHR: Self = Self::BLIT_SRC;
    pub const BLIT_DST: Self = Self(0x800);
    pub const BLIT_DST_KHR: Self = Self::BLIT_DST;
    pub const SAMPLED_IMAGE_FILTER_LINEAR: Self = Self(0x1000);
    pub const SAMPLED_IMAGE_FILTER_LINEAR_KHR: Self = Self::SAMPLED_IMAGE_FILTER_LINEAR;
    pub const SAMPLED_IMAGE_FILTER_CUBIC: Self = Self(0x2000);
    pub const SAMPLED_IMAGE_FILTER_CUBIC_EXT: Self = Self::SAMPLED_IMAGE_FILTER_CUBIC;
    pub const TRANSFER_SRC: Self = Self(0x4000);
    pub const TRANSFER_SRC_KHR: Self = Self::TRANSFER_SRC;
    pub const TRANSFER_DST: Self = Self(0x8000);
    pub const TRANSFER_DST_KHR: Self = Self::TRANSFER_DST;
    pub const SAMPLED_IMAGE_FILTER_MINMAX: Self = Self(0x10000);
    pub const SAMPLED_IMAGE_FILTER_MINMAX_KHR: Self = Self::SAMPLED_IMAGE_FILTER_MINMAX;
    pub const MIDPOINT_CHROMA_SAMPLES: Self = Self(0x20000);
    pub const MIDPOINT_CHROMA_SAMPLES_KHR: Self = Self::MIDPOINT_CHROMA_SAMPLES;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER: Self = Self(0x40000);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER: Self = Self(0x80000);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT: Self = Self(0x100000);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE: Self = Self(0x200000);
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE;
    pub const DISJOINT: Self = Self(0x400000);
    pub const DISJOINT_KHR: Self = Self::DISJOINT;
    pub const COSITED_CHROMA_SAMPLES: Self = Self(0x800000);
    pub const COSITED_CHROMA_SAMPLES_KHR: Self = Self::COSITED_CHROMA_SAMPLES;
    pub const STORAGE_READ_WITHOUT_FORMAT: Self = Self(0x80000000);
    pub const STORAGE_READ_WITHOUT_FORMAT_KHR: Self = Self::STORAGE_READ_WITHOUT_FORMAT;
    pub const STORAGE_WRITE_WITHOUT_FORMAT: Self = Self(0x100000000);
    pub const STORAGE_WRITE_WITHOUT_FORMAT_KHR: Self = Self::STORAGE_WRITE_WITHOUT_FORMAT;
    pub const SAMPLED_IMAGE_DEPTH_COMPARISON: Self = Self(0x200000000);
    pub const SAMPLED_IMAGE_DEPTH_COMPARISON_KHR: Self = Self::SAMPLED_IMAGE_DEPTH_COMPARISON;
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR: Self = Self(0x20000000);
    /// Added by extension VK_EXT_fragment_density_map.
    pub const FRAGMENT_DENSITY_MAP_EXT: Self = Self(0x1000000);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(0x40000000);
    /// Format support linear image as render target, it cannot be mixed with non linear attachment
    /// Added by extension VK_NV_linear_color_attachment.
    pub const LINEAR_COLOR_ATTACHMENT_NV: Self = Self(0x4000000000);
}
impl_bitmask!(FormatFeatureFlags2, 0x43e1ffffff);
impl fmt::Display for FormatFeatureFlags2 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "SAMPLED_IMAGE"),
                (0x2, "STORAGE_IMAGE"),
                (0x4, "STORAGE_IMAGE_ATOMIC"),
                (0x8, "UNIFORM_TEXEL_BUFFER"),
                (0x10, "STORAGE_TEXEL_BUFFER"),
                (0x20, "STORAGE_TEXEL_BUFFER_ATOMIC"),
                (0x40, "VERTEX_BUFFER"),
                (0x80, "COLOR_ATTACHMENT"),
                (0x100, "COLOR_ATTACHMENT_BLEND"),
                (0x200, "DEPTH_STENCIL_ATTACHMENT"),
                (0x400, "BLIT_SRC"),
                (0x800, "BLIT_DST"),
                (0x1000, "SAMPLED_IMAGE_FILTER_LINEAR"),
                (0x2000, "SAMPLED_IMAGE_FILTER_CUBIC"),
                (0x4000, "TRANSFER_SRC"),
                (0x8000, "TRANSFER_DST"),
                (0x10000, "SAMPLED_IMAGE_FILTER_MINMAX"),
                (0x20000, "MIDPOINT_CHROMA_SAMPLES"),
                (0x40000, "SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER"),
                (0x80000, "SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER"),
                (
                    0x100000,
                    "SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT",
                ),
                (
                    0x200000,
                    "SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE",
                ),
                (0x400000, "DISJOINT"),
                (0x800000, "COSITED_CHROMA_SAMPLES"),
                (0x80000000, "STORAGE_READ_WITHOUT_FORMAT"),
                (0x100000000, "STORAGE_WRITE_WITHOUT_FORMAT"),
                (0x200000000, "SAMPLED_IMAGE_DEPTH_COMPARISON"),
                (0x20000000, "ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR"),
                (0x1000000, "FRAGMENT_DENSITY_MAP_EXT"),
                (0x40000000, "FRAGMENT_SHADING_RATE_ATTACHMENT_KHR"),
                (0x4000000000, "LINEAR_COLOR_ATTACHMENT_NV"),
            ],
            f,
        )
    }
}
pub type FormatFeatureFlags2KHR = FormatFeatureFlags2;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct RenderingFlags(u32);
impl RenderingFlags {
    pub const CONTENTS_SECONDARY_COMMAND_BUFFERS: Self = Self(0x1);
    pub const CONTENTS_SECONDARY_COMMAND_BUFFERS_KHR: Self = Self::CONTENTS_SECONDARY_COMMAND_BUFFERS;
    pub const SUSPENDING: Self = Self(0x2);
    pub const SUSPENDING_KHR: Self = Self::SUSPENDING;
    pub const RESUMING: Self = Self(0x4);
    pub const RESUMING_KHR: Self = Self::RESUMING;
}
impl_bitmask!(RenderingFlags, 0x7);
impl fmt::Display for RenderingFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "CONTENTS_SECONDARY_COMMAND_BUFFERS"),
                (0x2, "SUSPENDING"),
                (0x4, "RESUMING"),
            ],
            f,
        )
    }
}
pub type RenderingFlagsKHR = RenderingFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct CompositeAlphaFlagsKHR(u32);
impl CompositeAlphaFlagsKHR {
    pub const OPAQUE: Self = Self(0x1);
    pub const PRE_MULTIPLIED: Self = Self(0x2);
    pub const POST_MULTIPLIED: Self = Self(0x4);
    pub const INHERIT: Self = Self(0x8);
}
impl_bitmask!(CompositeAlphaFlagsKHR, 0xf);
impl fmt::Display for CompositeAlphaFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "OPAQUE"),
                (0x2, "PRE_MULTIPLIED"),
                (0x4, "POST_MULTIPLIED"),
                (0x8, "INHERIT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DisplayPlaneAlphaFlagsKHR(u32);
impl DisplayPlaneAlphaFlagsKHR {
    pub const OPAQUE: Self = Self(0x1);
    pub const GLOBAL: Self = Self(0x2);
    pub const PER_PIXEL: Self = Self(0x4);
    pub const PER_PIXEL_PREMULTIPLIED: Self = Self(0x8);
}
impl_bitmask!(DisplayPlaneAlphaFlagsKHR, 0xf);
impl fmt::Display for DisplayPlaneAlphaFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "OPAQUE"),
                (0x2, "GLOBAL"),
                (0x4, "PER_PIXEL"),
                (0x8, "PER_PIXEL_PREMULTIPLIED"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SurfaceTransformFlagsKHR(u32);
impl SurfaceTransformFlagsKHR {
    pub const IDENTITY: Self = Self(0x1);
    pub const ROTATE_90: Self = Self(0x2);
    pub const ROTATE_180: Self = Self(0x4);
    pub const ROTATE_270: Self = Self(0x8);
    pub const HORIZONTAL_MIRROR: Self = Self(0x10);
    pub const HORIZONTAL_MIRROR_ROTATE_90: Self = Self(0x20);
    pub const HORIZONTAL_MIRROR_ROTATE_180: Self = Self(0x40);
    pub const HORIZONTAL_MIRROR_ROTATE_270: Self = Self(0x80);
    pub const INHERIT: Self = Self(0x100);
}
impl_bitmask!(SurfaceTransformFlagsKHR, 0x1ff);
impl fmt::Display for SurfaceTransformFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "IDENTITY"),
                (0x2, "ROTATE_90"),
                (0x4, "ROTATE_180"),
                (0x8, "ROTATE_270"),
                (0x10, "HORIZONTAL_MIRROR"),
                (0x20, "HORIZONTAL_MIRROR_ROTATE_90"),
                (0x40, "HORIZONTAL_MIRROR_ROTATE_180"),
                (0x80, "HORIZONTAL_MIRROR_ROTATE_270"),
                (0x100, "INHERIT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SwapchainCreateFlagsKHR(u32);
impl SwapchainCreateFlagsKHR {
    /// Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
    /// Added by extension VK_KHR_device_group.
    pub const SPLIT_INSTANCE_BIND_REGIONS: Self = Self(0x1);
    /// Swapchain is protected
    /// Added by extension VK_KHR_swapchain.
    pub const PROTECTED: Self = Self(0x2);
    /// Added by extension VK_KHR_swapchain_mutable_format.
    pub const MUTABLE_FORMAT: Self = Self(0x4);
}
impl_bitmask!(SwapchainCreateFlagsKHR, 0x7);
impl fmt::Display for SwapchainCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "SPLIT_INSTANCE_BIND_REGIONS"),
                (0x2, "PROTECTED"),
                (0x4, "MUTABLE_FORMAT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DisplayModeCreateFlagsKHR(u32);
impl DisplayModeCreateFlagsKHR {}
impl_bitmask!(DisplayModeCreateFlagsKHR, 0x0);
impl fmt::Display for DisplayModeCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DisplaySurfaceCreateFlagsKHR(u32);
impl DisplaySurfaceCreateFlagsKHR {}
impl_bitmask!(DisplaySurfaceCreateFlagsKHR, 0x0);
impl fmt::Display for DisplaySurfaceCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct AndroidSurfaceCreateFlagsKHR(u32);
impl AndroidSurfaceCreateFlagsKHR {}
impl_bitmask!(AndroidSurfaceCreateFlagsKHR, 0x0);
impl fmt::Display for AndroidSurfaceCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ViSurfaceCreateFlagsNN(u32);
impl ViSurfaceCreateFlagsNN {}
impl_bitmask!(ViSurfaceCreateFlagsNN, 0x0);
impl fmt::Display for ViSurfaceCreateFlagsNN {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct WaylandSurfaceCreateFlagsKHR(u32);
impl WaylandSurfaceCreateFlagsKHR {}
impl_bitmask!(WaylandSurfaceCreateFlagsKHR, 0x0);
impl fmt::Display for WaylandSurfaceCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct Win32SurfaceCreateFlagsKHR(u32);
impl Win32SurfaceCreateFlagsKHR {}
impl_bitmask!(Win32SurfaceCreateFlagsKHR, 0x0);
impl fmt::Display for Win32SurfaceCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct XlibSurfaceCreateFlagsKHR(u32);
impl XlibSurfaceCreateFlagsKHR {}
impl_bitmask!(XlibSurfaceCreateFlagsKHR, 0x0);
impl fmt::Display for XlibSurfaceCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct XcbSurfaceCreateFlagsKHR(u32);
impl XcbSurfaceCreateFlagsKHR {}
impl_bitmask!(XcbSurfaceCreateFlagsKHR, 0x0);
impl fmt::Display for XcbSurfaceCreateFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DirectFBSurfaceCreateFlagsEXT(u32);
impl DirectFBSurfaceCreateFlagsEXT {}
impl_bitmask!(DirectFBSurfaceCreateFlagsEXT, 0x0);
impl fmt::Display for DirectFBSurfaceCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct IOSSurfaceCreateFlagsMVK(u32);
impl IOSSurfaceCreateFlagsMVK {}
impl_bitmask!(IOSSurfaceCreateFlagsMVK, 0x0);
impl fmt::Display for IOSSurfaceCreateFlagsMVK {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct MacOSSurfaceCreateFlagsMVK(u32);
impl MacOSSurfaceCreateFlagsMVK {}
impl_bitmask!(MacOSSurfaceCreateFlagsMVK, 0x0);
impl fmt::Display for MacOSSurfaceCreateFlagsMVK {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct MetalSurfaceCreateFlagsEXT(u32);
impl MetalSurfaceCreateFlagsEXT {}
impl_bitmask!(MetalSurfaceCreateFlagsEXT, 0x0);
impl fmt::Display for MetalSurfaceCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImagePipeSurfaceCreateFlagsFUCHSIA(u32);
impl ImagePipeSurfaceCreateFlagsFUCHSIA {}
impl_bitmask!(ImagePipeSurfaceCreateFlagsFUCHSIA, 0x0);
impl fmt::Display for ImagePipeSurfaceCreateFlagsFUCHSIA {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct HeadlessSurfaceCreateFlagsEXT(u32);
impl HeadlessSurfaceCreateFlagsEXT {}
impl_bitmask!(HeadlessSurfaceCreateFlagsEXT, 0x0);
impl fmt::Display for HeadlessSurfaceCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PeerMemoryFeatureFlags(u32);
impl PeerMemoryFeatureFlags {
    /// Can read with vkCmdCopy commands
    pub const COPY_SRC: Self = Self(0x1);
    /// Can write with vkCmdCopy commands
    pub const COPY_DST: Self = Self(0x2);
    /// Can read with any access type/command
    pub const GENERIC_SRC: Self = Self(0x4);
    /// Can write with and access type/command
    pub const GENERIC_DST: Self = Self(0x8);
    pub const COPY_SRC_KHR: Self = Self::COPY_SRC;
    pub const COPY_DST_KHR: Self = Self::COPY_DST;
    pub const GENERIC_SRC_KHR: Self = Self::GENERIC_SRC;
    pub const GENERIC_DST_KHR: Self = Self::GENERIC_DST;
}
impl_bitmask!(PeerMemoryFeatureFlags, 0xf);
impl fmt::Display for PeerMemoryFeatureFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "COPY_SRC"),
                (0x2, "COPY_DST"),
                (0x4, "GENERIC_SRC"),
                (0x8, "GENERIC_DST"),
            ],
            f,
        )
    }
}
pub type PeerMemoryFeatureFlagsKHR = PeerMemoryFeatureFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct MemoryAllocateFlags(u32);
impl MemoryAllocateFlags {
    /// Force allocation on specific devices
    pub const DEVICE_MASK: Self = Self(0x1);
    pub const DEVICE_ADDRESS: Self = Self(0x2);
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY: Self = Self(0x4);
    pub const DEVICE_MASK_KHR: Self = Self::DEVICE_MASK;
    pub const DEVICE_ADDRESS_KHR: Self = Self::DEVICE_ADDRESS;
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_KHR: Self = Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
}
impl_bitmask!(MemoryAllocateFlags, 0x7);
impl fmt::Display for MemoryAllocateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "DEVICE_MASK"),
                (0x2, "DEVICE_ADDRESS"),
                (0x4, "DEVICE_ADDRESS_CAPTURE_REPLAY"),
            ],
            f,
        )
    }
}
pub type MemoryAllocateFlagsKHR = MemoryAllocateFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DeviceGroupPresentModeFlagsKHR(u32);
impl DeviceGroupPresentModeFlagsKHR {
    /// Present from local memory
    pub const LOCAL: Self = Self(0x1);
    /// Present from remote memory
    pub const REMOTE: Self = Self(0x2);
    /// Present sum of local and/or remote memory
    pub const SUM: Self = Self(0x4);
    /// Each physical device presents from local memory
    pub const LOCAL_MULTI_DEVICE: Self = Self(0x8);
}
impl_bitmask!(DeviceGroupPresentModeFlagsKHR, 0xf);
impl fmt::Display for DeviceGroupPresentModeFlagsKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "LOCAL"),
                (0x2, "REMOTE"),
                (0x4, "SUM"),
                (0x8, "LOCAL_MULTI_DEVICE"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DebugReportFlagsEXT(u32);
impl DebugReportFlagsEXT {
    pub const INFORMATION: Self = Self(0x1);
    pub const WARNING: Self = Self(0x2);
    pub const PERFORMANCE_WARNING: Self = Self(0x4);
    pub const ERROR: Self = Self(0x8);
    pub const DEBUG: Self = Self(0x10);
}
impl_bitmask!(DebugReportFlagsEXT, 0x1f);
impl fmt::Display for DebugReportFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "INFORMATION"),
                (0x2, "WARNING"),
                (0x4, "PERFORMANCE_WARNING"),
                (0x8, "ERROR"),
                (0x10, "DEBUG"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct CommandPoolTrimFlags(u32);
impl CommandPoolTrimFlags {}
impl_bitmask!(CommandPoolTrimFlags, 0x0);
impl fmt::Display for CommandPoolTrimFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
pub type CommandPoolTrimFlagsKHR = CommandPoolTrimFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ExternalMemoryHandleTypeFlagsNV(u32);
impl ExternalMemoryHandleTypeFlagsNV {
    pub const OPAQUE_WIN32: Self = Self(0x1);
    pub const OPAQUE_WIN32_KMT: Self = Self(0x2);
    pub const D3D11_IMAGE: Self = Self(0x4);
    pub const D3D11_IMAGE_KMT: Self = Self(0x8);
}
impl_bitmask!(ExternalMemoryHandleTypeFlagsNV, 0xf);
impl fmt::Display for ExternalMemoryHandleTypeFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "OPAQUE_WIN32"),
                (0x2, "OPAQUE_WIN32_KMT"),
                (0x4, "D3D11_IMAGE"),
                (0x8, "D3D11_IMAGE_KMT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ExternalMemoryFeatureFlagsNV(u32);
impl ExternalMemoryFeatureFlagsNV {
    pub const DEDICATED_ONLY: Self = Self(0x1);
    pub const EXPORTABLE: Self = Self(0x2);
    pub const IMPORTABLE: Self = Self(0x4);
}
impl_bitmask!(ExternalMemoryFeatureFlagsNV, 0x7);
impl fmt::Display for ExternalMemoryFeatureFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "DEDICATED_ONLY"), (0x2, "EXPORTABLE"), (0x4, "IMPORTABLE")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ExternalMemoryHandleTypeFlags(u32);
impl ExternalMemoryHandleTypeFlags {
    pub const OPAQUE_FD: Self = Self(0x1);
    pub const OPAQUE_WIN32: Self = Self(0x2);
    pub const OPAQUE_WIN32_KMT: Self = Self(0x4);
    pub const D3D11_TEXTURE: Self = Self(0x8);
    pub const D3D11_TEXTURE_KMT: Self = Self(0x10);
    pub const D3D12_HEAP: Self = Self(0x20);
    pub const D3D12_RESOURCE: Self = Self(0x40);
    pub const OPAQUE_FD_KHR: Self = Self::OPAQUE_FD;
    pub const OPAQUE_WIN32_KHR: Self = Self::OPAQUE_WIN32;
    pub const OPAQUE_WIN32_KMT_KHR: Self = Self::OPAQUE_WIN32_KMT;
    pub const D3D11_TEXTURE_KHR: Self = Self::D3D11_TEXTURE;
    pub const D3D11_TEXTURE_KMT_KHR: Self = Self::D3D11_TEXTURE_KMT;
    pub const D3D12_HEAP_KHR: Self = Self::D3D12_HEAP;
    pub const D3D12_RESOURCE_KHR: Self = Self::D3D12_RESOURCE;
    /// Added by extension VK_EXT_external_memory_dma_buf.
    pub const DMA_BUF_EXT: Self = Self(0x200);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const ANDROID_HARDWARE_BUFFER_ANDROID: Self = Self(0x400);
    /// Added by extension VK_EXT_external_memory_host.
    pub const HOST_ALLOCATION_EXT: Self = Self(0x80);
    /// Added by extension VK_EXT_external_memory_host.
    pub const HOST_MAPPED_FOREIGN_MEMORY_EXT: Self = Self(0x100);
    /// Added by extension VK_FUCHSIA_external_memory.
    pub const ZIRCON_VMO_FUCHSIA: Self = Self(0x800);
    /// Added by extension VK_NV_external_memory_rdma.
    pub const RDMA_ADDRESS_NV: Self = Self(0x1000);
}
impl_bitmask!(ExternalMemoryHandleTypeFlags, 0x1fff);
impl fmt::Display for ExternalMemoryHandleTypeFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "OPAQUE_FD"),
                (0x2, "OPAQUE_WIN32"),
                (0x4, "OPAQUE_WIN32_KMT"),
                (0x8, "D3D11_TEXTURE"),
                (0x10, "D3D11_TEXTURE_KMT"),
                (0x20, "D3D12_HEAP"),
                (0x40, "D3D12_RESOURCE"),
                (0x200, "DMA_BUF_EXT"),
                (0x400, "ANDROID_HARDWARE_BUFFER_ANDROID"),
                (0x80, "HOST_ALLOCATION_EXT"),
                (0x100, "HOST_MAPPED_FOREIGN_MEMORY_EXT"),
                (0x800, "ZIRCON_VMO_FUCHSIA"),
                (0x1000, "RDMA_ADDRESS_NV"),
            ],
            f,
        )
    }
}
pub type ExternalMemoryHandleTypeFlagsKHR = ExternalMemoryHandleTypeFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ExternalMemoryFeatureFlags(u32);
impl ExternalMemoryFeatureFlags {
    pub const DEDICATED_ONLY: Self = Self(0x1);
    pub const EXPORTABLE: Self = Self(0x2);
    pub const IMPORTABLE: Self = Self(0x4);
    pub const DEDICATED_ONLY_KHR: Self = Self::DEDICATED_ONLY;
    pub const EXPORTABLE_KHR: Self = Self::EXPORTABLE;
    pub const IMPORTABLE_KHR: Self = Self::IMPORTABLE;
}
impl_bitmask!(ExternalMemoryFeatureFlags, 0x7);
impl fmt::Display for ExternalMemoryFeatureFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "DEDICATED_ONLY"), (0x2, "EXPORTABLE"), (0x4, "IMPORTABLE")],
            f,
        )
    }
}
pub type ExternalMemoryFeatureFlagsKHR = ExternalMemoryFeatureFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ExternalSemaphoreHandleTypeFlags(u32);
impl ExternalSemaphoreHandleTypeFlags {
    pub const OPAQUE_FD: Self = Self(0x1);
    pub const OPAQUE_WIN32: Self = Self(0x2);
    pub const OPAQUE_WIN32_KMT: Self = Self(0x4);
    pub const D3D12_FENCE: Self = Self(0x8);
    pub const D3D11_FENCE: Self = Self::D3D12_FENCE;
    pub const SYNC_FD: Self = Self(0x10);
    pub const OPAQUE_FD_KHR: Self = Self::OPAQUE_FD;
    pub const OPAQUE_WIN32_KHR: Self = Self::OPAQUE_WIN32;
    pub const OPAQUE_WIN32_KMT_KHR: Self = Self::OPAQUE_WIN32_KMT;
    pub const D3D12_FENCE_KHR: Self = Self::D3D12_FENCE;
    pub const SYNC_FD_KHR: Self = Self::SYNC_FD;
    /// Added by extension VK_FUCHSIA_external_semaphore.
    pub const ZIRCON_EVENT_FUCHSIA: Self = Self(0x80);
}
impl_bitmask!(ExternalSemaphoreHandleTypeFlags, 0x9f);
impl fmt::Display for ExternalSemaphoreHandleTypeFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "OPAQUE_FD"),
                (0x2, "OPAQUE_WIN32"),
                (0x4, "OPAQUE_WIN32_KMT"),
                (0x8, "D3D12_FENCE"),
                (0x10, "SYNC_FD"),
                (0x80, "ZIRCON_EVENT_FUCHSIA"),
            ],
            f,
        )
    }
}
pub type ExternalSemaphoreHandleTypeFlagsKHR = ExternalSemaphoreHandleTypeFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ExternalSemaphoreFeatureFlags(u32);
impl ExternalSemaphoreFeatureFlags {
    pub const EXPORTABLE: Self = Self(0x1);
    pub const IMPORTABLE: Self = Self(0x2);
    pub const EXPORTABLE_KHR: Self = Self::EXPORTABLE;
    pub const IMPORTABLE_KHR: Self = Self::IMPORTABLE;
}
impl_bitmask!(ExternalSemaphoreFeatureFlags, 0x3);
impl fmt::Display for ExternalSemaphoreFeatureFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "EXPORTABLE"), (0x2, "IMPORTABLE")], f)
    }
}
pub type ExternalSemaphoreFeatureFlagsKHR = ExternalSemaphoreFeatureFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SemaphoreImportFlags(u32);
impl SemaphoreImportFlags {
    pub const TEMPORARY: Self = Self(0x1);
    pub const TEMPORARY_KHR: Self = Self::TEMPORARY;
}
impl_bitmask!(SemaphoreImportFlags, 0x1);
impl fmt::Display for SemaphoreImportFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "TEMPORARY")], f)
    }
}
pub type SemaphoreImportFlagsKHR = SemaphoreImportFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ExternalFenceHandleTypeFlags(u32);
impl ExternalFenceHandleTypeFlags {
    pub const OPAQUE_FD: Self = Self(0x1);
    pub const OPAQUE_WIN32: Self = Self(0x2);
    pub const OPAQUE_WIN32_KMT: Self = Self(0x4);
    pub const SYNC_FD: Self = Self(0x8);
    pub const OPAQUE_FD_KHR: Self = Self::OPAQUE_FD;
    pub const OPAQUE_WIN32_KHR: Self = Self::OPAQUE_WIN32;
    pub const OPAQUE_WIN32_KMT_KHR: Self = Self::OPAQUE_WIN32_KMT;
    pub const SYNC_FD_KHR: Self = Self::SYNC_FD;
}
impl_bitmask!(ExternalFenceHandleTypeFlags, 0xf);
impl fmt::Display for ExternalFenceHandleTypeFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "OPAQUE_FD"),
                (0x2, "OPAQUE_WIN32"),
                (0x4, "OPAQUE_WIN32_KMT"),
                (0x8, "SYNC_FD"),
            ],
            f,
        )
    }
}
pub type ExternalFenceHandleTypeFlagsKHR = ExternalFenceHandleTypeFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ExternalFenceFeatureFlags(u32);
impl ExternalFenceFeatureFlags {
    pub const EXPORTABLE: Self = Self(0x1);
    pub const IMPORTABLE: Self = Self(0x2);
    pub const EXPORTABLE_KHR: Self = Self::EXPORTABLE;
    pub const IMPORTABLE_KHR: Self = Self::IMPORTABLE;
}
impl_bitmask!(ExternalFenceFeatureFlags, 0x3);
impl fmt::Display for ExternalFenceFeatureFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "EXPORTABLE"), (0x2, "IMPORTABLE")], f)
    }
}
pub type ExternalFenceFeatureFlagsKHR = ExternalFenceFeatureFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct FenceImportFlags(u32);
impl FenceImportFlags {
    pub const TEMPORARY: Self = Self(0x1);
    pub const TEMPORARY_KHR: Self = Self::TEMPORARY;
}
impl_bitmask!(FenceImportFlags, 0x1);
impl fmt::Display for FenceImportFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "TEMPORARY")], f)
    }
}
pub type FenceImportFlagsKHR = FenceImportFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SurfaceCounterFlagsEXT(u32);
impl SurfaceCounterFlagsEXT {
    pub const VBLANK: Self = Self(0x1);
}
impl_bitmask!(SurfaceCounterFlagsEXT, 0x1);
impl fmt::Display for SurfaceCounterFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "VBLANK")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineViewportSwizzleStateCreateFlagsNV(u32);
impl PipelineViewportSwizzleStateCreateFlagsNV {}
impl_bitmask!(PipelineViewportSwizzleStateCreateFlagsNV, 0x0);
impl fmt::Display for PipelineViewportSwizzleStateCreateFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineDiscardRectangleStateCreateFlagsEXT(u32);
impl PipelineDiscardRectangleStateCreateFlagsEXT {}
impl_bitmask!(PipelineDiscardRectangleStateCreateFlagsEXT, 0x0);
impl fmt::Display for PipelineDiscardRectangleStateCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineCoverageToColorStateCreateFlagsNV(u32);
impl PipelineCoverageToColorStateCreateFlagsNV {}
impl_bitmask!(PipelineCoverageToColorStateCreateFlagsNV, 0x0);
impl fmt::Display for PipelineCoverageToColorStateCreateFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineCoverageModulationStateCreateFlagsNV(u32);
impl PipelineCoverageModulationStateCreateFlagsNV {}
impl_bitmask!(PipelineCoverageModulationStateCreateFlagsNV, 0x0);
impl fmt::Display for PipelineCoverageModulationStateCreateFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineCoverageReductionStateCreateFlagsNV(u32);
impl PipelineCoverageReductionStateCreateFlagsNV {}
impl_bitmask!(PipelineCoverageReductionStateCreateFlagsNV, 0x0);
impl fmt::Display for PipelineCoverageReductionStateCreateFlagsNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ValidationCacheCreateFlagsEXT(u32);
impl ValidationCacheCreateFlagsEXT {}
impl_bitmask!(ValidationCacheCreateFlagsEXT, 0x0);
impl fmt::Display for ValidationCacheCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DebugUtilsMessageSeverityFlagsEXT(u32);
impl DebugUtilsMessageSeverityFlagsEXT {
    pub const VERBOSE: Self = Self(0x1);
    pub const INFO: Self = Self(0x10);
    pub const WARNING: Self = Self(0x100);
    pub const ERROR: Self = Self(0x1000);
}
impl_bitmask!(DebugUtilsMessageSeverityFlagsEXT, 0x1111);
impl fmt::Display for DebugUtilsMessageSeverityFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "VERBOSE"), (0x10, "INFO"), (0x100, "WARNING"), (0x1000, "ERROR")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DebugUtilsMessageTypeFlagsEXT(u32);
impl DebugUtilsMessageTypeFlagsEXT {
    pub const GENERAL: Self = Self(0x1);
    pub const VALIDATION: Self = Self(0x2);
    pub const PERFORMANCE: Self = Self(0x4);
}
impl_bitmask!(DebugUtilsMessageTypeFlagsEXT, 0x7);
impl fmt::Display for DebugUtilsMessageTypeFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "GENERAL"), (0x2, "VALIDATION"), (0x4, "PERFORMANCE")],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DebugUtilsMessengerCreateFlagsEXT(u32);
impl DebugUtilsMessengerCreateFlagsEXT {}
impl_bitmask!(DebugUtilsMessengerCreateFlagsEXT, 0x0);
impl fmt::Display for DebugUtilsMessengerCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DebugUtilsMessengerCallbackDataFlagsEXT(u32);
impl DebugUtilsMessengerCallbackDataFlagsEXT {}
impl_bitmask!(DebugUtilsMessengerCallbackDataFlagsEXT, 0x0);
impl fmt::Display for DebugUtilsMessengerCallbackDataFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DeviceMemoryReportFlagsEXT(u32);
impl DeviceMemoryReportFlagsEXT {}
impl_bitmask!(DeviceMemoryReportFlagsEXT, 0x0);
impl fmt::Display for DeviceMemoryReportFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineRasterizationConservativeStateCreateFlagsEXT(u32);
impl PipelineRasterizationConservativeStateCreateFlagsEXT {}
impl_bitmask!(PipelineRasterizationConservativeStateCreateFlagsEXT, 0x0);
impl fmt::Display for PipelineRasterizationConservativeStateCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DescriptorBindingFlags(u32);
impl DescriptorBindingFlags {
    pub const UPDATE_AFTER_BIND: Self = Self(0x1);
    pub const UPDATE_UNUSED_WHILE_PENDING: Self = Self(0x2);
    pub const PARTIALLY_BOUND: Self = Self(0x4);
    pub const VARIABLE_DESCRIPTOR_COUNT: Self = Self(0x8);
    pub const UPDATE_AFTER_BIND_EXT: Self = Self::UPDATE_AFTER_BIND;
    pub const UPDATE_UNUSED_WHILE_PENDING_EXT: Self = Self::UPDATE_UNUSED_WHILE_PENDING;
    pub const PARTIALLY_BOUND_EXT: Self = Self::PARTIALLY_BOUND;
    pub const VARIABLE_DESCRIPTOR_COUNT_EXT: Self = Self::VARIABLE_DESCRIPTOR_COUNT;
}
impl_bitmask!(DescriptorBindingFlags, 0xf);
impl fmt::Display for DescriptorBindingFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "UPDATE_AFTER_BIND"),
                (0x2, "UPDATE_UNUSED_WHILE_PENDING"),
                (0x4, "PARTIALLY_BOUND"),
                (0x8, "VARIABLE_DESCRIPTOR_COUNT"),
            ],
            f,
        )
    }
}
pub type DescriptorBindingFlagsEXT = DescriptorBindingFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ConditionalRenderingFlagsEXT(u32);
impl ConditionalRenderingFlagsEXT {
    pub const INVERTED: Self = Self(0x1);
}
impl_bitmask!(ConditionalRenderingFlagsEXT, 0x1);
impl fmt::Display for ConditionalRenderingFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "INVERTED")], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ResolveModeFlags(u32);
impl ResolveModeFlags {
    pub const NONE: Self = Self(0x0);
    pub const SAMPLE_ZERO: Self = Self(0x1);
    pub const AVERAGE: Self = Self(0x2);
    pub const MIN: Self = Self(0x4);
    pub const MAX: Self = Self(0x8);
    pub const NONE_KHR: Self = Self::NONE;
    pub const SAMPLE_ZERO_KHR: Self = Self::SAMPLE_ZERO;
    pub const AVERAGE_KHR: Self = Self::AVERAGE;
    pub const MIN_KHR: Self = Self::MIN;
    pub const MAX_KHR: Self = Self::MAX;
}
impl_bitmask!(ResolveModeFlags, 0xf);
impl fmt::Display for ResolveModeFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[(0x1, "SAMPLE_ZERO"), (0x2, "AVERAGE"), (0x4, "MIN"), (0x8, "MAX")],
            f,
        )
    }
}
pub type ResolveModeFlagsKHR = ResolveModeFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineRasterizationStateStreamCreateFlagsEXT(u32);
impl PipelineRasterizationStateStreamCreateFlagsEXT {}
impl_bitmask!(PipelineRasterizationStateStreamCreateFlagsEXT, 0x0);
impl fmt::Display for PipelineRasterizationStateStreamCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineRasterizationDepthClipStateCreateFlagsEXT(u32);
impl PipelineRasterizationDepthClipStateCreateFlagsEXT {}
impl_bitmask!(PipelineRasterizationDepthClipStateCreateFlagsEXT, 0x0);
impl fmt::Display for PipelineRasterizationDepthClipStateCreateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ToolPurposeFlags(u32);
impl ToolPurposeFlags {
    pub const VALIDATION: Self = Self(0x1);
    pub const VALIDATION_EXT: Self = Self::VALIDATION;
    pub const PROFILING: Self = Self(0x2);
    pub const PROFILING_EXT: Self = Self::PROFILING;
    pub const TRACING: Self = Self(0x4);
    pub const TRACING_EXT: Self = Self::TRACING;
    pub const ADDITIONAL_FEATURES: Self = Self(0x8);
    pub const ADDITIONAL_FEATURES_EXT: Self = Self::ADDITIONAL_FEATURES;
    pub const MODIFYING_FEATURES: Self = Self(0x10);
    pub const MODIFYING_FEATURES_EXT: Self = Self::MODIFYING_FEATURES;
    /// Added by extension VK_EXT_tooling_info.
    pub const DEBUG_REPORTING_EXT: Self = Self(0x20);
    /// Added by extension VK_EXT_tooling_info.
    pub const DEBUG_MARKERS_EXT: Self = Self(0x40);
}
impl_bitmask!(ToolPurposeFlags, 0x7f);
impl fmt::Display for ToolPurposeFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "VALIDATION"),
                (0x2, "PROFILING"),
                (0x4, "TRACING"),
                (0x8, "ADDITIONAL_FEATURES"),
                (0x10, "MODIFYING_FEATURES"),
                (0x20, "DEBUG_REPORTING_EXT"),
                (0x40, "DEBUG_MARKERS_EXT"),
            ],
            f,
        )
    }
}
pub type ToolPurposeFlagsEXT = ToolPurposeFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SubmitFlags(u32);
impl SubmitFlags {
    pub const PROTECTED: Self = Self(0x1);
    pub const PROTECTED_KHR: Self = Self::PROTECTED;
}
impl_bitmask!(SubmitFlags, 0x1);
impl fmt::Display for SubmitFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[(0x1, "PROTECTED")], f)
    }
}
pub type SubmitFlagsKHR = SubmitFlags;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImageFormatConstraintsFlagsFUCHSIA(u32);
impl ImageFormatConstraintsFlagsFUCHSIA {}
impl_bitmask!(ImageFormatConstraintsFlagsFUCHSIA, 0x0);
impl fmt::Display for ImageFormatConstraintsFlagsFUCHSIA {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(self.0 as _, &[], f)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImageConstraintsInfoFlagsFUCHSIA(u32);
impl ImageConstraintsInfoFlagsFUCHSIA {
    pub const CPU_READ_RARELY: Self = Self(0x1);
    pub const CPU_READ_OFTEN: Self = Self(0x2);
    pub const CPU_WRITE_RARELY: Self = Self(0x4);
    pub const CPU_WRITE_OFTEN: Self = Self(0x8);
    pub const PROTECTED_OPTIONAL: Self = Self(0x10);
}
impl_bitmask!(ImageConstraintsInfoFlagsFUCHSIA, 0x1f);
impl fmt::Display for ImageConstraintsInfoFlagsFUCHSIA {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "CPU_READ_RARELY"),
                (0x2, "CPU_READ_OFTEN"),
                (0x4, "CPU_WRITE_RARELY"),
                (0x8, "CPU_WRITE_OFTEN"),
                (0x10, "PROTECTED_OPTIONAL"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct GraphicsPipelineLibraryFlagsEXT(u32);
impl GraphicsPipelineLibraryFlagsEXT {
    pub const VERTEX_INPUT_INTERFACE: Self = Self(0x1);
    pub const PRE_RASTERIZATION_SHADERS: Self = Self(0x2);
    pub const FRAGMENT_SHADER: Self = Self(0x4);
    pub const FRAGMENT_OUTPUT_INTERFACE: Self = Self(0x8);
}
impl_bitmask!(GraphicsPipelineLibraryFlagsEXT, 0xf);
impl fmt::Display for GraphicsPipelineLibraryFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "VERTEX_INPUT_INTERFACE"),
                (0x2, "PRE_RASTERIZATION_SHADERS"),
                (0x4, "FRAGMENT_SHADER"),
                (0x8, "FRAGMENT_OUTPUT_INTERFACE"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImageCompressionFlagsEXT(u32);
impl ImageCompressionFlagsEXT {
    pub const DEFAULT: Self = Self(0x0);
    pub const FIXED_RATE_DEFAULT: Self = Self(0x1);
    pub const FIXED_RATE_EXPLICIT: Self = Self(0x2);
    pub const DISABLED: Self = Self(0x4);
}
impl_bitmask!(ImageCompressionFlagsEXT, 0x7);
impl fmt::Display for ImageCompressionFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "FIXED_RATE_DEFAULT"),
                (0x2, "FIXED_RATE_EXPLICIT"),
                (0x4, "DISABLED"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImageCompressionFixedRateFlagsEXT(u32);
impl ImageCompressionFixedRateFlagsEXT {
    pub const NONE: Self = Self(0x0);
    pub const N1BPC: Self = Self(0x1);
    pub const N2BPC: Self = Self(0x2);
    pub const N3BPC: Self = Self(0x4);
    pub const N4BPC: Self = Self(0x8);
    pub const N5BPC: Self = Self(0x10);
    pub const N6BPC: Self = Self(0x20);
    pub const N7BPC: Self = Self(0x40);
    pub const N8BPC: Self = Self(0x80);
    pub const N9BPC: Self = Self(0x100);
    pub const N10BPC: Self = Self(0x200);
    pub const N11BPC: Self = Self(0x400);
    pub const N12BPC: Self = Self(0x800);
    pub const N13BPC: Self = Self(0x1000);
    pub const N14BPC: Self = Self(0x2000);
    pub const N15BPC: Self = Self(0x4000);
    pub const N16BPC: Self = Self(0x8000);
    pub const N17BPC: Self = Self(0x10000);
    pub const N18BPC: Self = Self(0x20000);
    pub const N19BPC: Self = Self(0x40000);
    pub const N20BPC: Self = Self(0x80000);
    pub const N21BPC: Self = Self(0x100000);
    pub const N22BPC: Self = Self(0x200000);
    pub const N23BPC: Self = Self(0x400000);
    pub const N24BPC: Self = Self(0x800000);
}
impl_bitmask!(ImageCompressionFixedRateFlagsEXT, 0xffffff);
impl fmt::Display for ImageCompressionFixedRateFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "N1BPC"),
                (0x2, "N2BPC"),
                (0x4, "N3BPC"),
                (0x8, "N4BPC"),
                (0x10, "N5BPC"),
                (0x20, "N6BPC"),
                (0x40, "N7BPC"),
                (0x80, "N8BPC"),
                (0x100, "N9BPC"),
                (0x200, "N10BPC"),
                (0x400, "N11BPC"),
                (0x800, "N12BPC"),
                (0x1000, "N13BPC"),
                (0x2000, "N14BPC"),
                (0x4000, "N15BPC"),
                (0x8000, "N16BPC"),
                (0x10000, "N17BPC"),
                (0x20000, "N18BPC"),
                (0x40000, "N19BPC"),
                (0x80000, "N20BPC"),
                (0x100000, "N21BPC"),
                (0x200000, "N22BPC"),
                (0x400000, "N23BPC"),
                (0x800000, "N24BPC"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ExportMetalObjectTypeFlagsEXT(u32);
impl ExportMetalObjectTypeFlagsEXT {
    pub const METAL_DEVICE: Self = Self(0x1);
    pub const METAL_COMMAND_QUEUE: Self = Self(0x2);
    pub const METAL_BUFFER: Self = Self(0x4);
    pub const METAL_TEXTURE: Self = Self(0x8);
    pub const METAL_IOSURFACE: Self = Self(0x10);
    pub const METAL_SHARED_EVENT: Self = Self(0x20);
}
impl_bitmask!(ExportMetalObjectTypeFlagsEXT, 0x3f);
impl fmt::Display for ExportMetalObjectTypeFlagsEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        display_bitmask(
            self.0 as _,
            &[
                (0x1, "METAL_DEVICE"),
                (0x2, "METAL_COMMAND_QUEUE"),
                (0x4, "METAL_BUFFER"),
                (0x8, "METAL_TEXTURE"),
                (0x10, "METAL_IOSURFACE"),
                (0x20, "METAL_SHARED_EVENT"),
            ],
            f,
        )
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Instance(num::NonZeroUsize);
impl Instance {
    pub fn from_raw(x: usize) -> Option<Self> {
        num::NonZeroUsize::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PhysicalDevice(num::NonZeroUsize);
impl PhysicalDevice {
    pub fn from_raw(x: usize) -> Option<Self> {
        num::NonZeroUsize::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Device(num::NonZeroUsize);
impl Device {
    pub fn from_raw(x: usize) -> Option<Self> {
        num::NonZeroUsize::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Queue(num::NonZeroUsize);
impl Queue {
    pub fn from_raw(x: usize) -> Option<Self> {
        num::NonZeroUsize::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CommandBuffer(num::NonZeroUsize);
impl CommandBuffer {
    pub fn from_raw(x: usize) -> Option<Self> {
        num::NonZeroUsize::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DeviceMemory(num::NonZeroU64);
impl DeviceMemory {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CommandPool(num::NonZeroU64);
impl CommandPool {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Buffer(num::NonZeroU64);
impl Buffer {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct BufferView(num::NonZeroU64);
impl BufferView {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Image(num::NonZeroU64);
impl Image {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ImageView(num::NonZeroU64);
impl ImageView {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ShaderModule(num::NonZeroU64);
impl ShaderModule {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Pipeline(num::NonZeroU64);
impl Pipeline {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineLayout(num::NonZeroU64);
impl PipelineLayout {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Sampler(num::NonZeroU64);
impl Sampler {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorSet(num::NonZeroU64);
impl DescriptorSet {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorSetLayout(num::NonZeroU64);
impl DescriptorSetLayout {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorPool(num::NonZeroU64);
impl DescriptorPool {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Fence(num::NonZeroU64);
impl Fence {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Semaphore(num::NonZeroU64);
impl Semaphore {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Event(num::NonZeroU64);
impl Event {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct QueryPool(num::NonZeroU64);
impl QueryPool {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Framebuffer(num::NonZeroU64);
impl Framebuffer {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct RenderPass(num::NonZeroU64);
impl RenderPass {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineCache(num::NonZeroU64);
impl PipelineCache {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct IndirectCommandsLayoutNV(num::NonZeroU64);
impl IndirectCommandsLayoutNV {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DescriptorUpdateTemplate(num::NonZeroU64);
impl DescriptorUpdateTemplate {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
pub type DescriptorUpdateTemplateKHR = DescriptorUpdateTemplate;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SamplerYcbcrConversion(num::NonZeroU64);
impl SamplerYcbcrConversion {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
pub type SamplerYcbcrConversionKHR = SamplerYcbcrConversion;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ValidationCacheEXT(num::NonZeroU64);
impl ValidationCacheEXT {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AccelerationStructureKHR(num::NonZeroU64);
impl AccelerationStructureKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AccelerationStructureNV(num::NonZeroU64);
impl AccelerationStructureNV {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PerformanceConfigurationINTEL(num::NonZeroU64);
impl PerformanceConfigurationINTEL {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct BufferCollectionFUCHSIA(num::NonZeroU64);
impl BufferCollectionFUCHSIA {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DeferredOperationKHR(num::NonZeroU64);
impl DeferredOperationKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PrivateDataSlot(num::NonZeroU64);
impl PrivateDataSlot {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
pub type PrivateDataSlotEXT = PrivateDataSlot;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CuModuleNVX(num::NonZeroU64);
impl CuModuleNVX {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CuFunctionNVX(num::NonZeroU64);
impl CuFunctionNVX {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DisplayKHR(num::NonZeroU64);
impl DisplayKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DisplayModeKHR(num::NonZeroU64);
impl DisplayModeKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SurfaceKHR(num::NonZeroU64);
impl SurfaceKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SwapchainKHR(num::NonZeroU64);
impl SwapchainKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DebugReportCallbackEXT(num::NonZeroU64);
impl DebugReportCallbackEXT {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DebugUtilsMessengerEXT(num::NonZeroU64);
impl DebugUtilsMessengerEXT {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct VideoSessionKHR(num::NonZeroU64);
impl VideoSessionKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct VideoSessionParametersKHR(num::NonZeroU64);
impl VideoSessionParametersKHR {
    pub fn from_raw(x: u64) -> Option<Self> {
        num::NonZeroU64::new(x).map(Self)
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct AttachmentLoadOp(i32);
impl AttachmentLoadOp {
    pub const LOAD: Self = Self(0);
    pub const CLEAR: Self = Self(1);
    pub const DONT_CARE: Self = Self(2);
    /// Added by extension VK_EXT_load_store_op_none.
    pub const NONE_EXT: Self = Self(1000400000);
}
impl fmt::Display for AttachmentLoadOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"LOAD"),
            1 => Some(&"CLEAR"),
            2 => Some(&"DONT_CARE"),
            1000400000 => Some(&"NONE_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct AttachmentStoreOp(i32);
impl AttachmentStoreOp {
    pub const STORE: Self = Self(0);
    pub const DONT_CARE: Self = Self(1);
    pub const NONE: Self = Self(1000301000);
    pub const NONE_KHR: Self = Self::NONE;
    pub const NONE_QCOM: Self = Self::NONE;
    pub const NONE_EXT: Self = Self::NONE;
}
impl fmt::Display for AttachmentStoreOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"STORE"),
            1 => Some(&"DONT_CARE"),
            1000301000 => Some(&"NONE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct BlendFactor(i32);
impl BlendFactor {
    pub const ZERO: Self = Self(0);
    pub const ONE: Self = Self(1);
    pub const SRC_COLOR: Self = Self(2);
    pub const ONE_MINUS_SRC_COLOR: Self = Self(3);
    pub const DST_COLOR: Self = Self(4);
    pub const ONE_MINUS_DST_COLOR: Self = Self(5);
    pub const SRC_ALPHA: Self = Self(6);
    pub const ONE_MINUS_SRC_ALPHA: Self = Self(7);
    pub const DST_ALPHA: Self = Self(8);
    pub const ONE_MINUS_DST_ALPHA: Self = Self(9);
    pub const CONSTANT_COLOR: Self = Self(10);
    pub const ONE_MINUS_CONSTANT_COLOR: Self = Self(11);
    pub const CONSTANT_ALPHA: Self = Self(12);
    pub const ONE_MINUS_CONSTANT_ALPHA: Self = Self(13);
    pub const SRC_ALPHA_SATURATE: Self = Self(14);
    pub const SRC1_COLOR: Self = Self(15);
    pub const ONE_MINUS_SRC1_COLOR: Self = Self(16);
    pub const SRC1_ALPHA: Self = Self(17);
    pub const ONE_MINUS_SRC1_ALPHA: Self = Self(18);
}
impl fmt::Display for BlendFactor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"ZERO"),
            1 => Some(&"ONE"),
            2 => Some(&"SRC_COLOR"),
            3 => Some(&"ONE_MINUS_SRC_COLOR"),
            4 => Some(&"DST_COLOR"),
            5 => Some(&"ONE_MINUS_DST_COLOR"),
            6 => Some(&"SRC_ALPHA"),
            7 => Some(&"ONE_MINUS_SRC_ALPHA"),
            8 => Some(&"DST_ALPHA"),
            9 => Some(&"ONE_MINUS_DST_ALPHA"),
            10 => Some(&"CONSTANT_COLOR"),
            11 => Some(&"ONE_MINUS_CONSTANT_COLOR"),
            12 => Some(&"CONSTANT_ALPHA"),
            13 => Some(&"ONE_MINUS_CONSTANT_ALPHA"),
            14 => Some(&"SRC_ALPHA_SATURATE"),
            15 => Some(&"SRC1_COLOR"),
            16 => Some(&"ONE_MINUS_SRC1_COLOR"),
            17 => Some(&"SRC1_ALPHA"),
            18 => Some(&"ONE_MINUS_SRC1_ALPHA"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct BlendOp(i32);
impl BlendOp {
    pub const ADD: Self = Self(0);
    pub const SUBTRACT: Self = Self(1);
    pub const REVERSE_SUBTRACT: Self = Self(2);
    pub const MIN: Self = Self(3);
    pub const MAX: Self = Self(4);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const ZERO_EXT: Self = Self(1000148000);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const SRC_EXT: Self = Self(1000148001);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const DST_EXT: Self = Self(1000148002);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const SRC_OVER_EXT: Self = Self(1000148003);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const DST_OVER_EXT: Self = Self(1000148004);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const SRC_IN_EXT: Self = Self(1000148005);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const DST_IN_EXT: Self = Self(1000148006);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const SRC_OUT_EXT: Self = Self(1000148007);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const DST_OUT_EXT: Self = Self(1000148008);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const SRC_ATOP_EXT: Self = Self(1000148009);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const DST_ATOP_EXT: Self = Self(1000148010);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const XOR_EXT: Self = Self(1000148011);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const MULTIPLY_EXT: Self = Self(1000148012);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const SCREEN_EXT: Self = Self(1000148013);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const OVERLAY_EXT: Self = Self(1000148014);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const DARKEN_EXT: Self = Self(1000148015);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const LIGHTEN_EXT: Self = Self(1000148016);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const COLORDODGE_EXT: Self = Self(1000148017);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const COLORBURN_EXT: Self = Self(1000148018);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const HARDLIGHT_EXT: Self = Self(1000148019);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const SOFTLIGHT_EXT: Self = Self(1000148020);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const DIFFERENCE_EXT: Self = Self(1000148021);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const EXCLUSION_EXT: Self = Self(1000148022);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const INVERT_EXT: Self = Self(1000148023);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const INVERT_RGB_EXT: Self = Self(1000148024);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const LINEARDODGE_EXT: Self = Self(1000148025);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const LINEARBURN_EXT: Self = Self(1000148026);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const VIVIDLIGHT_EXT: Self = Self(1000148027);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const LINEARLIGHT_EXT: Self = Self(1000148028);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PINLIGHT_EXT: Self = Self(1000148029);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const HARDMIX_EXT: Self = Self(1000148030);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const HSL_HUE_EXT: Self = Self(1000148031);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const HSL_SATURATION_EXT: Self = Self(1000148032);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const HSL_COLOR_EXT: Self = Self(1000148033);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const HSL_LUMINOSITY_EXT: Self = Self(1000148034);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PLUS_EXT: Self = Self(1000148035);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PLUS_CLAMPED_EXT: Self = Self(1000148036);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PLUS_CLAMPED_ALPHA_EXT: Self = Self(1000148037);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PLUS_DARKER_EXT: Self = Self(1000148038);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const MINUS_EXT: Self = Self(1000148039);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const MINUS_CLAMPED_EXT: Self = Self(1000148040);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const CONTRAST_EXT: Self = Self(1000148041);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const INVERT_OVG_EXT: Self = Self(1000148042);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const RED_EXT: Self = Self(1000148043);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const GREEN_EXT: Self = Self(1000148044);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const BLUE_EXT: Self = Self(1000148045);
}
impl fmt::Display for BlendOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"ADD"),
            1 => Some(&"SUBTRACT"),
            2 => Some(&"REVERSE_SUBTRACT"),
            3 => Some(&"MIN"),
            4 => Some(&"MAX"),
            1000148000 => Some(&"ZERO_EXT"),
            1000148001 => Some(&"SRC_EXT"),
            1000148002 => Some(&"DST_EXT"),
            1000148003 => Some(&"SRC_OVER_EXT"),
            1000148004 => Some(&"DST_OVER_EXT"),
            1000148005 => Some(&"SRC_IN_EXT"),
            1000148006 => Some(&"DST_IN_EXT"),
            1000148007 => Some(&"SRC_OUT_EXT"),
            1000148008 => Some(&"DST_OUT_EXT"),
            1000148009 => Some(&"SRC_ATOP_EXT"),
            1000148010 => Some(&"DST_ATOP_EXT"),
            1000148011 => Some(&"XOR_EXT"),
            1000148012 => Some(&"MULTIPLY_EXT"),
            1000148013 => Some(&"SCREEN_EXT"),
            1000148014 => Some(&"OVERLAY_EXT"),
            1000148015 => Some(&"DARKEN_EXT"),
            1000148016 => Some(&"LIGHTEN_EXT"),
            1000148017 => Some(&"COLORDODGE_EXT"),
            1000148018 => Some(&"COLORBURN_EXT"),
            1000148019 => Some(&"HARDLIGHT_EXT"),
            1000148020 => Some(&"SOFTLIGHT_EXT"),
            1000148021 => Some(&"DIFFERENCE_EXT"),
            1000148022 => Some(&"EXCLUSION_EXT"),
            1000148023 => Some(&"INVERT_EXT"),
            1000148024 => Some(&"INVERT_RGB_EXT"),
            1000148025 => Some(&"LINEARDODGE_EXT"),
            1000148026 => Some(&"LINEARBURN_EXT"),
            1000148027 => Some(&"VIVIDLIGHT_EXT"),
            1000148028 => Some(&"LINEARLIGHT_EXT"),
            1000148029 => Some(&"PINLIGHT_EXT"),
            1000148030 => Some(&"HARDMIX_EXT"),
            1000148031 => Some(&"HSL_HUE_EXT"),
            1000148032 => Some(&"HSL_SATURATION_EXT"),
            1000148033 => Some(&"HSL_COLOR_EXT"),
            1000148034 => Some(&"HSL_LUMINOSITY_EXT"),
            1000148035 => Some(&"PLUS_EXT"),
            1000148036 => Some(&"PLUS_CLAMPED_EXT"),
            1000148037 => Some(&"PLUS_CLAMPED_ALPHA_EXT"),
            1000148038 => Some(&"PLUS_DARKER_EXT"),
            1000148039 => Some(&"MINUS_EXT"),
            1000148040 => Some(&"MINUS_CLAMPED_EXT"),
            1000148041 => Some(&"CONTRAST_EXT"),
            1000148042 => Some(&"INVERT_OVG_EXT"),
            1000148043 => Some(&"RED_EXT"),
            1000148044 => Some(&"GREEN_EXT"),
            1000148045 => Some(&"BLUE_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct BorderColor(i32);
impl BorderColor {
    pub const FLOAT_TRANSPARENT_BLACK: Self = Self(0);
    pub const INT_TRANSPARENT_BLACK: Self = Self(1);
    pub const FLOAT_OPAQUE_BLACK: Self = Self(2);
    pub const INT_OPAQUE_BLACK: Self = Self(3);
    pub const FLOAT_OPAQUE_WHITE: Self = Self(4);
    pub const INT_OPAQUE_WHITE: Self = Self(5);
    /// Added by extension VK_EXT_custom_border_color.
    pub const FLOAT_CUSTOM_EXT: Self = Self(1000287003);
    /// Added by extension VK_EXT_custom_border_color.
    pub const INT_CUSTOM_EXT: Self = Self(1000287004);
}
impl fmt::Display for BorderColor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"FLOAT_TRANSPARENT_BLACK"),
            1 => Some(&"INT_TRANSPARENT_BLACK"),
            2 => Some(&"FLOAT_OPAQUE_BLACK"),
            3 => Some(&"INT_OPAQUE_BLACK"),
            4 => Some(&"FLOAT_OPAQUE_WHITE"),
            5 => Some(&"INT_OPAQUE_WHITE"),
            1000287003 => Some(&"FLOAT_CUSTOM_EXT"),
            1000287004 => Some(&"INT_CUSTOM_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PipelineCacheHeaderVersion(i32);
impl PipelineCacheHeaderVersion {
    pub const ONE: Self = Self(1);
}
impl fmt::Display for PipelineCacheHeaderVersion {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            1 => Some(&"ONE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ComponentSwizzle(i32);
impl ComponentSwizzle {
    pub const IDENTITY: Self = Self(0);
    pub const ZERO: Self = Self(1);
    pub const ONE: Self = Self(2);
    pub const R: Self = Self(3);
    pub const G: Self = Self(4);
    pub const B: Self = Self(5);
    pub const A: Self = Self(6);
}
impl fmt::Display for ComponentSwizzle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"IDENTITY"),
            1 => Some(&"ZERO"),
            2 => Some(&"ONE"),
            3 => Some(&"R"),
            4 => Some(&"G"),
            5 => Some(&"B"),
            6 => Some(&"A"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct CommandBufferLevel(i32);
impl CommandBufferLevel {
    pub const PRIMARY: Self = Self(0);
    pub const SECONDARY: Self = Self(1);
}
impl fmt::Display for CommandBufferLevel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"PRIMARY"),
            1 => Some(&"SECONDARY"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct CompareOp(i32);
impl CompareOp {
    pub const NEVER: Self = Self(0);
    pub const LESS: Self = Self(1);
    pub const EQUAL: Self = Self(2);
    pub const LESS_OR_EQUAL: Self = Self(3);
    pub const GREATER: Self = Self(4);
    pub const NOT_EQUAL: Self = Self(5);
    pub const GREATER_OR_EQUAL: Self = Self(6);
    pub const ALWAYS: Self = Self(7);
}
impl fmt::Display for CompareOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"NEVER"),
            1 => Some(&"LESS"),
            2 => Some(&"EQUAL"),
            3 => Some(&"LESS_OR_EQUAL"),
            4 => Some(&"GREATER"),
            5 => Some(&"NOT_EQUAL"),
            6 => Some(&"GREATER_OR_EQUAL"),
            7 => Some(&"ALWAYS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DescriptorType(i32);
impl DescriptorType {
    pub const SAMPLER: Self = Self(0);
    pub const COMBINED_IMAGE_SAMPLER: Self = Self(1);
    pub const SAMPLED_IMAGE: Self = Self(2);
    pub const STORAGE_IMAGE: Self = Self(3);
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(4);
    pub const STORAGE_TEXEL_BUFFER: Self = Self(5);
    pub const UNIFORM_BUFFER: Self = Self(6);
    pub const STORAGE_BUFFER: Self = Self(7);
    pub const UNIFORM_BUFFER_DYNAMIC: Self = Self(8);
    pub const STORAGE_BUFFER_DYNAMIC: Self = Self(9);
    pub const INPUT_ATTACHMENT: Self = Self(10);
    pub const INLINE_UNIFORM_BLOCK: Self = Self(1000138000);
    pub const INLINE_UNIFORM_BLOCK_EXT: Self = Self::INLINE_UNIFORM_BLOCK;
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_KHR: Self = Self(1000150000);
    /// Added by extension VK_NV_ray_tracing.
    pub const ACCELERATION_STRUCTURE_NV: Self = Self(1000165000);
    /// Added by extension VK_VALVE_mutable_descriptor_type.
    pub const MUTABLE_VALVE: Self = Self(1000351000);
}
impl fmt::Display for DescriptorType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"SAMPLER"),
            1 => Some(&"COMBINED_IMAGE_SAMPLER"),
            2 => Some(&"SAMPLED_IMAGE"),
            3 => Some(&"STORAGE_IMAGE"),
            4 => Some(&"UNIFORM_TEXEL_BUFFER"),
            5 => Some(&"STORAGE_TEXEL_BUFFER"),
            6 => Some(&"UNIFORM_BUFFER"),
            7 => Some(&"STORAGE_BUFFER"),
            8 => Some(&"UNIFORM_BUFFER_DYNAMIC"),
            9 => Some(&"STORAGE_BUFFER_DYNAMIC"),
            10 => Some(&"INPUT_ATTACHMENT"),
            1000138000 => Some(&"INLINE_UNIFORM_BLOCK"),
            1000150000 => Some(&"ACCELERATION_STRUCTURE_KHR"),
            1000165000 => Some(&"ACCELERATION_STRUCTURE_NV"),
            1000351000 => Some(&"MUTABLE_VALVE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DynamicState(i32);
impl DynamicState {
    pub const VIEWPORT: Self = Self(0);
    pub const SCISSOR: Self = Self(1);
    pub const LINE_WIDTH: Self = Self(2);
    pub const DEPTH_BIAS: Self = Self(3);
    pub const BLEND_CONSTANTS: Self = Self(4);
    pub const DEPTH_BOUNDS: Self = Self(5);
    pub const STENCIL_COMPARE_MASK: Self = Self(6);
    pub const STENCIL_WRITE_MASK: Self = Self(7);
    pub const STENCIL_REFERENCE: Self = Self(8);
    pub const CULL_MODE: Self = Self(1000267000);
    pub const FRONT_FACE: Self = Self(1000267001);
    pub const PRIMITIVE_TOPOLOGY: Self = Self(1000267002);
    pub const VIEWPORT_WITH_COUNT: Self = Self(1000267003);
    pub const SCISSOR_WITH_COUNT: Self = Self(1000267004);
    pub const VERTEX_INPUT_BINDING_STRIDE: Self = Self(1000267005);
    pub const DEPTH_TEST_ENABLE: Self = Self(1000267006);
    pub const DEPTH_WRITE_ENABLE: Self = Self(1000267007);
    pub const DEPTH_COMPARE_OP: Self = Self(1000267008);
    pub const DEPTH_BOUNDS_TEST_ENABLE: Self = Self(1000267009);
    pub const STENCIL_TEST_ENABLE: Self = Self(1000267010);
    pub const STENCIL_OP: Self = Self(1000267011);
    pub const RASTERIZER_DISCARD_ENABLE: Self = Self(1000377001);
    pub const DEPTH_BIAS_ENABLE: Self = Self(1000377002);
    pub const PRIMITIVE_RESTART_ENABLE: Self = Self(1000377004);
    /// Added by extension VK_NV_clip_space_w_scaling.
    pub const VIEWPORT_W_SCALING_NV: Self = Self(1000087000);
    /// Added by extension VK_EXT_discard_rectangles.
    pub const DISCARD_RECTANGLE_EXT: Self = Self(1000099000);
    /// Added by extension VK_EXT_sample_locations.
    pub const SAMPLE_LOCATIONS_EXT: Self = Self(1000143000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_PIPELINE_STACK_SIZE_KHR: Self = Self(1000347000);
    /// Added by extension VK_NV_shading_rate_image.
    pub const VIEWPORT_SHADING_RATE_PALETTE_NV: Self = Self(1000164004);
    /// Added by extension VK_NV_shading_rate_image.
    pub const VIEWPORT_COARSE_SAMPLE_ORDER_NV: Self = Self(1000164006);
    /// Added by extension VK_NV_scissor_exclusive.
    pub const EXCLUSIVE_SCISSOR_NV: Self = Self(1000205001);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_KHR: Self = Self(1000226000);
    /// Added by extension VK_EXT_line_rasterization.
    pub const LINE_STIPPLE_EXT: Self = Self(1000259000);
    pub const CULL_MODE_EXT: Self = Self::CULL_MODE;
    pub const FRONT_FACE_EXT: Self = Self::FRONT_FACE;
    pub const PRIMITIVE_TOPOLOGY_EXT: Self = Self::PRIMITIVE_TOPOLOGY;
    pub const VIEWPORT_WITH_COUNT_EXT: Self = Self::VIEWPORT_WITH_COUNT;
    pub const SCISSOR_WITH_COUNT_EXT: Self = Self::SCISSOR_WITH_COUNT;
    pub const VERTEX_INPUT_BINDING_STRIDE_EXT: Self = Self::VERTEX_INPUT_BINDING_STRIDE;
    pub const DEPTH_TEST_ENABLE_EXT: Self = Self::DEPTH_TEST_ENABLE;
    pub const DEPTH_WRITE_ENABLE_EXT: Self = Self::DEPTH_WRITE_ENABLE;
    pub const DEPTH_COMPARE_OP_EXT: Self = Self::DEPTH_COMPARE_OP;
    pub const DEPTH_BOUNDS_TEST_ENABLE_EXT: Self = Self::DEPTH_BOUNDS_TEST_ENABLE;
    pub const STENCIL_TEST_ENABLE_EXT: Self = Self::STENCIL_TEST_ENABLE;
    pub const STENCIL_OP_EXT: Self = Self::STENCIL_OP;
    /// Added by extension VK_EXT_vertex_input_dynamic_state.
    pub const VERTEX_INPUT_EXT: Self = Self(1000352000);
    /// Not promoted to 1.3
    /// Added by extension VK_EXT_extended_dynamic_state2.
    pub const PATCH_CONTROL_POINTS_EXT: Self = Self(1000377000);
    pub const RASTERIZER_DISCARD_ENABLE_EXT: Self = Self::RASTERIZER_DISCARD_ENABLE;
    pub const DEPTH_BIAS_ENABLE_EXT: Self = Self::DEPTH_BIAS_ENABLE;
    /// Not promoted to 1.3
    /// Added by extension VK_EXT_extended_dynamic_state2.
    pub const LOGIC_OP_EXT: Self = Self(1000377003);
    pub const PRIMITIVE_RESTART_ENABLE_EXT: Self = Self::PRIMITIVE_RESTART_ENABLE;
    /// Added by extension VK_EXT_color_write_enable.
    pub const COLOR_WRITE_ENABLE_EXT: Self = Self(1000381000);
}
impl fmt::Display for DynamicState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"VIEWPORT"),
            1 => Some(&"SCISSOR"),
            2 => Some(&"LINE_WIDTH"),
            3 => Some(&"DEPTH_BIAS"),
            4 => Some(&"BLEND_CONSTANTS"),
            5 => Some(&"DEPTH_BOUNDS"),
            6 => Some(&"STENCIL_COMPARE_MASK"),
            7 => Some(&"STENCIL_WRITE_MASK"),
            8 => Some(&"STENCIL_REFERENCE"),
            1000267000 => Some(&"CULL_MODE"),
            1000267001 => Some(&"FRONT_FACE"),
            1000267002 => Some(&"PRIMITIVE_TOPOLOGY"),
            1000267003 => Some(&"VIEWPORT_WITH_COUNT"),
            1000267004 => Some(&"SCISSOR_WITH_COUNT"),
            1000267005 => Some(&"VERTEX_INPUT_BINDING_STRIDE"),
            1000267006 => Some(&"DEPTH_TEST_ENABLE"),
            1000267007 => Some(&"DEPTH_WRITE_ENABLE"),
            1000267008 => Some(&"DEPTH_COMPARE_OP"),
            1000267009 => Some(&"DEPTH_BOUNDS_TEST_ENABLE"),
            1000267010 => Some(&"STENCIL_TEST_ENABLE"),
            1000267011 => Some(&"STENCIL_OP"),
            1000377001 => Some(&"RASTERIZER_DISCARD_ENABLE"),
            1000377002 => Some(&"DEPTH_BIAS_ENABLE"),
            1000377004 => Some(&"PRIMITIVE_RESTART_ENABLE"),
            1000087000 => Some(&"VIEWPORT_W_SCALING_NV"),
            1000099000 => Some(&"DISCARD_RECTANGLE_EXT"),
            1000143000 => Some(&"SAMPLE_LOCATIONS_EXT"),
            1000347000 => Some(&"RAY_TRACING_PIPELINE_STACK_SIZE_KHR"),
            1000164004 => Some(&"VIEWPORT_SHADING_RATE_PALETTE_NV"),
            1000164006 => Some(&"VIEWPORT_COARSE_SAMPLE_ORDER_NV"),
            1000205001 => Some(&"EXCLUSIVE_SCISSOR_NV"),
            1000226000 => Some(&"FRAGMENT_SHADING_RATE_KHR"),
            1000259000 => Some(&"LINE_STIPPLE_EXT"),
            1000352000 => Some(&"VERTEX_INPUT_EXT"),
            1000377000 => Some(&"PATCH_CONTROL_POINTS_EXT"),
            1000377003 => Some(&"LOGIC_OP_EXT"),
            1000381000 => Some(&"COLOR_WRITE_ENABLE_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PolygonMode(i32);
impl PolygonMode {
    pub const FILL: Self = Self(0);
    pub const LINE: Self = Self(1);
    pub const POINT: Self = Self(2);
    /// Added by extension VK_NV_fill_rectangle.
    pub const FILL_RECTANGLE_NV: Self = Self(1000153000);
}
impl fmt::Display for PolygonMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"FILL"),
            1 => Some(&"LINE"),
            2 => Some(&"POINT"),
            1000153000 => Some(&"FILL_RECTANGLE_NV"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct Format(i32);
impl Format {
    pub const UNDEFINED: Self = Self(0);
    pub const R4G4_UNORM_PACK8: Self = Self(1);
    pub const R4G4B4A4_UNORM_PACK16: Self = Self(2);
    pub const B4G4R4A4_UNORM_PACK16: Self = Self(3);
    pub const R5G6B5_UNORM_PACK16: Self = Self(4);
    pub const B5G6R5_UNORM_PACK16: Self = Self(5);
    pub const R5G5B5A1_UNORM_PACK16: Self = Self(6);
    pub const B5G5R5A1_UNORM_PACK16: Self = Self(7);
    pub const A1R5G5B5_UNORM_PACK16: Self = Self(8);
    pub const R8_UNORM: Self = Self(9);
    pub const R8_SNORM: Self = Self(10);
    pub const R8_USCALED: Self = Self(11);
    pub const R8_SSCALED: Self = Self(12);
    pub const R8_UINT: Self = Self(13);
    pub const R8_SINT: Self = Self(14);
    pub const R8_SRGB: Self = Self(15);
    pub const R8G8_UNORM: Self = Self(16);
    pub const R8G8_SNORM: Self = Self(17);
    pub const R8G8_USCALED: Self = Self(18);
    pub const R8G8_SSCALED: Self = Self(19);
    pub const R8G8_UINT: Self = Self(20);
    pub const R8G8_SINT: Self = Self(21);
    pub const R8G8_SRGB: Self = Self(22);
    pub const R8G8B8_UNORM: Self = Self(23);
    pub const R8G8B8_SNORM: Self = Self(24);
    pub const R8G8B8_USCALED: Self = Self(25);
    pub const R8G8B8_SSCALED: Self = Self(26);
    pub const R8G8B8_UINT: Self = Self(27);
    pub const R8G8B8_SINT: Self = Self(28);
    pub const R8G8B8_SRGB: Self = Self(29);
    pub const B8G8R8_UNORM: Self = Self(30);
    pub const B8G8R8_SNORM: Self = Self(31);
    pub const B8G8R8_USCALED: Self = Self(32);
    pub const B8G8R8_SSCALED: Self = Self(33);
    pub const B8G8R8_UINT: Self = Self(34);
    pub const B8G8R8_SINT: Self = Self(35);
    pub const B8G8R8_SRGB: Self = Self(36);
    pub const R8G8B8A8_UNORM: Self = Self(37);
    pub const R8G8B8A8_SNORM: Self = Self(38);
    pub const R8G8B8A8_USCALED: Self = Self(39);
    pub const R8G8B8A8_SSCALED: Self = Self(40);
    pub const R8G8B8A8_UINT: Self = Self(41);
    pub const R8G8B8A8_SINT: Self = Self(42);
    pub const R8G8B8A8_SRGB: Self = Self(43);
    pub const B8G8R8A8_UNORM: Self = Self(44);
    pub const B8G8R8A8_SNORM: Self = Self(45);
    pub const B8G8R8A8_USCALED: Self = Self(46);
    pub const B8G8R8A8_SSCALED: Self = Self(47);
    pub const B8G8R8A8_UINT: Self = Self(48);
    pub const B8G8R8A8_SINT: Self = Self(49);
    pub const B8G8R8A8_SRGB: Self = Self(50);
    pub const A8B8G8R8_UNORM_PACK32: Self = Self(51);
    pub const A8B8G8R8_SNORM_PACK32: Self = Self(52);
    pub const A8B8G8R8_USCALED_PACK32: Self = Self(53);
    pub const A8B8G8R8_SSCALED_PACK32: Self = Self(54);
    pub const A8B8G8R8_UINT_PACK32: Self = Self(55);
    pub const A8B8G8R8_SINT_PACK32: Self = Self(56);
    pub const A8B8G8R8_SRGB_PACK32: Self = Self(57);
    pub const A2R10G10B10_UNORM_PACK32: Self = Self(58);
    pub const A2R10G10B10_SNORM_PACK32: Self = Self(59);
    pub const A2R10G10B10_USCALED_PACK32: Self = Self(60);
    pub const A2R10G10B10_SSCALED_PACK32: Self = Self(61);
    pub const A2R10G10B10_UINT_PACK32: Self = Self(62);
    pub const A2R10G10B10_SINT_PACK32: Self = Self(63);
    pub const A2B10G10R10_UNORM_PACK32: Self = Self(64);
    pub const A2B10G10R10_SNORM_PACK32: Self = Self(65);
    pub const A2B10G10R10_USCALED_PACK32: Self = Self(66);
    pub const A2B10G10R10_SSCALED_PACK32: Self = Self(67);
    pub const A2B10G10R10_UINT_PACK32: Self = Self(68);
    pub const A2B10G10R10_SINT_PACK32: Self = Self(69);
    pub const R16_UNORM: Self = Self(70);
    pub const R16_SNORM: Self = Self(71);
    pub const R16_USCALED: Self = Self(72);
    pub const R16_SSCALED: Self = Self(73);
    pub const R16_UINT: Self = Self(74);
    pub const R16_SINT: Self = Self(75);
    pub const R16_SFLOAT: Self = Self(76);
    pub const R16G16_UNORM: Self = Self(77);
    pub const R16G16_SNORM: Self = Self(78);
    pub const R16G16_USCALED: Self = Self(79);
    pub const R16G16_SSCALED: Self = Self(80);
    pub const R16G16_UINT: Self = Self(81);
    pub const R16G16_SINT: Self = Self(82);
    pub const R16G16_SFLOAT: Self = Self(83);
    pub const R16G16B16_UNORM: Self = Self(84);
    pub const R16G16B16_SNORM: Self = Self(85);
    pub const R16G16B16_USCALED: Self = Self(86);
    pub const R16G16B16_SSCALED: Self = Self(87);
    pub const R16G16B16_UINT: Self = Self(88);
    pub const R16G16B16_SINT: Self = Self(89);
    pub const R16G16B16_SFLOAT: Self = Self(90);
    pub const R16G16B16A16_UNORM: Self = Self(91);
    pub const R16G16B16A16_SNORM: Self = Self(92);
    pub const R16G16B16A16_USCALED: Self = Self(93);
    pub const R16G16B16A16_SSCALED: Self = Self(94);
    pub const R16G16B16A16_UINT: Self = Self(95);
    pub const R16G16B16A16_SINT: Self = Self(96);
    pub const R16G16B16A16_SFLOAT: Self = Self(97);
    pub const R32_UINT: Self = Self(98);
    pub const R32_SINT: Self = Self(99);
    pub const R32_SFLOAT: Self = Self(100);
    pub const R32G32_UINT: Self = Self(101);
    pub const R32G32_SINT: Self = Self(102);
    pub const R32G32_SFLOAT: Self = Self(103);
    pub const R32G32B32_UINT: Self = Self(104);
    pub const R32G32B32_SINT: Self = Self(105);
    pub const R32G32B32_SFLOAT: Self = Self(106);
    pub const R32G32B32A32_UINT: Self = Self(107);
    pub const R32G32B32A32_SINT: Self = Self(108);
    pub const R32G32B32A32_SFLOAT: Self = Self(109);
    pub const R64_UINT: Self = Self(110);
    pub const R64_SINT: Self = Self(111);
    pub const R64_SFLOAT: Self = Self(112);
    pub const R64G64_UINT: Self = Self(113);
    pub const R64G64_SINT: Self = Self(114);
    pub const R64G64_SFLOAT: Self = Self(115);
    pub const R64G64B64_UINT: Self = Self(116);
    pub const R64G64B64_SINT: Self = Self(117);
    pub const R64G64B64_SFLOAT: Self = Self(118);
    pub const R64G64B64A64_UINT: Self = Self(119);
    pub const R64G64B64A64_SINT: Self = Self(120);
    pub const R64G64B64A64_SFLOAT: Self = Self(121);
    pub const B10G11R11_UFLOAT_PACK32: Self = Self(122);
    pub const E5B9G9R9_UFLOAT_PACK32: Self = Self(123);
    pub const D16_UNORM: Self = Self(124);
    pub const X8_D24_UNORM_PACK32: Self = Self(125);
    pub const D32_SFLOAT: Self = Self(126);
    pub const S8_UINT: Self = Self(127);
    pub const D16_UNORM_S8_UINT: Self = Self(128);
    pub const D24_UNORM_S8_UINT: Self = Self(129);
    pub const D32_SFLOAT_S8_UINT: Self = Self(130);
    pub const BC1_RGB_UNORM_BLOCK: Self = Self(131);
    pub const BC1_RGB_SRGB_BLOCK: Self = Self(132);
    pub const BC1_RGBA_UNORM_BLOCK: Self = Self(133);
    pub const BC1_RGBA_SRGB_BLOCK: Self = Self(134);
    pub const BC2_UNORM_BLOCK: Self = Self(135);
    pub const BC2_SRGB_BLOCK: Self = Self(136);
    pub const BC3_UNORM_BLOCK: Self = Self(137);
    pub const BC3_SRGB_BLOCK: Self = Self(138);
    pub const BC4_UNORM_BLOCK: Self = Self(139);
    pub const BC4_SNORM_BLOCK: Self = Self(140);
    pub const BC5_UNORM_BLOCK: Self = Self(141);
    pub const BC5_SNORM_BLOCK: Self = Self(142);
    pub const BC6H_UFLOAT_BLOCK: Self = Self(143);
    pub const BC6H_SFLOAT_BLOCK: Self = Self(144);
    pub const BC7_UNORM_BLOCK: Self = Self(145);
    pub const BC7_SRGB_BLOCK: Self = Self(146);
    pub const ETC2_R8G8B8_UNORM_BLOCK: Self = Self(147);
    pub const ETC2_R8G8B8_SRGB_BLOCK: Self = Self(148);
    pub const ETC2_R8G8B8A1_UNORM_BLOCK: Self = Self(149);
    pub const ETC2_R8G8B8A1_SRGB_BLOCK: Self = Self(150);
    pub const ETC2_R8G8B8A8_UNORM_BLOCK: Self = Self(151);
    pub const ETC2_R8G8B8A8_SRGB_BLOCK: Self = Self(152);
    pub const EAC_R11_UNORM_BLOCK: Self = Self(153);
    pub const EAC_R11_SNORM_BLOCK: Self = Self(154);
    pub const EAC_R11G11_UNORM_BLOCK: Self = Self(155);
    pub const EAC_R11G11_SNORM_BLOCK: Self = Self(156);
    pub const ASTC_4X4_UNORM_BLOCK: Self = Self(157);
    pub const ASTC_4X4_SRGB_BLOCK: Self = Self(158);
    pub const ASTC_5X4_UNORM_BLOCK: Self = Self(159);
    pub const ASTC_5X4_SRGB_BLOCK: Self = Self(160);
    pub const ASTC_5X5_UNORM_BLOCK: Self = Self(161);
    pub const ASTC_5X5_SRGB_BLOCK: Self = Self(162);
    pub const ASTC_6X5_UNORM_BLOCK: Self = Self(163);
    pub const ASTC_6X5_SRGB_BLOCK: Self = Self(164);
    pub const ASTC_6X6_UNORM_BLOCK: Self = Self(165);
    pub const ASTC_6X6_SRGB_BLOCK: Self = Self(166);
    pub const ASTC_8X5_UNORM_BLOCK: Self = Self(167);
    pub const ASTC_8X5_SRGB_BLOCK: Self = Self(168);
    pub const ASTC_8X6_UNORM_BLOCK: Self = Self(169);
    pub const ASTC_8X6_SRGB_BLOCK: Self = Self(170);
    pub const ASTC_8X8_UNORM_BLOCK: Self = Self(171);
    pub const ASTC_8X8_SRGB_BLOCK: Self = Self(172);
    pub const ASTC_10X5_UNORM_BLOCK: Self = Self(173);
    pub const ASTC_10X5_SRGB_BLOCK: Self = Self(174);
    pub const ASTC_10X6_UNORM_BLOCK: Self = Self(175);
    pub const ASTC_10X6_SRGB_BLOCK: Self = Self(176);
    pub const ASTC_10X8_UNORM_BLOCK: Self = Self(177);
    pub const ASTC_10X8_SRGB_BLOCK: Self = Self(178);
    pub const ASTC_10X10_UNORM_BLOCK: Self = Self(179);
    pub const ASTC_10X10_SRGB_BLOCK: Self = Self(180);
    pub const ASTC_12X10_UNORM_BLOCK: Self = Self(181);
    pub const ASTC_12X10_SRGB_BLOCK: Self = Self(182);
    pub const ASTC_12X12_UNORM_BLOCK: Self = Self(183);
    pub const ASTC_12X12_SRGB_BLOCK: Self = Self(184);
    pub const G8B8G8R8_422_UNORM: Self = Self(1000156000);
    pub const B8G8R8G8_422_UNORM: Self = Self(1000156001);
    pub const G8_B8_R8_3PLANE_420_UNORM: Self = Self(1000156002);
    pub const G8_B8R8_2PLANE_420_UNORM: Self = Self(1000156003);
    pub const G8_B8_R8_3PLANE_422_UNORM: Self = Self(1000156004);
    pub const G8_B8R8_2PLANE_422_UNORM: Self = Self(1000156005);
    pub const G8_B8_R8_3PLANE_444_UNORM: Self = Self(1000156006);
    pub const R10X6_UNORM_PACK16: Self = Self(1000156007);
    pub const R10X6G10X6_UNORM_2PACK16: Self = Self(1000156008);
    pub const R10X6G10X6B10X6A10X6_UNORM_4PACK16: Self = Self(1000156009);
    pub const G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: Self = Self(1000156010);
    pub const B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: Self = Self(1000156011);
    pub const G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: Self = Self(1000156012);
    pub const G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: Self = Self(1000156013);
    pub const G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: Self = Self(1000156014);
    pub const G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: Self = Self(1000156015);
    pub const G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: Self = Self(1000156016);
    pub const R12X4_UNORM_PACK16: Self = Self(1000156017);
    pub const R12X4G12X4_UNORM_2PACK16: Self = Self(1000156018);
    pub const R12X4G12X4B12X4A12X4_UNORM_4PACK16: Self = Self(1000156019);
    pub const G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: Self = Self(1000156020);
    pub const B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: Self = Self(1000156021);
    pub const G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: Self = Self(1000156022);
    pub const G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: Self = Self(1000156023);
    pub const G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: Self = Self(1000156024);
    pub const G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: Self = Self(1000156025);
    pub const G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: Self = Self(1000156026);
    pub const G16B16G16R16_422_UNORM: Self = Self(1000156027);
    pub const B16G16R16G16_422_UNORM: Self = Self(1000156028);
    pub const G16_B16_R16_3PLANE_420_UNORM: Self = Self(1000156029);
    pub const G16_B16R16_2PLANE_420_UNORM: Self = Self(1000156030);
    pub const G16_B16_R16_3PLANE_422_UNORM: Self = Self(1000156031);
    pub const G16_B16R16_2PLANE_422_UNORM: Self = Self(1000156032);
    pub const G16_B16_R16_3PLANE_444_UNORM: Self = Self(1000156033);
    pub const G8_B8R8_2PLANE_444_UNORM: Self = Self(1000330000);
    pub const G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16: Self = Self(1000330001);
    pub const G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16: Self = Self(1000330002);
    pub const G16_B16R16_2PLANE_444_UNORM: Self = Self(1000330003);
    pub const A4R4G4B4_UNORM_PACK16: Self = Self(1000340000);
    pub const A4B4G4R4_UNORM_PACK16: Self = Self(1000340001);
    pub const ASTC_4X4_SFLOAT_BLOCK: Self = Self(1000066000);
    pub const ASTC_5X4_SFLOAT_BLOCK: Self = Self(1000066001);
    pub const ASTC_5X5_SFLOAT_BLOCK: Self = Self(1000066002);
    pub const ASTC_6X5_SFLOAT_BLOCK: Self = Self(1000066003);
    pub const ASTC_6X6_SFLOAT_BLOCK: Self = Self(1000066004);
    pub const ASTC_8X5_SFLOAT_BLOCK: Self = Self(1000066005);
    pub const ASTC_8X6_SFLOAT_BLOCK: Self = Self(1000066006);
    pub const ASTC_8X8_SFLOAT_BLOCK: Self = Self(1000066007);
    pub const ASTC_10X5_SFLOAT_BLOCK: Self = Self(1000066008);
    pub const ASTC_10X6_SFLOAT_BLOCK: Self = Self(1000066009);
    pub const ASTC_10X8_SFLOAT_BLOCK: Self = Self(1000066010);
    pub const ASTC_10X10_SFLOAT_BLOCK: Self = Self(1000066011);
    pub const ASTC_12X10_SFLOAT_BLOCK: Self = Self(1000066012);
    pub const ASTC_12X12_SFLOAT_BLOCK: Self = Self(1000066013);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC1_2BPP_UNORM_BLOCK_IMG: Self = Self(1000054000);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC1_4BPP_UNORM_BLOCK_IMG: Self = Self(1000054001);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC2_2BPP_UNORM_BLOCK_IMG: Self = Self(1000054002);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC2_4BPP_UNORM_BLOCK_IMG: Self = Self(1000054003);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC1_2BPP_SRGB_BLOCK_IMG: Self = Self(1000054004);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC1_4BPP_SRGB_BLOCK_IMG: Self = Self(1000054005);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC2_2BPP_SRGB_BLOCK_IMG: Self = Self(1000054006);
    /// Added by extension VK_IMG_format_pvrtc.
    pub const PVRTC2_4BPP_SRGB_BLOCK_IMG: Self = Self(1000054007);
    pub const ASTC_4X4_SFLOAT_BLOCK_EXT: Self = Self::ASTC_4X4_SFLOAT_BLOCK;
    pub const ASTC_5X4_SFLOAT_BLOCK_EXT: Self = Self::ASTC_5X4_SFLOAT_BLOCK;
    pub const ASTC_5X5_SFLOAT_BLOCK_EXT: Self = Self::ASTC_5X5_SFLOAT_BLOCK;
    pub const ASTC_6X5_SFLOAT_BLOCK_EXT: Self = Self::ASTC_6X5_SFLOAT_BLOCK;
    pub const ASTC_6X6_SFLOAT_BLOCK_EXT: Self = Self::ASTC_6X6_SFLOAT_BLOCK;
    pub const ASTC_8X5_SFLOAT_BLOCK_EXT: Self = Self::ASTC_8X5_SFLOAT_BLOCK;
    pub const ASTC_8X6_SFLOAT_BLOCK_EXT: Self = Self::ASTC_8X6_SFLOAT_BLOCK;
    pub const ASTC_8X8_SFLOAT_BLOCK_EXT: Self = Self::ASTC_8X8_SFLOAT_BLOCK;
    pub const ASTC_10X5_SFLOAT_BLOCK_EXT: Self = Self::ASTC_10X5_SFLOAT_BLOCK;
    pub const ASTC_10X6_SFLOAT_BLOCK_EXT: Self = Self::ASTC_10X6_SFLOAT_BLOCK;
    pub const ASTC_10X8_SFLOAT_BLOCK_EXT: Self = Self::ASTC_10X8_SFLOAT_BLOCK;
    pub const ASTC_10X10_SFLOAT_BLOCK_EXT: Self = Self::ASTC_10X10_SFLOAT_BLOCK;
    pub const ASTC_12X10_SFLOAT_BLOCK_EXT: Self = Self::ASTC_12X10_SFLOAT_BLOCK;
    pub const ASTC_12X12_SFLOAT_BLOCK_EXT: Self = Self::ASTC_12X12_SFLOAT_BLOCK;
    pub const G8B8G8R8_422_UNORM_KHR: Self = Self::G8B8G8R8_422_UNORM;
    pub const B8G8R8G8_422_UNORM_KHR: Self = Self::B8G8R8G8_422_UNORM;
    pub const G8_B8_R8_3PLANE_420_UNORM_KHR: Self = Self::G8_B8_R8_3PLANE_420_UNORM;
    pub const G8_B8R8_2PLANE_420_UNORM_KHR: Self = Self::G8_B8R8_2PLANE_420_UNORM;
    pub const G8_B8_R8_3PLANE_422_UNORM_KHR: Self = Self::G8_B8_R8_3PLANE_422_UNORM;
    pub const G8_B8R8_2PLANE_422_UNORM_KHR: Self = Self::G8_B8R8_2PLANE_422_UNORM;
    pub const G8_B8_R8_3PLANE_444_UNORM_KHR: Self = Self::G8_B8_R8_3PLANE_444_UNORM;
    pub const R10X6_UNORM_PACK16_KHR: Self = Self::R10X6_UNORM_PACK16;
    pub const R10X6G10X6_UNORM_2PACK16_KHR: Self = Self::R10X6G10X6_UNORM_2PACK16;
    pub const R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR: Self = Self::R10X6G10X6B10X6A10X6_UNORM_4PACK16;
    pub const G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR: Self = Self::G10X6B10X6G10X6R10X6_422_UNORM_4PACK16;
    pub const B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR: Self = Self::B10X6G10X6R10X6G10X6_422_UNORM_4PACK16;
    pub const G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16;
    pub const G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16;
    pub const G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16;
    pub const G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16;
    pub const G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16;
    pub const R12X4_UNORM_PACK16_KHR: Self = Self::R12X4_UNORM_PACK16;
    pub const R12X4G12X4_UNORM_2PACK16_KHR: Self = Self::R12X4G12X4_UNORM_2PACK16;
    pub const R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR: Self = Self::R12X4G12X4B12X4A12X4_UNORM_4PACK16;
    pub const G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR: Self = Self::G12X4B12X4G12X4R12X4_422_UNORM_4PACK16;
    pub const B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR: Self = Self::B12X4G12X4R12X4G12X4_422_UNORM_4PACK16;
    pub const G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16;
    pub const G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16;
    pub const G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16;
    pub const G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16;
    pub const G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16;
    pub const G16B16G16R16_422_UNORM_KHR: Self = Self::G16B16G16R16_422_UNORM;
    pub const B16G16R16G16_422_UNORM_KHR: Self = Self::B16G16R16G16_422_UNORM;
    pub const G16_B16_R16_3PLANE_420_UNORM_KHR: Self = Self::G16_B16_R16_3PLANE_420_UNORM;
    pub const G16_B16R16_2PLANE_420_UNORM_KHR: Self = Self::G16_B16R16_2PLANE_420_UNORM;
    pub const G16_B16_R16_3PLANE_422_UNORM_KHR: Self = Self::G16_B16_R16_3PLANE_422_UNORM;
    pub const G16_B16R16_2PLANE_422_UNORM_KHR: Self = Self::G16_B16R16_2PLANE_422_UNORM;
    pub const G16_B16_R16_3PLANE_444_UNORM_KHR: Self = Self::G16_B16_R16_3PLANE_444_UNORM;
    pub const G8_B8R8_2PLANE_444_UNORM_EXT: Self = Self::G8_B8R8_2PLANE_444_UNORM;
    pub const G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT: Self = Self::G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16;
    pub const G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT: Self = Self::G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16;
    pub const G16_B16R16_2PLANE_444_UNORM_EXT: Self = Self::G16_B16R16_2PLANE_444_UNORM;
    pub const A4R4G4B4_UNORM_PACK16_EXT: Self = Self::A4R4G4B4_UNORM_PACK16;
    pub const A4B4G4R4_UNORM_PACK16_EXT: Self = Self::A4B4G4R4_UNORM_PACK16;
}
impl fmt::Display for Format {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UNDEFINED"),
            1 => Some(&"R4G4_UNORM_PACK8"),
            2 => Some(&"R4G4B4A4_UNORM_PACK16"),
            3 => Some(&"B4G4R4A4_UNORM_PACK16"),
            4 => Some(&"R5G6B5_UNORM_PACK16"),
            5 => Some(&"B5G6R5_UNORM_PACK16"),
            6 => Some(&"R5G5B5A1_UNORM_PACK16"),
            7 => Some(&"B5G5R5A1_UNORM_PACK16"),
            8 => Some(&"A1R5G5B5_UNORM_PACK16"),
            9 => Some(&"R8_UNORM"),
            10 => Some(&"R8_SNORM"),
            11 => Some(&"R8_USCALED"),
            12 => Some(&"R8_SSCALED"),
            13 => Some(&"R8_UINT"),
            14 => Some(&"R8_SINT"),
            15 => Some(&"R8_SRGB"),
            16 => Some(&"R8G8_UNORM"),
            17 => Some(&"R8G8_SNORM"),
            18 => Some(&"R8G8_USCALED"),
            19 => Some(&"R8G8_SSCALED"),
            20 => Some(&"R8G8_UINT"),
            21 => Some(&"R8G8_SINT"),
            22 => Some(&"R8G8_SRGB"),
            23 => Some(&"R8G8B8_UNORM"),
            24 => Some(&"R8G8B8_SNORM"),
            25 => Some(&"R8G8B8_USCALED"),
            26 => Some(&"R8G8B8_SSCALED"),
            27 => Some(&"R8G8B8_UINT"),
            28 => Some(&"R8G8B8_SINT"),
            29 => Some(&"R8G8B8_SRGB"),
            30 => Some(&"B8G8R8_UNORM"),
            31 => Some(&"B8G8R8_SNORM"),
            32 => Some(&"B8G8R8_USCALED"),
            33 => Some(&"B8G8R8_SSCALED"),
            34 => Some(&"B8G8R8_UINT"),
            35 => Some(&"B8G8R8_SINT"),
            36 => Some(&"B8G8R8_SRGB"),
            37 => Some(&"R8G8B8A8_UNORM"),
            38 => Some(&"R8G8B8A8_SNORM"),
            39 => Some(&"R8G8B8A8_USCALED"),
            40 => Some(&"R8G8B8A8_SSCALED"),
            41 => Some(&"R8G8B8A8_UINT"),
            42 => Some(&"R8G8B8A8_SINT"),
            43 => Some(&"R8G8B8A8_SRGB"),
            44 => Some(&"B8G8R8A8_UNORM"),
            45 => Some(&"B8G8R8A8_SNORM"),
            46 => Some(&"B8G8R8A8_USCALED"),
            47 => Some(&"B8G8R8A8_SSCALED"),
            48 => Some(&"B8G8R8A8_UINT"),
            49 => Some(&"B8G8R8A8_SINT"),
            50 => Some(&"B8G8R8A8_SRGB"),
            51 => Some(&"A8B8G8R8_UNORM_PACK32"),
            52 => Some(&"A8B8G8R8_SNORM_PACK32"),
            53 => Some(&"A8B8G8R8_USCALED_PACK32"),
            54 => Some(&"A8B8G8R8_SSCALED_PACK32"),
            55 => Some(&"A8B8G8R8_UINT_PACK32"),
            56 => Some(&"A8B8G8R8_SINT_PACK32"),
            57 => Some(&"A8B8G8R8_SRGB_PACK32"),
            58 => Some(&"A2R10G10B10_UNORM_PACK32"),
            59 => Some(&"A2R10G10B10_SNORM_PACK32"),
            60 => Some(&"A2R10G10B10_USCALED_PACK32"),
            61 => Some(&"A2R10G10B10_SSCALED_PACK32"),
            62 => Some(&"A2R10G10B10_UINT_PACK32"),
            63 => Some(&"A2R10G10B10_SINT_PACK32"),
            64 => Some(&"A2B10G10R10_UNORM_PACK32"),
            65 => Some(&"A2B10G10R10_SNORM_PACK32"),
            66 => Some(&"A2B10G10R10_USCALED_PACK32"),
            67 => Some(&"A2B10G10R10_SSCALED_PACK32"),
            68 => Some(&"A2B10G10R10_UINT_PACK32"),
            69 => Some(&"A2B10G10R10_SINT_PACK32"),
            70 => Some(&"R16_UNORM"),
            71 => Some(&"R16_SNORM"),
            72 => Some(&"R16_USCALED"),
            73 => Some(&"R16_SSCALED"),
            74 => Some(&"R16_UINT"),
            75 => Some(&"R16_SINT"),
            76 => Some(&"R16_SFLOAT"),
            77 => Some(&"R16G16_UNORM"),
            78 => Some(&"R16G16_SNORM"),
            79 => Some(&"R16G16_USCALED"),
            80 => Some(&"R16G16_SSCALED"),
            81 => Some(&"R16G16_UINT"),
            82 => Some(&"R16G16_SINT"),
            83 => Some(&"R16G16_SFLOAT"),
            84 => Some(&"R16G16B16_UNORM"),
            85 => Some(&"R16G16B16_SNORM"),
            86 => Some(&"R16G16B16_USCALED"),
            87 => Some(&"R16G16B16_SSCALED"),
            88 => Some(&"R16G16B16_UINT"),
            89 => Some(&"R16G16B16_SINT"),
            90 => Some(&"R16G16B16_SFLOAT"),
            91 => Some(&"R16G16B16A16_UNORM"),
            92 => Some(&"R16G16B16A16_SNORM"),
            93 => Some(&"R16G16B16A16_USCALED"),
            94 => Some(&"R16G16B16A16_SSCALED"),
            95 => Some(&"R16G16B16A16_UINT"),
            96 => Some(&"R16G16B16A16_SINT"),
            97 => Some(&"R16G16B16A16_SFLOAT"),
            98 => Some(&"R32_UINT"),
            99 => Some(&"R32_SINT"),
            100 => Some(&"R32_SFLOAT"),
            101 => Some(&"R32G32_UINT"),
            102 => Some(&"R32G32_SINT"),
            103 => Some(&"R32G32_SFLOAT"),
            104 => Some(&"R32G32B32_UINT"),
            105 => Some(&"R32G32B32_SINT"),
            106 => Some(&"R32G32B32_SFLOAT"),
            107 => Some(&"R32G32B32A32_UINT"),
            108 => Some(&"R32G32B32A32_SINT"),
            109 => Some(&"R32G32B32A32_SFLOAT"),
            110 => Some(&"R64_UINT"),
            111 => Some(&"R64_SINT"),
            112 => Some(&"R64_SFLOAT"),
            113 => Some(&"R64G64_UINT"),
            114 => Some(&"R64G64_SINT"),
            115 => Some(&"R64G64_SFLOAT"),
            116 => Some(&"R64G64B64_UINT"),
            117 => Some(&"R64G64B64_SINT"),
            118 => Some(&"R64G64B64_SFLOAT"),
            119 => Some(&"R64G64B64A64_UINT"),
            120 => Some(&"R64G64B64A64_SINT"),
            121 => Some(&"R64G64B64A64_SFLOAT"),
            122 => Some(&"B10G11R11_UFLOAT_PACK32"),
            123 => Some(&"E5B9G9R9_UFLOAT_PACK32"),
            124 => Some(&"D16_UNORM"),
            125 => Some(&"X8_D24_UNORM_PACK32"),
            126 => Some(&"D32_SFLOAT"),
            127 => Some(&"S8_UINT"),
            128 => Some(&"D16_UNORM_S8_UINT"),
            129 => Some(&"D24_UNORM_S8_UINT"),
            130 => Some(&"D32_SFLOAT_S8_UINT"),
            131 => Some(&"BC1_RGB_UNORM_BLOCK"),
            132 => Some(&"BC1_RGB_SRGB_BLOCK"),
            133 => Some(&"BC1_RGBA_UNORM_BLOCK"),
            134 => Some(&"BC1_RGBA_SRGB_BLOCK"),
            135 => Some(&"BC2_UNORM_BLOCK"),
            136 => Some(&"BC2_SRGB_BLOCK"),
            137 => Some(&"BC3_UNORM_BLOCK"),
            138 => Some(&"BC3_SRGB_BLOCK"),
            139 => Some(&"BC4_UNORM_BLOCK"),
            140 => Some(&"BC4_SNORM_BLOCK"),
            141 => Some(&"BC5_UNORM_BLOCK"),
            142 => Some(&"BC5_SNORM_BLOCK"),
            143 => Some(&"BC6H_UFLOAT_BLOCK"),
            144 => Some(&"BC6H_SFLOAT_BLOCK"),
            145 => Some(&"BC7_UNORM_BLOCK"),
            146 => Some(&"BC7_SRGB_BLOCK"),
            147 => Some(&"ETC2_R8G8B8_UNORM_BLOCK"),
            148 => Some(&"ETC2_R8G8B8_SRGB_BLOCK"),
            149 => Some(&"ETC2_R8G8B8A1_UNORM_BLOCK"),
            150 => Some(&"ETC2_R8G8B8A1_SRGB_BLOCK"),
            151 => Some(&"ETC2_R8G8B8A8_UNORM_BLOCK"),
            152 => Some(&"ETC2_R8G8B8A8_SRGB_BLOCK"),
            153 => Some(&"EAC_R11_UNORM_BLOCK"),
            154 => Some(&"EAC_R11_SNORM_BLOCK"),
            155 => Some(&"EAC_R11G11_UNORM_BLOCK"),
            156 => Some(&"EAC_R11G11_SNORM_BLOCK"),
            157 => Some(&"ASTC_4X4_UNORM_BLOCK"),
            158 => Some(&"ASTC_4X4_SRGB_BLOCK"),
            159 => Some(&"ASTC_5X4_UNORM_BLOCK"),
            160 => Some(&"ASTC_5X4_SRGB_BLOCK"),
            161 => Some(&"ASTC_5X5_UNORM_BLOCK"),
            162 => Some(&"ASTC_5X5_SRGB_BLOCK"),
            163 => Some(&"ASTC_6X5_UNORM_BLOCK"),
            164 => Some(&"ASTC_6X5_SRGB_BLOCK"),
            165 => Some(&"ASTC_6X6_UNORM_BLOCK"),
            166 => Some(&"ASTC_6X6_SRGB_BLOCK"),
            167 => Some(&"ASTC_8X5_UNORM_BLOCK"),
            168 => Some(&"ASTC_8X5_SRGB_BLOCK"),
            169 => Some(&"ASTC_8X6_UNORM_BLOCK"),
            170 => Some(&"ASTC_8X6_SRGB_BLOCK"),
            171 => Some(&"ASTC_8X8_UNORM_BLOCK"),
            172 => Some(&"ASTC_8X8_SRGB_BLOCK"),
            173 => Some(&"ASTC_10X5_UNORM_BLOCK"),
            174 => Some(&"ASTC_10X5_SRGB_BLOCK"),
            175 => Some(&"ASTC_10X6_UNORM_BLOCK"),
            176 => Some(&"ASTC_10X6_SRGB_BLOCK"),
            177 => Some(&"ASTC_10X8_UNORM_BLOCK"),
            178 => Some(&"ASTC_10X8_SRGB_BLOCK"),
            179 => Some(&"ASTC_10X10_UNORM_BLOCK"),
            180 => Some(&"ASTC_10X10_SRGB_BLOCK"),
            181 => Some(&"ASTC_12X10_UNORM_BLOCK"),
            182 => Some(&"ASTC_12X10_SRGB_BLOCK"),
            183 => Some(&"ASTC_12X12_UNORM_BLOCK"),
            184 => Some(&"ASTC_12X12_SRGB_BLOCK"),
            1000156000 => Some(&"G8B8G8R8_422_UNORM"),
            1000156001 => Some(&"B8G8R8G8_422_UNORM"),
            1000156002 => Some(&"G8_B8_R8_3PLANE_420_UNORM"),
            1000156003 => Some(&"G8_B8R8_2PLANE_420_UNORM"),
            1000156004 => Some(&"G8_B8_R8_3PLANE_422_UNORM"),
            1000156005 => Some(&"G8_B8R8_2PLANE_422_UNORM"),
            1000156006 => Some(&"G8_B8_R8_3PLANE_444_UNORM"),
            1000156007 => Some(&"R10X6_UNORM_PACK16"),
            1000156008 => Some(&"R10X6G10X6_UNORM_2PACK16"),
            1000156009 => Some(&"R10X6G10X6B10X6A10X6_UNORM_4PACK16"),
            1000156010 => Some(&"G10X6B10X6G10X6R10X6_422_UNORM_4PACK16"),
            1000156011 => Some(&"B10X6G10X6R10X6G10X6_422_UNORM_4PACK16"),
            1000156012 => Some(&"G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16"),
            1000156013 => Some(&"G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16"),
            1000156014 => Some(&"G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16"),
            1000156015 => Some(&"G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16"),
            1000156016 => Some(&"G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16"),
            1000156017 => Some(&"R12X4_UNORM_PACK16"),
            1000156018 => Some(&"R12X4G12X4_UNORM_2PACK16"),
            1000156019 => Some(&"R12X4G12X4B12X4A12X4_UNORM_4PACK16"),
            1000156020 => Some(&"G12X4B12X4G12X4R12X4_422_UNORM_4PACK16"),
            1000156021 => Some(&"B12X4G12X4R12X4G12X4_422_UNORM_4PACK16"),
            1000156022 => Some(&"G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16"),
            1000156023 => Some(&"G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16"),
            1000156024 => Some(&"G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16"),
            1000156025 => Some(&"G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16"),
            1000156026 => Some(&"G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16"),
            1000156027 => Some(&"G16B16G16R16_422_UNORM"),
            1000156028 => Some(&"B16G16R16G16_422_UNORM"),
            1000156029 => Some(&"G16_B16_R16_3PLANE_420_UNORM"),
            1000156030 => Some(&"G16_B16R16_2PLANE_420_UNORM"),
            1000156031 => Some(&"G16_B16_R16_3PLANE_422_UNORM"),
            1000156032 => Some(&"G16_B16R16_2PLANE_422_UNORM"),
            1000156033 => Some(&"G16_B16_R16_3PLANE_444_UNORM"),
            1000330000 => Some(&"G8_B8R8_2PLANE_444_UNORM"),
            1000330001 => Some(&"G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16"),
            1000330002 => Some(&"G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16"),
            1000330003 => Some(&"G16_B16R16_2PLANE_444_UNORM"),
            1000340000 => Some(&"A4R4G4B4_UNORM_PACK16"),
            1000340001 => Some(&"A4B4G4R4_UNORM_PACK16"),
            1000066000 => Some(&"ASTC_4X4_SFLOAT_BLOCK"),
            1000066001 => Some(&"ASTC_5X4_SFLOAT_BLOCK"),
            1000066002 => Some(&"ASTC_5X5_SFLOAT_BLOCK"),
            1000066003 => Some(&"ASTC_6X5_SFLOAT_BLOCK"),
            1000066004 => Some(&"ASTC_6X6_SFLOAT_BLOCK"),
            1000066005 => Some(&"ASTC_8X5_SFLOAT_BLOCK"),
            1000066006 => Some(&"ASTC_8X6_SFLOAT_BLOCK"),
            1000066007 => Some(&"ASTC_8X8_SFLOAT_BLOCK"),
            1000066008 => Some(&"ASTC_10X5_SFLOAT_BLOCK"),
            1000066009 => Some(&"ASTC_10X6_SFLOAT_BLOCK"),
            1000066010 => Some(&"ASTC_10X8_SFLOAT_BLOCK"),
            1000066011 => Some(&"ASTC_10X10_SFLOAT_BLOCK"),
            1000066012 => Some(&"ASTC_12X10_SFLOAT_BLOCK"),
            1000066013 => Some(&"ASTC_12X12_SFLOAT_BLOCK"),
            1000054000 => Some(&"PVRTC1_2BPP_UNORM_BLOCK_IMG"),
            1000054001 => Some(&"PVRTC1_4BPP_UNORM_BLOCK_IMG"),
            1000054002 => Some(&"PVRTC2_2BPP_UNORM_BLOCK_IMG"),
            1000054003 => Some(&"PVRTC2_4BPP_UNORM_BLOCK_IMG"),
            1000054004 => Some(&"PVRTC1_2BPP_SRGB_BLOCK_IMG"),
            1000054005 => Some(&"PVRTC1_4BPP_SRGB_BLOCK_IMG"),
            1000054006 => Some(&"PVRTC2_2BPP_SRGB_BLOCK_IMG"),
            1000054007 => Some(&"PVRTC2_4BPP_SRGB_BLOCK_IMG"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct FrontFace(i32);
impl FrontFace {
    pub const COUNTER_CLOCKWISE: Self = Self(0);
    pub const CLOCKWISE: Self = Self(1);
}
impl fmt::Display for FrontFace {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"COUNTER_CLOCKWISE"),
            1 => Some(&"CLOCKWISE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ImageLayout(i32);
impl ImageLayout {
    /// Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)
    pub const UNDEFINED: Self = Self(0);
    /// General layout when image can be used for any kind of access
    pub const GENERAL: Self = Self(1);
    /// Optimal layout when image is only used for color attachment read/write
    pub const COLOR_ATTACHMENT_OPTIMAL: Self = Self(2);
    /// Optimal layout when image is only used for depth/stencil attachment read/write
    pub const DEPTH_STENCIL_ATTACHMENT_OPTIMAL: Self = Self(3);
    /// Optimal layout when image is used for read only depth/stencil attachment and shader access
    pub const DEPTH_STENCIL_READ_ONLY_OPTIMAL: Self = Self(4);
    /// Optimal layout when image is used for read only shader access
    pub const SHADER_READ_ONLY_OPTIMAL: Self = Self(5);
    /// Optimal layout when image is used only as source of transfer operations
    pub const TRANSFER_SRC_OPTIMAL: Self = Self(6);
    /// Optimal layout when image is used only as destination of transfer operations
    pub const TRANSFER_DST_OPTIMAL: Self = Self(7);
    /// Initial layout used when the data is populated by the CPU
    pub const PREINITIALIZED: Self = Self(8);
    pub const DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: Self = Self(1000117000);
    pub const DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: Self = Self(1000117001);
    pub const DEPTH_ATTACHMENT_OPTIMAL: Self = Self(1000241000);
    pub const DEPTH_READ_ONLY_OPTIMAL: Self = Self(1000241001);
    pub const STENCIL_ATTACHMENT_OPTIMAL: Self = Self(1000241002);
    pub const STENCIL_READ_ONLY_OPTIMAL: Self = Self(1000241003);
    pub const READ_ONLY_OPTIMAL: Self = Self(1000314000);
    pub const ATTACHMENT_OPTIMAL: Self = Self(1000314001);
    /// Added by extension VK_KHR_swapchain.
    pub const PRESENT_SRC_KHR: Self = Self(1000001002);
    /// Added by extension VK_KHR_shared_presentable_image.
    pub const SHARED_PRESENT_KHR: Self = Self(1000111000);
    pub const DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR: Self = Self::DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL;
    pub const DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR: Self = Self::DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL;
    pub const SHADING_RATE_OPTIMAL_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR;
    /// Added by extension VK_EXT_fragment_density_map.
    pub const FRAGMENT_DENSITY_MAP_OPTIMAL_EXT: Self = Self(1000218000);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR: Self = Self(1000164003);
    pub const DEPTH_ATTACHMENT_OPTIMAL_KHR: Self = Self::DEPTH_ATTACHMENT_OPTIMAL;
    pub const DEPTH_READ_ONLY_OPTIMAL_KHR: Self = Self::DEPTH_READ_ONLY_OPTIMAL;
    pub const STENCIL_ATTACHMENT_OPTIMAL_KHR: Self = Self::STENCIL_ATTACHMENT_OPTIMAL;
    pub const STENCIL_READ_ONLY_OPTIMAL_KHR: Self = Self::STENCIL_READ_ONLY_OPTIMAL;
    pub const READ_ONLY_OPTIMAL_KHR: Self = Self::READ_ONLY_OPTIMAL;
    pub const ATTACHMENT_OPTIMAL_KHR: Self = Self::ATTACHMENT_OPTIMAL;
}
impl fmt::Display for ImageLayout {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UNDEFINED"),
            1 => Some(&"GENERAL"),
            2 => Some(&"COLOR_ATTACHMENT_OPTIMAL"),
            3 => Some(&"DEPTH_STENCIL_ATTACHMENT_OPTIMAL"),
            4 => Some(&"DEPTH_STENCIL_READ_ONLY_OPTIMAL"),
            5 => Some(&"SHADER_READ_ONLY_OPTIMAL"),
            6 => Some(&"TRANSFER_SRC_OPTIMAL"),
            7 => Some(&"TRANSFER_DST_OPTIMAL"),
            8 => Some(&"PREINITIALIZED"),
            1000117000 => Some(&"DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL"),
            1000117001 => Some(&"DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL"),
            1000241000 => Some(&"DEPTH_ATTACHMENT_OPTIMAL"),
            1000241001 => Some(&"DEPTH_READ_ONLY_OPTIMAL"),
            1000241002 => Some(&"STENCIL_ATTACHMENT_OPTIMAL"),
            1000241003 => Some(&"STENCIL_READ_ONLY_OPTIMAL"),
            1000314000 => Some(&"READ_ONLY_OPTIMAL"),
            1000314001 => Some(&"ATTACHMENT_OPTIMAL"),
            1000001002 => Some(&"PRESENT_SRC_KHR"),
            1000111000 => Some(&"SHARED_PRESENT_KHR"),
            1000218000 => Some(&"FRAGMENT_DENSITY_MAP_OPTIMAL_EXT"),
            1000164003 => Some(&"FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ImageTiling(i32);
impl ImageTiling {
    pub const OPTIMAL: Self = Self(0);
    pub const LINEAR: Self = Self(1);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const DRM_FORMAT_MODIFIER_EXT: Self = Self(1000158000);
}
impl fmt::Display for ImageTiling {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"OPTIMAL"),
            1 => Some(&"LINEAR"),
            1000158000 => Some(&"DRM_FORMAT_MODIFIER_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ImageType(i32);
impl ImageType {
    pub const N1D: Self = Self(0);
    pub const N2D: Self = Self(1);
    pub const N3D: Self = Self(2);
}
impl fmt::Display for ImageType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"N1D"),
            1 => Some(&"N2D"),
            2 => Some(&"N3D"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ImageViewType(i32);
impl ImageViewType {
    pub const N1D: Self = Self(0);
    pub const N2D: Self = Self(1);
    pub const N3D: Self = Self(2);
    pub const CUBE: Self = Self(3);
    pub const N1D_ARRAY: Self = Self(4);
    pub const N2D_ARRAY: Self = Self(5);
    pub const CUBE_ARRAY: Self = Self(6);
}
impl fmt::Display for ImageViewType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"N1D"),
            1 => Some(&"N2D"),
            2 => Some(&"N3D"),
            3 => Some(&"CUBE"),
            4 => Some(&"N1D_ARRAY"),
            5 => Some(&"N2D_ARRAY"),
            6 => Some(&"CUBE_ARRAY"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SharingMode(i32);
impl SharingMode {
    pub const EXCLUSIVE: Self = Self(0);
    pub const CONCURRENT: Self = Self(1);
}
impl fmt::Display for SharingMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"EXCLUSIVE"),
            1 => Some(&"CONCURRENT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct IndexType(i32);
impl IndexType {
    pub const UINT16: Self = Self(0);
    pub const UINT32: Self = Self(1);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const NONE_KHR: Self = Self(1000165000);
    pub const NONE_NV: Self = Self::NONE_KHR;
    /// Added by extension VK_EXT_index_type_uint8.
    pub const UINT8_EXT: Self = Self(1000265000);
}
impl fmt::Display for IndexType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UINT16"),
            1 => Some(&"UINT32"),
            1000165000 => Some(&"NONE_KHR"),
            1000265000 => Some(&"UINT8_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct LogicOp(i32);
impl LogicOp {
    pub const CLEAR: Self = Self(0);
    pub const AND: Self = Self(1);
    pub const AND_REVERSE: Self = Self(2);
    pub const COPY: Self = Self(3);
    pub const AND_INVERTED: Self = Self(4);
    pub const NO_OP: Self = Self(5);
    pub const XOR: Self = Self(6);
    pub const OR: Self = Self(7);
    pub const NOR: Self = Self(8);
    pub const EQUIVALENT: Self = Self(9);
    pub const INVERT: Self = Self(10);
    pub const OR_REVERSE: Self = Self(11);
    pub const COPY_INVERTED: Self = Self(12);
    pub const OR_INVERTED: Self = Self(13);
    pub const NAND: Self = Self(14);
    pub const SET: Self = Self(15);
}
impl fmt::Display for LogicOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"CLEAR"),
            1 => Some(&"AND"),
            2 => Some(&"AND_REVERSE"),
            3 => Some(&"COPY"),
            4 => Some(&"AND_INVERTED"),
            5 => Some(&"NO_OP"),
            6 => Some(&"XOR"),
            7 => Some(&"OR"),
            8 => Some(&"NOR"),
            9 => Some(&"EQUIVALENT"),
            10 => Some(&"INVERT"),
            11 => Some(&"OR_REVERSE"),
            12 => Some(&"COPY_INVERTED"),
            13 => Some(&"OR_INVERTED"),
            14 => Some(&"NAND"),
            15 => Some(&"SET"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PhysicalDeviceType(i32);
impl PhysicalDeviceType {
    pub const OTHER: Self = Self(0);
    pub const INTEGRATED_GPU: Self = Self(1);
    pub const DISCRETE_GPU: Self = Self(2);
    pub const VIRTUAL_GPU: Self = Self(3);
    pub const CPU: Self = Self(4);
}
impl fmt::Display for PhysicalDeviceType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"OTHER"),
            1 => Some(&"INTEGRATED_GPU"),
            2 => Some(&"DISCRETE_GPU"),
            3 => Some(&"VIRTUAL_GPU"),
            4 => Some(&"CPU"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PipelineBindPoint(i32);
impl PipelineBindPoint {
    pub const GRAPHICS: Self = Self(0);
    pub const COMPUTE: Self = Self(1);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_KHR: Self = Self(1000165000);
    pub const RAY_TRACING_NV: Self = Self::RAY_TRACING_KHR;
    /// Added by extension VK_HUAWEI_subpass_shading.
    pub const SUBPASS_SHADING_HUAWEI: Self = Self(1000369003);
}
impl fmt::Display for PipelineBindPoint {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"GRAPHICS"),
            1 => Some(&"COMPUTE"),
            1000165000 => Some(&"RAY_TRACING_KHR"),
            1000369003 => Some(&"SUBPASS_SHADING_HUAWEI"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PrimitiveTopology(i32);
impl PrimitiveTopology {
    pub const POINT_LIST: Self = Self(0);
    pub const LINE_LIST: Self = Self(1);
    pub const LINE_STRIP: Self = Self(2);
    pub const TRIANGLE_LIST: Self = Self(3);
    pub const TRIANGLE_STRIP: Self = Self(4);
    pub const TRIANGLE_FAN: Self = Self(5);
    pub const LINE_LIST_WITH_ADJACENCY: Self = Self(6);
    pub const LINE_STRIP_WITH_ADJACENCY: Self = Self(7);
    pub const TRIANGLE_LIST_WITH_ADJACENCY: Self = Self(8);
    pub const TRIANGLE_STRIP_WITH_ADJACENCY: Self = Self(9);
    pub const PATCH_LIST: Self = Self(10);
}
impl fmt::Display for PrimitiveTopology {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"POINT_LIST"),
            1 => Some(&"LINE_LIST"),
            2 => Some(&"LINE_STRIP"),
            3 => Some(&"TRIANGLE_LIST"),
            4 => Some(&"TRIANGLE_STRIP"),
            5 => Some(&"TRIANGLE_FAN"),
            6 => Some(&"LINE_LIST_WITH_ADJACENCY"),
            7 => Some(&"LINE_STRIP_WITH_ADJACENCY"),
            8 => Some(&"TRIANGLE_LIST_WITH_ADJACENCY"),
            9 => Some(&"TRIANGLE_STRIP_WITH_ADJACENCY"),
            10 => Some(&"PATCH_LIST"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct QueryType(i32);
impl QueryType {
    pub const OCCLUSION: Self = Self(0);
    /// Optional
    pub const PIPELINE_STATISTICS: Self = Self(1);
    pub const TIMESTAMP: Self = Self(2);
    /// Added by extension VK_EXT_transform_feedback.
    pub const TRANSFORM_FEEDBACK_STREAM_EXT: Self = Self(1000028004);
    /// Added by extension VK_KHR_performance_query.
    pub const PERFORMANCE_QUERY_KHR: Self = Self(1000116000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR: Self = Self(1000150000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR: Self = Self(1000150001);
    /// Added by extension VK_NV_ray_tracing.
    pub const ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV: Self = Self(1000165000);
    /// Added by extension VK_INTEL_performance_query.
    pub const PERFORMANCE_QUERY_INTEL: Self = Self(1000210000);
    /// Added by extension VK_EXT_primitives_generated_query.
    pub const PRIMITIVES_GENERATED_EXT: Self = Self(1000382000);
    /// Added by extension VK_KHR_ray_tracing_maintenance1.
    pub const ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR: Self = Self(1000386000);
    /// Added by extension VK_KHR_ray_tracing_maintenance1.
    pub const ACCELERATION_STRUCTURE_SIZE_KHR: Self = Self(1000386001);
}
impl fmt::Display for QueryType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"OCCLUSION"),
            1 => Some(&"PIPELINE_STATISTICS"),
            2 => Some(&"TIMESTAMP"),
            1000028004 => Some(&"TRANSFORM_FEEDBACK_STREAM_EXT"),
            1000116000 => Some(&"PERFORMANCE_QUERY_KHR"),
            1000150000 => Some(&"ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR"),
            1000150001 => Some(&"ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR"),
            1000165000 => Some(&"ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV"),
            1000210000 => Some(&"PERFORMANCE_QUERY_INTEL"),
            1000382000 => Some(&"PRIMITIVES_GENERATED_EXT"),
            1000386000 => Some(&"ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR"),
            1000386001 => Some(&"ACCELERATION_STRUCTURE_SIZE_KHR"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SubpassContents(i32);
impl SubpassContents {
    pub const INLINE: Self = Self(0);
    pub const SECONDARY_COMMAND_BUFFERS: Self = Self(1);
}
impl fmt::Display for SubpassContents {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"INLINE"),
            1 => Some(&"SECONDARY_COMMAND_BUFFERS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct Result(i32);
impl Result {
    /// Command completed successfully
    pub const SUCCESS: Self = Self(0);
    /// A fence or query has not yet completed
    pub const NOT_READY: Self = Self(1);
    /// A wait operation has not completed in the specified time
    pub const TIMEOUT: Self = Self(2);
    /// An event is signaled
    pub const EVENT_SET: Self = Self(3);
    /// An event is unsignaled
    pub const EVENT_RESET: Self = Self(4);
    /// A return array was too small for the result
    pub const INCOMPLETE: Self = Self(5);
    /// A host memory allocation has failed
    pub const ERROR_OUT_OF_HOST_MEMORY: Self = Self(-1);
    /// A device memory allocation has failed
    pub const ERROR_OUT_OF_DEVICE_MEMORY: Self = Self(-2);
    /// Initialization of an object has failed
    pub const ERROR_INITIALIZATION_FAILED: Self = Self(-3);
    /// The logical device has been lost. See <<devsandqueues-lost-device>>
    pub const ERROR_DEVICE_LOST: Self = Self(-4);
    /// Mapping of a memory object has failed
    pub const ERROR_MEMORY_MAP_FAILED: Self = Self(-5);
    /// Layer specified does not exist
    pub const ERROR_LAYER_NOT_PRESENT: Self = Self(-6);
    /// Extension specified does not exist
    pub const ERROR_EXTENSION_NOT_PRESENT: Self = Self(-7);
    /// Requested feature is not available on this device
    pub const ERROR_FEATURE_NOT_PRESENT: Self = Self(-8);
    /// Unable to find a Vulkan driver
    pub const ERROR_INCOMPATIBLE_DRIVER: Self = Self(-9);
    /// Too many objects of the type have already been created
    pub const ERROR_TOO_MANY_OBJECTS: Self = Self(-10);
    /// Requested format is not supported on this device
    pub const ERROR_FORMAT_NOT_SUPPORTED: Self = Self(-11);
    /// A requested pool allocation has failed due to fragmentation of the pool's memory
    pub const ERROR_FRAGMENTED_POOL: Self = Self(-12);
    /// An unknown error has occurred, due to an implementation or application bug
    pub const ERROR_UNKNOWN: Self = Self(-13);
    pub const ERROR_OUT_OF_POOL_MEMORY: Self = Self(-1000069000);
    pub const ERROR_INVALID_EXTERNAL_HANDLE: Self = Self(-1000072003);
    pub const ERROR_FRAGMENTATION: Self = Self(-1000161000);
    pub const ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS: Self = Self(-1000257000);
    pub const PIPELINE_COMPILE_REQUIRED: Self = Self(1000297000);
    /// Added by extension VK_KHR_surface.
    pub const ERROR_SURFACE_LOST_KHR: Self = Self(-1000000000);
    /// Added by extension VK_KHR_surface.
    pub const ERROR_NATIVE_WINDOW_IN_USE_KHR: Self = Self(-1000000001);
    /// Added by extension VK_KHR_swapchain.
    pub const SUBOPTIMAL_KHR: Self = Self(1000001003);
    /// Added by extension VK_KHR_swapchain.
    pub const ERROR_OUT_OF_DATE_KHR: Self = Self(-1000001004);
    /// Added by extension VK_KHR_display_swapchain.
    pub const ERROR_INCOMPATIBLE_DISPLAY_KHR: Self = Self(-1000003001);
    /// Added by extension VK_EXT_debug_report.
    pub const ERROR_VALIDATION_FAILED_EXT: Self = Self(-1000011001);
    /// Added by extension VK_NV_glsl_shader.
    pub const ERROR_INVALID_SHADER_NV: Self = Self(-1000012000);
    pub const ERROR_OUT_OF_POOL_MEMORY_KHR: Self = Self::ERROR_OUT_OF_POOL_MEMORY;
    pub const ERROR_INVALID_EXTERNAL_HANDLE_KHR: Self = Self::ERROR_INVALID_EXTERNAL_HANDLE;
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: Self = Self(-1000158000);
    pub const ERROR_FRAGMENTATION_EXT: Self = Self::ERROR_FRAGMENTATION;
    pub const ERROR_NOT_PERMITTED_EXT: Self = Self::ERROR_NOT_PERMITTED_KHR;
    /// Added by extension VK_KHR_global_priority.
    pub const ERROR_NOT_PERMITTED_KHR: Self = Self(-1000174001);
    pub const ERROR_INVALID_DEVICE_ADDRESS_EXT: Self = Self::ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
    /// Added by extension VK_EXT_full_screen_exclusive.
    pub const ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT: Self = Self(-1000255000);
    pub const ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR: Self = Self::ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
    /// Added by extension VK_KHR_deferred_host_operations.
    pub const THREAD_IDLE_KHR: Self = Self(1000268000);
    /// Added by extension VK_KHR_deferred_host_operations.
    pub const THREAD_DONE_KHR: Self = Self(1000268001);
    /// Added by extension VK_KHR_deferred_host_operations.
    pub const OPERATION_DEFERRED_KHR: Self = Self(1000268002);
    /// Added by extension VK_KHR_deferred_host_operations.
    pub const OPERATION_NOT_DEFERRED_KHR: Self = Self(1000268003);
    pub const PIPELINE_COMPILE_REQUIRED_EXT: Self = Self::PIPELINE_COMPILE_REQUIRED;
    pub const ERROR_PIPELINE_COMPILE_REQUIRED_EXT: Self = Self::PIPELINE_COMPILE_REQUIRED;
    /// Added by extension VK_EXT_image_compression_control.
    pub const ERROR_COMPRESSION_EXHAUSTED_EXT: Self = Self(-1000338000);
}
impl fmt::Display for Result {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"SUCCESS"),
            1 => Some(&"NOT_READY"),
            2 => Some(&"TIMEOUT"),
            3 => Some(&"EVENT_SET"),
            4 => Some(&"EVENT_RESET"),
            5 => Some(&"INCOMPLETE"),
            -1 => Some(&"ERROR_OUT_OF_HOST_MEMORY"),
            -2 => Some(&"ERROR_OUT_OF_DEVICE_MEMORY"),
            -3 => Some(&"ERROR_INITIALIZATION_FAILED"),
            -4 => Some(&"ERROR_DEVICE_LOST"),
            -5 => Some(&"ERROR_MEMORY_MAP_FAILED"),
            -6 => Some(&"ERROR_LAYER_NOT_PRESENT"),
            -7 => Some(&"ERROR_EXTENSION_NOT_PRESENT"),
            -8 => Some(&"ERROR_FEATURE_NOT_PRESENT"),
            -9 => Some(&"ERROR_INCOMPATIBLE_DRIVER"),
            -10 => Some(&"ERROR_TOO_MANY_OBJECTS"),
            -11 => Some(&"ERROR_FORMAT_NOT_SUPPORTED"),
            -12 => Some(&"ERROR_FRAGMENTED_POOL"),
            -13 => Some(&"ERROR_UNKNOWN"),
            -1000069000 => Some(&"ERROR_OUT_OF_POOL_MEMORY"),
            -1000072003 => Some(&"ERROR_INVALID_EXTERNAL_HANDLE"),
            -1000161000 => Some(&"ERROR_FRAGMENTATION"),
            -1000257000 => Some(&"ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS"),
            1000297000 => Some(&"PIPELINE_COMPILE_REQUIRED"),
            -1000000000 => Some(&"ERROR_SURFACE_LOST_KHR"),
            -1000000001 => Some(&"ERROR_NATIVE_WINDOW_IN_USE_KHR"),
            1000001003 => Some(&"SUBOPTIMAL_KHR"),
            -1000001004 => Some(&"ERROR_OUT_OF_DATE_KHR"),
            -1000003001 => Some(&"ERROR_INCOMPATIBLE_DISPLAY_KHR"),
            -1000011001 => Some(&"ERROR_VALIDATION_FAILED_EXT"),
            -1000012000 => Some(&"ERROR_INVALID_SHADER_NV"),
            -1000158000 => Some(&"ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT"),
            -1000174001 => Some(&"ERROR_NOT_PERMITTED_KHR"),
            -1000255000 => Some(&"ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT"),
            1000268000 => Some(&"THREAD_IDLE_KHR"),
            1000268001 => Some(&"THREAD_DONE_KHR"),
            1000268002 => Some(&"OPERATION_DEFERRED_KHR"),
            1000268003 => Some(&"OPERATION_NOT_DEFERRED_KHR"),
            -1000338000 => Some(&"ERROR_COMPRESSION_EXHAUSTED_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct StencilOp(i32);
impl StencilOp {
    pub const KEEP: Self = Self(0);
    pub const ZERO: Self = Self(1);
    pub const REPLACE: Self = Self(2);
    pub const INCREMENT_AND_CLAMP: Self = Self(3);
    pub const DECREMENT_AND_CLAMP: Self = Self(4);
    pub const INVERT: Self = Self(5);
    pub const INCREMENT_AND_WRAP: Self = Self(6);
    pub const DECREMENT_AND_WRAP: Self = Self(7);
}
impl fmt::Display for StencilOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"KEEP"),
            1 => Some(&"ZERO"),
            2 => Some(&"REPLACE"),
            3 => Some(&"INCREMENT_AND_CLAMP"),
            4 => Some(&"DECREMENT_AND_CLAMP"),
            5 => Some(&"INVERT"),
            6 => Some(&"INCREMENT_AND_WRAP"),
            7 => Some(&"DECREMENT_AND_WRAP"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct StructureType(i32);
impl StructureType {
    pub const APPLICATION_INFO: Self = Self(0);
    pub const INSTANCE_CREATE_INFO: Self = Self(1);
    pub const DEVICE_QUEUE_CREATE_INFO: Self = Self(2);
    pub const DEVICE_CREATE_INFO: Self = Self(3);
    pub const SUBMIT_INFO: Self = Self(4);
    pub const MEMORY_ALLOCATE_INFO: Self = Self(5);
    pub const MAPPED_MEMORY_RANGE: Self = Self(6);
    pub const BIND_SPARSE_INFO: Self = Self(7);
    pub const FENCE_CREATE_INFO: Self = Self(8);
    pub const SEMAPHORE_CREATE_INFO: Self = Self(9);
    pub const EVENT_CREATE_INFO: Self = Self(10);
    pub const QUERY_POOL_CREATE_INFO: Self = Self(11);
    pub const BUFFER_CREATE_INFO: Self = Self(12);
    pub const BUFFER_VIEW_CREATE_INFO: Self = Self(13);
    pub const IMAGE_CREATE_INFO: Self = Self(14);
    pub const IMAGE_VIEW_CREATE_INFO: Self = Self(15);
    pub const SHADER_MODULE_CREATE_INFO: Self = Self(16);
    pub const PIPELINE_CACHE_CREATE_INFO: Self = Self(17);
    pub const PIPELINE_SHADER_STAGE_CREATE_INFO: Self = Self(18);
    pub const PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO: Self = Self(19);
    pub const PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO: Self = Self(20);
    pub const PIPELINE_TESSELLATION_STATE_CREATE_INFO: Self = Self(21);
    pub const PIPELINE_VIEWPORT_STATE_CREATE_INFO: Self = Self(22);
    pub const PIPELINE_RASTERIZATION_STATE_CREATE_INFO: Self = Self(23);
    pub const PIPELINE_MULTISAMPLE_STATE_CREATE_INFO: Self = Self(24);
    pub const PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO: Self = Self(25);
    pub const PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: Self = Self(26);
    pub const PIPELINE_DYNAMIC_STATE_CREATE_INFO: Self = Self(27);
    pub const GRAPHICS_PIPELINE_CREATE_INFO: Self = Self(28);
    pub const COMPUTE_PIPELINE_CREATE_INFO: Self = Self(29);
    pub const PIPELINE_LAYOUT_CREATE_INFO: Self = Self(30);
    pub const SAMPLER_CREATE_INFO: Self = Self(31);
    pub const DESCRIPTOR_SET_LAYOUT_CREATE_INFO: Self = Self(32);
    pub const DESCRIPTOR_POOL_CREATE_INFO: Self = Self(33);
    pub const DESCRIPTOR_SET_ALLOCATE_INFO: Self = Self(34);
    pub const WRITE_DESCRIPTOR_SET: Self = Self(35);
    pub const COPY_DESCRIPTOR_SET: Self = Self(36);
    pub const FRAMEBUFFER_CREATE_INFO: Self = Self(37);
    pub const RENDER_PASS_CREATE_INFO: Self = Self(38);
    pub const COMMAND_POOL_CREATE_INFO: Self = Self(39);
    pub const COMMAND_BUFFER_ALLOCATE_INFO: Self = Self(40);
    pub const COMMAND_BUFFER_INHERITANCE_INFO: Self = Self(41);
    pub const COMMAND_BUFFER_BEGIN_INFO: Self = Self(42);
    pub const RENDER_PASS_BEGIN_INFO: Self = Self(43);
    pub const BUFFER_MEMORY_BARRIER: Self = Self(44);
    pub const IMAGE_MEMORY_BARRIER: Self = Self(45);
    pub const MEMORY_BARRIER: Self = Self(46);
    /// Reserved for internal use by the loader, layers, and ICDs
    pub const LOADER_INSTANCE_CREATE_INFO: Self = Self(47);
    /// Reserved for internal use by the loader, layers, and ICDs
    pub const LOADER_DEVICE_CREATE_INFO: Self = Self(48);
    pub const PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: Self = Self(1000094000);
    pub const BIND_BUFFER_MEMORY_INFO: Self = Self(1000157000);
    pub const BIND_IMAGE_MEMORY_INFO: Self = Self(1000157001);
    pub const PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: Self = Self(1000083000);
    pub const MEMORY_DEDICATED_REQUIREMENTS: Self = Self(1000127000);
    pub const MEMORY_DEDICATED_ALLOCATE_INFO: Self = Self(1000127001);
    pub const MEMORY_ALLOCATE_FLAGS_INFO: Self = Self(1000060000);
    pub const DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: Self = Self(1000060003);
    pub const DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: Self = Self(1000060004);
    pub const DEVICE_GROUP_SUBMIT_INFO: Self = Self(1000060005);
    pub const DEVICE_GROUP_BIND_SPARSE_INFO: Self = Self(1000060006);
    pub const BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: Self = Self(1000060013);
    pub const BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: Self = Self(1000060014);
    pub const PHYSICAL_DEVICE_GROUP_PROPERTIES: Self = Self(1000070000);
    pub const DEVICE_GROUP_DEVICE_CREATE_INFO: Self = Self(1000070001);
    pub const BUFFER_MEMORY_REQUIREMENTS_INFO_2: Self = Self(1000146000);
    pub const IMAGE_MEMORY_REQUIREMENTS_INFO_2: Self = Self(1000146001);
    pub const IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2: Self = Self(1000146002);
    pub const MEMORY_REQUIREMENTS_2: Self = Self(1000146003);
    pub const SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: Self = Self(1000146004);
    pub const PHYSICAL_DEVICE_FEATURES_2: Self = Self(1000059000);
    pub const PHYSICAL_DEVICE_PROPERTIES_2: Self = Self(1000059001);
    pub const FORMAT_PROPERTIES_2: Self = Self(1000059002);
    pub const IMAGE_FORMAT_PROPERTIES_2: Self = Self(1000059003);
    pub const PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: Self = Self(1000059004);
    pub const QUEUE_FAMILY_PROPERTIES_2: Self = Self(1000059005);
    pub const PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: Self = Self(1000059006);
    pub const SPARSE_IMAGE_FORMAT_PROPERTIES_2: Self = Self(1000059007);
    pub const PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2: Self = Self(1000059008);
    pub const PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: Self = Self(1000117000);
    pub const RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: Self = Self(1000117001);
    pub const IMAGE_VIEW_USAGE_CREATE_INFO: Self = Self(1000117002);
    pub const PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: Self = Self(1000117003);
    pub const RENDER_PASS_MULTIVIEW_CREATE_INFO: Self = Self(1000053000);
    pub const PHYSICAL_DEVICE_MULTIVIEW_FEATURES: Self = Self(1000053001);
    pub const PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: Self = Self(1000053002);
    pub const PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: Self = Self(1000120000);
    pub const PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES: Self = Self::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
    pub const PROTECTED_SUBMIT_INFO: Self = Self(1000145000);
    pub const PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: Self = Self(1000145001);
    pub const PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: Self = Self(1000145002);
    pub const DEVICE_QUEUE_INFO_2: Self = Self(1000145003);
    pub const SAMPLER_YCBCR_CONVERSION_CREATE_INFO: Self = Self(1000156000);
    pub const SAMPLER_YCBCR_CONVERSION_INFO: Self = Self(1000156001);
    pub const BIND_IMAGE_PLANE_MEMORY_INFO: Self = Self(1000156002);
    pub const IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: Self = Self(1000156003);
    pub const PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: Self = Self(1000156004);
    pub const SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: Self = Self(1000156005);
    pub const DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO: Self = Self(1000085000);
    pub const PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: Self = Self(1000071000);
    pub const EXTERNAL_IMAGE_FORMAT_PROPERTIES: Self = Self(1000071001);
    pub const PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: Self = Self(1000071002);
    pub const EXTERNAL_BUFFER_PROPERTIES: Self = Self(1000071003);
    pub const PHYSICAL_DEVICE_ID_PROPERTIES: Self = Self(1000071004);
    pub const EXTERNAL_MEMORY_BUFFER_CREATE_INFO: Self = Self(1000072000);
    pub const EXTERNAL_MEMORY_IMAGE_CREATE_INFO: Self = Self(1000072001);
    pub const EXPORT_MEMORY_ALLOCATE_INFO: Self = Self(1000072002);
    pub const PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: Self = Self(1000112000);
    pub const EXTERNAL_FENCE_PROPERTIES: Self = Self(1000112001);
    pub const EXPORT_FENCE_CREATE_INFO: Self = Self(1000113000);
    pub const EXPORT_SEMAPHORE_CREATE_INFO: Self = Self(1000077000);
    pub const PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO: Self = Self(1000076000);
    pub const EXTERNAL_SEMAPHORE_PROPERTIES: Self = Self(1000076001);
    pub const PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: Self = Self(1000168000);
    pub const DESCRIPTOR_SET_LAYOUT_SUPPORT: Self = Self(1000168001);
    pub const PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: Self = Self(1000063000);
    pub const PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES: Self =
        Self::PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
    pub const PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: Self = Self(49);
    pub const PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: Self = Self(50);
    pub const PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: Self = Self(51);
    pub const PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: Self = Self(52);
    pub const IMAGE_FORMAT_LIST_CREATE_INFO: Self = Self(1000147000);
    pub const ATTACHMENT_DESCRIPTION_2: Self = Self(1000109000);
    pub const ATTACHMENT_REFERENCE_2: Self = Self(1000109001);
    pub const SUBPASS_DESCRIPTION_2: Self = Self(1000109002);
    pub const SUBPASS_DEPENDENCY_2: Self = Self(1000109003);
    pub const RENDER_PASS_CREATE_INFO_2: Self = Self(1000109004);
    pub const SUBPASS_BEGIN_INFO: Self = Self(1000109005);
    pub const SUBPASS_END_INFO: Self = Self(1000109006);
    pub const PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: Self = Self(1000177000);
    pub const PHYSICAL_DEVICE_DRIVER_PROPERTIES: Self = Self(1000196000);
    pub const PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: Self = Self(1000180000);
    pub const PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: Self = Self(1000082000);
    pub const PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES: Self = Self(1000197000);
    pub const DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: Self = Self(1000161000);
    pub const PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: Self = Self(1000161001);
    pub const PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES: Self = Self(1000161002);
    pub const DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO: Self = Self(1000161003);
    pub const DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: Self = Self(1000161004);
    pub const PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES: Self = Self(1000199000);
    pub const SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: Self = Self(1000199001);
    pub const PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: Self = Self(1000221000);
    pub const IMAGE_STENCIL_USAGE_CREATE_INFO: Self = Self(1000246000);
    pub const PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: Self = Self(1000130000);
    pub const SAMPLER_REDUCTION_MODE_CREATE_INFO: Self = Self(1000130001);
    pub const PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: Self = Self(1000211000);
    pub const PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: Self = Self(1000108000);
    pub const FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: Self = Self(1000108001);
    pub const FRAMEBUFFER_ATTACHMENT_IMAGE_INFO: Self = Self(1000108002);
    pub const RENDER_PASS_ATTACHMENT_BEGIN_INFO: Self = Self(1000108003);
    pub const PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: Self = Self(1000253000);
    pub const PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: Self = Self(1000175000);
    pub const PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: Self = Self(1000241000);
    pub const ATTACHMENT_REFERENCE_STENCIL_LAYOUT: Self = Self(1000241001);
    pub const ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: Self = Self(1000241002);
    pub const PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: Self = Self(1000261000);
    pub const PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: Self = Self(1000207000);
    pub const PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES: Self = Self(1000207001);
    pub const SEMAPHORE_TYPE_CREATE_INFO: Self = Self(1000207002);
    pub const TIMELINE_SEMAPHORE_SUBMIT_INFO: Self = Self(1000207003);
    pub const SEMAPHORE_WAIT_INFO: Self = Self(1000207004);
    pub const SEMAPHORE_SIGNAL_INFO: Self = Self(1000207005);
    pub const PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: Self = Self(1000257000);
    pub const BUFFER_DEVICE_ADDRESS_INFO: Self = Self(1000244001);
    pub const BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: Self = Self(1000257002);
    pub const MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: Self = Self(1000257003);
    pub const DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO: Self = Self(1000257004);
    pub const PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: Self = Self(53);
    pub const PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES: Self = Self(54);
    pub const PIPELINE_CREATION_FEEDBACK_CREATE_INFO: Self = Self(1000192000);
    pub const PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES: Self = Self(1000215000);
    pub const PHYSICAL_DEVICE_TOOL_PROPERTIES: Self = Self(1000245000);
    pub const PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES: Self = Self(1000276000);
    pub const PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: Self = Self(1000295000);
    pub const DEVICE_PRIVATE_DATA_CREATE_INFO: Self = Self(1000295001);
    pub const PRIVATE_DATA_SLOT_CREATE_INFO: Self = Self(1000295002);
    pub const PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES: Self = Self(1000297000);
    pub const MEMORY_BARRIER_2: Self = Self(1000314000);
    pub const BUFFER_MEMORY_BARRIER_2: Self = Self(1000314001);
    pub const IMAGE_MEMORY_BARRIER_2: Self = Self(1000314002);
    pub const DEPENDENCY_INFO: Self = Self(1000314003);
    pub const SUBMIT_INFO_2: Self = Self(1000314004);
    pub const SEMAPHORE_SUBMIT_INFO: Self = Self(1000314005);
    pub const COMMAND_BUFFER_SUBMIT_INFO: Self = Self(1000314006);
    pub const PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES: Self = Self(1000314007);
    pub const PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES: Self = Self(1000325000);
    pub const PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES: Self = Self(1000335000);
    pub const COPY_BUFFER_INFO_2: Self = Self(1000337000);
    pub const COPY_IMAGE_INFO_2: Self = Self(1000337001);
    pub const COPY_BUFFER_TO_IMAGE_INFO_2: Self = Self(1000337002);
    pub const COPY_IMAGE_TO_BUFFER_INFO_2: Self = Self(1000337003);
    pub const BLIT_IMAGE_INFO_2: Self = Self(1000337004);
    pub const RESOLVE_IMAGE_INFO_2: Self = Self(1000337005);
    pub const BUFFER_COPY_2: Self = Self(1000337006);
    pub const IMAGE_COPY_2: Self = Self(1000337007);
    pub const IMAGE_BLIT_2: Self = Self(1000337008);
    pub const BUFFER_IMAGE_COPY_2: Self = Self(1000337009);
    pub const IMAGE_RESOLVE_2: Self = Self(1000337010);
    pub const PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES: Self = Self(1000225000);
    pub const PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO: Self = Self(1000225001);
    pub const PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES: Self = Self(1000225002);
    pub const PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES: Self = Self(1000138000);
    pub const PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES: Self = Self(1000138001);
    pub const WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK: Self = Self(1000138002);
    pub const DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO: Self = Self(1000138003);
    pub const PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES: Self = Self(1000066000);
    pub const RENDERING_INFO: Self = Self(1000044000);
    pub const RENDERING_ATTACHMENT_INFO: Self = Self(1000044001);
    pub const PIPELINE_RENDERING_CREATE_INFO: Self = Self(1000044002);
    pub const PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES: Self = Self(1000044003);
    pub const COMMAND_BUFFER_INHERITANCE_RENDERING_INFO: Self = Self(1000044004);
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES: Self = Self(1000280000);
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES: Self = Self(1000280001);
    pub const PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES: Self = Self(1000281001);
    pub const FORMAT_PROPERTIES_3: Self = Self(1000360000);
    pub const PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES: Self = Self(1000413000);
    pub const PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES: Self = Self(1000413001);
    pub const DEVICE_BUFFER_MEMORY_REQUIREMENTS: Self = Self(1000413002);
    pub const DEVICE_IMAGE_MEMORY_REQUIREMENTS: Self = Self(1000413003);
    /// Added by extension VK_KHR_swapchain.
    pub const SWAPCHAIN_CREATE_INFO_KHR: Self = Self(1000001000);
    /// Added by extension VK_KHR_swapchain.
    pub const PRESENT_INFO_KHR: Self = Self(1000001001);
    /// Added by extension VK_KHR_device_group.
    pub const DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: Self = Self(1000060007);
    /// Added by extension VK_KHR_device_group.
    pub const IMAGE_SWAPCHAIN_CREATE_INFO_KHR: Self = Self(1000060008);
    /// Added by extension VK_KHR_device_group.
    pub const BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: Self = Self(1000060009);
    /// Added by extension VK_KHR_device_group.
    pub const ACQUIRE_NEXT_IMAGE_INFO_KHR: Self = Self(1000060010);
    /// Added by extension VK_KHR_device_group.
    pub const DEVICE_GROUP_PRESENT_INFO_KHR: Self = Self(1000060011);
    /// Added by extension VK_KHR_device_group.
    pub const DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: Self = Self(1000060012);
    /// Added by extension VK_KHR_display.
    pub const DISPLAY_MODE_CREATE_INFO_KHR: Self = Self(1000002000);
    /// Added by extension VK_KHR_display.
    pub const DISPLAY_SURFACE_CREATE_INFO_KHR: Self = Self(1000002001);
    /// Added by extension VK_KHR_display_swapchain.
    pub const DISPLAY_PRESENT_INFO_KHR: Self = Self(1000003000);
    /// Added by extension VK_KHR_xlib_surface.
    pub const XLIB_SURFACE_CREATE_INFO_KHR: Self = Self(1000004000);
    /// Added by extension VK_KHR_xcb_surface.
    pub const XCB_SURFACE_CREATE_INFO_KHR: Self = Self(1000005000);
    /// Added by extension VK_KHR_wayland_surface.
    pub const WAYLAND_SURFACE_CREATE_INFO_KHR: Self = Self(1000006000);
    /// Added by extension VK_KHR_android_surface.
    pub const ANDROID_SURFACE_CREATE_INFO_KHR: Self = Self(1000008000);
    /// Added by extension VK_KHR_win32_surface.
    pub const WIN32_SURFACE_CREATE_INFO_KHR: Self = Self(1000009000);
    /// Added by extension VK_EXT_debug_report.
    pub const DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: Self = Self(1000011000);
    pub const DEBUG_REPORT_CREATE_INFO_EXT: Self = Self::DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
    /// Added by extension VK_AMD_rasterization_order.
    pub const PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: Self = Self(1000018000);
    /// Added by extension VK_EXT_debug_marker.
    pub const DEBUG_MARKER_OBJECT_NAME_INFO_EXT: Self = Self(1000022000);
    /// Added by extension VK_EXT_debug_marker.
    pub const DEBUG_MARKER_OBJECT_TAG_INFO_EXT: Self = Self(1000022001);
    /// Added by extension VK_EXT_debug_marker.
    pub const DEBUG_MARKER_MARKER_INFO_EXT: Self = Self(1000022002);
    /// Added by extension VK_NV_dedicated_allocation.
    pub const DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: Self = Self(1000026000);
    /// Added by extension VK_NV_dedicated_allocation.
    pub const DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: Self = Self(1000026001);
    /// Added by extension VK_NV_dedicated_allocation.
    pub const DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: Self = Self(1000026002);
    /// Added by extension VK_EXT_transform_feedback.
    pub const PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: Self = Self(1000028000);
    /// Added by extension VK_EXT_transform_feedback.
    pub const PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: Self = Self(1000028001);
    /// Added by extension VK_EXT_transform_feedback.
    pub const PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: Self = Self(1000028002);
    /// Added by extension VK_NVX_binary_import.
    pub const CU_MODULE_CREATE_INFO_NVX: Self = Self(1000029000);
    /// Added by extension VK_NVX_binary_import.
    pub const CU_FUNCTION_CREATE_INFO_NVX: Self = Self(1000029001);
    /// Added by extension VK_NVX_binary_import.
    pub const CU_LAUNCH_INFO_NVX: Self = Self(1000029002);
    /// Added by extension VK_NVX_image_view_handle.
    pub const IMAGE_VIEW_HANDLE_INFO_NVX: Self = Self(1000030000);
    /// Added by extension VK_NVX_image_view_handle.
    pub const IMAGE_VIEW_ADDRESS_PROPERTIES_NVX: Self = Self(1000030001);
    /// Added by extension VK_AMD_texture_gather_bias_lod.
    pub const TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: Self = Self(1000041000);
    pub const RENDERING_INFO_KHR: Self = Self::RENDERING_INFO;
    pub const RENDERING_ATTACHMENT_INFO_KHR: Self = Self::RENDERING_ATTACHMENT_INFO;
    pub const PIPELINE_RENDERING_CREATE_INFO_KHR: Self = Self::PIPELINE_RENDERING_CREATE_INFO;
    pub const PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
    pub const COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR: Self = Self::COMMAND_BUFFER_INHERITANCE_RENDERING_INFO;
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: Self = Self(1000044006);
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT: Self = Self(1000044007);
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const ATTACHMENT_SAMPLE_COUNT_INFO_AMD: Self = Self(1000044008);
    pub const ATTACHMENT_SAMPLE_COUNT_INFO_NV: Self = Self::ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
    /// Added by extension VK_KHR_dynamic_rendering.
    pub const MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX: Self = Self(1000044009);
    /// Added by extension VK_NV_corner_sampled_image.
    pub const PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: Self = Self(1000050000);
    pub const RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR: Self = Self::RENDER_PASS_MULTIVIEW_CREATE_INFO;
    pub const PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
    pub const PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
    /// Added by extension VK_NV_external_memory.
    pub const EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: Self = Self(1000056000);
    /// Added by extension VK_NV_external_memory.
    pub const EXPORT_MEMORY_ALLOCATE_INFO_NV: Self = Self(1000056001);
    /// Added by extension VK_NV_external_memory_win32.
    pub const IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: Self = Self(1000057000);
    /// Added by extension VK_NV_external_memory_win32.
    pub const EXPORT_MEMORY_WIN32_HANDLE_INFO_NV: Self = Self(1000057001);
    /// Added by extension VK_NV_win32_keyed_mutex.
    pub const WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV: Self = Self(1000058000);
    pub const PHYSICAL_DEVICE_FEATURES_2_KHR: Self = Self::PHYSICAL_DEVICE_FEATURES_2;
    pub const PHYSICAL_DEVICE_PROPERTIES_2_KHR: Self = Self::PHYSICAL_DEVICE_PROPERTIES_2;
    pub const FORMAT_PROPERTIES_2_KHR: Self = Self::FORMAT_PROPERTIES_2;
    pub const IMAGE_FORMAT_PROPERTIES_2_KHR: Self = Self::IMAGE_FORMAT_PROPERTIES_2;
    pub const PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR: Self = Self::PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
    pub const QUEUE_FAMILY_PROPERTIES_2_KHR: Self = Self::QUEUE_FAMILY_PROPERTIES_2;
    pub const PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR: Self = Self::PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
    pub const SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR: Self = Self::SPARSE_IMAGE_FORMAT_PROPERTIES_2;
    pub const PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR: Self = Self::PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
    pub const MEMORY_ALLOCATE_FLAGS_INFO_KHR: Self = Self::MEMORY_ALLOCATE_FLAGS_INFO;
    pub const DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR: Self = Self::DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
    pub const DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR: Self = Self::DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
    pub const DEVICE_GROUP_SUBMIT_INFO_KHR: Self = Self::DEVICE_GROUP_SUBMIT_INFO;
    pub const DEVICE_GROUP_BIND_SPARSE_INFO_KHR: Self = Self::DEVICE_GROUP_BIND_SPARSE_INFO;
    pub const BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR: Self = Self::BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
    pub const BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR: Self = Self::BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
    /// Added by extension VK_EXT_validation_flags.
    pub const VALIDATION_FLAGS_EXT: Self = Self(1000061000);
    /// Added by extension VK_NN_vi_surface.
    pub const VI_SURFACE_CREATE_INFO_NN: Self = Self(1000062000);
    pub const PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
    /// Added by extension VK_EXT_astc_decode_mode.
    pub const IMAGE_VIEW_ASTC_DECODE_MODE_EXT: Self = Self(1000067000);
    /// Added by extension VK_EXT_astc_decode_mode.
    pub const PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: Self = Self(1000067001);
    pub const PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_GROUP_PROPERTIES;
    pub const DEVICE_GROUP_DEVICE_CREATE_INFO_KHR: Self = Self::DEVICE_GROUP_DEVICE_CREATE_INFO;
    pub const PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR: Self = Self::PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
    pub const EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR: Self = Self::EXTERNAL_IMAGE_FORMAT_PROPERTIES;
    pub const PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR: Self = Self::PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
    pub const EXTERNAL_BUFFER_PROPERTIES_KHR: Self = Self::EXTERNAL_BUFFER_PROPERTIES;
    pub const PHYSICAL_DEVICE_ID_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_ID_PROPERTIES;
    pub const EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR: Self = Self::EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
    pub const EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR: Self = Self::EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
    pub const EXPORT_MEMORY_ALLOCATE_INFO_KHR: Self = Self::EXPORT_MEMORY_ALLOCATE_INFO;
    /// Added by extension VK_KHR_external_memory_win32.
    pub const IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: Self = Self(1000073000);
    /// Added by extension VK_KHR_external_memory_win32.
    pub const EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR: Self = Self(1000073001);
    /// Added by extension VK_KHR_external_memory_win32.
    pub const MEMORY_WIN32_HANDLE_PROPERTIES_KHR: Self = Self(1000073002);
    /// Added by extension VK_KHR_external_memory_win32.
    pub const MEMORY_GET_WIN32_HANDLE_INFO_KHR: Self = Self(1000073003);
    /// Added by extension VK_KHR_external_memory_fd.
    pub const IMPORT_MEMORY_FD_INFO_KHR: Self = Self(1000074000);
    /// Added by extension VK_KHR_external_memory_fd.
    pub const MEMORY_FD_PROPERTIES_KHR: Self = Self(1000074001);
    /// Added by extension VK_KHR_external_memory_fd.
    pub const MEMORY_GET_FD_INFO_KHR: Self = Self(1000074002);
    /// Added by extension VK_KHR_win32_keyed_mutex.
    pub const WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: Self = Self(1000075000);
    pub const PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR: Self = Self::PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
    pub const EXTERNAL_SEMAPHORE_PROPERTIES_KHR: Self = Self::EXTERNAL_SEMAPHORE_PROPERTIES;
    pub const EXPORT_SEMAPHORE_CREATE_INFO_KHR: Self = Self::EXPORT_SEMAPHORE_CREATE_INFO;
    /// Added by extension VK_KHR_external_semaphore_win32.
    pub const IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: Self = Self(1000078000);
    /// Added by extension VK_KHR_external_semaphore_win32.
    pub const EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: Self = Self(1000078001);
    /// Added by extension VK_KHR_external_semaphore_win32.
    pub const D3D12_FENCE_SUBMIT_INFO_KHR: Self = Self(1000078002);
    /// Added by extension VK_KHR_external_semaphore_win32.
    pub const SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR: Self = Self(1000078003);
    /// Added by extension VK_KHR_external_semaphore_fd.
    pub const IMPORT_SEMAPHORE_FD_INFO_KHR: Self = Self(1000079000);
    /// Added by extension VK_KHR_external_semaphore_fd.
    pub const SEMAPHORE_GET_FD_INFO_KHR: Self = Self(1000079001);
    /// Added by extension VK_KHR_push_descriptor.
    pub const PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR: Self = Self(1000080000);
    /// Added by extension VK_EXT_conditional_rendering.
    pub const COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: Self = Self(1000081000);
    /// Added by extension VK_EXT_conditional_rendering.
    pub const PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: Self = Self(1000081001);
    /// Added by extension VK_EXT_conditional_rendering.
    pub const CONDITIONAL_RENDERING_BEGIN_INFO_EXT: Self = Self(1000081002);
    pub const PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
    pub const PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
    pub const PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
    /// Added by extension VK_KHR_incremental_present.
    pub const PRESENT_REGIONS_KHR: Self = Self(1000084000);
    pub const DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR: Self = Self::DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
    /// Added by extension VK_NV_clip_space_w_scaling.
    pub const PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: Self = Self(1000087000);
    /// Added by extension VK_EXT_display_surface_counter.
    pub const SURFACE_CAPABILITIES_2_EXT: Self = Self(1000090000);
    pub const SURFACE_CAPABILITIES2_EXT: Self = Self::SURFACE_CAPABILITIES_2_EXT;
    /// Added by extension VK_EXT_display_control.
    pub const DISPLAY_POWER_INFO_EXT: Self = Self(1000091000);
    /// Added by extension VK_EXT_display_control.
    pub const DEVICE_EVENT_INFO_EXT: Self = Self(1000091001);
    /// Added by extension VK_EXT_display_control.
    pub const DISPLAY_EVENT_INFO_EXT: Self = Self(1000091002);
    /// Added by extension VK_EXT_display_control.
    pub const SWAPCHAIN_COUNTER_CREATE_INFO_EXT: Self = Self(1000091003);
    /// Added by extension VK_GOOGLE_display_timing.
    pub const PRESENT_TIMES_INFO_GOOGLE: Self = Self(1000092000);
    /// Added by extension VK_NVX_multiview_per_view_attributes.
    pub const PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX: Self = Self(1000097000);
    /// Added by extension VK_NV_viewport_swizzle.
    pub const PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: Self = Self(1000098000);
    /// Added by extension VK_EXT_discard_rectangles.
    pub const PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT: Self = Self(1000099000);
    /// Added by extension VK_EXT_discard_rectangles.
    pub const PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: Self = Self(1000099001);
    /// Added by extension VK_EXT_conservative_rasterization.
    pub const PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT: Self = Self(1000101000);
    /// Added by extension VK_EXT_conservative_rasterization.
    pub const PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: Self = Self(1000101001);
    /// Added by extension VK_EXT_depth_clip_enable.
    pub const PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: Self = Self(1000102000);
    /// Added by extension VK_EXT_depth_clip_enable.
    pub const PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: Self = Self(1000102001);
    /// Added by extension VK_EXT_hdr_metadata.
    pub const HDR_METADATA_EXT: Self = Self(1000105000);
    pub const PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
    pub const FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR: Self = Self::FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
    pub const FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR: Self = Self::FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;
    pub const RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR: Self = Self::RENDER_PASS_ATTACHMENT_BEGIN_INFO;
    pub const ATTACHMENT_DESCRIPTION_2_KHR: Self = Self::ATTACHMENT_DESCRIPTION_2;
    pub const ATTACHMENT_REFERENCE_2_KHR: Self = Self::ATTACHMENT_REFERENCE_2;
    pub const SUBPASS_DESCRIPTION_2_KHR: Self = Self::SUBPASS_DESCRIPTION_2;
    pub const SUBPASS_DEPENDENCY_2_KHR: Self = Self::SUBPASS_DEPENDENCY_2;
    pub const RENDER_PASS_CREATE_INFO_2_KHR: Self = Self::RENDER_PASS_CREATE_INFO_2;
    pub const SUBPASS_BEGIN_INFO_KHR: Self = Self::SUBPASS_BEGIN_INFO;
    pub const SUBPASS_END_INFO_KHR: Self = Self::SUBPASS_END_INFO;
    /// Added by extension VK_KHR_shared_presentable_image.
    pub const SHARED_PRESENT_SURFACE_CAPABILITIES_KHR: Self = Self(1000111000);
    pub const PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR: Self = Self::PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
    pub const EXTERNAL_FENCE_PROPERTIES_KHR: Self = Self::EXTERNAL_FENCE_PROPERTIES;
    pub const EXPORT_FENCE_CREATE_INFO_KHR: Self = Self::EXPORT_FENCE_CREATE_INFO;
    /// Added by extension VK_KHR_external_fence_win32.
    pub const IMPORT_FENCE_WIN32_HANDLE_INFO_KHR: Self = Self(1000114000);
    /// Added by extension VK_KHR_external_fence_win32.
    pub const EXPORT_FENCE_WIN32_HANDLE_INFO_KHR: Self = Self(1000114001);
    /// Added by extension VK_KHR_external_fence_win32.
    pub const FENCE_GET_WIN32_HANDLE_INFO_KHR: Self = Self(1000114002);
    /// Added by extension VK_KHR_external_fence_fd.
    pub const IMPORT_FENCE_FD_INFO_KHR: Self = Self(1000115000);
    /// Added by extension VK_KHR_external_fence_fd.
    pub const FENCE_GET_FD_INFO_KHR: Self = Self(1000115001);
    /// Added by extension VK_KHR_performance_query.
    pub const PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: Self = Self(1000116000);
    /// Added by extension VK_KHR_performance_query.
    pub const PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR: Self = Self(1000116001);
    /// Added by extension VK_KHR_performance_query.
    pub const QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR: Self = Self(1000116002);
    /// Added by extension VK_KHR_performance_query.
    pub const PERFORMANCE_QUERY_SUBMIT_INFO_KHR: Self = Self(1000116003);
    /// Added by extension VK_KHR_performance_query.
    pub const ACQUIRE_PROFILING_LOCK_INFO_KHR: Self = Self(1000116004);
    /// Added by extension VK_KHR_performance_query.
    pub const PERFORMANCE_COUNTER_KHR: Self = Self(1000116005);
    /// Added by extension VK_KHR_performance_query.
    pub const PERFORMANCE_COUNTER_DESCRIPTION_KHR: Self = Self(1000116006);
    pub const PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
    pub const RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR: Self =
        Self::RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
    pub const IMAGE_VIEW_USAGE_CREATE_INFO_KHR: Self = Self::IMAGE_VIEW_USAGE_CREATE_INFO;
    pub const PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR: Self =
        Self::PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
    /// Added by extension VK_KHR_get_surface_capabilities2.
    pub const PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: Self = Self(1000119000);
    /// Added by extension VK_KHR_get_surface_capabilities2.
    pub const SURFACE_CAPABILITIES_2_KHR: Self = Self(1000119001);
    /// Added by extension VK_KHR_get_surface_capabilities2.
    pub const SURFACE_FORMAT_2_KHR: Self = Self(1000119002);
    pub const PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
    pub const PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR;
    /// Added by extension VK_KHR_get_display_properties2.
    pub const DISPLAY_PROPERTIES_2_KHR: Self = Self(1000121000);
    /// Added by extension VK_KHR_get_display_properties2.
    pub const DISPLAY_PLANE_PROPERTIES_2_KHR: Self = Self(1000121001);
    /// Added by extension VK_KHR_get_display_properties2.
    pub const DISPLAY_MODE_PROPERTIES_2_KHR: Self = Self(1000121002);
    /// Added by extension VK_KHR_get_display_properties2.
    pub const DISPLAY_PLANE_INFO_2_KHR: Self = Self(1000121003);
    /// Added by extension VK_KHR_get_display_properties2.
    pub const DISPLAY_PLANE_CAPABILITIES_2_KHR: Self = Self(1000121004);
    /// Added by extension VK_MVK_ios_surface.
    pub const IOS_SURFACE_CREATE_INFO_MVK: Self = Self(1000122000);
    /// Added by extension VK_MVK_macos_surface.
    pub const MACOS_SURFACE_CREATE_INFO_MVK: Self = Self(1000123000);
    pub const MEMORY_DEDICATED_REQUIREMENTS_KHR: Self = Self::MEMORY_DEDICATED_REQUIREMENTS;
    pub const MEMORY_DEDICATED_ALLOCATE_INFO_KHR: Self = Self::MEMORY_DEDICATED_ALLOCATE_INFO;
    /// Added by extension VK_EXT_debug_utils.
    pub const DEBUG_UTILS_OBJECT_NAME_INFO_EXT: Self = Self(1000128000);
    /// Added by extension VK_EXT_debug_utils.
    pub const DEBUG_UTILS_OBJECT_TAG_INFO_EXT: Self = Self(1000128001);
    /// Added by extension VK_EXT_debug_utils.
    pub const DEBUG_UTILS_LABEL_EXT: Self = Self(1000128002);
    /// Added by extension VK_EXT_debug_utils.
    pub const DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: Self = Self(1000128003);
    /// Added by extension VK_EXT_debug_utils.
    pub const DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: Self = Self(1000128004);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: Self = Self(1000129000);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID: Self = Self(1000129001);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID: Self = Self(1000129002);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: Self = Self(1000129003);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: Self = Self(1000129004);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const EXTERNAL_FORMAT_ANDROID: Self = Self(1000129005);
    /// Added by extension VK_ANDROID_external_memory_android_hardware_buffer.
    pub const ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID: Self = Self(1000129006);
    pub const PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT: Self =
        Self::PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
    pub const SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT: Self = Self::SAMPLER_REDUCTION_MODE_CREATE_INFO;
    pub const PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
    pub const PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT: Self =
        Self::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
    pub const WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT: Self = Self::WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK;
    pub const DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT: Self =
        Self::DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO;
    /// Added by extension VK_EXT_sample_locations.
    pub const SAMPLE_LOCATIONS_INFO_EXT: Self = Self(1000143000);
    /// Added by extension VK_EXT_sample_locations.
    pub const RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: Self = Self(1000143001);
    /// Added by extension VK_EXT_sample_locations.
    pub const PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: Self = Self(1000143002);
    /// Added by extension VK_EXT_sample_locations.
    pub const PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT: Self = Self(1000143003);
    /// Added by extension VK_EXT_sample_locations.
    pub const MULTISAMPLE_PROPERTIES_EXT: Self = Self(1000143004);
    pub const BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR: Self = Self::BUFFER_MEMORY_REQUIREMENTS_INFO_2;
    pub const IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR: Self = Self::IMAGE_MEMORY_REQUIREMENTS_INFO_2;
    pub const IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR: Self = Self::IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
    pub const MEMORY_REQUIREMENTS_2_KHR: Self = Self::MEMORY_REQUIREMENTS_2;
    pub const SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR: Self = Self::SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
    pub const IMAGE_FORMAT_LIST_CREATE_INFO_KHR: Self = Self::IMAGE_FORMAT_LIST_CREATE_INFO;
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: Self = Self(1000148000);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: Self = Self(1000148001);
    /// Added by extension VK_EXT_blend_operation_advanced.
    pub const PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: Self = Self(1000148002);
    /// Added by extension VK_NV_fragment_coverage_to_color.
    pub const PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: Self = Self(1000149000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR: Self = Self(1000150007);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR: Self = Self(1000150000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR: Self = Self(1000150002);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR: Self = Self(1000150003);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR: Self = Self(1000150004);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR: Self = Self(1000150005);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_GEOMETRY_KHR: Self = Self(1000150006);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_VERSION_INFO_KHR: Self = Self(1000150009);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const COPY_ACCELERATION_STRUCTURE_INFO_KHR: Self = Self(1000150010);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR: Self = Self(1000150011);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR: Self = Self(1000150012);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR: Self = Self(1000150013);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR: Self = Self(1000150014);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_CREATE_INFO_KHR: Self = Self(1000150017);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR: Self = Self(1000150020);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR: Self = Self(1000347000);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR: Self = Self(1000347001);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_PIPELINE_CREATE_INFO_KHR: Self = Self(1000150015);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR: Self = Self(1000150016);
    /// Added by extension VK_KHR_ray_tracing_pipeline.
    pub const RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR: Self = Self(1000150018);
    /// Added by extension VK_KHR_ray_query.
    pub const PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR: Self = Self(1000348013);
    /// Added by extension VK_NV_framebuffer_mixed_samples.
    pub const PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: Self = Self(1000152000);
    /// Added by extension VK_NV_shader_sm_builtins.
    pub const PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV: Self = Self(1000154000);
    /// Added by extension VK_NV_shader_sm_builtins.
    pub const PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV: Self = Self(1000154001);
    pub const SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR: Self = Self::SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
    pub const SAMPLER_YCBCR_CONVERSION_INFO_KHR: Self = Self::SAMPLER_YCBCR_CONVERSION_INFO;
    pub const BIND_IMAGE_PLANE_MEMORY_INFO_KHR: Self = Self::BIND_IMAGE_PLANE_MEMORY_INFO;
    pub const IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR: Self = Self::IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
    pub const PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
    pub const SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR: Self =
        Self::SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
    pub const BIND_BUFFER_MEMORY_INFO_KHR: Self = Self::BIND_BUFFER_MEMORY_INFO;
    pub const BIND_IMAGE_MEMORY_INFO_KHR: Self = Self::BIND_IMAGE_MEMORY_INFO;
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT: Self = Self(1000158000);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT: Self = Self(1000158002);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT: Self = Self(1000158003);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT: Self = Self(1000158004);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT: Self = Self(1000158005);
    /// Added by extension VK_EXT_image_drm_format_modifier.
    pub const DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT: Self = Self(1000158006);
    /// Added by extension VK_EXT_validation_cache.
    pub const VALIDATION_CACHE_CREATE_INFO_EXT: Self = Self(1000160000);
    /// Added by extension VK_EXT_validation_cache.
    pub const SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: Self = Self(1000160001);
    pub const DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT: Self =
        Self::DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
    pub const PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
    pub const PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT: Self =
        Self::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
    pub const DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT: Self =
        Self::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
    pub const DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT: Self =
        Self::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
    /// Added by extension VK_KHR_portability_subset.
    pub const PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR: Self = Self(1000163000);
    /// Added by extension VK_KHR_portability_subset.
    pub const PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR: Self = Self(1000163001);
    /// Added by extension VK_NV_shading_rate_image.
    pub const PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: Self = Self(1000164000);
    /// Added by extension VK_NV_shading_rate_image.
    pub const PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: Self = Self(1000164001);
    /// Added by extension VK_NV_shading_rate_image.
    pub const PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV: Self = Self(1000164002);
    /// Added by extension VK_NV_shading_rate_image.
    pub const PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: Self = Self(1000164005);
    /// Added by extension VK_NV_ray_tracing.
    pub const RAY_TRACING_PIPELINE_CREATE_INFO_NV: Self = Self(1000165000);
    /// Added by extension VK_NV_ray_tracing.
    pub const ACCELERATION_STRUCTURE_CREATE_INFO_NV: Self = Self(1000165001);
    /// Added by extension VK_NV_ray_tracing.
    pub const GEOMETRY_NV: Self = Self(1000165003);
    /// Added by extension VK_NV_ray_tracing.
    pub const GEOMETRY_TRIANGLES_NV: Self = Self(1000165004);
    /// Added by extension VK_NV_ray_tracing.
    pub const GEOMETRY_AABB_NV: Self = Self(1000165005);
    /// Added by extension VK_NV_ray_tracing.
    pub const BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV: Self = Self(1000165006);
    /// Added by extension VK_NV_ray_tracing.
    pub const WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: Self = Self(1000165007);
    /// Added by extension VK_NV_ray_tracing.
    pub const ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV: Self = Self(1000165008);
    /// Added by extension VK_NV_ray_tracing.
    pub const PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV: Self = Self(1000165009);
    /// Added by extension VK_NV_ray_tracing.
    pub const RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV: Self = Self(1000165011);
    /// Added by extension VK_NV_ray_tracing.
    pub const ACCELERATION_STRUCTURE_INFO_NV: Self = Self(1000165012);
    /// Added by extension VK_NV_representative_fragment_test.
    pub const PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: Self = Self(1000166000);
    /// Added by extension VK_NV_representative_fragment_test.
    pub const PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: Self = Self(1000166001);
    pub const PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
    pub const DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR: Self = Self::DESCRIPTOR_SET_LAYOUT_SUPPORT;
    /// Added by extension VK_EXT_filter_cubic.
    pub const PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: Self = Self(1000170000);
    /// Added by extension VK_EXT_filter_cubic.
    pub const FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: Self = Self(1000170001);
    pub const DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT: Self = Self::DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR;
    pub const PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
    pub const PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
    /// Added by extension VK_EXT_external_memory_host.
    pub const IMPORT_MEMORY_HOST_POINTER_INFO_EXT: Self = Self(1000178000);
    /// Added by extension VK_EXT_external_memory_host.
    pub const MEMORY_HOST_POINTER_PROPERTIES_EXT: Self = Self(1000178001);
    /// Added by extension VK_EXT_external_memory_host.
    pub const PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT: Self = Self(1000178002);
    pub const PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
    /// Added by extension VK_KHR_shader_clock.
    pub const PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: Self = Self(1000181000);
    /// Added by extension VK_AMD_pipeline_compiler_control.
    pub const PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD: Self = Self(1000183000);
    /// Added by extension VK_EXT_calibrated_timestamps.
    pub const CALIBRATED_TIMESTAMP_INFO_EXT: Self = Self(1000184000);
    /// Added by extension VK_AMD_shader_core_properties.
    pub const PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: Self = Self(1000185000);
    /// Added by extension VK_KHR_global_priority.
    pub const DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR: Self = Self(1000174000);
    /// Added by extension VK_KHR_global_priority.
    pub const PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: Self = Self(1000388000);
    /// Added by extension VK_KHR_global_priority.
    pub const QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR: Self = Self(1000388001);
    /// Added by extension VK_AMD_memory_overallocation_behavior.
    pub const DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: Self = Self(1000189000);
    /// Added by extension VK_EXT_vertex_attribute_divisor.
    pub const PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: Self = Self(1000190000);
    /// Added by extension VK_EXT_vertex_attribute_divisor.
    pub const PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: Self = Self(1000190001);
    /// Added by extension VK_EXT_vertex_attribute_divisor.
    pub const PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: Self = Self(1000190002);
    pub const PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT: Self = Self::PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
    pub const PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_DRIVER_PROPERTIES;
    pub const PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
    pub const PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR: Self =
        Self::PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
    pub const SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR: Self = Self::SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
    /// Added by extension VK_NV_compute_shader_derivatives.
    pub const PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV: Self = Self(1000201000);
    /// Added by extension VK_NV_mesh_shader.
    pub const PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: Self = Self(1000202000);
    /// Added by extension VK_NV_mesh_shader.
    pub const PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV: Self = Self(1000202001);
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV: Self =
        Self::PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
    /// Added by extension VK_NV_shader_image_footprint.
    pub const PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: Self = Self(1000204000);
    /// Added by extension VK_NV_scissor_exclusive.
    pub const PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV: Self = Self(1000205000);
    /// Added by extension VK_NV_scissor_exclusive.
    pub const PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: Self = Self(1000205002);
    /// Added by extension VK_NV_device_diagnostic_checkpoints.
    pub const CHECKPOINT_DATA_NV: Self = Self(1000206000);
    /// Added by extension VK_NV_device_diagnostic_checkpoints.
    pub const QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: Self = Self(1000206001);
    pub const PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
    pub const PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR: Self =
        Self::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
    pub const SEMAPHORE_TYPE_CREATE_INFO_KHR: Self = Self::SEMAPHORE_TYPE_CREATE_INFO;
    pub const TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR: Self = Self::TIMELINE_SEMAPHORE_SUBMIT_INFO;
    pub const SEMAPHORE_WAIT_INFO_KHR: Self = Self::SEMAPHORE_WAIT_INFO;
    pub const SEMAPHORE_SIGNAL_INFO_KHR: Self = Self::SEMAPHORE_SIGNAL_INFO;
    /// Added by extension VK_INTEL_shader_integer_functions2.
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL: Self = Self(1000209000);
    /// Added by extension VK_INTEL_performance_query.
    pub const QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL: Self = Self(1000210000);
    pub const QUERY_POOL_CREATE_INFO_INTEL: Self = Self::QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL;
    /// Added by extension VK_INTEL_performance_query.
    pub const INITIALIZE_PERFORMANCE_API_INFO_INTEL: Self = Self(1000210001);
    /// Added by extension VK_INTEL_performance_query.
    pub const PERFORMANCE_MARKER_INFO_INTEL: Self = Self(1000210002);
    /// Added by extension VK_INTEL_performance_query.
    pub const PERFORMANCE_STREAM_MARKER_INFO_INTEL: Self = Self(1000210003);
    /// Added by extension VK_INTEL_performance_query.
    pub const PERFORMANCE_OVERRIDE_INFO_INTEL: Self = Self(1000210004);
    /// Added by extension VK_INTEL_performance_query.
    pub const PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL: Self = Self(1000210005);
    pub const PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
    /// Added by extension VK_EXT_pci_bus_info.
    pub const PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: Self = Self(1000212000);
    /// Added by extension VK_AMD_display_native_hdr.
    pub const DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD: Self = Self(1000213000);
    /// Added by extension VK_AMD_display_native_hdr.
    pub const SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD: Self = Self(1000213001);
    /// Added by extension VK_FUCHSIA_imagepipe_surface.
    pub const IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA: Self = Self(1000214000);
    pub const PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
    /// Added by extension VK_EXT_metal_surface.
    pub const METAL_SURFACE_CREATE_INFO_EXT: Self = Self(1000217000);
    /// Added by extension VK_EXT_fragment_density_map.
    pub const PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: Self = Self(1000218000);
    /// Added by extension VK_EXT_fragment_density_map.
    pub const PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT: Self = Self(1000218001);
    /// Added by extension VK_EXT_fragment_density_map.
    pub const RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: Self = Self(1000218002);
    pub const PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
    pub const PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT: Self =
        Self::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
    pub const PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT: Self =
        Self::PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
    pub const PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: Self = Self(1000226000);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR: Self = Self(1000226001);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR: Self = Self(1000226002);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: Self = Self(1000226003);
    /// Added by extension VK_KHR_fragment_shading_rate.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR: Self = Self(1000226004);
    /// Added by extension VK_AMD_shader_core_properties2.
    pub const PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD: Self = Self(1000227000);
    /// Added by extension VK_AMD_device_coherent_memory.
    pub const PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD: Self = Self(1000229000);
    /// Added by extension VK_EXT_shader_image_atomic_int64.
    pub const PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT: Self = Self(1000234000);
    /// Added by extension VK_EXT_memory_budget.
    pub const PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT: Self = Self(1000237000);
    /// Added by extension VK_EXT_memory_priority.
    pub const PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT: Self = Self(1000238000);
    /// Added by extension VK_EXT_memory_priority.
    pub const MEMORY_PRIORITY_ALLOCATE_INFO_EXT: Self = Self(1000238001);
    /// Added by extension VK_KHR_surface_protected_capabilities.
    pub const SURFACE_PROTECTED_CAPABILITIES_KHR: Self = Self(1000239000);
    /// Added by extension VK_NV_dedicated_allocation_image_aliasing.
    pub const PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV: Self = Self(1000240000);
    pub const PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
    pub const ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR: Self = Self::ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
    pub const ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR: Self = Self::ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
    /// Added by extension VK_EXT_buffer_device_address.
    pub const PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT: Self = Self(1000244000);
    pub const PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
    pub const BUFFER_DEVICE_ADDRESS_INFO_EXT: Self = Self::BUFFER_DEVICE_ADDRESS_INFO;
    /// Added by extension VK_EXT_buffer_device_address.
    pub const BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: Self = Self(1000244002);
    pub const PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT: Self = Self::PHYSICAL_DEVICE_TOOL_PROPERTIES;
    pub const IMAGE_STENCIL_USAGE_CREATE_INFO_EXT: Self = Self::IMAGE_STENCIL_USAGE_CREATE_INFO;
    /// Added by extension VK_EXT_validation_features.
    pub const VALIDATION_FEATURES_EXT: Self = Self(1000247000);
    /// Added by extension VK_KHR_present_wait.
    pub const PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR: Self = Self(1000248000);
    /// Added by extension VK_NV_cooperative_matrix.
    pub const PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV: Self = Self(1000249000);
    /// Added by extension VK_NV_cooperative_matrix.
    pub const COOPERATIVE_MATRIX_PROPERTIES_NV: Self = Self(1000249001);
    /// Added by extension VK_NV_cooperative_matrix.
    pub const PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV: Self = Self(1000249002);
    /// Added by extension VK_NV_coverage_reduction_mode.
    pub const PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV: Self = Self(1000250000);
    /// Added by extension VK_NV_coverage_reduction_mode.
    pub const PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV: Self = Self(1000250001);
    /// Added by extension VK_NV_coverage_reduction_mode.
    pub const FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV: Self = Self(1000250002);
    /// Added by extension VK_EXT_fragment_shader_interlock.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: Self = Self(1000251000);
    /// Added by extension VK_EXT_ycbcr_image_arrays.
    pub const PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: Self = Self(1000252000);
    pub const PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
    /// Added by extension VK_EXT_provoking_vertex.
    pub const PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: Self = Self(1000254000);
    /// Added by extension VK_EXT_provoking_vertex.
    pub const PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT: Self = Self(1000254001);
    /// Added by extension VK_EXT_provoking_vertex.
    pub const PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT: Self = Self(1000254002);
    /// Added by extension VK_EXT_full_screen_exclusive.
    pub const SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT: Self = Self(1000255000);
    /// Added by extension VK_EXT_full_screen_exclusive.
    pub const SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT: Self = Self(1000255002);
    /// Added by extension VK_EXT_full_screen_exclusive.
    pub const SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT: Self = Self(1000255001);
    /// Added by extension VK_EXT_headless_surface.
    pub const HEADLESS_SURFACE_CREATE_INFO_EXT: Self = Self(1000256000);
    pub const PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
    pub const BUFFER_DEVICE_ADDRESS_INFO_KHR: Self = Self::BUFFER_DEVICE_ADDRESS_INFO;
    pub const BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR: Self = Self::BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
    pub const MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR: Self = Self::MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
    pub const DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR: Self = Self::DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;
    /// Added by extension VK_EXT_line_rasterization.
    pub const PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: Self = Self(1000259000);
    /// Added by extension VK_EXT_line_rasterization.
    pub const PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: Self = Self(1000259001);
    /// Added by extension VK_EXT_line_rasterization.
    pub const PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: Self = Self(1000259002);
    /// Added by extension VK_EXT_shader_atomic_float.
    pub const PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: Self = Self(1000260000);
    pub const PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT: Self = Self::PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
    /// Added by extension VK_EXT_index_type_uint8.
    pub const PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: Self = Self(1000265000);
    /// Not promoted to 1.3
    /// Added by extension VK_EXT_extended_dynamic_state.
    pub const PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: Self = Self(1000267000);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: Self = Self(1000269000);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const PIPELINE_INFO_KHR: Self = Self(1000269001);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const PIPELINE_EXECUTABLE_PROPERTIES_KHR: Self = Self(1000269002);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const PIPELINE_EXECUTABLE_INFO_KHR: Self = Self(1000269003);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const PIPELINE_EXECUTABLE_STATISTIC_KHR: Self = Self(1000269004);
    /// Added by extension VK_KHR_pipeline_executable_properties.
    pub const PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR: Self = Self(1000269005);
    /// Added by extension VK_EXT_shader_atomic_float2.
    pub const PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT: Self = Self(1000273000);
    pub const PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
    /// Added by extension VK_NV_device_generated_commands.
    pub const PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV: Self = Self(1000277000);
    /// Added by extension VK_NV_device_generated_commands.
    pub const GRAPHICS_SHADER_GROUP_CREATE_INFO_NV: Self = Self(1000277001);
    /// Added by extension VK_NV_device_generated_commands.
    pub const GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV: Self = Self(1000277002);
    /// Added by extension VK_NV_device_generated_commands.
    pub const INDIRECT_COMMANDS_LAYOUT_TOKEN_NV: Self = Self(1000277003);
    /// Added by extension VK_NV_device_generated_commands.
    pub const INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV: Self = Self(1000277004);
    /// Added by extension VK_NV_device_generated_commands.
    pub const GENERATED_COMMANDS_INFO_NV: Self = Self(1000277005);
    /// Added by extension VK_NV_device_generated_commands.
    pub const GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV: Self = Self(1000277006);
    /// Added by extension VK_NV_device_generated_commands.
    pub const PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV: Self = Self(1000277007);
    /// Added by extension VK_NV_inherited_viewport_scissor.
    pub const PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV: Self = Self(1000278000);
    /// Added by extension VK_NV_inherited_viewport_scissor.
    pub const COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV: Self = Self(1000278001);
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
    /// Not promoted to 1.3
    /// Added by extension VK_EXT_texel_buffer_alignment.
    pub const PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: Self = Self(1000281000);
    pub const PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT: Self =
        Self::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
    /// Added by extension VK_QCOM_render_pass_transform.
    pub const COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM: Self = Self(1000282000);
    /// Added by extension VK_QCOM_render_pass_transform.
    pub const RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM: Self = Self(1000282001);
    /// Added by extension VK_EXT_device_memory_report.
    pub const PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT: Self = Self(1000284000);
    /// Added by extension VK_EXT_device_memory_report.
    pub const DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT: Self = Self(1000284001);
    /// Added by extension VK_EXT_device_memory_report.
    pub const DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT: Self = Self(1000284002);
    /// Added by extension VK_EXT_robustness2.
    pub const PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT: Self = Self(1000286000);
    /// Added by extension VK_EXT_robustness2.
    pub const PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT: Self = Self(1000286001);
    /// Added by extension VK_EXT_custom_border_color.
    pub const SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: Self = Self(1000287000);
    /// Added by extension VK_EXT_custom_border_color.
    pub const PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT: Self = Self(1000287001);
    /// Added by extension VK_EXT_custom_border_color.
    pub const PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: Self = Self(1000287002);
    /// Added by extension VK_KHR_pipeline_library.
    pub const PIPELINE_LIBRARY_CREATE_INFO_KHR: Self = Self(1000290000);
    /// Added by extension VK_KHR_present_id.
    pub const PRESENT_ID_KHR: Self = Self(1000294000);
    /// Added by extension VK_KHR_present_id.
    pub const PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR: Self = Self(1000294001);
    pub const PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT: Self = Self::PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
    pub const DEVICE_PRIVATE_DATA_CREATE_INFO_EXT: Self = Self::DEVICE_PRIVATE_DATA_CREATE_INFO;
    pub const PRIVATE_DATA_SLOT_CREATE_INFO_EXT: Self = Self::PRIVATE_DATA_SLOT_CREATE_INFO;
    pub const PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
    /// Added by extension VK_NV_device_diagnostics_config.
    pub const PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV: Self = Self(1000300000);
    /// Added by extension VK_NV_device_diagnostics_config.
    pub const DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV: Self = Self(1000300001);
    /// Added by extension VK_EXT_metal_objects.
    pub const EXPORT_METAL_OBJECT_CREATE_INFO_EXT: Self = Self(1000311000);
    /// Added by extension VK_EXT_metal_objects.
    pub const EXPORT_METAL_OBJECTS_INFO_EXT: Self = Self(1000311001);
    /// Added by extension VK_EXT_metal_objects.
    pub const EXPORT_METAL_DEVICE_INFO_EXT: Self = Self(1000311002);
    /// Added by extension VK_EXT_metal_objects.
    pub const EXPORT_METAL_COMMAND_QUEUE_INFO_EXT: Self = Self(1000311003);
    /// Added by extension VK_EXT_metal_objects.
    pub const EXPORT_METAL_BUFFER_INFO_EXT: Self = Self(1000311004);
    /// Added by extension VK_EXT_metal_objects.
    pub const IMPORT_METAL_BUFFER_INFO_EXT: Self = Self(1000311005);
    /// Added by extension VK_EXT_metal_objects.
    pub const EXPORT_METAL_TEXTURE_INFO_EXT: Self = Self(1000311006);
    /// Added by extension VK_EXT_metal_objects.
    pub const IMPORT_METAL_TEXTURE_INFO_EXT: Self = Self(1000311007);
    /// Added by extension VK_EXT_metal_objects.
    pub const EXPORT_METAL_IO_SURFACE_INFO_EXT: Self = Self(1000311008);
    /// Added by extension VK_EXT_metal_objects.
    pub const IMPORT_METAL_IO_SURFACE_INFO_EXT: Self = Self(1000311009);
    /// Added by extension VK_EXT_metal_objects.
    pub const EXPORT_METAL_SHARED_EVENT_INFO_EXT: Self = Self(1000311010);
    /// Added by extension VK_EXT_metal_objects.
    pub const IMPORT_METAL_SHARED_EVENT_INFO_EXT: Self = Self(1000311011);
    pub const MEMORY_BARRIER_2_KHR: Self = Self::MEMORY_BARRIER_2;
    pub const BUFFER_MEMORY_BARRIER_2_KHR: Self = Self::BUFFER_MEMORY_BARRIER_2;
    pub const IMAGE_MEMORY_BARRIER_2_KHR: Self = Self::IMAGE_MEMORY_BARRIER_2;
    pub const DEPENDENCY_INFO_KHR: Self = Self::DEPENDENCY_INFO;
    pub const SUBMIT_INFO_2_KHR: Self = Self::SUBMIT_INFO_2;
    pub const SEMAPHORE_SUBMIT_INFO_KHR: Self = Self::SEMAPHORE_SUBMIT_INFO;
    pub const COMMAND_BUFFER_SUBMIT_INFO_KHR: Self = Self::COMMAND_BUFFER_SUBMIT_INFO;
    pub const PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
    /// Added by extension VK_KHR_synchronization2.
    pub const QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV: Self = Self(1000314008);
    /// Added by extension VK_KHR_synchronization2.
    pub const CHECKPOINT_DATA_2_NV: Self = Self(1000314009);
    /// Added by extension VK_EXT_graphics_pipeline_library.
    pub const PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT: Self = Self(1000320000);
    /// Added by extension VK_EXT_graphics_pipeline_library.
    pub const PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT: Self = Self(1000320001);
    /// Added by extension VK_EXT_graphics_pipeline_library.
    pub const GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT: Self = Self(1000320002);
    /// Added by extension VK_AMD_shader_early_and_late_fragment_tests.
    pub const PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD: Self = Self(1000321000);
    /// Added by extension VK_KHR_fragment_shader_barycentric.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR: Self = Self(1000203000);
    /// Added by extension VK_KHR_fragment_shader_barycentric.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR: Self = Self(1000322000);
    /// Added by extension VK_KHR_shader_subgroup_uniform_control_flow.
    pub const PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR: Self = Self(1000323000);
    pub const PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
    /// Added by extension VK_NV_fragment_shading_rate_enums.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV: Self = Self(1000326000);
    /// Added by extension VK_NV_fragment_shading_rate_enums.
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV: Self = Self(1000326001);
    /// Added by extension VK_NV_fragment_shading_rate_enums.
    pub const PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV: Self = Self(1000326002);
    /// Added by extension VK_NV_ray_tracing_motion_blur.
    pub const ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV: Self = Self(1000327000);
    /// Added by extension VK_NV_ray_tracing_motion_blur.
    pub const PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV: Self = Self(1000327001);
    /// Added by extension VK_NV_ray_tracing_motion_blur.
    pub const ACCELERATION_STRUCTURE_MOTION_INFO_NV: Self = Self(1000327002);
    /// Added by extension VK_EXT_ycbcr_2plane_444_formats.
    pub const PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT: Self = Self(1000330000);
    /// Added by extension VK_EXT_fragment_density_map2.
    pub const PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT: Self = Self(1000332000);
    /// Added by extension VK_EXT_fragment_density_map2.
    pub const PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT: Self = Self(1000332001);
    /// Added by extension VK_QCOM_rotated_copy_commands.
    pub const COPY_COMMAND_TRANSFORM_INFO_QCOM: Self = Self(1000333000);
    pub const PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT: Self = Self::PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
    /// Added by extension VK_KHR_workgroup_memory_explicit_layout.
    pub const PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR: Self = Self(1000336000);
    pub const COPY_BUFFER_INFO_2_KHR: Self = Self::COPY_BUFFER_INFO_2;
    pub const COPY_IMAGE_INFO_2_KHR: Self = Self::COPY_IMAGE_INFO_2;
    pub const COPY_BUFFER_TO_IMAGE_INFO_2_KHR: Self = Self::COPY_BUFFER_TO_IMAGE_INFO_2;
    pub const COPY_IMAGE_TO_BUFFER_INFO_2_KHR: Self = Self::COPY_IMAGE_TO_BUFFER_INFO_2;
    pub const BLIT_IMAGE_INFO_2_KHR: Self = Self::BLIT_IMAGE_INFO_2;
    pub const RESOLVE_IMAGE_INFO_2_KHR: Self = Self::RESOLVE_IMAGE_INFO_2;
    pub const BUFFER_COPY_2_KHR: Self = Self::BUFFER_COPY_2;
    pub const IMAGE_COPY_2_KHR: Self = Self::IMAGE_COPY_2;
    pub const IMAGE_BLIT_2_KHR: Self = Self::IMAGE_BLIT_2;
    pub const BUFFER_IMAGE_COPY_2_KHR: Self = Self::BUFFER_IMAGE_COPY_2;
    pub const IMAGE_RESOLVE_2_KHR: Self = Self::IMAGE_RESOLVE_2;
    /// Added by extension VK_EXT_image_compression_control.
    pub const PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT: Self = Self(1000338000);
    /// Added by extension VK_EXT_image_compression_control.
    pub const IMAGE_COMPRESSION_CONTROL_EXT: Self = Self(1000338001);
    /// Added by extension VK_EXT_image_compression_control.
    pub const SUBRESOURCE_LAYOUT_2_EXT: Self = Self(1000338002);
    /// Added by extension VK_EXT_image_compression_control.
    pub const IMAGE_SUBRESOURCE_2_EXT: Self = Self(1000338003);
    /// Added by extension VK_EXT_image_compression_control.
    pub const IMAGE_COMPRESSION_PROPERTIES_EXT: Self = Self(1000338004);
    /// Added by extension VK_EXT_4444_formats.
    pub const PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: Self = Self(1000340000);
    /// Added by extension VK_ARM_rasterization_order_attachment_access.
    pub const PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM: Self = Self(1000342000);
    /// Added by extension VK_EXT_rgba10x6_formats.
    pub const PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT: Self = Self(1000344000);
    /// Added by extension VK_EXT_directfb_surface.
    pub const DIRECTFB_SURFACE_CREATE_INFO_EXT: Self = Self(1000346000);
    /// Added by extension VK_VALVE_mutable_descriptor_type.
    pub const PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE: Self = Self(1000351000);
    /// Added by extension VK_VALVE_mutable_descriptor_type.
    pub const MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE: Self = Self(1000351002);
    /// Added by extension VK_EXT_vertex_input_dynamic_state.
    pub const PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT: Self = Self(1000352000);
    /// Added by extension VK_EXT_vertex_input_dynamic_state.
    pub const VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT: Self = Self(1000352001);
    /// Added by extension VK_EXT_vertex_input_dynamic_state.
    pub const VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT: Self = Self(1000352002);
    /// Added by extension VK_EXT_physical_device_drm.
    pub const PHYSICAL_DEVICE_DRM_PROPERTIES_EXT: Self = Self(1000353000);
    /// Added by extension VK_EXT_depth_clip_control.
    pub const PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT: Self = Self(1000355000);
    /// Added by extension VK_EXT_depth_clip_control.
    pub const PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT: Self = Self(1000355001);
    /// Added by extension VK_EXT_primitive_topology_list_restart.
    pub const PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT: Self = Self(1000356000);
    pub const FORMAT_PROPERTIES_3_KHR: Self = Self::FORMAT_PROPERTIES_3;
    /// Added by extension VK_FUCHSIA_external_memory.
    pub const IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA: Self = Self(1000364000);
    /// Added by extension VK_FUCHSIA_external_memory.
    pub const MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA: Self = Self(1000364001);
    /// Added by extension VK_FUCHSIA_external_memory.
    pub const MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA: Self = Self(1000364002);
    /// Added by extension VK_FUCHSIA_external_semaphore.
    pub const IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA: Self = Self(1000365000);
    /// Added by extension VK_FUCHSIA_external_semaphore.
    pub const SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA: Self = Self(1000365001);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_COLLECTION_CREATE_INFO_FUCHSIA: Self = Self(1000366000);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA: Self = Self(1000366001);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA: Self = Self(1000366002);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_COLLECTION_PROPERTIES_FUCHSIA: Self = Self(1000366003);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_CONSTRAINTS_INFO_FUCHSIA: Self = Self(1000366004);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA: Self = Self(1000366005);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const IMAGE_CONSTRAINTS_INFO_FUCHSIA: Self = Self(1000366006);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA: Self = Self(1000366007);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const SYSMEM_COLOR_SPACE_FUCHSIA: Self = Self(1000366008);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA: Self = Self(1000366009);
    /// Added by extension VK_HUAWEI_subpass_shading.
    pub const SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI: Self = Self(1000369000);
    /// Added by extension VK_HUAWEI_subpass_shading.
    pub const PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI: Self = Self(1000369001);
    /// Added by extension VK_HUAWEI_subpass_shading.
    pub const PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI: Self = Self(1000369002);
    /// Added by extension VK_HUAWEI_invocation_mask.
    pub const PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI: Self = Self(1000370000);
    /// Added by extension VK_NV_external_memory_rdma.
    pub const MEMORY_GET_REMOTE_ADDRESS_INFO_NV: Self = Self(1000371000);
    /// Added by extension VK_NV_external_memory_rdma.
    pub const PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV: Self = Self(1000371001);
    /// Added by extension VK_EXT_pipeline_properties.
    pub const PIPELINE_PROPERTIES_IDENTIFIER_EXT: Self = Self(1000372000);
    /// Added by extension VK_EXT_pipeline_properties.
    pub const PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT: Self = Self(1000372001);
    pub const PIPELINE_INFO_EXT: Self = Self::PIPELINE_INFO_KHR;
    /// Not promoted to 1.3
    /// Added by extension VK_EXT_extended_dynamic_state2.
    pub const PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT: Self = Self(1000377000);
    /// Added by extension VK_EXT_color_write_enable.
    pub const PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT: Self = Self(1000381000);
    /// Added by extension VK_EXT_color_write_enable.
    pub const PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: Self = Self(1000381001);
    /// Added by extension VK_EXT_primitives_generated_query.
    pub const PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT: Self = Self(1000382000);
    /// Added by extension VK_KHR_ray_tracing_maintenance1.
    pub const PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR: Self = Self(1000386000);
    pub const PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR;
    pub const QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT: Self = Self::QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR;
    /// Added by extension VK_EXT_image_view_min_lod.
    pub const PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT: Self = Self(1000391000);
    /// Added by extension VK_EXT_image_view_min_lod.
    pub const IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT: Self = Self(1000391001);
    /// Added by extension VK_EXT_multi_draw.
    pub const PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT: Self = Self(1000392000);
    /// Added by extension VK_EXT_multi_draw.
    pub const PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT: Self = Self(1000392001);
    /// Added by extension VK_EXT_image_2d_view_of_3d.
    pub const PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT: Self = Self(1000393000);
    /// Added by extension VK_EXT_border_color_swizzle.
    pub const PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT: Self = Self(1000411000);
    /// Added by extension VK_EXT_border_color_swizzle.
    pub const SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT: Self = Self(1000411001);
    /// Added by extension VK_EXT_pageable_device_local_memory.
    pub const PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT: Self = Self(1000412000);
    pub const PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
    pub const PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
    pub const DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR: Self = Self::DEVICE_BUFFER_MEMORY_REQUIREMENTS;
    pub const DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR: Self = Self::DEVICE_IMAGE_MEMORY_REQUIREMENTS;
    /// Added by extension VK_VALVE_descriptor_set_host_mapping.
    pub const PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE: Self = Self(1000420000);
    /// Added by extension VK_VALVE_descriptor_set_host_mapping.
    pub const DESCRIPTOR_SET_BINDING_REFERENCE_VALVE: Self = Self(1000420001);
    /// Added by extension VK_VALVE_descriptor_set_host_mapping.
    pub const DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE: Self = Self(1000420002);
    /// Added by extension VK_EXT_non_seamless_cube_map.
    pub const PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT: Self = Self(1000422000);
    /// Added by extension VK_QCOM_fragment_density_map_offset.
    pub const PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM: Self = Self(1000425000);
    /// Added by extension VK_QCOM_fragment_density_map_offset.
    pub const PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM: Self = Self(1000425001);
    /// Added by extension VK_QCOM_fragment_density_map_offset.
    pub const SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM: Self = Self(1000425002);
    /// Added by extension VK_NV_linear_color_attachment.
    pub const PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV: Self = Self(1000430000);
    /// Added by extension VK_EXT_image_compression_control_swapchain.
    pub const PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT: Self = Self(1000437000);
    /// Added by extension VK_EXT_subpass_merge_feedback.
    pub const PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT: Self = Self(1000458000);
    /// Added by extension VK_EXT_subpass_merge_feedback.
    pub const RENDER_PASS_CREATION_CONTROL_EXT: Self = Self(1000458001);
    /// Added by extension VK_EXT_subpass_merge_feedback.
    pub const RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT: Self = Self(1000458002);
    /// Added by extension VK_EXT_subpass_merge_feedback.
    pub const RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT: Self = Self(1000458003);
}
impl fmt::Display for StructureType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"APPLICATION_INFO"),
            1 => Some(&"INSTANCE_CREATE_INFO"),
            2 => Some(&"DEVICE_QUEUE_CREATE_INFO"),
            3 => Some(&"DEVICE_CREATE_INFO"),
            4 => Some(&"SUBMIT_INFO"),
            5 => Some(&"MEMORY_ALLOCATE_INFO"),
            6 => Some(&"MAPPED_MEMORY_RANGE"),
            7 => Some(&"BIND_SPARSE_INFO"),
            8 => Some(&"FENCE_CREATE_INFO"),
            9 => Some(&"SEMAPHORE_CREATE_INFO"),
            10 => Some(&"EVENT_CREATE_INFO"),
            11 => Some(&"QUERY_POOL_CREATE_INFO"),
            12 => Some(&"BUFFER_CREATE_INFO"),
            13 => Some(&"BUFFER_VIEW_CREATE_INFO"),
            14 => Some(&"IMAGE_CREATE_INFO"),
            15 => Some(&"IMAGE_VIEW_CREATE_INFO"),
            16 => Some(&"SHADER_MODULE_CREATE_INFO"),
            17 => Some(&"PIPELINE_CACHE_CREATE_INFO"),
            18 => Some(&"PIPELINE_SHADER_STAGE_CREATE_INFO"),
            19 => Some(&"PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"),
            20 => Some(&"PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"),
            21 => Some(&"PIPELINE_TESSELLATION_STATE_CREATE_INFO"),
            22 => Some(&"PIPELINE_VIEWPORT_STATE_CREATE_INFO"),
            23 => Some(&"PIPELINE_RASTERIZATION_STATE_CREATE_INFO"),
            24 => Some(&"PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"),
            25 => Some(&"PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"),
            26 => Some(&"PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"),
            27 => Some(&"PIPELINE_DYNAMIC_STATE_CREATE_INFO"),
            28 => Some(&"GRAPHICS_PIPELINE_CREATE_INFO"),
            29 => Some(&"COMPUTE_PIPELINE_CREATE_INFO"),
            30 => Some(&"PIPELINE_LAYOUT_CREATE_INFO"),
            31 => Some(&"SAMPLER_CREATE_INFO"),
            32 => Some(&"DESCRIPTOR_SET_LAYOUT_CREATE_INFO"),
            33 => Some(&"DESCRIPTOR_POOL_CREATE_INFO"),
            34 => Some(&"DESCRIPTOR_SET_ALLOCATE_INFO"),
            35 => Some(&"WRITE_DESCRIPTOR_SET"),
            36 => Some(&"COPY_DESCRIPTOR_SET"),
            37 => Some(&"FRAMEBUFFER_CREATE_INFO"),
            38 => Some(&"RENDER_PASS_CREATE_INFO"),
            39 => Some(&"COMMAND_POOL_CREATE_INFO"),
            40 => Some(&"COMMAND_BUFFER_ALLOCATE_INFO"),
            41 => Some(&"COMMAND_BUFFER_INHERITANCE_INFO"),
            42 => Some(&"COMMAND_BUFFER_BEGIN_INFO"),
            43 => Some(&"RENDER_PASS_BEGIN_INFO"),
            44 => Some(&"BUFFER_MEMORY_BARRIER"),
            45 => Some(&"IMAGE_MEMORY_BARRIER"),
            46 => Some(&"MEMORY_BARRIER"),
            47 => Some(&"LOADER_INSTANCE_CREATE_INFO"),
            48 => Some(&"LOADER_DEVICE_CREATE_INFO"),
            1000094000 => Some(&"PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"),
            1000157000 => Some(&"BIND_BUFFER_MEMORY_INFO"),
            1000157001 => Some(&"BIND_IMAGE_MEMORY_INFO"),
            1000083000 => Some(&"PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"),
            1000127000 => Some(&"MEMORY_DEDICATED_REQUIREMENTS"),
            1000127001 => Some(&"MEMORY_DEDICATED_ALLOCATE_INFO"),
            1000060000 => Some(&"MEMORY_ALLOCATE_FLAGS_INFO"),
            1000060003 => Some(&"DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"),
            1000060004 => Some(&"DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"),
            1000060005 => Some(&"DEVICE_GROUP_SUBMIT_INFO"),
            1000060006 => Some(&"DEVICE_GROUP_BIND_SPARSE_INFO"),
            1000060013 => Some(&"BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"),
            1000060014 => Some(&"BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"),
            1000070000 => Some(&"PHYSICAL_DEVICE_GROUP_PROPERTIES"),
            1000070001 => Some(&"DEVICE_GROUP_DEVICE_CREATE_INFO"),
            1000146000 => Some(&"BUFFER_MEMORY_REQUIREMENTS_INFO_2"),
            1000146001 => Some(&"IMAGE_MEMORY_REQUIREMENTS_INFO_2"),
            1000146002 => Some(&"IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"),
            1000146003 => Some(&"MEMORY_REQUIREMENTS_2"),
            1000146004 => Some(&"SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"),
            1000059000 => Some(&"PHYSICAL_DEVICE_FEATURES_2"),
            1000059001 => Some(&"PHYSICAL_DEVICE_PROPERTIES_2"),
            1000059002 => Some(&"FORMAT_PROPERTIES_2"),
            1000059003 => Some(&"IMAGE_FORMAT_PROPERTIES_2"),
            1000059004 => Some(&"PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"),
            1000059005 => Some(&"QUEUE_FAMILY_PROPERTIES_2"),
            1000059006 => Some(&"PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"),
            1000059007 => Some(&"SPARSE_IMAGE_FORMAT_PROPERTIES_2"),
            1000059008 => Some(&"PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"),
            1000117000 => Some(&"PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"),
            1000117001 => Some(&"RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"),
            1000117002 => Some(&"IMAGE_VIEW_USAGE_CREATE_INFO"),
            1000117003 => Some(&"PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"),
            1000053000 => Some(&"RENDER_PASS_MULTIVIEW_CREATE_INFO"),
            1000053001 => Some(&"PHYSICAL_DEVICE_MULTIVIEW_FEATURES"),
            1000053002 => Some(&"PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"),
            1000120000 => Some(&"PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"),
            1000145000 => Some(&"PROTECTED_SUBMIT_INFO"),
            1000145001 => Some(&"PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"),
            1000145002 => Some(&"PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"),
            1000145003 => Some(&"DEVICE_QUEUE_INFO_2"),
            1000156000 => Some(&"SAMPLER_YCBCR_CONVERSION_CREATE_INFO"),
            1000156001 => Some(&"SAMPLER_YCBCR_CONVERSION_INFO"),
            1000156002 => Some(&"BIND_IMAGE_PLANE_MEMORY_INFO"),
            1000156003 => Some(&"IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"),
            1000156004 => Some(&"PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"),
            1000156005 => Some(&"SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"),
            1000085000 => Some(&"DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"),
            1000071000 => Some(&"PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"),
            1000071001 => Some(&"EXTERNAL_IMAGE_FORMAT_PROPERTIES"),
            1000071002 => Some(&"PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"),
            1000071003 => Some(&"EXTERNAL_BUFFER_PROPERTIES"),
            1000071004 => Some(&"PHYSICAL_DEVICE_ID_PROPERTIES"),
            1000072000 => Some(&"EXTERNAL_MEMORY_BUFFER_CREATE_INFO"),
            1000072001 => Some(&"EXTERNAL_MEMORY_IMAGE_CREATE_INFO"),
            1000072002 => Some(&"EXPORT_MEMORY_ALLOCATE_INFO"),
            1000112000 => Some(&"PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"),
            1000112001 => Some(&"EXTERNAL_FENCE_PROPERTIES"),
            1000113000 => Some(&"EXPORT_FENCE_CREATE_INFO"),
            1000077000 => Some(&"EXPORT_SEMAPHORE_CREATE_INFO"),
            1000076000 => Some(&"PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"),
            1000076001 => Some(&"EXTERNAL_SEMAPHORE_PROPERTIES"),
            1000168000 => Some(&"PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"),
            1000168001 => Some(&"DESCRIPTOR_SET_LAYOUT_SUPPORT"),
            1000063000 => Some(&"PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"),
            49 => Some(&"PHYSICAL_DEVICE_VULKAN_1_1_FEATURES"),
            50 => Some(&"PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES"),
            51 => Some(&"PHYSICAL_DEVICE_VULKAN_1_2_FEATURES"),
            52 => Some(&"PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES"),
            1000147000 => Some(&"IMAGE_FORMAT_LIST_CREATE_INFO"),
            1000109000 => Some(&"ATTACHMENT_DESCRIPTION_2"),
            1000109001 => Some(&"ATTACHMENT_REFERENCE_2"),
            1000109002 => Some(&"SUBPASS_DESCRIPTION_2"),
            1000109003 => Some(&"SUBPASS_DEPENDENCY_2"),
            1000109004 => Some(&"RENDER_PASS_CREATE_INFO_2"),
            1000109005 => Some(&"SUBPASS_BEGIN_INFO"),
            1000109006 => Some(&"SUBPASS_END_INFO"),
            1000177000 => Some(&"PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"),
            1000196000 => Some(&"PHYSICAL_DEVICE_DRIVER_PROPERTIES"),
            1000180000 => Some(&"PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"),
            1000082000 => Some(&"PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"),
            1000197000 => Some(&"PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"),
            1000161000 => Some(&"DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO"),
            1000161001 => Some(&"PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"),
            1000161002 => Some(&"PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"),
            1000161003 => Some(&"DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO"),
            1000161004 => Some(&"DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT"),
            1000199000 => Some(&"PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"),
            1000199001 => Some(&"SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE"),
            1000221000 => Some(&"PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"),
            1000246000 => Some(&"IMAGE_STENCIL_USAGE_CREATE_INFO"),
            1000130000 => Some(&"PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"),
            1000130001 => Some(&"SAMPLER_REDUCTION_MODE_CREATE_INFO"),
            1000211000 => Some(&"PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"),
            1000108000 => Some(&"PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"),
            1000108001 => Some(&"FRAMEBUFFER_ATTACHMENTS_CREATE_INFO"),
            1000108002 => Some(&"FRAMEBUFFER_ATTACHMENT_IMAGE_INFO"),
            1000108003 => Some(&"RENDER_PASS_ATTACHMENT_BEGIN_INFO"),
            1000253000 => Some(&"PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"),
            1000175000 => Some(&"PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"),
            1000241000 => Some(&"PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"),
            1000241001 => Some(&"ATTACHMENT_REFERENCE_STENCIL_LAYOUT"),
            1000241002 => Some(&"ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT"),
            1000261000 => Some(&"PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"),
            1000207000 => Some(&"PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"),
            1000207001 => Some(&"PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"),
            1000207002 => Some(&"SEMAPHORE_TYPE_CREATE_INFO"),
            1000207003 => Some(&"TIMELINE_SEMAPHORE_SUBMIT_INFO"),
            1000207004 => Some(&"SEMAPHORE_WAIT_INFO"),
            1000207005 => Some(&"SEMAPHORE_SIGNAL_INFO"),
            1000257000 => Some(&"PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"),
            1000244001 => Some(&"BUFFER_DEVICE_ADDRESS_INFO"),
            1000257002 => Some(&"BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO"),
            1000257003 => Some(&"MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO"),
            1000257004 => Some(&"DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO"),
            53 => Some(&"PHYSICAL_DEVICE_VULKAN_1_3_FEATURES"),
            54 => Some(&"PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES"),
            1000192000 => Some(&"PIPELINE_CREATION_FEEDBACK_CREATE_INFO"),
            1000215000 => Some(&"PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES"),
            1000245000 => Some(&"PHYSICAL_DEVICE_TOOL_PROPERTIES"),
            1000276000 => Some(&"PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES"),
            1000295000 => Some(&"PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES"),
            1000295001 => Some(&"DEVICE_PRIVATE_DATA_CREATE_INFO"),
            1000295002 => Some(&"PRIVATE_DATA_SLOT_CREATE_INFO"),
            1000297000 => Some(&"PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES"),
            1000314000 => Some(&"MEMORY_BARRIER_2"),
            1000314001 => Some(&"BUFFER_MEMORY_BARRIER_2"),
            1000314002 => Some(&"IMAGE_MEMORY_BARRIER_2"),
            1000314003 => Some(&"DEPENDENCY_INFO"),
            1000314004 => Some(&"SUBMIT_INFO_2"),
            1000314005 => Some(&"SEMAPHORE_SUBMIT_INFO"),
            1000314006 => Some(&"COMMAND_BUFFER_SUBMIT_INFO"),
            1000314007 => Some(&"PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES"),
            1000325000 => Some(&"PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES"),
            1000335000 => Some(&"PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES"),
            1000337000 => Some(&"COPY_BUFFER_INFO_2"),
            1000337001 => Some(&"COPY_IMAGE_INFO_2"),
            1000337002 => Some(&"COPY_BUFFER_TO_IMAGE_INFO_2"),
            1000337003 => Some(&"COPY_IMAGE_TO_BUFFER_INFO_2"),
            1000337004 => Some(&"BLIT_IMAGE_INFO_2"),
            1000337005 => Some(&"RESOLVE_IMAGE_INFO_2"),
            1000337006 => Some(&"BUFFER_COPY_2"),
            1000337007 => Some(&"IMAGE_COPY_2"),
            1000337008 => Some(&"IMAGE_BLIT_2"),
            1000337009 => Some(&"BUFFER_IMAGE_COPY_2"),
            1000337010 => Some(&"IMAGE_RESOLVE_2"),
            1000225000 => Some(&"PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES"),
            1000225001 => Some(&"PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO"),
            1000225002 => Some(&"PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES"),
            1000138000 => Some(&"PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES"),
            1000138001 => Some(&"PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES"),
            1000138002 => Some(&"WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK"),
            1000138003 => Some(&"DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO"),
            1000066000 => Some(&"PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES"),
            1000044000 => Some(&"RENDERING_INFO"),
            1000044001 => Some(&"RENDERING_ATTACHMENT_INFO"),
            1000044002 => Some(&"PIPELINE_RENDERING_CREATE_INFO"),
            1000044003 => Some(&"PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES"),
            1000044004 => Some(&"COMMAND_BUFFER_INHERITANCE_RENDERING_INFO"),
            1000280000 => Some(&"PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES"),
            1000280001 => Some(&"PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES"),
            1000281001 => Some(&"PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES"),
            1000360000 => Some(&"FORMAT_PROPERTIES_3"),
            1000413000 => Some(&"PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES"),
            1000413001 => Some(&"PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES"),
            1000413002 => Some(&"DEVICE_BUFFER_MEMORY_REQUIREMENTS"),
            1000413003 => Some(&"DEVICE_IMAGE_MEMORY_REQUIREMENTS"),
            1000001000 => Some(&"SWAPCHAIN_CREATE_INFO_KHR"),
            1000001001 => Some(&"PRESENT_INFO_KHR"),
            1000060007 => Some(&"DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"),
            1000060008 => Some(&"IMAGE_SWAPCHAIN_CREATE_INFO_KHR"),
            1000060009 => Some(&"BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"),
            1000060010 => Some(&"ACQUIRE_NEXT_IMAGE_INFO_KHR"),
            1000060011 => Some(&"DEVICE_GROUP_PRESENT_INFO_KHR"),
            1000060012 => Some(&"DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"),
            1000002000 => Some(&"DISPLAY_MODE_CREATE_INFO_KHR"),
            1000002001 => Some(&"DISPLAY_SURFACE_CREATE_INFO_KHR"),
            1000003000 => Some(&"DISPLAY_PRESENT_INFO_KHR"),
            1000004000 => Some(&"XLIB_SURFACE_CREATE_INFO_KHR"),
            1000005000 => Some(&"XCB_SURFACE_CREATE_INFO_KHR"),
            1000006000 => Some(&"WAYLAND_SURFACE_CREATE_INFO_KHR"),
            1000008000 => Some(&"ANDROID_SURFACE_CREATE_INFO_KHR"),
            1000009000 => Some(&"WIN32_SURFACE_CREATE_INFO_KHR"),
            1000011000 => Some(&"DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"),
            1000018000 => Some(&"PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"),
            1000022000 => Some(&"DEBUG_MARKER_OBJECT_NAME_INFO_EXT"),
            1000022001 => Some(&"DEBUG_MARKER_OBJECT_TAG_INFO_EXT"),
            1000022002 => Some(&"DEBUG_MARKER_MARKER_INFO_EXT"),
            1000026000 => Some(&"DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"),
            1000026001 => Some(&"DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"),
            1000026002 => Some(&"DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"),
            1000028000 => Some(&"PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT"),
            1000028001 => Some(&"PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT"),
            1000028002 => Some(&"PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT"),
            1000029000 => Some(&"CU_MODULE_CREATE_INFO_NVX"),
            1000029001 => Some(&"CU_FUNCTION_CREATE_INFO_NVX"),
            1000029002 => Some(&"CU_LAUNCH_INFO_NVX"),
            1000030000 => Some(&"IMAGE_VIEW_HANDLE_INFO_NVX"),
            1000030001 => Some(&"IMAGE_VIEW_ADDRESS_PROPERTIES_NVX"),
            1000041000 => Some(&"TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"),
            1000044006 => Some(&"RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"),
            1000044007 => Some(&"RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT"),
            1000044008 => Some(&"ATTACHMENT_SAMPLE_COUNT_INFO_AMD"),
            1000044009 => Some(&"MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX"),
            1000050000 => Some(&"PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV"),
            1000056000 => Some(&"EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"),
            1000056001 => Some(&"EXPORT_MEMORY_ALLOCATE_INFO_NV"),
            1000057000 => Some(&"IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
            1000057001 => Some(&"EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
            1000058000 => Some(&"WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"),
            1000061000 => Some(&"VALIDATION_FLAGS_EXT"),
            1000062000 => Some(&"VI_SURFACE_CREATE_INFO_NN"),
            1000067000 => Some(&"IMAGE_VIEW_ASTC_DECODE_MODE_EXT"),
            1000067001 => Some(&"PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT"),
            1000073000 => Some(&"IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
            1000073001 => Some(&"EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"),
            1000073002 => Some(&"MEMORY_WIN32_HANDLE_PROPERTIES_KHR"),
            1000073003 => Some(&"MEMORY_GET_WIN32_HANDLE_INFO_KHR"),
            1000074000 => Some(&"IMPORT_MEMORY_FD_INFO_KHR"),
            1000074001 => Some(&"MEMORY_FD_PROPERTIES_KHR"),
            1000074002 => Some(&"MEMORY_GET_FD_INFO_KHR"),
            1000075000 => Some(&"WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"),
            1000078000 => Some(&"IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"),
            1000078001 => Some(&"EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"),
            1000078002 => Some(&"D3D12_FENCE_SUBMIT_INFO_KHR"),
            1000078003 => Some(&"SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"),
            1000079000 => Some(&"IMPORT_SEMAPHORE_FD_INFO_KHR"),
            1000079001 => Some(&"SEMAPHORE_GET_FD_INFO_KHR"),
            1000080000 => Some(&"PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"),
            1000081000 => Some(&"COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT"),
            1000081001 => Some(&"PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT"),
            1000081002 => Some(&"CONDITIONAL_RENDERING_BEGIN_INFO_EXT"),
            1000084000 => Some(&"PRESENT_REGIONS_KHR"),
            1000087000 => Some(&"PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"),
            1000090000 => Some(&"SURFACE_CAPABILITIES_2_EXT"),
            1000091000 => Some(&"DISPLAY_POWER_INFO_EXT"),
            1000091001 => Some(&"DEVICE_EVENT_INFO_EXT"),
            1000091002 => Some(&"DISPLAY_EVENT_INFO_EXT"),
            1000091003 => Some(&"SWAPCHAIN_COUNTER_CREATE_INFO_EXT"),
            1000092000 => Some(&"PRESENT_TIMES_INFO_GOOGLE"),
            1000097000 => Some(&"PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"),
            1000098000 => Some(&"PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"),
            1000099000 => Some(&"PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"),
            1000099001 => Some(&"PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"),
            1000101000 => Some(&"PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"),
            1000101001 => Some(&"PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"),
            1000102000 => Some(&"PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT"),
            1000102001 => Some(&"PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT"),
            1000105000 => Some(&"HDR_METADATA_EXT"),
            1000111000 => Some(&"SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"),
            1000114000 => Some(&"IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
            1000114001 => Some(&"EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"),
            1000114002 => Some(&"FENCE_GET_WIN32_HANDLE_INFO_KHR"),
            1000115000 => Some(&"IMPORT_FENCE_FD_INFO_KHR"),
            1000115001 => Some(&"FENCE_GET_FD_INFO_KHR"),
            1000116000 => Some(&"PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR"),
            1000116001 => Some(&"PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR"),
            1000116002 => Some(&"QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR"),
            1000116003 => Some(&"PERFORMANCE_QUERY_SUBMIT_INFO_KHR"),
            1000116004 => Some(&"ACQUIRE_PROFILING_LOCK_INFO_KHR"),
            1000116005 => Some(&"PERFORMANCE_COUNTER_KHR"),
            1000116006 => Some(&"PERFORMANCE_COUNTER_DESCRIPTION_KHR"),
            1000119000 => Some(&"PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"),
            1000119001 => Some(&"SURFACE_CAPABILITIES_2_KHR"),
            1000119002 => Some(&"SURFACE_FORMAT_2_KHR"),
            1000121000 => Some(&"DISPLAY_PROPERTIES_2_KHR"),
            1000121001 => Some(&"DISPLAY_PLANE_PROPERTIES_2_KHR"),
            1000121002 => Some(&"DISPLAY_MODE_PROPERTIES_2_KHR"),
            1000121003 => Some(&"DISPLAY_PLANE_INFO_2_KHR"),
            1000121004 => Some(&"DISPLAY_PLANE_CAPABILITIES_2_KHR"),
            1000122000 => Some(&"IOS_SURFACE_CREATE_INFO_MVK"),
            1000123000 => Some(&"MACOS_SURFACE_CREATE_INFO_MVK"),
            1000128000 => Some(&"DEBUG_UTILS_OBJECT_NAME_INFO_EXT"),
            1000128001 => Some(&"DEBUG_UTILS_OBJECT_TAG_INFO_EXT"),
            1000128002 => Some(&"DEBUG_UTILS_LABEL_EXT"),
            1000128003 => Some(&"DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"),
            1000128004 => Some(&"DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"),
            1000129000 => Some(&"ANDROID_HARDWARE_BUFFER_USAGE_ANDROID"),
            1000129001 => Some(&"ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID"),
            1000129002 => Some(&"ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID"),
            1000129003 => Some(&"IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"),
            1000129004 => Some(&"MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"),
            1000129005 => Some(&"EXTERNAL_FORMAT_ANDROID"),
            1000129006 => Some(&"ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID"),
            1000143000 => Some(&"SAMPLE_LOCATIONS_INFO_EXT"),
            1000143001 => Some(&"RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"),
            1000143002 => Some(&"PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"),
            1000143003 => Some(&"PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"),
            1000143004 => Some(&"MULTISAMPLE_PROPERTIES_EXT"),
            1000148000 => Some(&"PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"),
            1000148001 => Some(&"PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"),
            1000148002 => Some(&"PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"),
            1000149000 => Some(&"PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"),
            1000150007 => Some(&"WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR"),
            1000150000 => Some(&"ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR"),
            1000150002 => Some(&"ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR"),
            1000150003 => Some(&"ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR"),
            1000150004 => Some(&"ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR"),
            1000150005 => Some(&"ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR"),
            1000150006 => Some(&"ACCELERATION_STRUCTURE_GEOMETRY_KHR"),
            1000150009 => Some(&"ACCELERATION_STRUCTURE_VERSION_INFO_KHR"),
            1000150010 => Some(&"COPY_ACCELERATION_STRUCTURE_INFO_KHR"),
            1000150011 => Some(&"COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR"),
            1000150012 => Some(&"COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR"),
            1000150013 => Some(&"PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR"),
            1000150014 => Some(&"PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR"),
            1000150017 => Some(&"ACCELERATION_STRUCTURE_CREATE_INFO_KHR"),
            1000150020 => Some(&"ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR"),
            1000347000 => Some(&"PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR"),
            1000347001 => Some(&"PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR"),
            1000150015 => Some(&"RAY_TRACING_PIPELINE_CREATE_INFO_KHR"),
            1000150016 => Some(&"RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR"),
            1000150018 => Some(&"RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR"),
            1000348013 => Some(&"PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR"),
            1000152000 => Some(&"PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"),
            1000154000 => Some(&"PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV"),
            1000154001 => Some(&"PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV"),
            1000158000 => Some(&"DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT"),
            1000158002 => Some(&"PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT"),
            1000158003 => Some(&"IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT"),
            1000158004 => Some(&"IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT"),
            1000158005 => Some(&"IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT"),
            1000158006 => Some(&"DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT"),
            1000160000 => Some(&"VALIDATION_CACHE_CREATE_INFO_EXT"),
            1000160001 => Some(&"SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"),
            1000163000 => Some(&"PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR"),
            1000163001 => Some(&"PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR"),
            1000164000 => Some(&"PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV"),
            1000164001 => Some(&"PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV"),
            1000164002 => Some(&"PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV"),
            1000164005 => Some(&"PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV"),
            1000165000 => Some(&"RAY_TRACING_PIPELINE_CREATE_INFO_NV"),
            1000165001 => Some(&"ACCELERATION_STRUCTURE_CREATE_INFO_NV"),
            1000165003 => Some(&"GEOMETRY_NV"),
            1000165004 => Some(&"GEOMETRY_TRIANGLES_NV"),
            1000165005 => Some(&"GEOMETRY_AABB_NV"),
            1000165006 => Some(&"BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV"),
            1000165007 => Some(&"WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV"),
            1000165008 => Some(&"ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV"),
            1000165009 => Some(&"PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV"),
            1000165011 => Some(&"RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV"),
            1000165012 => Some(&"ACCELERATION_STRUCTURE_INFO_NV"),
            1000166000 => Some(&"PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV"),
            1000166001 => Some(&"PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV"),
            1000170000 => Some(&"PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT"),
            1000170001 => Some(&"FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT"),
            1000178000 => Some(&"IMPORT_MEMORY_HOST_POINTER_INFO_EXT"),
            1000178001 => Some(&"MEMORY_HOST_POINTER_PROPERTIES_EXT"),
            1000178002 => Some(&"PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"),
            1000181000 => Some(&"PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR"),
            1000183000 => Some(&"PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD"),
            1000184000 => Some(&"CALIBRATED_TIMESTAMP_INFO_EXT"),
            1000185000 => Some(&"PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"),
            1000174000 => Some(&"DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR"),
            1000388000 => Some(&"PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR"),
            1000388001 => Some(&"QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR"),
            1000189000 => Some(&"DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD"),
            1000190000 => Some(&"PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"),
            1000190001 => Some(&"PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT"),
            1000190002 => Some(&"PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT"),
            1000201000 => Some(&"PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV"),
            1000202000 => Some(&"PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV"),
            1000202001 => Some(&"PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV"),
            1000204000 => Some(&"PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV"),
            1000205000 => Some(&"PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV"),
            1000205002 => Some(&"PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV"),
            1000206000 => Some(&"CHECKPOINT_DATA_NV"),
            1000206001 => Some(&"QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV"),
            1000209000 => Some(&"PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL"),
            1000210000 => Some(&"QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL"),
            1000210001 => Some(&"INITIALIZE_PERFORMANCE_API_INFO_INTEL"),
            1000210002 => Some(&"PERFORMANCE_MARKER_INFO_INTEL"),
            1000210003 => Some(&"PERFORMANCE_STREAM_MARKER_INFO_INTEL"),
            1000210004 => Some(&"PERFORMANCE_OVERRIDE_INFO_INTEL"),
            1000210005 => Some(&"PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL"),
            1000212000 => Some(&"PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT"),
            1000213000 => Some(&"DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD"),
            1000213001 => Some(&"SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD"),
            1000214000 => Some(&"IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA"),
            1000217000 => Some(&"METAL_SURFACE_CREATE_INFO_EXT"),
            1000218000 => Some(&"PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT"),
            1000218001 => Some(&"PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT"),
            1000218002 => Some(&"RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT"),
            1000226000 => Some(&"FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"),
            1000226001 => Some(&"PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR"),
            1000226002 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR"),
            1000226003 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR"),
            1000226004 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR"),
            1000227000 => Some(&"PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD"),
            1000229000 => Some(&"PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD"),
            1000234000 => Some(&"PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT"),
            1000237000 => Some(&"PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT"),
            1000238000 => Some(&"PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT"),
            1000238001 => Some(&"MEMORY_PRIORITY_ALLOCATE_INFO_EXT"),
            1000239000 => Some(&"SURFACE_PROTECTED_CAPABILITIES_KHR"),
            1000240000 => Some(&"PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV"),
            1000244000 => Some(&"PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"),
            1000244002 => Some(&"BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT"),
            1000247000 => Some(&"VALIDATION_FEATURES_EXT"),
            1000248000 => Some(&"PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR"),
            1000249000 => Some(&"PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV"),
            1000249001 => Some(&"COOPERATIVE_MATRIX_PROPERTIES_NV"),
            1000249002 => Some(&"PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV"),
            1000250000 => Some(&"PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV"),
            1000250001 => Some(&"PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV"),
            1000250002 => Some(&"FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV"),
            1000251000 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT"),
            1000252000 => Some(&"PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT"),
            1000254000 => Some(&"PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT"),
            1000254001 => Some(&"PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT"),
            1000254002 => Some(&"PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT"),
            1000255000 => Some(&"SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT"),
            1000255002 => Some(&"SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT"),
            1000255001 => Some(&"SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT"),
            1000256000 => Some(&"HEADLESS_SURFACE_CREATE_INFO_EXT"),
            1000259000 => Some(&"PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT"),
            1000259001 => Some(&"PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT"),
            1000259002 => Some(&"PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT"),
            1000260000 => Some(&"PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT"),
            1000265000 => Some(&"PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT"),
            1000267000 => Some(&"PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT"),
            1000269000 => Some(&"PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR"),
            1000269001 => Some(&"PIPELINE_INFO_KHR"),
            1000269002 => Some(&"PIPELINE_EXECUTABLE_PROPERTIES_KHR"),
            1000269003 => Some(&"PIPELINE_EXECUTABLE_INFO_KHR"),
            1000269004 => Some(&"PIPELINE_EXECUTABLE_STATISTIC_KHR"),
            1000269005 => Some(&"PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR"),
            1000273000 => Some(&"PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT"),
            1000277000 => Some(&"PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV"),
            1000277001 => Some(&"GRAPHICS_SHADER_GROUP_CREATE_INFO_NV"),
            1000277002 => Some(&"GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV"),
            1000277003 => Some(&"INDIRECT_COMMANDS_LAYOUT_TOKEN_NV"),
            1000277004 => Some(&"INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV"),
            1000277005 => Some(&"GENERATED_COMMANDS_INFO_NV"),
            1000277006 => Some(&"GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV"),
            1000277007 => Some(&"PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV"),
            1000278000 => Some(&"PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV"),
            1000278001 => Some(&"COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV"),
            1000281000 => Some(&"PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT"),
            1000282000 => Some(&"COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM"),
            1000282001 => Some(&"RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM"),
            1000284000 => Some(&"PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT"),
            1000284001 => Some(&"DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT"),
            1000284002 => Some(&"DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT"),
            1000286000 => Some(&"PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT"),
            1000286001 => Some(&"PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT"),
            1000287000 => Some(&"SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT"),
            1000287001 => Some(&"PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT"),
            1000287002 => Some(&"PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT"),
            1000290000 => Some(&"PIPELINE_LIBRARY_CREATE_INFO_KHR"),
            1000294000 => Some(&"PRESENT_ID_KHR"),
            1000294001 => Some(&"PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR"),
            1000300000 => Some(&"PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV"),
            1000300001 => Some(&"DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV"),
            1000311000 => Some(&"EXPORT_METAL_OBJECT_CREATE_INFO_EXT"),
            1000311001 => Some(&"EXPORT_METAL_OBJECTS_INFO_EXT"),
            1000311002 => Some(&"EXPORT_METAL_DEVICE_INFO_EXT"),
            1000311003 => Some(&"EXPORT_METAL_COMMAND_QUEUE_INFO_EXT"),
            1000311004 => Some(&"EXPORT_METAL_BUFFER_INFO_EXT"),
            1000311005 => Some(&"IMPORT_METAL_BUFFER_INFO_EXT"),
            1000311006 => Some(&"EXPORT_METAL_TEXTURE_INFO_EXT"),
            1000311007 => Some(&"IMPORT_METAL_TEXTURE_INFO_EXT"),
            1000311008 => Some(&"EXPORT_METAL_IO_SURFACE_INFO_EXT"),
            1000311009 => Some(&"IMPORT_METAL_IO_SURFACE_INFO_EXT"),
            1000311010 => Some(&"EXPORT_METAL_SHARED_EVENT_INFO_EXT"),
            1000311011 => Some(&"IMPORT_METAL_SHARED_EVENT_INFO_EXT"),
            1000314008 => Some(&"QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV"),
            1000314009 => Some(&"CHECKPOINT_DATA_2_NV"),
            1000320000 => Some(&"PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT"),
            1000320001 => Some(&"PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT"),
            1000320002 => Some(&"GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT"),
            1000321000 => Some(&"PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD"),
            1000203000 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR"),
            1000322000 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR"),
            1000323000 => Some(&"PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR"),
            1000326000 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV"),
            1000326001 => Some(&"PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV"),
            1000326002 => Some(&"PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV"),
            1000327000 => Some(&"ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV"),
            1000327001 => Some(&"PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV"),
            1000327002 => Some(&"ACCELERATION_STRUCTURE_MOTION_INFO_NV"),
            1000330000 => Some(&"PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT"),
            1000332000 => Some(&"PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT"),
            1000332001 => Some(&"PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT"),
            1000333000 => Some(&"COPY_COMMAND_TRANSFORM_INFO_QCOM"),
            1000336000 => Some(&"PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR"),
            1000338000 => Some(&"PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT"),
            1000338001 => Some(&"IMAGE_COMPRESSION_CONTROL_EXT"),
            1000338002 => Some(&"SUBRESOURCE_LAYOUT_2_EXT"),
            1000338003 => Some(&"IMAGE_SUBRESOURCE_2_EXT"),
            1000338004 => Some(&"IMAGE_COMPRESSION_PROPERTIES_EXT"),
            1000340000 => Some(&"PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT"),
            1000342000 => Some(&"PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM"),
            1000344000 => Some(&"PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT"),
            1000346000 => Some(&"DIRECTFB_SURFACE_CREATE_INFO_EXT"),
            1000351000 => Some(&"PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE"),
            1000351002 => Some(&"MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE"),
            1000352000 => Some(&"PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT"),
            1000352001 => Some(&"VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT"),
            1000352002 => Some(&"VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT"),
            1000353000 => Some(&"PHYSICAL_DEVICE_DRM_PROPERTIES_EXT"),
            1000355000 => Some(&"PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT"),
            1000355001 => Some(&"PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT"),
            1000356000 => Some(&"PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT"),
            1000364000 => Some(&"IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA"),
            1000364001 => Some(&"MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA"),
            1000364002 => Some(&"MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA"),
            1000365000 => Some(&"IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA"),
            1000365001 => Some(&"SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA"),
            1000366000 => Some(&"BUFFER_COLLECTION_CREATE_INFO_FUCHSIA"),
            1000366001 => Some(&"IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA"),
            1000366002 => Some(&"BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA"),
            1000366003 => Some(&"BUFFER_COLLECTION_PROPERTIES_FUCHSIA"),
            1000366004 => Some(&"BUFFER_CONSTRAINTS_INFO_FUCHSIA"),
            1000366005 => Some(&"BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA"),
            1000366006 => Some(&"IMAGE_CONSTRAINTS_INFO_FUCHSIA"),
            1000366007 => Some(&"IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA"),
            1000366008 => Some(&"SYSMEM_COLOR_SPACE_FUCHSIA"),
            1000366009 => Some(&"BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA"),
            1000369000 => Some(&"SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI"),
            1000369001 => Some(&"PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI"),
            1000369002 => Some(&"PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI"),
            1000370000 => Some(&"PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI"),
            1000371000 => Some(&"MEMORY_GET_REMOTE_ADDRESS_INFO_NV"),
            1000371001 => Some(&"PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV"),
            1000372000 => Some(&"PIPELINE_PROPERTIES_IDENTIFIER_EXT"),
            1000372001 => Some(&"PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT"),
            1000377000 => Some(&"PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT"),
            1000381000 => Some(&"PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT"),
            1000381001 => Some(&"PIPELINE_COLOR_WRITE_CREATE_INFO_EXT"),
            1000382000 => Some(&"PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT"),
            1000386000 => Some(&"PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR"),
            1000391000 => Some(&"PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT"),
            1000391001 => Some(&"IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT"),
            1000392000 => Some(&"PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT"),
            1000392001 => Some(&"PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT"),
            1000393000 => Some(&"PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT"),
            1000411000 => Some(&"PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT"),
            1000411001 => Some(&"SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT"),
            1000412000 => Some(&"PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT"),
            1000420000 => Some(&"PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE"),
            1000420001 => Some(&"DESCRIPTOR_SET_BINDING_REFERENCE_VALVE"),
            1000420002 => Some(&"DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE"),
            1000422000 => Some(&"PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT"),
            1000425000 => Some(&"PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM"),
            1000425001 => Some(&"PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM"),
            1000425002 => Some(&"SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM"),
            1000430000 => Some(&"PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV"),
            1000437000 => Some(&"PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT"),
            1000458000 => Some(&"PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT"),
            1000458001 => Some(&"RENDER_PASS_CREATION_CONTROL_EXT"),
            1000458002 => Some(&"RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT"),
            1000458003 => Some(&"RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SystemAllocationScope(i32);
impl SystemAllocationScope {
    pub const COMMAND: Self = Self(0);
    pub const OBJECT: Self = Self(1);
    pub const CACHE: Self = Self(2);
    pub const DEVICE: Self = Self(3);
    pub const INSTANCE: Self = Self(4);
}
impl fmt::Display for SystemAllocationScope {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"COMMAND"),
            1 => Some(&"OBJECT"),
            2 => Some(&"CACHE"),
            3 => Some(&"DEVICE"),
            4 => Some(&"INSTANCE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct InternalAllocationType(i32);
impl InternalAllocationType {
    pub const EXECUTABLE: Self = Self(0);
}
impl fmt::Display for InternalAllocationType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"EXECUTABLE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SamplerAddressMode(i32);
impl SamplerAddressMode {
    pub const REPEAT: Self = Self(0);
    pub const MIRRORED_REPEAT: Self = Self(1);
    pub const CLAMP_TO_EDGE: Self = Self(2);
    pub const CLAMP_TO_BORDER: Self = Self(3);
    /// No need to add an extnumber attribute, since this uses a core enum value
    /// Added by extension VK_KHR_sampler_mirror_clamp_to_edge.
    pub const MIRROR_CLAMP_TO_EDGE: Self = Self(4);
    pub const MIRROR_CLAMP_TO_EDGE_KHR: Self = Self::MIRROR_CLAMP_TO_EDGE;
}
impl fmt::Display for SamplerAddressMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"REPEAT"),
            1 => Some(&"MIRRORED_REPEAT"),
            2 => Some(&"CLAMP_TO_EDGE"),
            3 => Some(&"CLAMP_TO_BORDER"),
            4 => Some(&"MIRROR_CLAMP_TO_EDGE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct Filter(i32);
impl Filter {
    pub const NEAREST: Self = Self(0);
    pub const LINEAR: Self = Self(1);
    /// Added by extension VK_IMG_filter_cubic.
    pub const CUBIC_IMG: Self = Self(1000015000);
    pub const CUBIC_EXT: Self = Self::CUBIC_IMG;
}
impl fmt::Display for Filter {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"NEAREST"),
            1 => Some(&"LINEAR"),
            1000015000 => Some(&"CUBIC_IMG"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SamplerMipmapMode(i32);
impl SamplerMipmapMode {
    /// Choose nearest mip level
    pub const NEAREST: Self = Self(0);
    /// Linear filter between mip levels
    pub const LINEAR: Self = Self(1);
}
impl fmt::Display for SamplerMipmapMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"NEAREST"),
            1 => Some(&"LINEAR"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct VertexInputRate(i32);
impl VertexInputRate {
    pub const VERTEX: Self = Self(0);
    pub const INSTANCE: Self = Self(1);
}
impl fmt::Display for VertexInputRate {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"VERTEX"),
            1 => Some(&"INSTANCE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ObjectType(i32);
impl ObjectType {
    pub const UNKNOWN: Self = Self(0);
    pub const INSTANCE: Self = Self(1);
    pub const PHYSICAL_DEVICE: Self = Self(2);
    pub const DEVICE: Self = Self(3);
    pub const QUEUE: Self = Self(4);
    pub const SEMAPHORE: Self = Self(5);
    pub const COMMAND_BUFFER: Self = Self(6);
    pub const FENCE: Self = Self(7);
    pub const DEVICE_MEMORY: Self = Self(8);
    pub const BUFFER: Self = Self(9);
    pub const IMAGE: Self = Self(10);
    pub const EVENT: Self = Self(11);
    pub const QUERY_POOL: Self = Self(12);
    pub const BUFFER_VIEW: Self = Self(13);
    pub const IMAGE_VIEW: Self = Self(14);
    pub const SHADER_MODULE: Self = Self(15);
    pub const PIPELINE_CACHE: Self = Self(16);
    pub const PIPELINE_LAYOUT: Self = Self(17);
    pub const RENDER_PASS: Self = Self(18);
    pub const PIPELINE: Self = Self(19);
    pub const DESCRIPTOR_SET_LAYOUT: Self = Self(20);
    pub const SAMPLER: Self = Self(21);
    pub const DESCRIPTOR_POOL: Self = Self(22);
    pub const DESCRIPTOR_SET: Self = Self(23);
    pub const FRAMEBUFFER: Self = Self(24);
    pub const COMMAND_POOL: Self = Self(25);
    pub const SAMPLER_YCBCR_CONVERSION: Self = Self(1000156000);
    pub const DESCRIPTOR_UPDATE_TEMPLATE: Self = Self(1000085000);
    pub const PRIVATE_DATA_SLOT: Self = Self(1000295000);
    /// Added by extension VK_KHR_surface.
    pub const SURFACE_KHR: Self = Self(1000000000);
    /// Added by extension VK_KHR_swapchain.
    pub const SWAPCHAIN_KHR: Self = Self(1000001000);
    /// Added by extension VK_KHR_display.
    pub const DISPLAY_KHR: Self = Self(1000002000);
    /// Added by extension VK_KHR_display.
    pub const DISPLAY_MODE_KHR: Self = Self(1000002001);
    /// Added by extension VK_EXT_debug_report.
    pub const DEBUG_REPORT_CALLBACK_EXT: Self = Self(1000011000);
    /// Added by extension VK_NVX_binary_import.
    pub const CU_MODULE_NVX: Self = Self(1000029000);
    /// Added by extension VK_NVX_binary_import.
    pub const CU_FUNCTION_NVX: Self = Self(1000029001);
    pub const DESCRIPTOR_UPDATE_TEMPLATE_KHR: Self = Self::DESCRIPTOR_UPDATE_TEMPLATE;
    /// Added by extension VK_EXT_debug_utils.
    pub const DEBUG_UTILS_MESSENGER_EXT: Self = Self(1000128000);
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_KHR: Self = Self(1000150000);
    pub const SAMPLER_YCBCR_CONVERSION_KHR: Self = Self::SAMPLER_YCBCR_CONVERSION;
    /// Added by extension VK_EXT_validation_cache.
    pub const VALIDATION_CACHE_EXT: Self = Self(1000160000);
    /// Added by extension VK_NV_ray_tracing.
    pub const ACCELERATION_STRUCTURE_NV: Self = Self(1000165000);
    /// Added by extension VK_INTEL_performance_query.
    pub const PERFORMANCE_CONFIGURATION_INTEL: Self = Self(1000210000);
    /// Added by extension VK_KHR_deferred_host_operations.
    pub const DEFERRED_OPERATION_KHR: Self = Self(1000268000);
    /// Added by extension VK_NV_device_generated_commands.
    pub const INDIRECT_COMMANDS_LAYOUT_NV: Self = Self(1000277000);
    pub const PRIVATE_DATA_SLOT_EXT: Self = Self::PRIVATE_DATA_SLOT;
    /// VkBufferCollectionFUCHSIA
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_COLLECTION_FUCHSIA: Self = Self(1000366000);
}
impl fmt::Display for ObjectType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UNKNOWN"),
            1 => Some(&"INSTANCE"),
            2 => Some(&"PHYSICAL_DEVICE"),
            3 => Some(&"DEVICE"),
            4 => Some(&"QUEUE"),
            5 => Some(&"SEMAPHORE"),
            6 => Some(&"COMMAND_BUFFER"),
            7 => Some(&"FENCE"),
            8 => Some(&"DEVICE_MEMORY"),
            9 => Some(&"BUFFER"),
            10 => Some(&"IMAGE"),
            11 => Some(&"EVENT"),
            12 => Some(&"QUERY_POOL"),
            13 => Some(&"BUFFER_VIEW"),
            14 => Some(&"IMAGE_VIEW"),
            15 => Some(&"SHADER_MODULE"),
            16 => Some(&"PIPELINE_CACHE"),
            17 => Some(&"PIPELINE_LAYOUT"),
            18 => Some(&"RENDER_PASS"),
            19 => Some(&"PIPELINE"),
            20 => Some(&"DESCRIPTOR_SET_LAYOUT"),
            21 => Some(&"SAMPLER"),
            22 => Some(&"DESCRIPTOR_POOL"),
            23 => Some(&"DESCRIPTOR_SET"),
            24 => Some(&"FRAMEBUFFER"),
            25 => Some(&"COMMAND_POOL"),
            1000156000 => Some(&"SAMPLER_YCBCR_CONVERSION"),
            1000085000 => Some(&"DESCRIPTOR_UPDATE_TEMPLATE"),
            1000295000 => Some(&"PRIVATE_DATA_SLOT"),
            1000000000 => Some(&"SURFACE_KHR"),
            1000001000 => Some(&"SWAPCHAIN_KHR"),
            1000002000 => Some(&"DISPLAY_KHR"),
            1000002001 => Some(&"DISPLAY_MODE_KHR"),
            1000011000 => Some(&"DEBUG_REPORT_CALLBACK_EXT"),
            1000029000 => Some(&"CU_MODULE_NVX"),
            1000029001 => Some(&"CU_FUNCTION_NVX"),
            1000128000 => Some(&"DEBUG_UTILS_MESSENGER_EXT"),
            1000150000 => Some(&"ACCELERATION_STRUCTURE_KHR"),
            1000160000 => Some(&"VALIDATION_CACHE_EXT"),
            1000165000 => Some(&"ACCELERATION_STRUCTURE_NV"),
            1000210000 => Some(&"PERFORMANCE_CONFIGURATION_INTEL"),
            1000268000 => Some(&"DEFERRED_OPERATION_KHR"),
            1000277000 => Some(&"INDIRECT_COMMANDS_LAYOUT_NV"),
            1000366000 => Some(&"BUFFER_COLLECTION_FUCHSIA"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct IndirectCommandsTokenTypeNV(i32);
impl IndirectCommandsTokenTypeNV {
    pub const SHADER_GROUP: Self = Self(0);
    pub const STATE_FLAGS: Self = Self(1);
    pub const INDEX_BUFFER: Self = Self(2);
    pub const VERTEX_BUFFER: Self = Self(3);
    pub const PUSH_CONSTANT: Self = Self(4);
    pub const DRAW_INDEXED: Self = Self(5);
    pub const DRAW: Self = Self(6);
    pub const DRAW_TASKS: Self = Self(7);
}
impl fmt::Display for IndirectCommandsTokenTypeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"SHADER_GROUP"),
            1 => Some(&"STATE_FLAGS"),
            2 => Some(&"INDEX_BUFFER"),
            3 => Some(&"VERTEX_BUFFER"),
            4 => Some(&"PUSH_CONSTANT"),
            5 => Some(&"DRAW_INDEXED"),
            6 => Some(&"DRAW"),
            7 => Some(&"DRAW_TASKS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DescriptorUpdateTemplateType(i32);
impl DescriptorUpdateTemplateType {
    /// Create descriptor update template for descriptor set updates
    pub const DESCRIPTOR_SET: Self = Self(0);
    /// Create descriptor update template for pushed descriptor updates
    /// Added by extension VK_KHR_descriptor_update_template.
    pub const PUSH_DESCRIPTORS_KHR: Self = Self(1);
    pub const DESCRIPTOR_SET_KHR: Self = Self::DESCRIPTOR_SET;
}
impl fmt::Display for DescriptorUpdateTemplateType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DESCRIPTOR_SET"),
            1 => Some(&"PUSH_DESCRIPTORS_KHR"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type DescriptorUpdateTemplateTypeKHR = DescriptorUpdateTemplateType;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ViewportCoordinateSwizzleNV(i32);
impl ViewportCoordinateSwizzleNV {
    pub const POSITIVE_X: Self = Self(0);
    pub const NEGATIVE_X: Self = Self(1);
    pub const POSITIVE_Y: Self = Self(2);
    pub const NEGATIVE_Y: Self = Self(3);
    pub const POSITIVE_Z: Self = Self(4);
    pub const NEGATIVE_Z: Self = Self(5);
    pub const POSITIVE_W: Self = Self(6);
    pub const NEGATIVE_W: Self = Self(7);
}
impl fmt::Display for ViewportCoordinateSwizzleNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"POSITIVE_X"),
            1 => Some(&"NEGATIVE_X"),
            2 => Some(&"POSITIVE_Y"),
            3 => Some(&"NEGATIVE_Y"),
            4 => Some(&"POSITIVE_Z"),
            5 => Some(&"NEGATIVE_Z"),
            6 => Some(&"POSITIVE_W"),
            7 => Some(&"NEGATIVE_W"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DiscardRectangleModeEXT(i32);
impl DiscardRectangleModeEXT {
    pub const INCLUSIVE: Self = Self(0);
    pub const EXCLUSIVE: Self = Self(1);
}
impl fmt::Display for DiscardRectangleModeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"INCLUSIVE"),
            1 => Some(&"EXCLUSIVE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PointClippingBehavior(i32);
impl PointClippingBehavior {
    pub const ALL_CLIP_PLANES: Self = Self(0);
    pub const USER_CLIP_PLANES_ONLY: Self = Self(1);
    pub const ALL_CLIP_PLANES_KHR: Self = Self::ALL_CLIP_PLANES;
    pub const USER_CLIP_PLANES_ONLY_KHR: Self = Self::USER_CLIP_PLANES_ONLY;
}
impl fmt::Display for PointClippingBehavior {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"ALL_CLIP_PLANES"),
            1 => Some(&"USER_CLIP_PLANES_ONLY"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type PointClippingBehaviorKHR = PointClippingBehavior;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct CoverageModulationModeNV(i32);
impl CoverageModulationModeNV {
    pub const NONE: Self = Self(0);
    pub const RGB: Self = Self(1);
    pub const ALPHA: Self = Self(2);
    pub const RGBA: Self = Self(3);
}
impl fmt::Display for CoverageModulationModeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"NONE"),
            1 => Some(&"RGB"),
            2 => Some(&"ALPHA"),
            3 => Some(&"RGBA"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct CoverageReductionModeNV(i32);
impl CoverageReductionModeNV {
    pub const MERGE: Self = Self(0);
    pub const TRUNCATE: Self = Self(1);
}
impl fmt::Display for CoverageReductionModeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"MERGE"),
            1 => Some(&"TRUNCATE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ValidationCacheHeaderVersionEXT(i32);
impl ValidationCacheHeaderVersionEXT {
    pub const ONE: Self = Self(1);
}
impl fmt::Display for ValidationCacheHeaderVersionEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            1 => Some(&"ONE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ShaderInfoTypeAMD(i32);
impl ShaderInfoTypeAMD {
    pub const STATISTICS: Self = Self(0);
    pub const BINARY: Self = Self(1);
    pub const DISASSEMBLY: Self = Self(2);
}
impl fmt::Display for ShaderInfoTypeAMD {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"STATISTICS"),
            1 => Some(&"BINARY"),
            2 => Some(&"DISASSEMBLY"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct QueueGlobalPriorityKHR(i32);
impl QueueGlobalPriorityKHR {
    pub const LOW: Self = Self(128);
    pub const MEDIUM: Self = Self(256);
    pub const HIGH: Self = Self(512);
    pub const REALTIME: Self = Self(1024);
    pub const LOW_EXT: Self = Self::LOW;
    pub const MEDIUM_EXT: Self = Self::MEDIUM;
    pub const HIGH_EXT: Self = Self::HIGH;
    pub const REALTIME_EXT: Self = Self::REALTIME;
}
impl fmt::Display for QueueGlobalPriorityKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            128 => Some(&"LOW"),
            256 => Some(&"MEDIUM"),
            512 => Some(&"HIGH"),
            1024 => Some(&"REALTIME"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type QueueGlobalPriorityEXT = QueueGlobalPriorityKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct TimeDomainEXT(i32);
impl TimeDomainEXT {
    pub const DEVICE: Self = Self(0);
    pub const CLOCK_MONOTONIC: Self = Self(1);
    pub const CLOCK_MONOTONIC_RAW: Self = Self(2);
    pub const QUERY_PERFORMANCE_COUNTER: Self = Self(3);
}
impl fmt::Display for TimeDomainEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DEVICE"),
            1 => Some(&"CLOCK_MONOTONIC"),
            2 => Some(&"CLOCK_MONOTONIC_RAW"),
            3 => Some(&"QUERY_PERFORMANCE_COUNTER"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ConservativeRasterizationModeEXT(i32);
impl ConservativeRasterizationModeEXT {
    pub const DISABLED: Self = Self(0);
    pub const OVERESTIMATE: Self = Self(1);
    pub const UNDERESTIMATE: Self = Self(2);
}
impl fmt::Display for ConservativeRasterizationModeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DISABLED"),
            1 => Some(&"OVERESTIMATE"),
            2 => Some(&"UNDERESTIMATE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SemaphoreType(i32);
impl SemaphoreType {
    pub const BINARY: Self = Self(0);
    pub const TIMELINE: Self = Self(1);
    pub const BINARY_KHR: Self = Self::BINARY;
    pub const TIMELINE_KHR: Self = Self::TIMELINE;
}
impl fmt::Display for SemaphoreType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"BINARY"),
            1 => Some(&"TIMELINE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type SemaphoreTypeKHR = SemaphoreType;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct BuildAccelerationStructureModeKHR(i32);
impl BuildAccelerationStructureModeKHR {
    pub const BUILD: Self = Self(0);
    pub const UPDATE: Self = Self(1);
}
impl fmt::Display for BuildAccelerationStructureModeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"BUILD"),
            1 => Some(&"UPDATE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct CopyAccelerationStructureModeKHR(i32);
impl CopyAccelerationStructureModeKHR {
    pub const CLONE: Self = Self(0);
    pub const COMPACT: Self = Self(1);
    pub const SERIALIZE: Self = Self(2);
    pub const DESERIALIZE: Self = Self(3);
    pub const CLONE_NV: Self = Self::CLONE;
    pub const COMPACT_NV: Self = Self::COMPACT;
}
impl fmt::Display for CopyAccelerationStructureModeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"CLONE"),
            1 => Some(&"COMPACT"),
            2 => Some(&"SERIALIZE"),
            3 => Some(&"DESERIALIZE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type CopyAccelerationStructureModeNV = CopyAccelerationStructureModeKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct AccelerationStructureTypeKHR(i32);
impl AccelerationStructureTypeKHR {
    pub const TOP_LEVEL: Self = Self(0);
    pub const BOTTOM_LEVEL: Self = Self(1);
    pub const GENERIC: Self = Self(2);
    pub const TOP_LEVEL_NV: Self = Self::TOP_LEVEL;
    pub const BOTTOM_LEVEL_NV: Self = Self::BOTTOM_LEVEL;
}
impl fmt::Display for AccelerationStructureTypeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"TOP_LEVEL"),
            1 => Some(&"BOTTOM_LEVEL"),
            2 => Some(&"GENERIC"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type AccelerationStructureTypeNV = AccelerationStructureTypeKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct GeometryTypeKHR(i32);
impl GeometryTypeKHR {
    pub const TRIANGLES: Self = Self(0);
    pub const AABBS: Self = Self(1);
    pub const INSTANCES: Self = Self(2);
    pub const TRIANGLES_NV: Self = Self::TRIANGLES;
    pub const AABBS_NV: Self = Self::AABBS;
}
impl fmt::Display for GeometryTypeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"TRIANGLES"),
            1 => Some(&"AABBS"),
            2 => Some(&"INSTANCES"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type GeometryTypeNV = GeometryTypeKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct RayTracingShaderGroupTypeKHR(i32);
impl RayTracingShaderGroupTypeKHR {
    pub const GENERAL: Self = Self(0);
    pub const TRIANGLES_HIT_GROUP: Self = Self(1);
    pub const PROCEDURAL_HIT_GROUP: Self = Self(2);
    pub const GENERAL_NV: Self = Self::GENERAL;
    pub const TRIANGLES_HIT_GROUP_NV: Self = Self::TRIANGLES_HIT_GROUP;
    pub const PROCEDURAL_HIT_GROUP_NV: Self = Self::PROCEDURAL_HIT_GROUP;
}
impl fmt::Display for RayTracingShaderGroupTypeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"GENERAL"),
            1 => Some(&"TRIANGLES_HIT_GROUP"),
            2 => Some(&"PROCEDURAL_HIT_GROUP"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type RayTracingShaderGroupTypeNV = RayTracingShaderGroupTypeKHR;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct AccelerationStructureMemoryRequirementsTypeNV(i32);
impl AccelerationStructureMemoryRequirementsTypeNV {
    pub const OBJECT: Self = Self(0);
    pub const BUILD_SCRATCH: Self = Self(1);
    pub const UPDATE_SCRATCH: Self = Self(2);
}
impl fmt::Display for AccelerationStructureMemoryRequirementsTypeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"OBJECT"),
            1 => Some(&"BUILD_SCRATCH"),
            2 => Some(&"UPDATE_SCRATCH"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct AccelerationStructureBuildTypeKHR(i32);
impl AccelerationStructureBuildTypeKHR {
    pub const HOST: Self = Self(0);
    pub const DEVICE: Self = Self(1);
    pub const HOST_OR_DEVICE: Self = Self(2);
}
impl fmt::Display for AccelerationStructureBuildTypeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"HOST"),
            1 => Some(&"DEVICE"),
            2 => Some(&"HOST_OR_DEVICE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct AccelerationStructureCompatibilityKHR(i32);
impl AccelerationStructureCompatibilityKHR {
    pub const COMPATIBLE: Self = Self(0);
    pub const INCOMPATIBLE: Self = Self(1);
}
impl fmt::Display for AccelerationStructureCompatibilityKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"COMPATIBLE"),
            1 => Some(&"INCOMPATIBLE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ShaderGroupShaderKHR(i32);
impl ShaderGroupShaderKHR {
    pub const GENERAL: Self = Self(0);
    pub const CLOSEST_HIT: Self = Self(1);
    pub const ANY_HIT: Self = Self(2);
    pub const INTERSECTION: Self = Self(3);
}
impl fmt::Display for ShaderGroupShaderKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"GENERAL"),
            1 => Some(&"CLOSEST_HIT"),
            2 => Some(&"ANY_HIT"),
            3 => Some(&"INTERSECTION"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct MemoryOverallocationBehaviorAMD(i32);
impl MemoryOverallocationBehaviorAMD {
    pub const DEFAULT: Self = Self(0);
    pub const ALLOWED: Self = Self(1);
    pub const DISALLOWED: Self = Self(2);
}
impl fmt::Display for MemoryOverallocationBehaviorAMD {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DEFAULT"),
            1 => Some(&"ALLOWED"),
            2 => Some(&"DISALLOWED"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ScopeNV(i32);
impl ScopeNV {
    pub const DEVICE: Self = Self(1);
    pub const WORKGROUP: Self = Self(2);
    pub const SUBGROUP: Self = Self(3);
    pub const QUEUE_FAMILY: Self = Self(5);
}
impl fmt::Display for ScopeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            1 => Some(&"DEVICE"),
            2 => Some(&"WORKGROUP"),
            3 => Some(&"SUBGROUP"),
            5 => Some(&"QUEUE_FAMILY"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ComponentTypeNV(i32);
impl ComponentTypeNV {
    pub const FLOAT16: Self = Self(0);
    pub const FLOAT32: Self = Self(1);
    pub const FLOAT64: Self = Self(2);
    pub const SINT8: Self = Self(3);
    pub const SINT16: Self = Self(4);
    pub const SINT32: Self = Self(5);
    pub const SINT64: Self = Self(6);
    pub const UINT8: Self = Self(7);
    pub const UINT16: Self = Self(8);
    pub const UINT32: Self = Self(9);
    pub const UINT64: Self = Self(10);
}
impl fmt::Display for ComponentTypeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"FLOAT16"),
            1 => Some(&"FLOAT32"),
            2 => Some(&"FLOAT64"),
            3 => Some(&"SINT8"),
            4 => Some(&"SINT16"),
            5 => Some(&"SINT32"),
            6 => Some(&"SINT64"),
            7 => Some(&"UINT8"),
            8 => Some(&"UINT16"),
            9 => Some(&"UINT32"),
            10 => Some(&"UINT64"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PerformanceCounterScopeKHR(i32);
impl PerformanceCounterScopeKHR {
    pub const COMMAND_BUFFER: Self = Self(0);
    pub const RENDER_PASS: Self = Self(1);
    pub const COMMAND: Self = Self(2);
    pub const QUERY_SCOPE_COMMAND_BUFFER: Self = Self::COMMAND_BUFFER;
    pub const QUERY_SCOPE_RENDER_PASS: Self = Self::RENDER_PASS;
    pub const QUERY_SCOPE_COMMAND: Self = Self::COMMAND;
}
impl fmt::Display for PerformanceCounterScopeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"COMMAND_BUFFER"),
            1 => Some(&"RENDER_PASS"),
            2 => Some(&"COMMAND"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PerformanceCounterUnitKHR(i32);
impl PerformanceCounterUnitKHR {
    pub const GENERIC: Self = Self(0);
    pub const PERCENTAGE: Self = Self(1);
    pub const NANOSECONDS: Self = Self(2);
    pub const BYTES: Self = Self(3);
    pub const BYTES_PER_SECOND: Self = Self(4);
    pub const KELVIN: Self = Self(5);
    pub const WATTS: Self = Self(6);
    pub const VOLTS: Self = Self(7);
    pub const AMPS: Self = Self(8);
    pub const HERTZ: Self = Self(9);
    pub const CYCLES: Self = Self(10);
}
impl fmt::Display for PerformanceCounterUnitKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"GENERIC"),
            1 => Some(&"PERCENTAGE"),
            2 => Some(&"NANOSECONDS"),
            3 => Some(&"BYTES"),
            4 => Some(&"BYTES_PER_SECOND"),
            5 => Some(&"KELVIN"),
            6 => Some(&"WATTS"),
            7 => Some(&"VOLTS"),
            8 => Some(&"AMPS"),
            9 => Some(&"HERTZ"),
            10 => Some(&"CYCLES"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PerformanceCounterStorageKHR(i32);
impl PerformanceCounterStorageKHR {
    pub const INT32: Self = Self(0);
    pub const INT64: Self = Self(1);
    pub const UINT32: Self = Self(2);
    pub const UINT64: Self = Self(3);
    pub const FLOAT32: Self = Self(4);
    pub const FLOAT64: Self = Self(5);
}
impl fmt::Display for PerformanceCounterStorageKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"INT32"),
            1 => Some(&"INT64"),
            2 => Some(&"UINT32"),
            3 => Some(&"UINT64"),
            4 => Some(&"FLOAT32"),
            5 => Some(&"FLOAT64"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PerformanceConfigurationTypeINTEL(i32);
impl PerformanceConfigurationTypeINTEL {
    pub const COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED: Self = Self(0);
}
impl fmt::Display for PerformanceConfigurationTypeINTEL {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct QueryPoolSamplingModeINTEL(i32);
impl QueryPoolSamplingModeINTEL {
    pub const MANUAL: Self = Self(0);
}
impl fmt::Display for QueryPoolSamplingModeINTEL {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"MANUAL"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PerformanceOverrideTypeINTEL(i32);
impl PerformanceOverrideTypeINTEL {
    pub const NULL_HARDWARE: Self = Self(0);
    pub const FLUSH_GPU_CACHES: Self = Self(1);
}
impl fmt::Display for PerformanceOverrideTypeINTEL {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"NULL_HARDWARE"),
            1 => Some(&"FLUSH_GPU_CACHES"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PerformanceParameterTypeINTEL(i32);
impl PerformanceParameterTypeINTEL {
    pub const HW_COUNTERS_SUPPORTED: Self = Self(0);
    pub const STREAM_MARKER_VALID_BITS: Self = Self(1);
}
impl fmt::Display for PerformanceParameterTypeINTEL {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"HW_COUNTERS_SUPPORTED"),
            1 => Some(&"STREAM_MARKER_VALID_BITS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PerformanceValueTypeINTEL(i32);
impl PerformanceValueTypeINTEL {
    pub const UINT32: Self = Self(0);
    pub const UINT64: Self = Self(1);
    pub const FLOAT: Self = Self(2);
    pub const BOOL: Self = Self(3);
    pub const STRING: Self = Self(4);
}
impl fmt::Display for PerformanceValueTypeINTEL {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UINT32"),
            1 => Some(&"UINT64"),
            2 => Some(&"FLOAT"),
            3 => Some(&"BOOL"),
            4 => Some(&"STRING"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct LineRasterizationModeEXT(i32);
impl LineRasterizationModeEXT {
    pub const DEFAULT: Self = Self(0);
    pub const RECTANGULAR: Self = Self(1);
    pub const BRESENHAM: Self = Self(2);
    pub const RECTANGULAR_SMOOTH: Self = Self(3);
}
impl fmt::Display for LineRasterizationModeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DEFAULT"),
            1 => Some(&"RECTANGULAR"),
            2 => Some(&"BRESENHAM"),
            3 => Some(&"RECTANGULAR_SMOOTH"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct FragmentShadingRateNV(i32);
impl FragmentShadingRateNV {
    pub const N1_INVOCATION_PER_PIXEL: Self = Self(0);
    pub const N1_INVOCATION_PER_1X2_PIXELS: Self = Self(1);
    pub const N1_INVOCATION_PER_2X1_PIXELS: Self = Self(4);
    pub const N1_INVOCATION_PER_2X2_PIXELS: Self = Self(5);
    pub const N1_INVOCATION_PER_2X4_PIXELS: Self = Self(6);
    pub const N1_INVOCATION_PER_4X2_PIXELS: Self = Self(9);
    pub const N1_INVOCATION_PER_4X4_PIXELS: Self = Self(10);
    pub const N2_INVOCATIONS_PER_PIXEL: Self = Self(11);
    pub const N4_INVOCATIONS_PER_PIXEL: Self = Self(12);
    pub const N8_INVOCATIONS_PER_PIXEL: Self = Self(13);
    pub const N16_INVOCATIONS_PER_PIXEL: Self = Self(14);
    pub const NO_INVOCATIONS: Self = Self(15);
}
impl fmt::Display for FragmentShadingRateNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"N1_INVOCATION_PER_PIXEL"),
            1 => Some(&"N1_INVOCATION_PER_1X2_PIXELS"),
            4 => Some(&"N1_INVOCATION_PER_2X1_PIXELS"),
            5 => Some(&"N1_INVOCATION_PER_2X2_PIXELS"),
            6 => Some(&"N1_INVOCATION_PER_2X4_PIXELS"),
            9 => Some(&"N1_INVOCATION_PER_4X2_PIXELS"),
            10 => Some(&"N1_INVOCATION_PER_4X4_PIXELS"),
            11 => Some(&"N2_INVOCATIONS_PER_PIXEL"),
            12 => Some(&"N4_INVOCATIONS_PER_PIXEL"),
            13 => Some(&"N8_INVOCATIONS_PER_PIXEL"),
            14 => Some(&"N16_INVOCATIONS_PER_PIXEL"),
            15 => Some(&"NO_INVOCATIONS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct FragmentShadingRateTypeNV(i32);
impl FragmentShadingRateTypeNV {
    pub const FRAGMENT_SIZE: Self = Self(0);
    pub const ENUMS: Self = Self(1);
}
impl fmt::Display for FragmentShadingRateTypeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"FRAGMENT_SIZE"),
            1 => Some(&"ENUMS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SubpassMergeStatusEXT(i32);
impl SubpassMergeStatusEXT {
    pub const MERGED: Self = Self(0);
    pub const DISALLOWED: Self = Self(1);
    pub const NOT_MERGED_SIDE_EFFECTS: Self = Self(2);
    pub const NOT_MERGED_SAMPLES_MISMATCH: Self = Self(3);
    pub const NOT_MERGED_VIEWS_MISMATCH: Self = Self(4);
    pub const NOT_MERGED_ALIASING: Self = Self(5);
    pub const NOT_MERGED_DEPENDENCIES: Self = Self(6);
    pub const NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT: Self = Self(7);
    pub const NOT_MERGED_TOO_MANY_ATTACHMENTS: Self = Self(8);
    pub const NOT_MERGED_INSUFFICIENT_STORAGE: Self = Self(9);
    pub const NOT_MERGED_DEPTH_STENCIL_COUNT: Self = Self(10);
    pub const NOT_MERGED_RESOLVE_ATTACHMENT_REUSE: Self = Self(11);
    pub const NOT_MERGED_SINGLE_SUBPASS: Self = Self(12);
    pub const NOT_MERGED_UNSPECIFIED: Self = Self(13);
}
impl fmt::Display for SubpassMergeStatusEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"MERGED"),
            1 => Some(&"DISALLOWED"),
            2 => Some(&"NOT_MERGED_SIDE_EFFECTS"),
            3 => Some(&"NOT_MERGED_SAMPLES_MISMATCH"),
            4 => Some(&"NOT_MERGED_VIEWS_MISMATCH"),
            5 => Some(&"NOT_MERGED_ALIASING"),
            6 => Some(&"NOT_MERGED_DEPENDENCIES"),
            7 => Some(&"NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT"),
            8 => Some(&"NOT_MERGED_TOO_MANY_ATTACHMENTS"),
            9 => Some(&"NOT_MERGED_INSUFFICIENT_STORAGE"),
            10 => Some(&"NOT_MERGED_DEPTH_STENCIL_COUNT"),
            11 => Some(&"NOT_MERGED_RESOLVE_ATTACHMENT_REUSE"),
            12 => Some(&"NOT_MERGED_SINGLE_SUBPASS"),
            13 => Some(&"NOT_MERGED_UNSPECIFIED"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ProvokingVertexModeEXT(i32);
impl ProvokingVertexModeEXT {
    pub const FIRST_VERTEX: Self = Self(0);
    pub const LAST_VERTEX: Self = Self(1);
}
impl fmt::Display for ProvokingVertexModeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"FIRST_VERTEX"),
            1 => Some(&"LAST_VERTEX"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ColorSpaceKHR(i32);
impl ColorSpaceKHR {
    pub const SRGB_NONLINEAR: Self = Self(0);
    pub const COLORSPACE_SRGB_NONLINEAR: Self = Self::SRGB_NONLINEAR;
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const DISPLAY_P3_NONLINEAR_EXT: Self = Self(1000104001);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const EXTENDED_SRGB_LINEAR_EXT: Self = Self(1000104002);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const DISPLAY_P3_LINEAR_EXT: Self = Self(1000104003);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const DCI_P3_NONLINEAR_EXT: Self = Self(1000104004);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const BT709_LINEAR_EXT: Self = Self(1000104005);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const BT709_NONLINEAR_EXT: Self = Self(1000104006);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const BT2020_LINEAR_EXT: Self = Self(1000104007);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const HDR10_ST2084_EXT: Self = Self(1000104008);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const DOLBYVISION_EXT: Self = Self(1000104009);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const HDR10_HLG_EXT: Self = Self(1000104010);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const ADOBERGB_LINEAR_EXT: Self = Self(1000104011);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const ADOBERGB_NONLINEAR_EXT: Self = Self(1000104012);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const PASS_THROUGH_EXT: Self = Self(1000104013);
    /// Added by extension VK_EXT_swapchain_colorspace.
    pub const EXTENDED_SRGB_NONLINEAR_EXT: Self = Self(1000104014);
    pub const DCI_P3_LINEAR_EXT: Self = Self::DISPLAY_P3_LINEAR_EXT;
    /// Added by extension VK_AMD_display_native_hdr.
    pub const DISPLAY_NATIVE_AMD: Self = Self(1000213000);
}
impl fmt::Display for ColorSpaceKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"SRGB_NONLINEAR"),
            1000104001 => Some(&"DISPLAY_P3_NONLINEAR_EXT"),
            1000104002 => Some(&"EXTENDED_SRGB_LINEAR_EXT"),
            1000104003 => Some(&"DISPLAY_P3_LINEAR_EXT"),
            1000104004 => Some(&"DCI_P3_NONLINEAR_EXT"),
            1000104005 => Some(&"BT709_LINEAR_EXT"),
            1000104006 => Some(&"BT709_NONLINEAR_EXT"),
            1000104007 => Some(&"BT2020_LINEAR_EXT"),
            1000104008 => Some(&"HDR10_ST2084_EXT"),
            1000104009 => Some(&"DOLBYVISION_EXT"),
            1000104010 => Some(&"HDR10_HLG_EXT"),
            1000104011 => Some(&"ADOBERGB_LINEAR_EXT"),
            1000104012 => Some(&"ADOBERGB_NONLINEAR_EXT"),
            1000104013 => Some(&"PASS_THROUGH_EXT"),
            1000104014 => Some(&"EXTENDED_SRGB_NONLINEAR_EXT"),
            1000213000 => Some(&"DISPLAY_NATIVE_AMD"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PresentModeKHR(i32);
impl PresentModeKHR {
    pub const IMMEDIATE: Self = Self(0);
    pub const MAILBOX: Self = Self(1);
    pub const FIFO: Self = Self(2);
    pub const FIFO_RELAXED: Self = Self(3);
    /// Added by extension VK_KHR_shared_presentable_image.
    pub const SHARED_DEMAND_REFRESH: Self = Self(1000111000);
    /// Added by extension VK_KHR_shared_presentable_image.
    pub const SHARED_CONTINUOUS_REFRESH: Self = Self(1000111001);
}
impl fmt::Display for PresentModeKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"IMMEDIATE"),
            1 => Some(&"MAILBOX"),
            2 => Some(&"FIFO"),
            3 => Some(&"FIFO_RELAXED"),
            1000111000 => Some(&"SHARED_DEMAND_REFRESH"),
            1000111001 => Some(&"SHARED_CONTINUOUS_REFRESH"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DebugReportObjectTypeEXT(i32);
impl DebugReportObjectTypeEXT {
    pub const UNKNOWN: Self = Self(0);
    pub const INSTANCE: Self = Self(1);
    pub const PHYSICAL_DEVICE: Self = Self(2);
    pub const DEVICE: Self = Self(3);
    pub const QUEUE: Self = Self(4);
    pub const SEMAPHORE: Self = Self(5);
    pub const COMMAND_BUFFER: Self = Self(6);
    pub const FENCE: Self = Self(7);
    pub const DEVICE_MEMORY: Self = Self(8);
    pub const BUFFER: Self = Self(9);
    pub const IMAGE: Self = Self(10);
    pub const EVENT: Self = Self(11);
    pub const QUERY_POOL: Self = Self(12);
    pub const BUFFER_VIEW: Self = Self(13);
    pub const IMAGE_VIEW: Self = Self(14);
    pub const SHADER_MODULE: Self = Self(15);
    pub const PIPELINE_CACHE: Self = Self(16);
    pub const PIPELINE_LAYOUT: Self = Self(17);
    pub const RENDER_PASS: Self = Self(18);
    pub const PIPELINE: Self = Self(19);
    pub const DESCRIPTOR_SET_LAYOUT: Self = Self(20);
    pub const SAMPLER: Self = Self(21);
    pub const DESCRIPTOR_POOL: Self = Self(22);
    pub const DESCRIPTOR_SET: Self = Self(23);
    pub const FRAMEBUFFER: Self = Self(24);
    pub const COMMAND_POOL: Self = Self(25);
    pub const SURFACE_KHR: Self = Self(26);
    pub const SWAPCHAIN_KHR: Self = Self(27);
    pub const DEBUG_REPORT_CALLBACK_EXT: Self = Self(28);
    pub const DEBUG_REPORT: Self = Self::DEBUG_REPORT_CALLBACK_EXT;
    pub const DISPLAY_KHR: Self = Self(29);
    pub const DISPLAY_MODE_KHR: Self = Self(30);
    pub const VALIDATION_CACHE_EXT: Self = Self(33);
    pub const VALIDATION_CACHE: Self = Self::VALIDATION_CACHE_EXT;
    /// Added by extension VK_KHR_sampler_ycbcr_conversion.
    pub const SAMPLER_YCBCR_CONVERSION: Self = Self(1000156000);
    /// Added by extension VK_EXT_debug_report.
    pub const DESCRIPTOR_UPDATE_TEMPLATE: Self = Self(1000085000);
    /// Added by extension VK_NVX_binary_import.
    pub const CU_MODULE_NVX: Self = Self(1000029000);
    /// Added by extension VK_NVX_binary_import.
    pub const CU_FUNCTION_NVX: Self = Self(1000029001);
    pub const DESCRIPTOR_UPDATE_TEMPLATE_KHR: Self = Self::DESCRIPTOR_UPDATE_TEMPLATE;
    /// Added by extension VK_KHR_acceleration_structure.
    pub const ACCELERATION_STRUCTURE_KHR: Self = Self(1000150000);
    pub const SAMPLER_YCBCR_CONVERSION_KHR: Self = Self::SAMPLER_YCBCR_CONVERSION;
    /// Added by extension VK_NV_ray_tracing.
    pub const ACCELERATION_STRUCTURE_NV: Self = Self(1000165000);
    /// Added by extension VK_FUCHSIA_buffer_collection.
    pub const BUFFER_COLLECTION_FUCHSIA: Self = Self(1000366000);
}
impl fmt::Display for DebugReportObjectTypeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UNKNOWN"),
            1 => Some(&"INSTANCE"),
            2 => Some(&"PHYSICAL_DEVICE"),
            3 => Some(&"DEVICE"),
            4 => Some(&"QUEUE"),
            5 => Some(&"SEMAPHORE"),
            6 => Some(&"COMMAND_BUFFER"),
            7 => Some(&"FENCE"),
            8 => Some(&"DEVICE_MEMORY"),
            9 => Some(&"BUFFER"),
            10 => Some(&"IMAGE"),
            11 => Some(&"EVENT"),
            12 => Some(&"QUERY_POOL"),
            13 => Some(&"BUFFER_VIEW"),
            14 => Some(&"IMAGE_VIEW"),
            15 => Some(&"SHADER_MODULE"),
            16 => Some(&"PIPELINE_CACHE"),
            17 => Some(&"PIPELINE_LAYOUT"),
            18 => Some(&"RENDER_PASS"),
            19 => Some(&"PIPELINE"),
            20 => Some(&"DESCRIPTOR_SET_LAYOUT"),
            21 => Some(&"SAMPLER"),
            22 => Some(&"DESCRIPTOR_POOL"),
            23 => Some(&"DESCRIPTOR_SET"),
            24 => Some(&"FRAMEBUFFER"),
            25 => Some(&"COMMAND_POOL"),
            26 => Some(&"SURFACE_KHR"),
            27 => Some(&"SWAPCHAIN_KHR"),
            28 => Some(&"DEBUG_REPORT_CALLBACK_EXT"),
            29 => Some(&"DISPLAY_KHR"),
            30 => Some(&"DISPLAY_MODE_KHR"),
            33 => Some(&"VALIDATION_CACHE_EXT"),
            1000156000 => Some(&"SAMPLER_YCBCR_CONVERSION"),
            1000085000 => Some(&"DESCRIPTOR_UPDATE_TEMPLATE"),
            1000029000 => Some(&"CU_MODULE_NVX"),
            1000029001 => Some(&"CU_FUNCTION_NVX"),
            1000150000 => Some(&"ACCELERATION_STRUCTURE_KHR"),
            1000165000 => Some(&"ACCELERATION_STRUCTURE_NV"),
            1000366000 => Some(&"BUFFER_COLLECTION_FUCHSIA"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DeviceMemoryReportEventTypeEXT(i32);
impl DeviceMemoryReportEventTypeEXT {
    pub const ALLOCATE: Self = Self(0);
    pub const FREE: Self = Self(1);
    pub const IMPORT: Self = Self(2);
    pub const UNIMPORT: Self = Self(3);
    pub const ALLOCATION_FAILED: Self = Self(4);
}
impl fmt::Display for DeviceMemoryReportEventTypeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"ALLOCATE"),
            1 => Some(&"FREE"),
            2 => Some(&"IMPORT"),
            3 => Some(&"UNIMPORT"),
            4 => Some(&"ALLOCATION_FAILED"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct RasterizationOrderAMD(i32);
impl RasterizationOrderAMD {
    pub const STRICT: Self = Self(0);
    pub const RELAXED: Self = Self(1);
}
impl fmt::Display for RasterizationOrderAMD {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"STRICT"),
            1 => Some(&"RELAXED"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ValidationCheckEXT(i32);
impl ValidationCheckEXT {
    pub const ALL: Self = Self(0);
    pub const SHADERS: Self = Self(1);
}
impl fmt::Display for ValidationCheckEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"ALL"),
            1 => Some(&"SHADERS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ValidationFeatureEnableEXT(i32);
impl ValidationFeatureEnableEXT {
    pub const GPU_ASSISTED: Self = Self(0);
    pub const GPU_ASSISTED_RESERVE_BINDING_SLOT: Self = Self(1);
    pub const BEST_PRACTICES: Self = Self(2);
    pub const DEBUG_PRINTF: Self = Self(3);
    pub const SYNCHRONIZATION_VALIDATION: Self = Self(4);
}
impl fmt::Display for ValidationFeatureEnableEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"GPU_ASSISTED"),
            1 => Some(&"GPU_ASSISTED_RESERVE_BINDING_SLOT"),
            2 => Some(&"BEST_PRACTICES"),
            3 => Some(&"DEBUG_PRINTF"),
            4 => Some(&"SYNCHRONIZATION_VALIDATION"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ValidationFeatureDisableEXT(i32);
impl ValidationFeatureDisableEXT {
    pub const ALL: Self = Self(0);
    pub const SHADERS: Self = Self(1);
    pub const THREAD_SAFETY: Self = Self(2);
    pub const API_PARAMETERS: Self = Self(3);
    pub const OBJECT_LIFETIMES: Self = Self(4);
    pub const CORE_CHECKS: Self = Self(5);
    pub const UNIQUE_HANDLES: Self = Self(6);
    pub const SHADER_VALIDATION_CACHE: Self = Self(7);
}
impl fmt::Display for ValidationFeatureDisableEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"ALL"),
            1 => Some(&"SHADERS"),
            2 => Some(&"THREAD_SAFETY"),
            3 => Some(&"API_PARAMETERS"),
            4 => Some(&"OBJECT_LIFETIMES"),
            5 => Some(&"CORE_CHECKS"),
            6 => Some(&"UNIQUE_HANDLES"),
            7 => Some(&"SHADER_VALIDATION_CACHE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DisplayPowerStateEXT(i32);
impl DisplayPowerStateEXT {
    pub const OFF: Self = Self(0);
    pub const SUSPEND: Self = Self(1);
    pub const ON: Self = Self(2);
}
impl fmt::Display for DisplayPowerStateEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"OFF"),
            1 => Some(&"SUSPEND"),
            2 => Some(&"ON"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DeviceEventTypeEXT(i32);
impl DeviceEventTypeEXT {
    pub const DISPLAY_HOTPLUG: Self = Self(0);
}
impl fmt::Display for DeviceEventTypeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DISPLAY_HOTPLUG"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DisplayEventTypeEXT(i32);
impl DisplayEventTypeEXT {
    pub const FIRST_PIXEL_OUT: Self = Self(0);
}
impl fmt::Display for DisplayEventTypeEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"FIRST_PIXEL_OUT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct TessellationDomainOrigin(i32);
impl TessellationDomainOrigin {
    pub const UPPER_LEFT: Self = Self(0);
    pub const LOWER_LEFT: Self = Self(1);
    pub const UPPER_LEFT_KHR: Self = Self::UPPER_LEFT;
    pub const LOWER_LEFT_KHR: Self = Self::LOWER_LEFT;
}
impl fmt::Display for TessellationDomainOrigin {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UPPER_LEFT"),
            1 => Some(&"LOWER_LEFT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type TessellationDomainOriginKHR = TessellationDomainOrigin;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SamplerYcbcrModelConversion(i32);
impl SamplerYcbcrModelConversion {
    pub const RGB_IDENTITY: Self = Self(0);
    /// just range expansion
    pub const YCBCR_IDENTITY: Self = Self(1);
    /// aka HD YUV
    pub const YCBCR_709: Self = Self(2);
    /// aka SD YUV
    pub const YCBCR_601: Self = Self(3);
    /// aka UHD YUV
    pub const YCBCR_2020: Self = Self(4);
    pub const RGB_IDENTITY_KHR: Self = Self::RGB_IDENTITY;
    pub const YCBCR_IDENTITY_KHR: Self = Self::YCBCR_IDENTITY;
    pub const YCBCR_709_KHR: Self = Self::YCBCR_709;
    pub const YCBCR_601_KHR: Self = Self::YCBCR_601;
    pub const YCBCR_2020_KHR: Self = Self::YCBCR_2020;
}
impl fmt::Display for SamplerYcbcrModelConversion {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"RGB_IDENTITY"),
            1 => Some(&"YCBCR_IDENTITY"),
            2 => Some(&"YCBCR_709"),
            3 => Some(&"YCBCR_601"),
            4 => Some(&"YCBCR_2020"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type SamplerYcbcrModelConversionKHR = SamplerYcbcrModelConversion;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SamplerYcbcrRange(i32);
impl SamplerYcbcrRange {
    /// Luma 0..1 maps to 0..255, chroma -0.5..0.5 to 1..255 (clamped)
    pub const ITU_FULL: Self = Self(0);
    /// Luma 0..1 maps to 16..235, chroma -0.5..0.5 to 16..240
    pub const ITU_NARROW: Self = Self(1);
    pub const ITU_FULL_KHR: Self = Self::ITU_FULL;
    pub const ITU_NARROW_KHR: Self = Self::ITU_NARROW;
}
impl fmt::Display for SamplerYcbcrRange {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"ITU_FULL"),
            1 => Some(&"ITU_NARROW"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type SamplerYcbcrRangeKHR = SamplerYcbcrRange;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ChromaLocation(i32);
impl ChromaLocation {
    pub const COSITED_EVEN: Self = Self(0);
    pub const MIDPOINT: Self = Self(1);
    pub const COSITED_EVEN_KHR: Self = Self::COSITED_EVEN;
    pub const MIDPOINT_KHR: Self = Self::MIDPOINT;
}
impl fmt::Display for ChromaLocation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"COSITED_EVEN"),
            1 => Some(&"MIDPOINT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type ChromaLocationKHR = ChromaLocation;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct SamplerReductionMode(i32);
impl SamplerReductionMode {
    pub const WEIGHTED_AVERAGE: Self = Self(0);
    pub const MIN: Self = Self(1);
    pub const MAX: Self = Self(2);
    pub const WEIGHTED_AVERAGE_EXT: Self = Self::WEIGHTED_AVERAGE;
    pub const MIN_EXT: Self = Self::MIN;
    pub const MAX_EXT: Self = Self::MAX;
}
impl fmt::Display for SamplerReductionMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"WEIGHTED_AVERAGE"),
            1 => Some(&"MIN"),
            2 => Some(&"MAX"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type SamplerReductionModeEXT = SamplerReductionMode;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct BlendOverlapEXT(i32);
impl BlendOverlapEXT {
    pub const UNCORRELATED: Self = Self(0);
    pub const DISJOINT: Self = Self(1);
    pub const CONJOINT: Self = Self(2);
}
impl fmt::Display for BlendOverlapEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"UNCORRELATED"),
            1 => Some(&"DISJOINT"),
            2 => Some(&"CONJOINT"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct FullScreenExclusiveEXT(i32);
impl FullScreenExclusiveEXT {
    pub const DEFAULT: Self = Self(0);
    pub const ALLOWED: Self = Self(1);
    pub const DISALLOWED: Self = Self(2);
    pub const APPLICATION_CONTROLLED: Self = Self(3);
}
impl fmt::Display for FullScreenExclusiveEXT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DEFAULT"),
            1 => Some(&"ALLOWED"),
            2 => Some(&"DISALLOWED"),
            3 => Some(&"APPLICATION_CONTROLLED"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ShaderFloatControlsIndependence(i32);
impl ShaderFloatControlsIndependence {
    pub const N32_BIT_ONLY: Self = Self(0);
    pub const ALL: Self = Self(1);
    pub const NONE: Self = Self(2);
    pub const N32_BIT_ONLY_KHR: Self = Self::N32_BIT_ONLY;
    pub const ALL_KHR: Self = Self::ALL;
    pub const NONE_KHR: Self = Self::NONE;
}
impl fmt::Display for ShaderFloatControlsIndependence {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"N32_BIT_ONLY"),
            1 => Some(&"ALL"),
            2 => Some(&"NONE"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type ShaderFloatControlsIndependenceKHR = ShaderFloatControlsIndependence;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct FragmentShadingRateCombinerOpKHR(i32);
impl FragmentShadingRateCombinerOpKHR {
    pub const KEEP: Self = Self(0);
    pub const REPLACE: Self = Self(1);
    pub const MIN: Self = Self(2);
    pub const MAX: Self = Self(3);
    pub const MUL: Self = Self(4);
}
impl fmt::Display for FragmentShadingRateCombinerOpKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"KEEP"),
            1 => Some(&"REPLACE"),
            2 => Some(&"MIN"),
            3 => Some(&"MAX"),
            4 => Some(&"MUL"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct VendorId(i32);
impl VendorId {
    /// Vivante vendor ID
    pub const VIV: Self = Self(65537);
    /// VeriSilicon vendor ID
    pub const VSI: Self = Self(65538);
    /// Kazan Software Renderer
    pub const KAZAN: Self = Self(65539);
    /// Codeplay Software Ltd. vendor ID
    pub const CODEPLAY: Self = Self(65540);
    /// Mesa vendor ID
    pub const MESA: Self = Self(65541);
    /// PoCL vendor ID
    pub const POCL: Self = Self(65542);
}
impl fmt::Display for VendorId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            65537 => Some(&"VIV"),
            65538 => Some(&"VSI"),
            65539 => Some(&"KAZAN"),
            65540 => Some(&"CODEPLAY"),
            65541 => Some(&"MESA"),
            65542 => Some(&"POCL"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct DriverId(i32);
impl DriverId {
    /// Advanced Micro Devices, Inc.
    pub const AMD_PROPRIETARY: Self = Self(1);
    /// Advanced Micro Devices, Inc.
    pub const AMD_OPEN_SOURCE: Self = Self(2);
    /// Mesa open source project
    pub const MESA_RADV: Self = Self(3);
    /// NVIDIA Corporation
    pub const NVIDIA_PROPRIETARY: Self = Self(4);
    /// Intel Corporation
    pub const INTEL_PROPRIETARY_WINDOWS: Self = Self(5);
    /// Intel Corporation
    pub const INTEL_OPEN_SOURCE_MESA: Self = Self(6);
    /// Imagination Technologies
    pub const IMAGINATION_PROPRIETARY: Self = Self(7);
    /// Qualcomm Technologies, Inc.
    pub const QUALCOMM_PROPRIETARY: Self = Self(8);
    /// Arm Limited
    pub const ARM_PROPRIETARY: Self = Self(9);
    /// Google LLC
    pub const GOOGLE_SWIFTSHADER: Self = Self(10);
    /// Google LLC
    pub const GGP_PROPRIETARY: Self = Self(11);
    /// Broadcom Inc.
    pub const BROADCOM_PROPRIETARY: Self = Self(12);
    /// Mesa
    pub const MESA_LLVMPIPE: Self = Self(13);
    /// MoltenVK
    pub const MOLTENVK: Self = Self(14);
    /// Core Avionics & Industrial Inc.
    pub const COREAVI_PROPRIETARY: Self = Self(15);
    /// Juice Technologies, Inc.
    pub const JUICE_PROPRIETARY: Self = Self(16);
    /// Verisilicon, Inc.
    pub const VERISILICON_PROPRIETARY: Self = Self(17);
    /// Mesa open source project
    pub const MESA_TURNIP: Self = Self(18);
    /// Mesa open source project
    pub const MESA_V3DV: Self = Self(19);
    /// Mesa open source project
    pub const MESA_PANVK: Self = Self(20);
    /// Samsung Electronics Co., Ltd.
    pub const SAMSUNG_PROPRIETARY: Self = Self(21);
    /// Mesa open source project
    pub const MESA_VENUS: Self = Self(22);
    pub const AMD_PROPRIETARY_KHR: Self = Self::AMD_PROPRIETARY;
    pub const AMD_OPEN_SOURCE_KHR: Self = Self::AMD_OPEN_SOURCE;
    pub const MESA_RADV_KHR: Self = Self::MESA_RADV;
    pub const NVIDIA_PROPRIETARY_KHR: Self = Self::NVIDIA_PROPRIETARY;
    pub const INTEL_PROPRIETARY_WINDOWS_KHR: Self = Self::INTEL_PROPRIETARY_WINDOWS;
    pub const INTEL_OPEN_SOURCE_MESA_KHR: Self = Self::INTEL_OPEN_SOURCE_MESA;
    pub const IMAGINATION_PROPRIETARY_KHR: Self = Self::IMAGINATION_PROPRIETARY;
    pub const QUALCOMM_PROPRIETARY_KHR: Self = Self::QUALCOMM_PROPRIETARY;
    pub const ARM_PROPRIETARY_KHR: Self = Self::ARM_PROPRIETARY;
    pub const GOOGLE_SWIFTSHADER_KHR: Self = Self::GOOGLE_SWIFTSHADER;
    pub const GGP_PROPRIETARY_KHR: Self = Self::GGP_PROPRIETARY;
    pub const BROADCOM_PROPRIETARY_KHR: Self = Self::BROADCOM_PROPRIETARY;
}
impl fmt::Display for DriverId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            1 => Some(&"AMD_PROPRIETARY"),
            2 => Some(&"AMD_OPEN_SOURCE"),
            3 => Some(&"MESA_RADV"),
            4 => Some(&"NVIDIA_PROPRIETARY"),
            5 => Some(&"INTEL_PROPRIETARY_WINDOWS"),
            6 => Some(&"INTEL_OPEN_SOURCE_MESA"),
            7 => Some(&"IMAGINATION_PROPRIETARY"),
            8 => Some(&"QUALCOMM_PROPRIETARY"),
            9 => Some(&"ARM_PROPRIETARY"),
            10 => Some(&"GOOGLE_SWIFTSHADER"),
            11 => Some(&"GGP_PROPRIETARY"),
            12 => Some(&"BROADCOM_PROPRIETARY"),
            13 => Some(&"MESA_LLVMPIPE"),
            14 => Some(&"MOLTENVK"),
            15 => Some(&"COREAVI_PROPRIETARY"),
            16 => Some(&"JUICE_PROPRIETARY"),
            17 => Some(&"VERISILICON_PROPRIETARY"),
            18 => Some(&"MESA_TURNIP"),
            19 => Some(&"MESA_V3DV"),
            20 => Some(&"MESA_PANVK"),
            21 => Some(&"SAMSUNG_PROPRIETARY"),
            22 => Some(&"MESA_VENUS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type DriverIdKHR = DriverId;
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct ShadingRatePaletteEntryNV(i32);
impl ShadingRatePaletteEntryNV {
    pub const NO_INVOCATIONS: Self = Self(0);
    pub const N16_INVOCATIONS_PER_PIXEL: Self = Self(1);
    pub const N8_INVOCATIONS_PER_PIXEL: Self = Self(2);
    pub const N4_INVOCATIONS_PER_PIXEL: Self = Self(3);
    pub const N2_INVOCATIONS_PER_PIXEL: Self = Self(4);
    pub const N1_INVOCATION_PER_PIXEL: Self = Self(5);
    pub const N1_INVOCATION_PER_2X1_PIXELS: Self = Self(6);
    pub const N1_INVOCATION_PER_1X2_PIXELS: Self = Self(7);
    pub const N1_INVOCATION_PER_2X2_PIXELS: Self = Self(8);
    pub const N1_INVOCATION_PER_4X2_PIXELS: Self = Self(9);
    pub const N1_INVOCATION_PER_2X4_PIXELS: Self = Self(10);
    pub const N1_INVOCATION_PER_4X4_PIXELS: Self = Self(11);
}
impl fmt::Display for ShadingRatePaletteEntryNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"NO_INVOCATIONS"),
            1 => Some(&"N16_INVOCATIONS_PER_PIXEL"),
            2 => Some(&"N8_INVOCATIONS_PER_PIXEL"),
            3 => Some(&"N4_INVOCATIONS_PER_PIXEL"),
            4 => Some(&"N2_INVOCATIONS_PER_PIXEL"),
            5 => Some(&"N1_INVOCATION_PER_PIXEL"),
            6 => Some(&"N1_INVOCATION_PER_2X1_PIXELS"),
            7 => Some(&"N1_INVOCATION_PER_1X2_PIXELS"),
            8 => Some(&"N1_INVOCATION_PER_2X2_PIXELS"),
            9 => Some(&"N1_INVOCATION_PER_4X2_PIXELS"),
            10 => Some(&"N1_INVOCATION_PER_2X4_PIXELS"),
            11 => Some(&"N1_INVOCATION_PER_4X4_PIXELS"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct CoarseSampleOrderTypeNV(i32);
impl CoarseSampleOrderTypeNV {
    pub const DEFAULT: Self = Self(0);
    pub const CUSTOM: Self = Self(1);
    pub const PIXEL_MAJOR: Self = Self(2);
    pub const SAMPLE_MAJOR: Self = Self(3);
}
impl fmt::Display for CoarseSampleOrderTypeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"DEFAULT"),
            1 => Some(&"CUSTOM"),
            2 => Some(&"PIXEL_MAJOR"),
            3 => Some(&"SAMPLE_MAJOR"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct PipelineExecutableStatisticFormatKHR(i32);
impl PipelineExecutableStatisticFormatKHR {
    pub const BOOL32: Self = Self(0);
    pub const INT64: Self = Self(1);
    pub const UINT64: Self = Self(2);
    pub const FLOAT64: Self = Self(3);
}
impl fmt::Display for PipelineExecutableStatisticFormatKHR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"BOOL32"),
            1 => Some(&"INT64"),
            2 => Some(&"UINT64"),
            3 => Some(&"FLOAT64"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
pub type FnInternalAllocationNotification = unsafe extern "system" fn(
    p_user_data: *mut c_void,
    size: usize,
    allocation_type: InternalAllocationType,
    allocation_scope: SystemAllocationScope,
);
pub type FnInternalFreeNotification = unsafe extern "system" fn(
    p_user_data: *mut c_void,
    size: usize,
    allocation_type: InternalAllocationType,
    allocation_scope: SystemAllocationScope,
);
pub type FnReallocationFunction = unsafe extern "system" fn(
    p_user_data: *mut c_void,
    p_original: *mut c_void,
    size: usize,
    alignment: usize,
    allocation_scope: SystemAllocationScope,
) -> *mut c_void;
pub type FnAllocationFunction = unsafe extern "system" fn(
    p_user_data: *mut c_void,
    size: usize,
    alignment: usize,
    allocation_scope: SystemAllocationScope,
) -> *mut c_void;
pub type FnFreeFunction = unsafe extern "system" fn(p_user_data: *mut c_void, p_memory: *mut c_void);
pub type FnVoidFunction = unsafe extern "system" fn();
pub type FnDebugReportCallbackEXT = unsafe extern "system" fn(
    flags: DebugReportFlagsEXT,
    object_type: DebugReportObjectTypeEXT,
    object: u64,
    location: usize,
    message_code: i32,
    p_layer_prefix: *const c_char,
    p_message: *const c_char,
    p_user_data: *mut c_void,
) -> Bool32;
pub type FnDebugUtilsMessengerCallbackEXT = unsafe extern "system" fn(
    message_severity: DebugUtilsMessageSeverityFlagsEXT,
    message_types: DebugUtilsMessageTypeFlagsEXT,
    p_callback_data: *const DebugUtilsMessengerCallbackDataEXT,
    p_user_data: *mut c_void,
) -> Bool32;
pub type FnDeviceMemoryReportCallbackEXT =
    unsafe extern "system" fn(p_callback_data: *const DeviceMemoryReportCallbackDataEXT, p_user_data: *mut c_void);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BaseOutStructure {
    pub s_type: StructureType,
    pub p_next: *mut BaseOutStructure,
}
unsafe impl Send for BaseOutStructure {}
unsafe impl Sync for BaseOutStructure {}
impl Default for BaseOutStructure {
    fn default() -> Self {
        Self {
            s_type: Default::default(),
            p_next: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for BaseOutStructure {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BaseOutStructure")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BaseInStructure {
    pub s_type: StructureType,
    pub p_next: *const BaseInStructure,
}
unsafe impl Send for BaseInStructure {}
unsafe impl Sync for BaseInStructure {}
impl Default for BaseInStructure {
    fn default() -> Self {
        Self {
            s_type: Default::default(),
            p_next: ptr::null(),
        }
    }
}
impl fmt::Debug for BaseInStructure {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BaseInStructure")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct Offset2D {
    pub x: i32,
    pub y: i32,
}
impl fmt::Debug for Offset2D {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Offset2D")
            .field("x", &self.x)
            .field("y", &self.y)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct Offset3D {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl fmt::Debug for Offset3D {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Offset3D")
            .field("x", &self.x)
            .field("y", &self.y)
            .field("z", &self.z)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct Extent2D {
    pub width: u32,
    pub height: u32,
}
impl fmt::Debug for Extent2D {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Extent2D")
            .field("width", &self.width)
            .field("height", &self.height)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct Extent3D {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
impl fmt::Debug for Extent3D {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Extent3D")
            .field("width", &self.width)
            .field("height", &self.height)
            .field("depth", &self.depth)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct Viewport {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    pub min_depth: f32,
    pub max_depth: f32,
}
impl fmt::Debug for Viewport {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Viewport")
            .field("x", &self.x)
            .field("y", &self.y)
            .field("width", &self.width)
            .field("height", &self.height)
            .field("min_depth", &self.min_depth)
            .field("max_depth", &self.max_depth)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct Rect2D {
    pub offset: Offset2D,
    pub extent: Extent2D,
}
impl fmt::Debug for Rect2D {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Rect2D")
            .field("offset", &self.offset)
            .field("extent", &self.extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ClearRect {
    pub rect: Rect2D,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
impl fmt::Debug for ClearRect {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ClearRect")
            .field("rect", &self.rect)
            .field("base_array_layer", &self.base_array_layer)
            .field("layer_count", &self.layer_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ComponentMapping {
    pub r: ComponentSwizzle,
    pub g: ComponentSwizzle,
    pub b: ComponentSwizzle,
    pub a: ComponentSwizzle,
}
impl fmt::Debug for ComponentMapping {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ComponentMapping")
            .field("r", &self.r)
            .field("g", &self.g)
            .field("b", &self.b)
            .field("a", &self.a)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceProperties {
    pub api_version: Version,
    pub driver_version: u32,
    pub vendor_id: u32,
    pub device_id: u32,
    pub device_type: PhysicalDeviceType,
    pub device_name: [c_char; MAX_PHYSICAL_DEVICE_NAME_SIZE],
    pub pipeline_cache_uuid: [u8; UUID_SIZE],
    pub limits: PhysicalDeviceLimits,
    pub sparse_properties: PhysicalDeviceSparseProperties,
}
impl Default for PhysicalDeviceProperties {
    fn default() -> Self {
        Self {
            api_version: Default::default(),
            driver_version: Default::default(),
            vendor_id: Default::default(),
            device_id: Default::default(),
            device_type: Default::default(),
            device_name: [Default::default(); MAX_PHYSICAL_DEVICE_NAME_SIZE],
            pipeline_cache_uuid: [Default::default(); UUID_SIZE],
            limits: Default::default(),
            sparse_properties: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceProperties")
            .field("api_version", &self.api_version)
            .field("driver_version", &self.driver_version)
            .field("vendor_id", &self.vendor_id)
            .field("device_id", &self.device_id)
            .field("device_type", &self.device_type)
            .field("device_name", &unsafe { CStr::from_ptr(self.device_name.as_ptr()) })
            .field("pipeline_cache_uuid", &self.pipeline_cache_uuid)
            .field("limits", &self.limits)
            .field("sparse_properties", &self.sparse_properties)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExtensionProperties {
    /// extension name
    pub extension_name: [c_char; MAX_EXTENSION_NAME_SIZE],
    /// version of the extension specification implemented
    pub spec_version: u32,
}
impl Default for ExtensionProperties {
    fn default() -> Self {
        Self {
            extension_name: [Default::default(); MAX_EXTENSION_NAME_SIZE],
            spec_version: Default::default(),
        }
    }
}
impl fmt::Debug for ExtensionProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExtensionProperties")
            .field("extension_name", &unsafe {
                CStr::from_ptr(self.extension_name.as_ptr())
            })
            .field("spec_version", &self.spec_version)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LayerProperties {
    /// layer name
    pub layer_name: [c_char; MAX_EXTENSION_NAME_SIZE],
    /// version of the layer specification implemented
    pub spec_version: Version,
    /// build or release version of the layer's library
    pub implementation_version: u32,
    /// Free-form description of the layer
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
}
impl Default for LayerProperties {
    fn default() -> Self {
        Self {
            layer_name: [Default::default(); MAX_EXTENSION_NAME_SIZE],
            spec_version: Default::default(),
            implementation_version: Default::default(),
            description: [Default::default(); MAX_DESCRIPTION_SIZE],
        }
    }
}
impl fmt::Debug for LayerProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("LayerProperties")
            .field("layer_name", &unsafe { CStr::from_ptr(self.layer_name.as_ptr()) })
            .field("spec_version", &self.spec_version)
            .field("implementation_version", &self.implementation_version)
            .field("description", &unsafe { CStr::from_ptr(self.description.as_ptr()) })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ApplicationInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_application_name: *const c_char,
    pub application_version: u32,
    pub p_engine_name: *const c_char,
    pub engine_version: u32,
    pub api_version: Version,
}
unsafe impl Send for ApplicationInfo {}
unsafe impl Sync for ApplicationInfo {}
impl Default for ApplicationInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::APPLICATION_INFO,
            p_next: ptr::null(),
            p_application_name: ptr::null(),
            application_version: Default::default(),
            p_engine_name: ptr::null(),
            engine_version: Default::default(),
            api_version: Default::default(),
        }
    }
}
impl fmt::Debug for ApplicationInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ApplicationInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_application_name", &self.p_application_name)
            .field("application_version", &self.application_version)
            .field("p_engine_name", &self.p_engine_name)
            .field("engine_version", &self.engine_version)
            .field("api_version", &self.api_version)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AllocationCallbacks {
    pub p_user_data: *mut c_void,
    pub pfn_allocation: Option<FnAllocationFunction>,
    pub pfn_reallocation: Option<FnReallocationFunction>,
    pub pfn_free: Option<FnFreeFunction>,
    pub pfn_internal_allocation: Option<FnInternalAllocationNotification>,
    pub pfn_internal_free: Option<FnInternalFreeNotification>,
}
unsafe impl Send for AllocationCallbacks {}
unsafe impl Sync for AllocationCallbacks {}
impl Default for AllocationCallbacks {
    fn default() -> Self {
        Self {
            p_user_data: ptr::null_mut(),
            pfn_allocation: Default::default(),
            pfn_reallocation: Default::default(),
            pfn_free: Default::default(),
            pfn_internal_allocation: Default::default(),
            pfn_internal_free: Default::default(),
        }
    }
}
impl fmt::Debug for AllocationCallbacks {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AllocationCallbacks")
            .field("p_user_data", &self.p_user_data)
            .field(
                "pfn_allocation",
                if self.pfn_allocation.is_some() {
                    &"Some"
                } else {
                    &"None"
                },
            )
            .field(
                "pfn_reallocation",
                if self.pfn_reallocation.is_some() {
                    &"Some"
                } else {
                    &"None"
                },
            )
            .field("pfn_free", if self.pfn_free.is_some() { &"Some" } else { &"None" })
            .field(
                "pfn_internal_allocation",
                if self.pfn_internal_allocation.is_some() {
                    &"Some"
                } else {
                    &"None"
                },
            )
            .field(
                "pfn_internal_free",
                if self.pfn_internal_free.is_some() {
                    &"Some"
                } else {
                    &"None"
                },
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceQueueCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceQueueCreateFlags,
    pub queue_family_index: u32,
    pub queue_count: u32,
    pub p_queue_priorities: *const f32,
}
unsafe impl Send for DeviceQueueCreateInfo {}
unsafe impl Sync for DeviceQueueCreateInfo {}
impl Default for DeviceQueueCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_QUEUE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            queue_family_index: Default::default(),
            queue_count: Default::default(),
            p_queue_priorities: ptr::null(),
        }
    }
}
impl fmt::Debug for DeviceQueueCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceQueueCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("queue_family_index", &self.queue_family_index)
            .field("queue_count", &self.queue_count)
            .field("p_queue_priorities", &self.p_queue_priorities)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceCreateFlags,
    pub queue_create_info_count: u32,
    pub p_queue_create_infos: *const DeviceQueueCreateInfo,
    pub enabled_layer_count: u32,
    /// Ordered list of layer names to be enabled
    pub pp_enabled_layer_names: *const *const c_char,
    pub enabled_extension_count: u32,
    pub pp_enabled_extension_names: *const *const c_char,
    pub p_enabled_features: *const PhysicalDeviceFeatures,
}
unsafe impl Send for DeviceCreateInfo {}
unsafe impl Sync for DeviceCreateInfo {}
impl Default for DeviceCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            queue_create_info_count: Default::default(),
            p_queue_create_infos: ptr::null(),
            enabled_layer_count: Default::default(),
            pp_enabled_layer_names: ptr::null(),
            enabled_extension_count: Default::default(),
            pp_enabled_extension_names: ptr::null(),
            p_enabled_features: ptr::null(),
        }
    }
}
impl fmt::Debug for DeviceCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("queue_create_info_count", &self.queue_create_info_count)
            .field("p_queue_create_infos", &self.p_queue_create_infos)
            .field("enabled_layer_count", &self.enabled_layer_count)
            .field("pp_enabled_layer_names", &self.pp_enabled_layer_names)
            .field("enabled_extension_count", &self.enabled_extension_count)
            .field("pp_enabled_extension_names", &self.pp_enabled_extension_names)
            .field("p_enabled_features", &self.p_enabled_features)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct InstanceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: InstanceCreateFlags,
    pub p_application_info: *const ApplicationInfo,
    pub enabled_layer_count: u32,
    /// Ordered list of layer names to be enabled
    pub pp_enabled_layer_names: *const *const c_char,
    pub enabled_extension_count: u32,
    /// Extension names to be enabled
    pub pp_enabled_extension_names: *const *const c_char,
}
unsafe impl Send for InstanceCreateInfo {}
unsafe impl Sync for InstanceCreateInfo {}
impl Default for InstanceCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::INSTANCE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            p_application_info: ptr::null(),
            enabled_layer_count: Default::default(),
            pp_enabled_layer_names: ptr::null(),
            enabled_extension_count: Default::default(),
            pp_enabled_extension_names: ptr::null(),
        }
    }
}
impl fmt::Debug for InstanceCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("InstanceCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("p_application_info", &self.p_application_info)
            .field("enabled_layer_count", &self.enabled_layer_count)
            .field("pp_enabled_layer_names", &self.pp_enabled_layer_names)
            .field("enabled_extension_count", &self.enabled_extension_count)
            .field("pp_enabled_extension_names", &self.pp_enabled_extension_names)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct QueueFamilyProperties {
    /// Queue flags
    pub queue_flags: QueueFlags,
    pub queue_count: u32,
    pub timestamp_valid_bits: u32,
    /// Minimum alignment requirement for image transfers
    pub min_image_transfer_granularity: Extent3D,
}
impl fmt::Debug for QueueFamilyProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueueFamilyProperties")
            .field("queue_flags", &self.queue_flags)
            .field("queue_count", &self.queue_count)
            .field("timestamp_valid_bits", &self.timestamp_valid_bits)
            .field("min_image_transfer_granularity", &self.min_image_transfer_granularity)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMemoryProperties {
    pub memory_type_count: u32,
    pub memory_types: [MemoryType; MAX_MEMORY_TYPES],
    pub memory_heap_count: u32,
    pub memory_heaps: [MemoryHeap; MAX_MEMORY_HEAPS],
}
impl Default for PhysicalDeviceMemoryProperties {
    fn default() -> Self {
        Self {
            memory_type_count: Default::default(),
            memory_types: [Default::default(); MAX_MEMORY_TYPES],
            memory_heap_count: Default::default(),
            memory_heaps: [Default::default(); MAX_MEMORY_HEAPS],
        }
    }
}
impl fmt::Debug for PhysicalDeviceMemoryProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMemoryProperties")
            .field("memory_type_count", &self.memory_type_count)
            .field("memory_types", &self.memory_types)
            .field("memory_heap_count", &self.memory_heap_count)
            .field("memory_heaps", &self.memory_heaps)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Size of memory allocation
    pub allocation_size: DeviceSize,
    /// Index of the of the memory type to allocate from
    pub memory_type_index: u32,
}
unsafe impl Send for MemoryAllocateInfo {}
unsafe impl Sync for MemoryAllocateInfo {}
impl Default for MemoryAllocateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_ALLOCATE_INFO,
            p_next: ptr::null(),
            allocation_size: Default::default(),
            memory_type_index: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryAllocateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryAllocateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("allocation_size", &self.allocation_size)
            .field("memory_type_index", &self.memory_type_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct MemoryRequirements {
    /// Specified in bytes
    pub size: DeviceSize,
    /// Specified in bytes
    pub alignment: DeviceSize,
    /// Bitmask of the allowed memory type indices into memoryTypes[] for this object
    pub memory_type_bits: u32,
}
impl fmt::Debug for MemoryRequirements {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryRequirements")
            .field("size", &self.size)
            .field("alignment", &self.alignment)
            .field("memory_type_bits", &self.memory_type_bits)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SparseImageFormatProperties {
    pub aspect_mask: ImageAspectFlags,
    pub image_granularity: Extent3D,
    pub flags: SparseImageFormatFlags,
}
impl fmt::Debug for SparseImageFormatProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseImageFormatProperties")
            .field("aspect_mask", &self.aspect_mask)
            .field("image_granularity", &self.image_granularity)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SparseImageMemoryRequirements {
    pub format_properties: SparseImageFormatProperties,
    pub image_mip_tail_first_lod: u32,
    /// Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    pub image_mip_tail_size: DeviceSize,
    /// Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    pub image_mip_tail_offset: DeviceSize,
    /// Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    pub image_mip_tail_stride: DeviceSize,
}
impl fmt::Debug for SparseImageMemoryRequirements {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseImageMemoryRequirements")
            .field("format_properties", &self.format_properties)
            .field("image_mip_tail_first_lod", &self.image_mip_tail_first_lod)
            .field("image_mip_tail_size", &self.image_mip_tail_size)
            .field("image_mip_tail_offset", &self.image_mip_tail_offset)
            .field("image_mip_tail_stride", &self.image_mip_tail_stride)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct MemoryType {
    /// Memory properties of this memory type
    pub property_flags: MemoryPropertyFlags,
    /// Index of the memory heap allocations of this memory type are taken from
    pub heap_index: u32,
}
impl fmt::Debug for MemoryType {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryType")
            .field("property_flags", &self.property_flags)
            .field("heap_index", &self.heap_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct MemoryHeap {
    /// Available memory in the heap
    pub size: DeviceSize,
    /// Flags for the heap
    pub flags: MemoryHeapFlags,
}
impl fmt::Debug for MemoryHeap {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryHeap")
            .field("size", &self.size)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MappedMemoryRange {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Mapped memory object
    pub memory: Option<DeviceMemory>,
    /// Offset within the memory object where the range starts
    pub offset: DeviceSize,
    /// Size of the range within the memory object
    pub size: DeviceSize,
}
unsafe impl Send for MappedMemoryRange {}
unsafe impl Sync for MappedMemoryRange {}
impl Default for MappedMemoryRange {
    fn default() -> Self {
        Self {
            s_type: StructureType::MAPPED_MEMORY_RANGE,
            p_next: ptr::null(),
            memory: Default::default(),
            offset: Default::default(),
            size: Default::default(),
        }
    }
}
impl fmt::Debug for MappedMemoryRange {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MappedMemoryRange")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct FormatProperties {
    /// Format features in case of linear tiling
    pub linear_tiling_features: FormatFeatureFlags,
    /// Format features in case of optimal tiling
    pub optimal_tiling_features: FormatFeatureFlags,
    /// Format features supported by buffers
    pub buffer_features: FormatFeatureFlags,
}
impl fmt::Debug for FormatProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FormatProperties")
            .field("linear_tiling_features", &self.linear_tiling_features)
            .field("optimal_tiling_features", &self.optimal_tiling_features)
            .field("buffer_features", &self.buffer_features)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImageFormatProperties {
    /// max image dimensions for this resource type
    pub max_extent: Extent3D,
    /// max number of mipmap levels for this resource type
    pub max_mip_levels: u32,
    /// max array size for this resource type
    pub max_array_layers: u32,
    /// supported sample counts for this resource type
    pub sample_counts: SampleCountFlags,
    /// max size (in bytes) of this resource type
    pub max_resource_size: DeviceSize,
}
impl fmt::Debug for ImageFormatProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageFormatProperties")
            .field("max_extent", &self.max_extent)
            .field("max_mip_levels", &self.max_mip_levels)
            .field("max_array_layers", &self.max_array_layers)
            .field("sample_counts", &self.sample_counts)
            .field("max_resource_size", &self.max_resource_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct DescriptorBufferInfo {
    /// Buffer used for this descriptor slot.
    pub buffer: Option<Buffer>,
    /// Base offset from buffer start in bytes to update in the descriptor set.
    pub offset: DeviceSize,
    /// Size in bytes of the buffer resource for this descriptor update.
    pub range: DeviceSize,
}
impl fmt::Debug for DescriptorBufferInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorBufferInfo")
            .field("buffer", &self.buffer)
            .field("offset", &self.offset)
            .field("range", &self.range)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct DescriptorImageInfo {
    /// Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise.
    pub sampler: Option<Sampler>,
    /// Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise.
    pub image_view: Option<ImageView>,
    /// Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE).
    pub image_layout: ImageLayout,
}
impl fmt::Debug for DescriptorImageInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorImageInfo")
            .field("sampler", &self.sampler)
            .field("image_view", &self.image_view)
            .field("image_layout", &self.image_layout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WriteDescriptorSet {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Destination descriptor set
    pub dst_set: Option<DescriptorSet>,
    /// Binding within the destination descriptor set to write
    pub dst_binding: u32,
    /// Array element within the destination binding to write
    pub dst_array_element: u32,
    /// Number of descriptors to write (determines the size of the array pointed by pDescriptors)
    pub descriptor_count: u32,
    /// Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used)
    pub descriptor_type: DescriptorType,
    /// Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types.
    pub p_image_info: *const DescriptorImageInfo,
    /// Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types.
    pub p_buffer_info: *const DescriptorBufferInfo,
    /// Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types.
    pub p_texel_buffer_view: *const BufferView,
}
unsafe impl Send for WriteDescriptorSet {}
unsafe impl Sync for WriteDescriptorSet {}
impl Default for WriteDescriptorSet {
    fn default() -> Self {
        Self {
            s_type: StructureType::WRITE_DESCRIPTOR_SET,
            p_next: ptr::null(),
            dst_set: Default::default(),
            dst_binding: Default::default(),
            dst_array_element: Default::default(),
            descriptor_count: Default::default(),
            descriptor_type: Default::default(),
            p_image_info: ptr::null(),
            p_buffer_info: ptr::null(),
            p_texel_buffer_view: ptr::null(),
        }
    }
}
impl fmt::Debug for WriteDescriptorSet {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("WriteDescriptorSet")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("dst_set", &self.dst_set)
            .field("dst_binding", &self.dst_binding)
            .field("dst_array_element", &self.dst_array_element)
            .field("descriptor_count", &self.descriptor_count)
            .field("descriptor_type", &self.descriptor_type)
            .field("p_image_info", &self.p_image_info)
            .field("p_buffer_info", &self.p_buffer_info)
            .field("p_texel_buffer_view", &self.p_texel_buffer_view)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyDescriptorSet {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Source descriptor set
    pub src_set: Option<DescriptorSet>,
    /// Binding within the source descriptor set to copy from
    pub src_binding: u32,
    /// Array element within the source binding to copy from
    pub src_array_element: u32,
    /// Destination descriptor set
    pub dst_set: Option<DescriptorSet>,
    /// Binding within the destination descriptor set to copy to
    pub dst_binding: u32,
    /// Array element within the destination binding to copy to
    pub dst_array_element: u32,
    /// Number of descriptors to write (determines the size of the array pointed by pDescriptors)
    pub descriptor_count: u32,
}
unsafe impl Send for CopyDescriptorSet {}
unsafe impl Sync for CopyDescriptorSet {}
impl Default for CopyDescriptorSet {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_DESCRIPTOR_SET,
            p_next: ptr::null(),
            src_set: Default::default(),
            src_binding: Default::default(),
            src_array_element: Default::default(),
            dst_set: Default::default(),
            dst_binding: Default::default(),
            dst_array_element: Default::default(),
            descriptor_count: Default::default(),
        }
    }
}
impl fmt::Debug for CopyDescriptorSet {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyDescriptorSet")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_set", &self.src_set)
            .field("src_binding", &self.src_binding)
            .field("src_array_element", &self.src_array_element)
            .field("dst_set", &self.dst_set)
            .field("dst_binding", &self.dst_binding)
            .field("dst_array_element", &self.dst_array_element)
            .field("descriptor_count", &self.descriptor_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Buffer creation flags
    pub flags: BufferCreateFlags,
    /// Specified in bytes
    pub size: DeviceSize,
    /// Buffer usage flags
    pub usage: BufferUsageFlags,
    pub sharing_mode: SharingMode,
    pub queue_family_index_count: u32,
    pub p_queue_family_indices: *const u32,
}
unsafe impl Send for BufferCreateInfo {}
unsafe impl Sync for BufferCreateInfo {}
impl Default for BufferCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            size: Default::default(),
            usage: Default::default(),
            sharing_mode: Default::default(),
            queue_family_index_count: Default::default(),
            p_queue_family_indices: ptr::null(),
        }
    }
}
impl fmt::Debug for BufferCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("size", &self.size)
            .field("usage", &self.usage)
            .field("sharing_mode", &self.sharing_mode)
            .field("queue_family_index_count", &self.queue_family_index_count)
            .field("p_queue_family_indices", &self.p_queue_family_indices)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferViewCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: BufferViewCreateFlags,
    pub buffer: Option<Buffer>,
    /// Optionally specifies format of elements
    pub format: Format,
    /// Specified in bytes
    pub offset: DeviceSize,
    /// View size specified in bytes
    pub range: DeviceSize,
}
unsafe impl Send for BufferViewCreateInfo {}
unsafe impl Sync for BufferViewCreateInfo {}
impl Default for BufferViewCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_VIEW_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            buffer: Default::default(),
            format: Default::default(),
            offset: Default::default(),
            range: Default::default(),
        }
    }
}
impl fmt::Debug for BufferViewCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferViewCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("buffer", &self.buffer)
            .field("format", &self.format)
            .field("offset", &self.offset)
            .field("range", &self.range)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImageSubresource {
    pub aspect_mask: ImageAspectFlags,
    pub mip_level: u32,
    pub array_layer: u32,
}
impl fmt::Debug for ImageSubresource {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageSubresource")
            .field("aspect_mask", &self.aspect_mask)
            .field("mip_level", &self.mip_level)
            .field("array_layer", &self.array_layer)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImageSubresourceLayers {
    pub aspect_mask: ImageAspectFlags,
    pub mip_level: u32,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
impl fmt::Debug for ImageSubresourceLayers {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageSubresourceLayers")
            .field("aspect_mask", &self.aspect_mask)
            .field("mip_level", &self.mip_level)
            .field("base_array_layer", &self.base_array_layer)
            .field("layer_count", &self.layer_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImageSubresourceRange {
    pub aspect_mask: ImageAspectFlags,
    pub base_mip_level: u32,
    pub level_count: u32,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
impl fmt::Debug for ImageSubresourceRange {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageSubresourceRange")
            .field("aspect_mask", &self.aspect_mask)
            .field("base_mip_level", &self.base_mip_level)
            .field("level_count", &self.level_count)
            .field("base_array_layer", &self.base_array_layer)
            .field("layer_count", &self.layer_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryBarrier {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Memory accesses from the source of the dependency to synchronize
    pub src_access_mask: AccessFlags,
    /// Memory accesses from the destination of the dependency to synchronize
    pub dst_access_mask: AccessFlags,
}
unsafe impl Send for MemoryBarrier {}
unsafe impl Sync for MemoryBarrier {}
impl Default for MemoryBarrier {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_BARRIER,
            p_next: ptr::null(),
            src_access_mask: Default::default(),
            dst_access_mask: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryBarrier {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryBarrier")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferMemoryBarrier {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Memory accesses from the source of the dependency to synchronize
    pub src_access_mask: AccessFlags,
    /// Memory accesses from the destination of the dependency to synchronize
    pub dst_access_mask: AccessFlags,
    /// Queue family to transition ownership from
    pub src_queue_family_index: u32,
    /// Queue family to transition ownership to
    pub dst_queue_family_index: u32,
    /// Buffer to sync
    pub buffer: Option<Buffer>,
    /// Offset within the buffer to sync
    pub offset: DeviceSize,
    /// Amount of bytes to sync
    pub size: DeviceSize,
}
unsafe impl Send for BufferMemoryBarrier {}
unsafe impl Sync for BufferMemoryBarrier {}
impl Default for BufferMemoryBarrier {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_MEMORY_BARRIER,
            p_next: ptr::null(),
            src_access_mask: Default::default(),
            dst_access_mask: Default::default(),
            src_queue_family_index: Default::default(),
            dst_queue_family_index: Default::default(),
            buffer: Default::default(),
            offset: Default::default(),
            size: Default::default(),
        }
    }
}
impl fmt::Debug for BufferMemoryBarrier {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferMemoryBarrier")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .field("src_queue_family_index", &self.src_queue_family_index)
            .field("dst_queue_family_index", &self.dst_queue_family_index)
            .field("buffer", &self.buffer)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageMemoryBarrier {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Memory accesses from the source of the dependency to synchronize
    pub src_access_mask: AccessFlags,
    /// Memory accesses from the destination of the dependency to synchronize
    pub dst_access_mask: AccessFlags,
    /// Current layout of the image
    pub old_layout: ImageLayout,
    /// New layout to transition the image to
    pub new_layout: ImageLayout,
    /// Queue family to transition ownership from
    pub src_queue_family_index: u32,
    /// Queue family to transition ownership to
    pub dst_queue_family_index: u32,
    /// Image to sync
    pub image: Option<Image>,
    /// Subresource range to sync
    pub subresource_range: ImageSubresourceRange,
}
unsafe impl Send for ImageMemoryBarrier {}
unsafe impl Sync for ImageMemoryBarrier {}
impl Default for ImageMemoryBarrier {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_MEMORY_BARRIER,
            p_next: ptr::null(),
            src_access_mask: Default::default(),
            dst_access_mask: Default::default(),
            old_layout: Default::default(),
            new_layout: Default::default(),
            src_queue_family_index: Default::default(),
            dst_queue_family_index: Default::default(),
            image: Default::default(),
            subresource_range: Default::default(),
        }
    }
}
impl fmt::Debug for ImageMemoryBarrier {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageMemoryBarrier")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .field("old_layout", &self.old_layout)
            .field("new_layout", &self.new_layout)
            .field("src_queue_family_index", &self.src_queue_family_index)
            .field("dst_queue_family_index", &self.dst_queue_family_index)
            .field("image", &self.image)
            .field("subresource_range", &self.subresource_range)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Image creation flags
    pub flags: ImageCreateFlags,
    pub image_type: ImageType,
    pub format: Format,
    pub extent: Extent3D,
    pub mip_levels: u32,
    pub array_layers: u32,
    pub samples: SampleCountFlags,
    pub tiling: ImageTiling,
    /// Image usage flags
    pub usage: ImageUsageFlags,
    /// Cross-queue-family sharing mode
    pub sharing_mode: SharingMode,
    /// Number of queue families to share across
    pub queue_family_index_count: u32,
    /// Array of queue family indices to share across
    pub p_queue_family_indices: *const u32,
    /// Initial image layout for all subresources
    pub initial_layout: ImageLayout,
}
unsafe impl Send for ImageCreateInfo {}
unsafe impl Sync for ImageCreateInfo {}
impl Default for ImageCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            image_type: Default::default(),
            format: Default::default(),
            extent: Default::default(),
            mip_levels: Default::default(),
            array_layers: Default::default(),
            samples: Default::default(),
            tiling: Default::default(),
            usage: Default::default(),
            sharing_mode: Default::default(),
            queue_family_index_count: Default::default(),
            p_queue_family_indices: ptr::null(),
            initial_layout: Default::default(),
        }
    }
}
impl fmt::Debug for ImageCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("image_type", &self.image_type)
            .field("format", &self.format)
            .field("extent", &self.extent)
            .field("mip_levels", &self.mip_levels)
            .field("array_layers", &self.array_layers)
            .field("samples", &self.samples)
            .field("tiling", &self.tiling)
            .field("usage", &self.usage)
            .field("sharing_mode", &self.sharing_mode)
            .field("queue_family_index_count", &self.queue_family_index_count)
            .field("p_queue_family_indices", &self.p_queue_family_indices)
            .field("initial_layout", &self.initial_layout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SubresourceLayout {
    /// Specified in bytes
    pub offset: DeviceSize,
    /// Specified in bytes
    pub size: DeviceSize,
    /// Specified in bytes
    pub row_pitch: DeviceSize,
    /// Specified in bytes
    pub array_pitch: DeviceSize,
    /// Specified in bytes
    pub depth_pitch: DeviceSize,
}
impl fmt::Debug for SubresourceLayout {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubresourceLayout")
            .field("offset", &self.offset)
            .field("size", &self.size)
            .field("row_pitch", &self.row_pitch)
            .field("array_pitch", &self.array_pitch)
            .field("depth_pitch", &self.depth_pitch)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageViewCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImageViewCreateFlags,
    pub image: Option<Image>,
    pub view_type: ImageViewType,
    pub format: Format,
    pub components: ComponentMapping,
    pub subresource_range: ImageSubresourceRange,
}
unsafe impl Send for ImageViewCreateInfo {}
unsafe impl Sync for ImageViewCreateInfo {}
impl Default for ImageViewCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_VIEW_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            image: Default::default(),
            view_type: Default::default(),
            format: Default::default(),
            components: Default::default(),
            subresource_range: Default::default(),
        }
    }
}
impl fmt::Debug for ImageViewCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageViewCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("image", &self.image)
            .field("view_type", &self.view_type)
            .field("format", &self.format)
            .field("components", &self.components)
            .field("subresource_range", &self.subresource_range)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct BufferCopy {
    /// Specified in bytes
    pub src_offset: DeviceSize,
    /// Specified in bytes
    pub dst_offset: DeviceSize,
    /// Specified in bytes
    pub size: DeviceSize,
}
impl fmt::Debug for BufferCopy {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCopy")
            .field("src_offset", &self.src_offset)
            .field("dst_offset", &self.dst_offset)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct SparseMemoryBind {
    /// Specified in bytes
    pub resource_offset: DeviceSize,
    /// Specified in bytes
    pub size: DeviceSize,
    pub memory: Option<DeviceMemory>,
    /// Specified in bytes
    pub memory_offset: DeviceSize,
    pub flags: SparseMemoryBindFlags,
}
impl fmt::Debug for SparseMemoryBind {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseMemoryBind")
            .field("resource_offset", &self.resource_offset)
            .field("size", &self.size)
            .field("memory", &self.memory)
            .field("memory_offset", &self.memory_offset)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct SparseImageMemoryBind {
    pub subresource: ImageSubresource,
    pub offset: Offset3D,
    pub extent: Extent3D,
    pub memory: Option<DeviceMemory>,
    /// Specified in bytes
    pub memory_offset: DeviceSize,
    pub flags: SparseMemoryBindFlags,
}
impl fmt::Debug for SparseImageMemoryBind {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseImageMemoryBind")
            .field("subresource", &self.subresource)
            .field("offset", &self.offset)
            .field("extent", &self.extent)
            .field("memory", &self.memory)
            .field("memory_offset", &self.memory_offset)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SparseBufferMemoryBindInfo {
    pub buffer: Option<Buffer>,
    pub bind_count: u32,
    pub p_binds: *const SparseMemoryBind,
}
unsafe impl Send for SparseBufferMemoryBindInfo {}
unsafe impl Sync for SparseBufferMemoryBindInfo {}
impl Default for SparseBufferMemoryBindInfo {
    fn default() -> Self {
        Self {
            buffer: Default::default(),
            bind_count: Default::default(),
            p_binds: ptr::null(),
        }
    }
}
impl fmt::Debug for SparseBufferMemoryBindInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseBufferMemoryBindInfo")
            .field("buffer", &self.buffer)
            .field("bind_count", &self.bind_count)
            .field("p_binds", &self.p_binds)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SparseImageOpaqueMemoryBindInfo {
    pub image: Option<Image>,
    pub bind_count: u32,
    pub p_binds: *const SparseMemoryBind,
}
unsafe impl Send for SparseImageOpaqueMemoryBindInfo {}
unsafe impl Sync for SparseImageOpaqueMemoryBindInfo {}
impl Default for SparseImageOpaqueMemoryBindInfo {
    fn default() -> Self {
        Self {
            image: Default::default(),
            bind_count: Default::default(),
            p_binds: ptr::null(),
        }
    }
}
impl fmt::Debug for SparseImageOpaqueMemoryBindInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseImageOpaqueMemoryBindInfo")
            .field("image", &self.image)
            .field("bind_count", &self.bind_count)
            .field("p_binds", &self.p_binds)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SparseImageMemoryBindInfo {
    pub image: Option<Image>,
    pub bind_count: u32,
    pub p_binds: *const SparseImageMemoryBind,
}
unsafe impl Send for SparseImageMemoryBindInfo {}
unsafe impl Sync for SparseImageMemoryBindInfo {}
impl Default for SparseImageMemoryBindInfo {
    fn default() -> Self {
        Self {
            image: Default::default(),
            bind_count: Default::default(),
            p_binds: ptr::null(),
        }
    }
}
impl fmt::Debug for SparseImageMemoryBindInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseImageMemoryBindInfo")
            .field("image", &self.image)
            .field("bind_count", &self.bind_count)
            .field("p_binds", &self.p_binds)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindSparseInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_count: u32,
    pub p_wait_semaphores: *const Semaphore,
    pub buffer_bind_count: u32,
    pub p_buffer_binds: *const SparseBufferMemoryBindInfo,
    pub image_opaque_bind_count: u32,
    pub p_image_opaque_binds: *const SparseImageOpaqueMemoryBindInfo,
    pub image_bind_count: u32,
    pub p_image_binds: *const SparseImageMemoryBindInfo,
    pub signal_semaphore_count: u32,
    pub p_signal_semaphores: *const Semaphore,
}
unsafe impl Send for BindSparseInfo {}
unsafe impl Sync for BindSparseInfo {}
impl Default for BindSparseInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_SPARSE_INFO,
            p_next: ptr::null(),
            wait_semaphore_count: Default::default(),
            p_wait_semaphores: ptr::null(),
            buffer_bind_count: Default::default(),
            p_buffer_binds: ptr::null(),
            image_opaque_bind_count: Default::default(),
            p_image_opaque_binds: ptr::null(),
            image_bind_count: Default::default(),
            p_image_binds: ptr::null(),
            signal_semaphore_count: Default::default(),
            p_signal_semaphores: ptr::null(),
        }
    }
}
impl fmt::Debug for BindSparseInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindSparseInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("wait_semaphore_count", &self.wait_semaphore_count)
            .field("p_wait_semaphores", &self.p_wait_semaphores)
            .field("buffer_bind_count", &self.buffer_bind_count)
            .field("p_buffer_binds", &self.p_buffer_binds)
            .field("image_opaque_bind_count", &self.image_opaque_bind_count)
            .field("p_image_opaque_binds", &self.p_image_opaque_binds)
            .field("image_bind_count", &self.image_bind_count)
            .field("p_image_binds", &self.p_image_binds)
            .field("signal_semaphore_count", &self.signal_semaphore_count)
            .field("p_signal_semaphores", &self.p_signal_semaphores)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImageCopy {
    pub src_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub dst_offset: Offset3D,
    /// Specified in pixels for both compressed and uncompressed images
    pub extent: Extent3D,
}
impl fmt::Debug for ImageCopy {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageCopy")
            .field("src_subresource", &self.src_subresource)
            .field("src_offset", &self.src_offset)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offset", &self.dst_offset)
            .field("extent", &self.extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct ImageBlit {
    pub src_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub src_offsets: [Offset3D; 2],
    pub dst_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub dst_offsets: [Offset3D; 2],
}
impl fmt::Debug for ImageBlit {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageBlit")
            .field("src_subresource", &self.src_subresource)
            .field("src_offsets", &self.src_offsets)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offsets", &self.dst_offsets)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct BufferImageCopy {
    /// Specified in bytes
    pub buffer_offset: DeviceSize,
    /// Specified in texels
    pub buffer_row_length: u32,
    pub buffer_image_height: u32,
    pub image_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub image_offset: Offset3D,
    /// Specified in pixels for both compressed and uncompressed images
    pub image_extent: Extent3D,
}
impl fmt::Debug for BufferImageCopy {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferImageCopy")
            .field("buffer_offset", &self.buffer_offset)
            .field("buffer_row_length", &self.buffer_row_length)
            .field("buffer_image_height", &self.buffer_image_height)
            .field("image_subresource", &self.image_subresource)
            .field("image_offset", &self.image_offset)
            .field("image_extent", &self.image_extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ImageResolve {
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
}
impl fmt::Debug for ImageResolve {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageResolve")
            .field("src_subresource", &self.src_subresource)
            .field("src_offset", &self.src_offset)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offset", &self.dst_offset)
            .field("extent", &self.extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ShaderModuleCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ShaderModuleCreateFlags,
    /// Specified in bytes
    pub code_size: usize,
    /// Binary code of size codeSize
    pub p_code: *const u32,
}
unsafe impl Send for ShaderModuleCreateInfo {}
unsafe impl Sync for ShaderModuleCreateInfo {}
impl Default for ShaderModuleCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SHADER_MODULE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            code_size: Default::default(),
            p_code: ptr::null(),
        }
    }
}
impl fmt::Debug for ShaderModuleCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ShaderModuleCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("code_size", &self.code_size)
            .field("p_code", &self.p_code)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetLayoutBinding {
    /// Binding number for this entry
    pub binding: u32,
    /// Type of the descriptors in this binding
    pub descriptor_type: DescriptorType,
    /// Number of descriptors in this binding
    pub descriptor_count: u32,
    /// Shader stages this binding is visible to
    pub stage_flags: ShaderStageFlags,
    /// Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements)
    pub p_immutable_samplers: *const Sampler,
}
unsafe impl Send for DescriptorSetLayoutBinding {}
unsafe impl Sync for DescriptorSetLayoutBinding {}
impl Default for DescriptorSetLayoutBinding {
    fn default() -> Self {
        Self {
            binding: Default::default(),
            descriptor_type: Default::default(),
            descriptor_count: Default::default(),
            stage_flags: Default::default(),
            p_immutable_samplers: ptr::null(),
        }
    }
}
impl fmt::Debug for DescriptorSetLayoutBinding {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetLayoutBinding")
            .field("binding", &self.binding)
            .field("descriptor_type", &self.descriptor_type)
            .field("descriptor_count", &self.descriptor_count)
            .field("stage_flags", &self.stage_flags)
            .field("p_immutable_samplers", &self.p_immutable_samplers)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetLayoutCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DescriptorSetLayoutCreateFlags,
    /// Number of bindings in the descriptor set layout
    pub binding_count: u32,
    /// Array of descriptor set layout bindings
    pub p_bindings: *const DescriptorSetLayoutBinding,
}
unsafe impl Send for DescriptorSetLayoutCreateInfo {}
unsafe impl Sync for DescriptorSetLayoutCreateInfo {}
impl Default for DescriptorSetLayoutCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            binding_count: Default::default(),
            p_bindings: ptr::null(),
        }
    }
}
impl fmt::Debug for DescriptorSetLayoutCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetLayoutCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("binding_count", &self.binding_count)
            .field("p_bindings", &self.p_bindings)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DescriptorPoolSize {
    pub ty: DescriptorType,
    pub descriptor_count: u32,
}
impl fmt::Debug for DescriptorPoolSize {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorPoolSize")
            .field("ty", &self.ty)
            .field("descriptor_count", &self.descriptor_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorPoolCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DescriptorPoolCreateFlags,
    pub max_sets: u32,
    pub pool_size_count: u32,
    pub p_pool_sizes: *const DescriptorPoolSize,
}
unsafe impl Send for DescriptorPoolCreateInfo {}
unsafe impl Sync for DescriptorPoolCreateInfo {}
impl Default for DescriptorPoolCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_POOL_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            max_sets: Default::default(),
            pool_size_count: Default::default(),
            p_pool_sizes: ptr::null(),
        }
    }
}
impl fmt::Debug for DescriptorPoolCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorPoolCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("max_sets", &self.max_sets)
            .field("pool_size_count", &self.pool_size_count)
            .field("p_pool_sizes", &self.p_pool_sizes)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub descriptor_pool: Option<DescriptorPool>,
    pub descriptor_set_count: u32,
    pub p_set_layouts: *const DescriptorSetLayout,
}
unsafe impl Send for DescriptorSetAllocateInfo {}
unsafe impl Sync for DescriptorSetAllocateInfo {}
impl Default for DescriptorSetAllocateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_SET_ALLOCATE_INFO,
            p_next: ptr::null(),
            descriptor_pool: Default::default(),
            descriptor_set_count: Default::default(),
            p_set_layouts: ptr::null(),
        }
    }
}
impl fmt::Debug for DescriptorSetAllocateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetAllocateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("descriptor_pool", &self.descriptor_pool)
            .field("descriptor_set_count", &self.descriptor_set_count)
            .field("p_set_layouts", &self.p_set_layouts)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SpecializationMapEntry {
    /// The SpecConstant ID specified in the BIL
    pub constant_id: u32,
    /// Offset of the value in the data block
    pub offset: u32,
    /// Size in bytes of the SpecConstant
    pub size: usize,
}
impl fmt::Debug for SpecializationMapEntry {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SpecializationMapEntry")
            .field("constant_id", &self.constant_id)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SpecializationInfo {
    /// Number of entries in the map
    pub map_entry_count: u32,
    /// Array of map entries
    pub p_map_entries: *const SpecializationMapEntry,
    /// Size in bytes of pData
    pub data_size: usize,
    /// Pointer to SpecConstant data
    pub p_data: *const c_void,
}
unsafe impl Send for SpecializationInfo {}
unsafe impl Sync for SpecializationInfo {}
impl Default for SpecializationInfo {
    fn default() -> Self {
        Self {
            map_entry_count: Default::default(),
            p_map_entries: ptr::null(),
            data_size: Default::default(),
            p_data: ptr::null(),
        }
    }
}
impl fmt::Debug for SpecializationInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SpecializationInfo")
            .field("map_entry_count", &self.map_entry_count)
            .field("p_map_entries", &self.p_map_entries)
            .field("data_size", &self.data_size)
            .field("p_data", &self.p_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineShaderStageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineShaderStageCreateFlags,
    /// Shader stage
    pub stage: ShaderStageFlags,
    /// Module containing entry point
    pub module: Option<ShaderModule>,
    /// Null-terminated entry point name
    pub p_name: *const c_char,
    pub p_specialization_info: *const SpecializationInfo,
}
unsafe impl Send for PipelineShaderStageCreateInfo {}
unsafe impl Sync for PipelineShaderStageCreateInfo {}
impl Default for PipelineShaderStageCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_SHADER_STAGE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            stage: Default::default(),
            module: Default::default(),
            p_name: ptr::null(),
            p_specialization_info: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineShaderStageCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineShaderStageCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("stage", &self.stage)
            .field("module", &self.module)
            .field("p_name", &self.p_name)
            .field("p_specialization_info", &self.p_specialization_info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ComputePipelineCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Pipeline creation flags
    pub flags: PipelineCreateFlags,
    pub stage: PipelineShaderStageCreateInfo,
    /// Interface layout of the pipeline
    pub layout: Option<PipelineLayout>,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    pub base_pipeline_handle: Option<Pipeline>,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    pub base_pipeline_index: i32,
}
unsafe impl Send for ComputePipelineCreateInfo {}
unsafe impl Sync for ComputePipelineCreateInfo {}
impl Default for ComputePipelineCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMPUTE_PIPELINE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            stage: Default::default(),
            layout: Default::default(),
            base_pipeline_handle: Default::default(),
            base_pipeline_index: Default::default(),
        }
    }
}
impl fmt::Debug for ComputePipelineCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ComputePipelineCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("stage", &self.stage)
            .field("layout", &self.layout)
            .field("base_pipeline_handle", &self.base_pipeline_handle)
            .field("base_pipeline_index", &self.base_pipeline_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct VertexInputBindingDescription {
    /// Vertex buffer binding id
    pub binding: u32,
    /// Distance between vertices in bytes (0 = no advancement)
    pub stride: u32,
    /// The rate at which the vertex data is consumed
    pub input_rate: VertexInputRate,
}
impl fmt::Debug for VertexInputBindingDescription {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("VertexInputBindingDescription")
            .field("binding", &self.binding)
            .field("stride", &self.stride)
            .field("input_rate", &self.input_rate)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct VertexInputAttributeDescription {
    /// location of the shader vertex attrib
    pub location: u32,
    /// Vertex buffer binding id
    pub binding: u32,
    /// format of source data
    pub format: Format,
    /// Offset of first element in bytes from base of vertex
    pub offset: u32,
}
impl fmt::Debug for VertexInputAttributeDescription {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("VertexInputAttributeDescription")
            .field("location", &self.location)
            .field("binding", &self.binding)
            .field("format", &self.format)
            .field("offset", &self.offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineVertexInputStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineVertexInputStateCreateFlags,
    /// number of bindings
    pub vertex_binding_description_count: u32,
    pub p_vertex_binding_descriptions: *const VertexInputBindingDescription,
    /// number of attributes
    pub vertex_attribute_description_count: u32,
    pub p_vertex_attribute_descriptions: *const VertexInputAttributeDescription,
}
unsafe impl Send for PipelineVertexInputStateCreateInfo {}
unsafe impl Sync for PipelineVertexInputStateCreateInfo {}
impl Default for PipelineVertexInputStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            vertex_binding_description_count: Default::default(),
            p_vertex_binding_descriptions: ptr::null(),
            vertex_attribute_description_count: Default::default(),
            p_vertex_attribute_descriptions: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineVertexInputStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineVertexInputStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field(
                "vertex_binding_description_count",
                &self.vertex_binding_description_count,
            )
            .field("p_vertex_binding_descriptions", &self.p_vertex_binding_descriptions)
            .field(
                "vertex_attribute_description_count",
                &self.vertex_attribute_description_count,
            )
            .field("p_vertex_attribute_descriptions", &self.p_vertex_attribute_descriptions)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineInputAssemblyStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineInputAssemblyStateCreateFlags,
    pub topology: PrimitiveTopology,
    pub primitive_restart_enable: Bool32,
}
unsafe impl Send for PipelineInputAssemblyStateCreateInfo {}
unsafe impl Sync for PipelineInputAssemblyStateCreateInfo {}
impl Default for PipelineInputAssemblyStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            topology: Default::default(),
            primitive_restart_enable: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineInputAssemblyStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineInputAssemblyStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("topology", &self.topology)
            .field("primitive_restart_enable", &self.primitive_restart_enable)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineTessellationStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineTessellationStateCreateFlags,
    pub patch_control_points: u32,
}
unsafe impl Send for PipelineTessellationStateCreateInfo {}
unsafe impl Sync for PipelineTessellationStateCreateInfo {}
impl Default for PipelineTessellationStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_TESSELLATION_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            patch_control_points: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineTessellationStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineTessellationStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("patch_control_points", &self.patch_control_points)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineViewportStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineViewportStateCreateFlags,
    pub viewport_count: u32,
    pub p_viewports: *const Viewport,
    pub scissor_count: u32,
    pub p_scissors: *const Rect2D,
}
unsafe impl Send for PipelineViewportStateCreateInfo {}
unsafe impl Sync for PipelineViewportStateCreateInfo {}
impl Default for PipelineViewportStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VIEWPORT_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            viewport_count: Default::default(),
            p_viewports: ptr::null(),
            scissor_count: Default::default(),
            p_scissors: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineViewportStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineViewportStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("viewport_count", &self.viewport_count)
            .field("p_viewports", &self.p_viewports)
            .field("scissor_count", &self.scissor_count)
            .field("p_scissors", &self.p_scissors)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRasterizationStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineRasterizationStateCreateFlags,
    pub depth_clamp_enable: Bool32,
    pub rasterizer_discard_enable: Bool32,
    /// optional (GL45)
    pub polygon_mode: PolygonMode,
    pub cull_mode: CullModeFlags,
    pub front_face: FrontFace,
    pub depth_bias_enable: Bool32,
    pub depth_bias_constant_factor: f32,
    pub depth_bias_clamp: f32,
    pub depth_bias_slope_factor: f32,
    pub line_width: f32,
}
unsafe impl Send for PipelineRasterizationStateCreateInfo {}
unsafe impl Sync for PipelineRasterizationStateCreateInfo {}
impl Default for PipelineRasterizationStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            depth_clamp_enable: Default::default(),
            rasterizer_discard_enable: Default::default(),
            polygon_mode: Default::default(),
            cull_mode: Default::default(),
            front_face: Default::default(),
            depth_bias_enable: Default::default(),
            depth_bias_constant_factor: Default::default(),
            depth_bias_clamp: Default::default(),
            depth_bias_slope_factor: Default::default(),
            line_width: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineRasterizationStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRasterizationStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("depth_clamp_enable", &self.depth_clamp_enable)
            .field("rasterizer_discard_enable", &self.rasterizer_discard_enable)
            .field("polygon_mode", &self.polygon_mode)
            .field("cull_mode", &self.cull_mode)
            .field("front_face", &self.front_face)
            .field("depth_bias_enable", &self.depth_bias_enable)
            .field("depth_bias_constant_factor", &self.depth_bias_constant_factor)
            .field("depth_bias_clamp", &self.depth_bias_clamp)
            .field("depth_bias_slope_factor", &self.depth_bias_slope_factor)
            .field("line_width", &self.line_width)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineMultisampleStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineMultisampleStateCreateFlags,
    /// Number of samples used for rasterization
    pub rasterization_samples: SampleCountFlags,
    /// optional (GL45)
    pub sample_shading_enable: Bool32,
    /// optional (GL45)
    pub min_sample_shading: f32,
    /// Array of sampleMask words
    pub p_sample_mask: *const SampleMask,
    pub alpha_to_coverage_enable: Bool32,
    pub alpha_to_one_enable: Bool32,
}
unsafe impl Send for PipelineMultisampleStateCreateInfo {}
unsafe impl Sync for PipelineMultisampleStateCreateInfo {}
impl Default for PipelineMultisampleStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            rasterization_samples: Default::default(),
            sample_shading_enable: Default::default(),
            min_sample_shading: Default::default(),
            p_sample_mask: ptr::null(),
            alpha_to_coverage_enable: Default::default(),
            alpha_to_one_enable: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineMultisampleStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineMultisampleStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("rasterization_samples", &self.rasterization_samples)
            .field("sample_shading_enable", &self.sample_shading_enable)
            .field("min_sample_shading", &self.min_sample_shading)
            .field("p_sample_mask", &self.p_sample_mask)
            .field("alpha_to_coverage_enable", &self.alpha_to_coverage_enable)
            .field("alpha_to_one_enable", &self.alpha_to_one_enable)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineColorBlendAttachmentState {
    pub blend_enable: Bool32,
    pub src_color_blend_factor: BlendFactor,
    pub dst_color_blend_factor: BlendFactor,
    pub color_blend_op: BlendOp,
    pub src_alpha_blend_factor: BlendFactor,
    pub dst_alpha_blend_factor: BlendFactor,
    pub alpha_blend_op: BlendOp,
    pub color_write_mask: ColorComponentFlags,
}
impl fmt::Debug for PipelineColorBlendAttachmentState {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineColorBlendAttachmentState")
            .field("blend_enable", &self.blend_enable)
            .field("src_color_blend_factor", &self.src_color_blend_factor)
            .field("dst_color_blend_factor", &self.dst_color_blend_factor)
            .field("color_blend_op", &self.color_blend_op)
            .field("src_alpha_blend_factor", &self.src_alpha_blend_factor)
            .field("dst_alpha_blend_factor", &self.dst_alpha_blend_factor)
            .field("alpha_blend_op", &self.alpha_blend_op)
            .field("color_write_mask", &self.color_write_mask)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineColorBlendStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineColorBlendStateCreateFlags,
    pub logic_op_enable: Bool32,
    pub logic_op: LogicOp,
    /// # of pAttachments
    pub attachment_count: u32,
    pub p_attachments: *const PipelineColorBlendAttachmentState,
    pub blend_constants: [f32; 4],
}
unsafe impl Send for PipelineColorBlendStateCreateInfo {}
unsafe impl Sync for PipelineColorBlendStateCreateInfo {}
impl Default for PipelineColorBlendStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            logic_op_enable: Default::default(),
            logic_op: Default::default(),
            attachment_count: Default::default(),
            p_attachments: ptr::null(),
            blend_constants: [Default::default(); 4],
        }
    }
}
impl fmt::Debug for PipelineColorBlendStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineColorBlendStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("logic_op_enable", &self.logic_op_enable)
            .field("logic_op", &self.logic_op)
            .field("attachment_count", &self.attachment_count)
            .field("p_attachments", &self.p_attachments)
            .field("blend_constants", &self.blend_constants)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineDynamicStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineDynamicStateCreateFlags,
    pub dynamic_state_count: u32,
    pub p_dynamic_states: *const DynamicState,
}
unsafe impl Send for PipelineDynamicStateCreateInfo {}
unsafe impl Sync for PipelineDynamicStateCreateInfo {}
impl Default for PipelineDynamicStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_DYNAMIC_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            dynamic_state_count: Default::default(),
            p_dynamic_states: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineDynamicStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineDynamicStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("dynamic_state_count", &self.dynamic_state_count)
            .field("p_dynamic_states", &self.p_dynamic_states)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct StencilOpState {
    pub fail_op: StencilOp,
    pub pass_op: StencilOp,
    pub depth_fail_op: StencilOp,
    pub compare_op: CompareOp,
    pub compare_mask: u32,
    pub write_mask: u32,
    pub reference: u32,
}
impl fmt::Debug for StencilOpState {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("StencilOpState")
            .field("fail_op", &self.fail_op)
            .field("pass_op", &self.pass_op)
            .field("depth_fail_op", &self.depth_fail_op)
            .field("compare_op", &self.compare_op)
            .field("compare_mask", &self.compare_mask)
            .field("write_mask", &self.write_mask)
            .field("reference", &self.reference)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineDepthStencilStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineDepthStencilStateCreateFlags,
    pub depth_test_enable: Bool32,
    pub depth_write_enable: Bool32,
    pub depth_compare_op: CompareOp,
    /// optional (depth_bounds_test)
    pub depth_bounds_test_enable: Bool32,
    pub stencil_test_enable: Bool32,
    pub front: StencilOpState,
    pub back: StencilOpState,
    pub min_depth_bounds: f32,
    pub max_depth_bounds: f32,
}
unsafe impl Send for PipelineDepthStencilStateCreateInfo {}
unsafe impl Sync for PipelineDepthStencilStateCreateInfo {}
impl Default for PipelineDepthStencilStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            depth_test_enable: Default::default(),
            depth_write_enable: Default::default(),
            depth_compare_op: Default::default(),
            depth_bounds_test_enable: Default::default(),
            stencil_test_enable: Default::default(),
            front: Default::default(),
            back: Default::default(),
            min_depth_bounds: Default::default(),
            max_depth_bounds: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineDepthStencilStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineDepthStencilStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("depth_test_enable", &self.depth_test_enable)
            .field("depth_write_enable", &self.depth_write_enable)
            .field("depth_compare_op", &self.depth_compare_op)
            .field("depth_bounds_test_enable", &self.depth_bounds_test_enable)
            .field("stencil_test_enable", &self.stencil_test_enable)
            .field("front", &self.front)
            .field("back", &self.back)
            .field("min_depth_bounds", &self.min_depth_bounds)
            .field("max_depth_bounds", &self.max_depth_bounds)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GraphicsPipelineCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Pipeline creation flags
    pub flags: PipelineCreateFlags,
    pub stage_count: u32,
    /// One entry for each active shader stage
    pub p_stages: *const PipelineShaderStageCreateInfo,
    pub p_vertex_input_state: *const PipelineVertexInputStateCreateInfo,
    pub p_input_assembly_state: *const PipelineInputAssemblyStateCreateInfo,
    pub p_tessellation_state: *const PipelineTessellationStateCreateInfo,
    pub p_viewport_state: *const PipelineViewportStateCreateInfo,
    pub p_rasterization_state: *const PipelineRasterizationStateCreateInfo,
    pub p_multisample_state: *const PipelineMultisampleStateCreateInfo,
    pub p_depth_stencil_state: *const PipelineDepthStencilStateCreateInfo,
    pub p_color_blend_state: *const PipelineColorBlendStateCreateInfo,
    pub p_dynamic_state: *const PipelineDynamicStateCreateInfo,
    /// Interface layout of the pipeline
    pub layout: Option<PipelineLayout>,
    pub render_pass: Option<RenderPass>,
    pub subpass: u32,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    pub base_pipeline_handle: Option<Pipeline>,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    pub base_pipeline_index: i32,
}
unsafe impl Send for GraphicsPipelineCreateInfo {}
unsafe impl Sync for GraphicsPipelineCreateInfo {}
impl Default for GraphicsPipelineCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::GRAPHICS_PIPELINE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            stage_count: Default::default(),
            p_stages: ptr::null(),
            p_vertex_input_state: ptr::null(),
            p_input_assembly_state: ptr::null(),
            p_tessellation_state: ptr::null(),
            p_viewport_state: ptr::null(),
            p_rasterization_state: ptr::null(),
            p_multisample_state: ptr::null(),
            p_depth_stencil_state: ptr::null(),
            p_color_blend_state: ptr::null(),
            p_dynamic_state: ptr::null(),
            layout: Default::default(),
            render_pass: Default::default(),
            subpass: Default::default(),
            base_pipeline_handle: Default::default(),
            base_pipeline_index: Default::default(),
        }
    }
}
impl fmt::Debug for GraphicsPipelineCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GraphicsPipelineCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("stage_count", &self.stage_count)
            .field("p_stages", &self.p_stages)
            .field("p_vertex_input_state", &self.p_vertex_input_state)
            .field("p_input_assembly_state", &self.p_input_assembly_state)
            .field("p_tessellation_state", &self.p_tessellation_state)
            .field("p_viewport_state", &self.p_viewport_state)
            .field("p_rasterization_state", &self.p_rasterization_state)
            .field("p_multisample_state", &self.p_multisample_state)
            .field("p_depth_stencil_state", &self.p_depth_stencil_state)
            .field("p_color_blend_state", &self.p_color_blend_state)
            .field("p_dynamic_state", &self.p_dynamic_state)
            .field("layout", &self.layout)
            .field("render_pass", &self.render_pass)
            .field("subpass", &self.subpass)
            .field("base_pipeline_handle", &self.base_pipeline_handle)
            .field("base_pipeline_index", &self.base_pipeline_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineCacheCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCacheCreateFlags,
    /// Size of initial data to populate cache, in bytes
    pub initial_data_size: usize,
    /// Initial data to populate cache
    pub p_initial_data: *const c_void,
}
unsafe impl Send for PipelineCacheCreateInfo {}
unsafe impl Sync for PipelineCacheCreateInfo {}
impl Default for PipelineCacheCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_CACHE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            initial_data_size: Default::default(),
            p_initial_data: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineCacheCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCacheCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("initial_data_size", &self.initial_data_size)
            .field("p_initial_data", &self.p_initial_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineCacheHeaderVersionOne {
    pub header_size: u32,
    pub header_version: PipelineCacheHeaderVersion,
    pub vendor_id: u32,
    pub device_id: u32,
    pub pipeline_cache_uuid: [u8; UUID_SIZE],
}
impl Default for PipelineCacheHeaderVersionOne {
    fn default() -> Self {
        Self {
            header_size: Default::default(),
            header_version: Default::default(),
            vendor_id: Default::default(),
            device_id: Default::default(),
            pipeline_cache_uuid: [Default::default(); UUID_SIZE],
        }
    }
}
impl fmt::Debug for PipelineCacheHeaderVersionOne {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCacheHeaderVersionOne")
            .field("header_size", &self.header_size)
            .field("header_version", &self.header_version)
            .field("vendor_id", &self.vendor_id)
            .field("device_id", &self.device_id)
            .field("pipeline_cache_uuid", &self.pipeline_cache_uuid)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PushConstantRange {
    /// Which stages use the range
    pub stage_flags: ShaderStageFlags,
    /// Start of the range, in bytes
    pub offset: u32,
    /// Size of the range, in bytes
    pub size: u32,
}
impl fmt::Debug for PushConstantRange {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PushConstantRange")
            .field("stage_flags", &self.stage_flags)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineLayoutCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineLayoutCreateFlags,
    /// Number of descriptor sets interfaced by the pipeline
    pub set_layout_count: u32,
    /// Array of setCount number of descriptor set layout objects defining the layout of the
    pub p_set_layouts: *const DescriptorSetLayout,
    /// Number of push-constant ranges used by the pipeline
    pub push_constant_range_count: u32,
    /// Array of pushConstantRangeCount number of ranges used by various shader stages
    pub p_push_constant_ranges: *const PushConstantRange,
}
unsafe impl Send for PipelineLayoutCreateInfo {}
unsafe impl Sync for PipelineLayoutCreateInfo {}
impl Default for PipelineLayoutCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_LAYOUT_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            set_layout_count: Default::default(),
            p_set_layouts: ptr::null(),
            push_constant_range_count: Default::default(),
            p_push_constant_ranges: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineLayoutCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineLayoutCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("set_layout_count", &self.set_layout_count)
            .field("p_set_layouts", &self.p_set_layouts)
            .field("push_constant_range_count", &self.push_constant_range_count)
            .field("p_push_constant_ranges", &self.p_push_constant_ranges)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplerCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SamplerCreateFlags,
    /// Filter mode for magnification
    pub mag_filter: Filter,
    /// Filter mode for minifiation
    pub min_filter: Filter,
    /// Mipmap selection mode
    pub mipmap_mode: SamplerMipmapMode,
    pub address_mode_u: SamplerAddressMode,
    pub address_mode_v: SamplerAddressMode,
    pub address_mode_w: SamplerAddressMode,
    pub mip_lod_bias: f32,
    pub anisotropy_enable: Bool32,
    pub max_anisotropy: f32,
    pub compare_enable: Bool32,
    pub compare_op: CompareOp,
    pub min_lod: f32,
    pub max_lod: f32,
    pub border_color: BorderColor,
    pub unnormalized_coordinates: Bool32,
}
unsafe impl Send for SamplerCreateInfo {}
unsafe impl Sync for SamplerCreateInfo {}
impl Default for SamplerCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLER_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            mag_filter: Default::default(),
            min_filter: Default::default(),
            mipmap_mode: Default::default(),
            address_mode_u: Default::default(),
            address_mode_v: Default::default(),
            address_mode_w: Default::default(),
            mip_lod_bias: Default::default(),
            anisotropy_enable: Default::default(),
            max_anisotropy: Default::default(),
            compare_enable: Default::default(),
            compare_op: Default::default(),
            min_lod: Default::default(),
            max_lod: Default::default(),
            border_color: Default::default(),
            unnormalized_coordinates: Default::default(),
        }
    }
}
impl fmt::Debug for SamplerCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("mag_filter", &self.mag_filter)
            .field("min_filter", &self.min_filter)
            .field("mipmap_mode", &self.mipmap_mode)
            .field("address_mode_u", &self.address_mode_u)
            .field("address_mode_v", &self.address_mode_v)
            .field("address_mode_w", &self.address_mode_w)
            .field("mip_lod_bias", &self.mip_lod_bias)
            .field("anisotropy_enable", &self.anisotropy_enable)
            .field("max_anisotropy", &self.max_anisotropy)
            .field("compare_enable", &self.compare_enable)
            .field("compare_op", &self.compare_op)
            .field("min_lod", &self.min_lod)
            .field("max_lod", &self.max_lod)
            .field("border_color", &self.border_color)
            .field("unnormalized_coordinates", &self.unnormalized_coordinates)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandPoolCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Command pool creation flags
    pub flags: CommandPoolCreateFlags,
    pub queue_family_index: u32,
}
unsafe impl Send for CommandPoolCreateInfo {}
unsafe impl Sync for CommandPoolCreateInfo {}
impl Default for CommandPoolCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_POOL_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            queue_family_index: Default::default(),
        }
    }
}
impl fmt::Debug for CommandPoolCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandPoolCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("queue_family_index", &self.queue_family_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub command_pool: Option<CommandPool>,
    pub level: CommandBufferLevel,
    pub command_buffer_count: u32,
}
unsafe impl Send for CommandBufferAllocateInfo {}
unsafe impl Sync for CommandBufferAllocateInfo {}
impl Default for CommandBufferAllocateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_ALLOCATE_INFO,
            p_next: ptr::null(),
            command_pool: Default::default(),
            level: Default::default(),
            command_buffer_count: Default::default(),
        }
    }
}
impl fmt::Debug for CommandBufferAllocateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferAllocateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("command_pool", &self.command_pool)
            .field("level", &self.level)
            .field("command_buffer_count", &self.command_buffer_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferInheritanceInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Render pass for secondary command buffers
    pub render_pass: Option<RenderPass>,
    pub subpass: u32,
    /// Framebuffer for secondary command buffers
    pub framebuffer: Option<Framebuffer>,
    /// Whether this secondary command buffer may be executed during an occlusion query
    pub occlusion_query_enable: Bool32,
    /// Query flags used by this secondary command buffer, if executed during an occlusion query
    pub query_flags: QueryControlFlags,
    /// Pipeline statistics that may be counted for this secondary command buffer
    pub pipeline_statistics: QueryPipelineStatisticFlags,
}
unsafe impl Send for CommandBufferInheritanceInfo {}
unsafe impl Sync for CommandBufferInheritanceInfo {}
impl Default for CommandBufferInheritanceInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_INHERITANCE_INFO,
            p_next: ptr::null(),
            render_pass: Default::default(),
            subpass: Default::default(),
            framebuffer: Default::default(),
            occlusion_query_enable: Default::default(),
            query_flags: Default::default(),
            pipeline_statistics: Default::default(),
        }
    }
}
impl fmt::Debug for CommandBufferInheritanceInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferInheritanceInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("render_pass", &self.render_pass)
            .field("subpass", &self.subpass)
            .field("framebuffer", &self.framebuffer)
            .field("occlusion_query_enable", &self.occlusion_query_enable)
            .field("query_flags", &self.query_flags)
            .field("pipeline_statistics", &self.pipeline_statistics)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Command buffer usage flags
    pub flags: CommandBufferUsageFlags,
    /// Pointer to inheritance info for secondary command buffers
    pub p_inheritance_info: *const CommandBufferInheritanceInfo,
}
unsafe impl Send for CommandBufferBeginInfo {}
unsafe impl Sync for CommandBufferBeginInfo {}
impl Default for CommandBufferBeginInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_BEGIN_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            p_inheritance_info: ptr::null(),
        }
    }
}
impl fmt::Debug for CommandBufferBeginInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferBeginInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("p_inheritance_info", &self.p_inheritance_info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub render_pass: Option<RenderPass>,
    pub framebuffer: Option<Framebuffer>,
    pub render_area: Rect2D,
    pub clear_value_count: u32,
    pub p_clear_values: *const ClearValue,
}
unsafe impl Send for RenderPassBeginInfo {}
unsafe impl Sync for RenderPassBeginInfo {}
impl Default for RenderPassBeginInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_BEGIN_INFO,
            p_next: ptr::null(),
            render_pass: Default::default(),
            framebuffer: Default::default(),
            render_area: Default::default(),
            clear_value_count: Default::default(),
            p_clear_values: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderPassBeginInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassBeginInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("render_pass", &self.render_pass)
            .field("framebuffer", &self.framebuffer)
            .field("render_area", &self.render_area)
            .field("clear_value_count", &self.clear_value_count)
            .field("p_clear_values", &self.p_clear_values)
            .finish()
    }
}
///  Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.
#[repr(C)]
#[derive(Copy, Clone)]
pub union ClearColorValue {
    pub float32: [f32; 4],
    pub int32: [i32; 4],
    pub uint32: [u32; 4],
}
impl Default for ClearColorValue {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for ClearColorValue {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ClearColorValue")
            .field("float32", unsafe { &self.float32 })
            .field("int32", unsafe { &self.int32 })
            .field("uint32", unsafe { &self.uint32 })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct ClearDepthStencilValue {
    pub depth: f32,
    pub stencil: u32,
}
impl fmt::Debug for ClearDepthStencilValue {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ClearDepthStencilValue")
            .field("depth", &self.depth)
            .field("stencil", &self.stencil)
            .finish()
    }
}
///  Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared.
#[repr(C)]
#[derive(Copy, Clone)]
pub union ClearValue {
    pub color: ClearColorValue,
    pub depth_stencil: ClearDepthStencilValue,
}
impl Default for ClearValue {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for ClearValue {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ClearValue")
            .field("color", unsafe { &self.color })
            .field("depth_stencil", unsafe { &self.depth_stencil })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct ClearAttachment {
    pub aspect_mask: ImageAspectFlags,
    pub color_attachment: u32,
    pub clear_value: ClearValue,
}
impl fmt::Debug for ClearAttachment {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ClearAttachment")
            .field("aspect_mask", &self.aspect_mask)
            .field("color_attachment", &self.color_attachment)
            .field("clear_value", &self.clear_value)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct AttachmentDescription {
    pub flags: AttachmentDescriptionFlags,
    pub format: Format,
    pub samples: SampleCountFlags,
    /// Load operation for color or depth data
    pub load_op: AttachmentLoadOp,
    /// Store operation for color or depth data
    pub store_op: AttachmentStoreOp,
    /// Load operation for stencil data
    pub stencil_load_op: AttachmentLoadOp,
    /// Store operation for stencil data
    pub stencil_store_op: AttachmentStoreOp,
    pub initial_layout: ImageLayout,
    pub final_layout: ImageLayout,
}
impl fmt::Debug for AttachmentDescription {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentDescription")
            .field("flags", &self.flags)
            .field("format", &self.format)
            .field("samples", &self.samples)
            .field("load_op", &self.load_op)
            .field("store_op", &self.store_op)
            .field("stencil_load_op", &self.stencil_load_op)
            .field("stencil_store_op", &self.stencil_store_op)
            .field("initial_layout", &self.initial_layout)
            .field("final_layout", &self.final_layout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct AttachmentReference {
    pub attachment: u32,
    pub layout: ImageLayout,
}
impl fmt::Debug for AttachmentReference {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentReference")
            .field("attachment", &self.attachment)
            .field("layout", &self.layout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassDescription {
    pub flags: SubpassDescriptionFlags,
    /// Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
    pub pipeline_bind_point: PipelineBindPoint,
    pub input_attachment_count: u32,
    pub p_input_attachments: *const AttachmentReference,
    pub color_attachment_count: u32,
    pub p_color_attachments: *const AttachmentReference,
    pub p_resolve_attachments: *const AttachmentReference,
    pub p_depth_stencil_attachment: *const AttachmentReference,
    pub preserve_attachment_count: u32,
    pub p_preserve_attachments: *const u32,
}
unsafe impl Send for SubpassDescription {}
unsafe impl Sync for SubpassDescription {}
impl Default for SubpassDescription {
    fn default() -> Self {
        Self {
            flags: Default::default(),
            pipeline_bind_point: Default::default(),
            input_attachment_count: Default::default(),
            p_input_attachments: ptr::null(),
            color_attachment_count: Default::default(),
            p_color_attachments: ptr::null(),
            p_resolve_attachments: ptr::null(),
            p_depth_stencil_attachment: ptr::null(),
            preserve_attachment_count: Default::default(),
            p_preserve_attachments: ptr::null(),
        }
    }
}
impl fmt::Debug for SubpassDescription {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassDescription")
            .field("flags", &self.flags)
            .field("pipeline_bind_point", &self.pipeline_bind_point)
            .field("input_attachment_count", &self.input_attachment_count)
            .field("p_input_attachments", &self.p_input_attachments)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachments", &self.p_color_attachments)
            .field("p_resolve_attachments", &self.p_resolve_attachments)
            .field("p_depth_stencil_attachment", &self.p_depth_stencil_attachment)
            .field("preserve_attachment_count", &self.preserve_attachment_count)
            .field("p_preserve_attachments", &self.p_preserve_attachments)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SubpassDependency {
    pub src_subpass: u32,
    pub dst_subpass: u32,
    pub src_stage_mask: PipelineStageFlags,
    pub dst_stage_mask: PipelineStageFlags,
    /// Memory accesses from the source of the dependency to synchronize
    pub src_access_mask: AccessFlags,
    /// Memory accesses from the destination of the dependency to synchronize
    pub dst_access_mask: AccessFlags,
    pub dependency_flags: DependencyFlags,
}
impl fmt::Debug for SubpassDependency {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassDependency")
            .field("src_subpass", &self.src_subpass)
            .field("dst_subpass", &self.dst_subpass)
            .field("src_stage_mask", &self.src_stage_mask)
            .field("dst_stage_mask", &self.dst_stage_mask)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .field("dependency_flags", &self.dependency_flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderPassCreateFlags,
    pub attachment_count: u32,
    pub p_attachments: *const AttachmentDescription,
    pub subpass_count: u32,
    pub p_subpasses: *const SubpassDescription,
    pub dependency_count: u32,
    pub p_dependencies: *const SubpassDependency,
}
unsafe impl Send for RenderPassCreateInfo {}
unsafe impl Sync for RenderPassCreateInfo {}
impl Default for RenderPassCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            attachment_count: Default::default(),
            p_attachments: ptr::null(),
            subpass_count: Default::default(),
            p_subpasses: ptr::null(),
            dependency_count: Default::default(),
            p_dependencies: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderPassCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("attachment_count", &self.attachment_count)
            .field("p_attachments", &self.p_attachments)
            .field("subpass_count", &self.subpass_count)
            .field("p_subpasses", &self.p_subpasses)
            .field("dependency_count", &self.dependency_count)
            .field("p_dependencies", &self.p_dependencies)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EventCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Event creation flags
    pub flags: EventCreateFlags,
}
unsafe impl Send for EventCreateInfo {}
unsafe impl Sync for EventCreateInfo {}
impl Default for EventCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::EVENT_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
        }
    }
}
impl fmt::Debug for EventCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("EventCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FenceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Fence creation flags
    pub flags: FenceCreateFlags,
}
unsafe impl Send for FenceCreateInfo {}
unsafe impl Sync for FenceCreateInfo {}
impl Default for FenceCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::FENCE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
        }
    }
}
impl fmt::Debug for FenceCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FenceCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PhysicalDeviceFeatures {
    /// out of bounds buffer accesses are well defined
    pub robust_buffer_access: Bool32,
    /// full 32-bit range of indices for indexed draw calls
    pub full_draw_index_uint32: Bool32,
    /// image views which are arrays of cube maps
    pub image_cube_array: Bool32,
    /// blending operations are controlled per-attachment
    pub independent_blend: Bool32,
    /// geometry stage
    pub geometry_shader: Bool32,
    /// tessellation control and evaluation stage
    pub tessellation_shader: Bool32,
    /// per-sample shading and interpolation
    pub sample_rate_shading: Bool32,
    /// blend operations which take two sources
    pub dual_src_blend: Bool32,
    /// logic operations
    pub logic_op: Bool32,
    /// multi draw indirect
    pub multi_draw_indirect: Bool32,
    /// indirect drawing can use non-zero firstInstance
    pub draw_indirect_first_instance: Bool32,
    /// depth clamping
    pub depth_clamp: Bool32,
    /// depth bias clamping
    pub depth_bias_clamp: Bool32,
    /// point and wireframe fill modes
    pub fill_mode_non_solid: Bool32,
    /// depth bounds test
    pub depth_bounds: Bool32,
    /// lines with width greater than 1
    pub wide_lines: Bool32,
    /// points with size greater than 1
    pub large_points: Bool32,
    /// the fragment alpha component can be forced to maximum representable alpha value
    pub alpha_to_one: Bool32,
    /// viewport arrays
    pub multi_viewport: Bool32,
    /// anisotropic sampler filtering
    pub sampler_anisotropy: Bool32,
    /// ETC texture compression formats
    pub texture_compression_etc2: Bool32,
    /// ASTC LDR texture compression formats
    pub texture_compression_astc_ldr: Bool32,
    /// BC1-7 texture compressed formats
    pub texture_compression_bc: Bool32,
    /// precise occlusion queries returning actual sample counts
    pub occlusion_query_precise: Bool32,
    /// pipeline statistics query
    pub pipeline_statistics_query: Bool32,
    /// stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages
    pub vertex_pipeline_stores_and_atomics: Bool32,
    /// stores and atomic ops on storage buffers and images are supported in the fragment stage
    pub fragment_stores_and_atomics: Bool32,
    /// tessellation and geometry stages can export point size
    pub shader_tessellation_and_geometry_point_size: Bool32,
    /// image gather with run-time values and independent offsets
    pub shader_image_gather_extended: Bool32,
    /// the extended set of formats can be used for storage images
    pub shader_storage_image_extended_formats: Bool32,
    /// multisample images can be used for storage images
    pub shader_storage_image_multisample: Bool32,
    /// read from storage image does not require format qualifier
    pub shader_storage_image_read_without_format: Bool32,
    /// write to storage image does not require format qualifier
    pub shader_storage_image_write_without_format: Bool32,
    /// arrays of uniform buffers can be accessed with dynamically uniform indices
    pub shader_uniform_buffer_array_dynamic_indexing: Bool32,
    /// arrays of sampled images can be accessed with dynamically uniform indices
    pub shader_sampled_image_array_dynamic_indexing: Bool32,
    /// arrays of storage buffers can be accessed with dynamically uniform indices
    pub shader_storage_buffer_array_dynamic_indexing: Bool32,
    /// arrays of storage images can be accessed with dynamically uniform indices
    pub shader_storage_image_array_dynamic_indexing: Bool32,
    /// clip distance in shaders
    pub shader_clip_distance: Bool32,
    /// cull distance in shaders
    pub shader_cull_distance: Bool32,
    /// 64-bit floats (doubles) in shaders
    pub shader_float64: Bool32,
    /// 64-bit integers in shaders
    pub shader_int64: Bool32,
    /// 16-bit integers in shaders
    pub shader_int16: Bool32,
    /// shader can use texture operations that return resource residency information (requires sparseNonResident support)
    pub shader_resource_residency: Bool32,
    /// shader can use texture operations that specify minimum resource LOD
    pub shader_resource_min_lod: Bool32,
    /// Sparse resources support: Resource memory can be managed at opaque page level rather than object level
    pub sparse_binding: Bool32,
    /// Sparse resources support: GPU can access partially resident buffers
    pub sparse_residency_buffer: Bool32,
    /// Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images
    pub sparse_residency_image_2d: Bool32,
    /// Sparse resources support: GPU can access partially resident 3D images
    pub sparse_residency_image_3d: Bool32,
    /// Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
    pub sparse_residency2_samples: Bool32,
    /// Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
    pub sparse_residency4_samples: Bool32,
    /// Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
    pub sparse_residency8_samples: Bool32,
    /// Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
    pub sparse_residency16_samples: Bool32,
    /// Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
    pub sparse_residency_aliased: Bool32,
    /// multisample rate must be the same for all pipelines in a subpass
    pub variable_multisample_rate: Bool32,
    /// Queries may be inherited from primary to secondary command buffers
    pub inherited_queries: Bool32,
}
impl fmt::Debug for PhysicalDeviceFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFeatures")
            .field("robust_buffer_access", &self.robust_buffer_access)
            .field("full_draw_index_uint32", &self.full_draw_index_uint32)
            .field("image_cube_array", &self.image_cube_array)
            .field("independent_blend", &self.independent_blend)
            .field("geometry_shader", &self.geometry_shader)
            .field("tessellation_shader", &self.tessellation_shader)
            .field("sample_rate_shading", &self.sample_rate_shading)
            .field("dual_src_blend", &self.dual_src_blend)
            .field("logic_op", &self.logic_op)
            .field("multi_draw_indirect", &self.multi_draw_indirect)
            .field("draw_indirect_first_instance", &self.draw_indirect_first_instance)
            .field("depth_clamp", &self.depth_clamp)
            .field("depth_bias_clamp", &self.depth_bias_clamp)
            .field("fill_mode_non_solid", &self.fill_mode_non_solid)
            .field("depth_bounds", &self.depth_bounds)
            .field("wide_lines", &self.wide_lines)
            .field("large_points", &self.large_points)
            .field("alpha_to_one", &self.alpha_to_one)
            .field("multi_viewport", &self.multi_viewport)
            .field("sampler_anisotropy", &self.sampler_anisotropy)
            .field("texture_compression_etc2", &self.texture_compression_etc2)
            .field("texture_compression_astc_ldr", &self.texture_compression_astc_ldr)
            .field("texture_compression_bc", &self.texture_compression_bc)
            .field("occlusion_query_precise", &self.occlusion_query_precise)
            .field("pipeline_statistics_query", &self.pipeline_statistics_query)
            .field(
                "vertex_pipeline_stores_and_atomics",
                &self.vertex_pipeline_stores_and_atomics,
            )
            .field("fragment_stores_and_atomics", &self.fragment_stores_and_atomics)
            .field(
                "shader_tessellation_and_geometry_point_size",
                &self.shader_tessellation_and_geometry_point_size,
            )
            .field("shader_image_gather_extended", &self.shader_image_gather_extended)
            .field(
                "shader_storage_image_extended_formats",
                &self.shader_storage_image_extended_formats,
            )
            .field(
                "shader_storage_image_multisample",
                &self.shader_storage_image_multisample,
            )
            .field(
                "shader_storage_image_read_without_format",
                &self.shader_storage_image_read_without_format,
            )
            .field(
                "shader_storage_image_write_without_format",
                &self.shader_storage_image_write_without_format,
            )
            .field(
                "shader_uniform_buffer_array_dynamic_indexing",
                &self.shader_uniform_buffer_array_dynamic_indexing,
            )
            .field(
                "shader_sampled_image_array_dynamic_indexing",
                &self.shader_sampled_image_array_dynamic_indexing,
            )
            .field(
                "shader_storage_buffer_array_dynamic_indexing",
                &self.shader_storage_buffer_array_dynamic_indexing,
            )
            .field(
                "shader_storage_image_array_dynamic_indexing",
                &self.shader_storage_image_array_dynamic_indexing,
            )
            .field("shader_clip_distance", &self.shader_clip_distance)
            .field("shader_cull_distance", &self.shader_cull_distance)
            .field("shader_float64", &self.shader_float64)
            .field("shader_int64", &self.shader_int64)
            .field("shader_int16", &self.shader_int16)
            .field("shader_resource_residency", &self.shader_resource_residency)
            .field("shader_resource_min_lod", &self.shader_resource_min_lod)
            .field("sparse_binding", &self.sparse_binding)
            .field("sparse_residency_buffer", &self.sparse_residency_buffer)
            .field("sparse_residency_image_2d", &self.sparse_residency_image_2d)
            .field("sparse_residency_image_3d", &self.sparse_residency_image_3d)
            .field("sparse_residency2_samples", &self.sparse_residency2_samples)
            .field("sparse_residency4_samples", &self.sparse_residency4_samples)
            .field("sparse_residency8_samples", &self.sparse_residency8_samples)
            .field("sparse_residency16_samples", &self.sparse_residency16_samples)
            .field("sparse_residency_aliased", &self.sparse_residency_aliased)
            .field("variable_multisample_rate", &self.variable_multisample_rate)
            .field("inherited_queries", &self.inherited_queries)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PhysicalDeviceSparseProperties {
    /// Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format)
    pub residency_standard_2d_block_shape: Bool32,
    /// Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format)
    pub residency_standard_2d_multisample_block_shape: Bool32,
    /// Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format)
    pub residency_standard_3d_block_shape: Bool32,
    /// Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail
    pub residency_aligned_mip_size: Bool32,
    /// Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
    pub residency_non_resident_strict: Bool32,
}
impl fmt::Debug for PhysicalDeviceSparseProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSparseProperties")
            .field(
                "residency_standard_2d_block_shape",
                &self.residency_standard_2d_block_shape,
            )
            .field(
                "residency_standard_2d_multisample_block_shape",
                &self.residency_standard_2d_multisample_block_shape,
            )
            .field(
                "residency_standard_3d_block_shape",
                &self.residency_standard_3d_block_shape,
            )
            .field("residency_aligned_mip_size", &self.residency_aligned_mip_size)
            .field("residency_non_resident_strict", &self.residency_non_resident_strict)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct PhysicalDeviceLimits {
    /// max 1D image dimension
    pub max_image_dimension_1d: u32,
    /// max 2D image dimension
    pub max_image_dimension_2d: u32,
    /// max 3D image dimension
    pub max_image_dimension_3d: u32,
    /// max cubemap image dimension
    pub max_image_dimension_cube: u32,
    /// max layers for image arrays
    pub max_image_array_layers: u32,
    /// max texel buffer size (fstexels)
    pub max_texel_buffer_elements: u32,
    /// max uniform buffer range (bytes)
    pub max_uniform_buffer_range: u32,
    /// max storage buffer range (bytes)
    pub max_storage_buffer_range: u32,
    /// max size of the push constants pool (bytes)
    pub max_push_constants_size: u32,
    /// max number of device memory allocations supported
    pub max_memory_allocation_count: u32,
    /// max number of samplers that can be allocated on a device
    pub max_sampler_allocation_count: u32,
    /// Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage
    pub buffer_image_granularity: DeviceSize,
    /// Total address space available for sparse allocations (bytes)
    pub sparse_address_space_size: DeviceSize,
    /// max number of descriptors sets that can be bound to a pipeline
    pub max_bound_descriptor_sets: u32,
    /// max number of samplers allowed per-stage in a descriptor set
    pub max_per_stage_descriptor_samplers: u32,
    /// max number of uniform buffers allowed per-stage in a descriptor set
    pub max_per_stage_descriptor_uniform_buffers: u32,
    /// max number of storage buffers allowed per-stage in a descriptor set
    pub max_per_stage_descriptor_storage_buffers: u32,
    /// max number of sampled images allowed per-stage in a descriptor set
    pub max_per_stage_descriptor_sampled_images: u32,
    /// max number of storage images allowed per-stage in a descriptor set
    pub max_per_stage_descriptor_storage_images: u32,
    /// max number of input attachments allowed per-stage in a descriptor set
    pub max_per_stage_descriptor_input_attachments: u32,
    /// max number of resources allowed by a single stage
    pub max_per_stage_resources: u32,
    /// max number of samplers allowed in all stages in a descriptor set
    pub max_descriptor_set_samplers: u32,
    /// max number of uniform buffers allowed in all stages in a descriptor set
    pub max_descriptor_set_uniform_buffers: u32,
    /// max number of dynamic uniform buffers allowed in all stages in a descriptor set
    pub max_descriptor_set_uniform_buffers_dynamic: u32,
    /// max number of storage buffers allowed in all stages in a descriptor set
    pub max_descriptor_set_storage_buffers: u32,
    /// max number of dynamic storage buffers allowed in all stages in a descriptor set
    pub max_descriptor_set_storage_buffers_dynamic: u32,
    /// max number of sampled images allowed in all stages in a descriptor set
    pub max_descriptor_set_sampled_images: u32,
    /// max number of storage images allowed in all stages in a descriptor set
    pub max_descriptor_set_storage_images: u32,
    /// max number of input attachments allowed in all stages in a descriptor set
    pub max_descriptor_set_input_attachments: u32,
    /// max number of vertex input attribute slots
    pub max_vertex_input_attributes: u32,
    /// max number of vertex input binding slots
    pub max_vertex_input_bindings: u32,
    /// max vertex input attribute offset added to vertex buffer offset
    pub max_vertex_input_attribute_offset: u32,
    /// max vertex input binding stride
    pub max_vertex_input_binding_stride: u32,
    /// max number of output components written by vertex shader
    pub max_vertex_output_components: u32,
    /// max level supported by tessellation primitive generator
    pub max_tessellation_generation_level: u32,
    /// max patch size (vertices)
    pub max_tessellation_patch_size: u32,
    /// max number of input components per-vertex in TCS
    pub max_tessellation_control_per_vertex_input_components: u32,
    /// max number of output components per-vertex in TCS
    pub max_tessellation_control_per_vertex_output_components: u32,
    /// max number of output components per-patch in TCS
    pub max_tessellation_control_per_patch_output_components: u32,
    /// max total number of per-vertex and per-patch output components in TCS
    pub max_tessellation_control_total_output_components: u32,
    /// max number of input components per vertex in TES
    pub max_tessellation_evaluation_input_components: u32,
    /// max number of output components per vertex in TES
    pub max_tessellation_evaluation_output_components: u32,
    /// max invocation count supported in geometry shader
    pub max_geometry_shader_invocations: u32,
    /// max number of input components read in geometry stage
    pub max_geometry_input_components: u32,
    /// max number of output components written in geometry stage
    pub max_geometry_output_components: u32,
    /// max number of vertices that can be emitted in geometry stage
    pub max_geometry_output_vertices: u32,
    /// max total number of components (all vertices) written in geometry stage
    pub max_geometry_total_output_components: u32,
    /// max number of input components read in fragment stage
    pub max_fragment_input_components: u32,
    /// max number of output attachments written in fragment stage
    pub max_fragment_output_attachments: u32,
    /// max number of output attachments written when using dual source blending
    pub max_fragment_dual_src_attachments: u32,
    /// max total number of storage buffers, storage images and output buffers
    pub max_fragment_combined_output_resources: u32,
    /// max total storage size of work group local storage (bytes)
    pub max_compute_shared_memory_size: u32,
    /// max num of compute work groups that may be dispatched by a single command (x,y,z)
    pub max_compute_work_group_count: [u32; 3],
    /// max total compute invocations in a single local work group
    pub max_compute_work_group_invocations: u32,
    /// max local size of a compute work group (x,y,z)
    pub max_compute_work_group_size: [u32; 3],
    /// number bits of subpixel precision in screen x and y
    pub sub_pixel_precision_bits: u32,
    /// number bits of precision for selecting texel weights
    pub sub_texel_precision_bits: u32,
    /// number bits of precision for selecting mipmap weights
    pub mipmap_precision_bits: u32,
    /// max index value for indexed draw calls (for 32-bit indices)
    pub max_draw_indexed_index_value: u32,
    /// max draw count for indirect drawing calls
    pub max_draw_indirect_count: u32,
    /// max absolute sampler LOD bias
    pub max_sampler_lod_bias: f32,
    /// max degree of sampler anisotropy
    pub max_sampler_anisotropy: f32,
    /// max number of active viewports
    pub max_viewports: u32,
    /// max viewport dimensions (x,y)
    pub max_viewport_dimensions: [u32; 2],
    /// viewport bounds range (min,max)
    pub viewport_bounds_range: [f32; 2],
    /// number bits of subpixel precision for viewport
    pub viewport_sub_pixel_bits: u32,
    /// min required alignment of pointers returned by MapMemory (bytes)
    pub min_memory_map_alignment: usize,
    /// min required alignment for texel buffer offsets (bytes)
    pub min_texel_buffer_offset_alignment: DeviceSize,
    /// min required alignment for uniform buffer sizes and offsets (bytes)
    pub min_uniform_buffer_offset_alignment: DeviceSize,
    /// min required alignment for storage buffer offsets (bytes)
    pub min_storage_buffer_offset_alignment: DeviceSize,
    /// min texel offset for OpTextureSampleOffset
    pub min_texel_offset: i32,
    /// max texel offset for OpTextureSampleOffset
    pub max_texel_offset: u32,
    /// min texel offset for OpTextureGatherOffset
    pub min_texel_gather_offset: i32,
    /// max texel offset for OpTextureGatherOffset
    pub max_texel_gather_offset: u32,
    /// furthest negative offset for interpolateAtOffset
    pub min_interpolation_offset: f32,
    /// furthest positive offset for interpolateAtOffset
    pub max_interpolation_offset: f32,
    /// number of subpixel bits for interpolateAtOffset
    pub sub_pixel_interpolation_offset_bits: u32,
    /// max width for a framebuffer
    pub max_framebuffer_width: u32,
    /// max height for a framebuffer
    pub max_framebuffer_height: u32,
    /// max layer count for a layered framebuffer
    pub max_framebuffer_layers: u32,
    /// supported color sample counts for a framebuffer
    pub framebuffer_color_sample_counts: SampleCountFlags,
    /// supported depth sample counts for a framebuffer
    pub framebuffer_depth_sample_counts: SampleCountFlags,
    /// supported stencil sample counts for a framebuffer
    pub framebuffer_stencil_sample_counts: SampleCountFlags,
    /// supported sample counts for a subpass which uses no attachments
    pub framebuffer_no_attachments_sample_counts: SampleCountFlags,
    /// max number of color attachments per subpass
    pub max_color_attachments: u32,
    /// supported color sample counts for a non-integer sampled image
    pub sampled_image_color_sample_counts: SampleCountFlags,
    /// supported sample counts for an integer image
    pub sampled_image_integer_sample_counts: SampleCountFlags,
    /// supported depth sample counts for a sampled image
    pub sampled_image_depth_sample_counts: SampleCountFlags,
    /// supported stencil sample counts for a sampled image
    pub sampled_image_stencil_sample_counts: SampleCountFlags,
    /// supported sample counts for a storage image
    pub storage_image_sample_counts: SampleCountFlags,
    /// max number of sample mask words
    pub max_sample_mask_words: u32,
    /// timestamps on graphics and compute queues
    pub timestamp_compute_and_graphics: Bool32,
    /// number of nanoseconds it takes for timestamp query value to increment by 1
    pub timestamp_period: f32,
    /// max number of clip distances
    pub max_clip_distances: u32,
    /// max number of cull distances
    pub max_cull_distances: u32,
    /// max combined number of user clipping
    pub max_combined_clip_and_cull_distances: u32,
    /// distinct queue priorities available
    pub discrete_queue_priorities: u32,
    /// range (min,max) of supported point sizes
    pub point_size_range: [f32; 2],
    /// range (min,max) of supported line widths
    pub line_width_range: [f32; 2],
    /// granularity of supported point sizes
    pub point_size_granularity: f32,
    /// granularity of supported line widths
    pub line_width_granularity: f32,
    /// line rasterization follows preferred rules
    pub strict_lines: Bool32,
    /// supports standard sample locations for all supported sample counts
    pub standard_sample_locations: Bool32,
    /// optimal offset of buffer copies
    pub optimal_buffer_copy_offset_alignment: DeviceSize,
    /// optimal pitch of buffer copies
    pub optimal_buffer_copy_row_pitch_alignment: DeviceSize,
    /// minimum size and alignment for non-coherent host-mapped device memory access
    pub non_coherent_atom_size: DeviceSize,
}
impl fmt::Debug for PhysicalDeviceLimits {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceLimits")
            .field("max_image_dimension_1d", &self.max_image_dimension_1d)
            .field("max_image_dimension_2d", &self.max_image_dimension_2d)
            .field("max_image_dimension_3d", &self.max_image_dimension_3d)
            .field("max_image_dimension_cube", &self.max_image_dimension_cube)
            .field("max_image_array_layers", &self.max_image_array_layers)
            .field("max_texel_buffer_elements", &self.max_texel_buffer_elements)
            .field("max_uniform_buffer_range", &self.max_uniform_buffer_range)
            .field("max_storage_buffer_range", &self.max_storage_buffer_range)
            .field("max_push_constants_size", &self.max_push_constants_size)
            .field("max_memory_allocation_count", &self.max_memory_allocation_count)
            .field("max_sampler_allocation_count", &self.max_sampler_allocation_count)
            .field("buffer_image_granularity", &self.buffer_image_granularity)
            .field("sparse_address_space_size", &self.sparse_address_space_size)
            .field("max_bound_descriptor_sets", &self.max_bound_descriptor_sets)
            .field(
                "max_per_stage_descriptor_samplers",
                &self.max_per_stage_descriptor_samplers,
            )
            .field(
                "max_per_stage_descriptor_uniform_buffers",
                &self.max_per_stage_descriptor_uniform_buffers,
            )
            .field(
                "max_per_stage_descriptor_storage_buffers",
                &self.max_per_stage_descriptor_storage_buffers,
            )
            .field(
                "max_per_stage_descriptor_sampled_images",
                &self.max_per_stage_descriptor_sampled_images,
            )
            .field(
                "max_per_stage_descriptor_storage_images",
                &self.max_per_stage_descriptor_storage_images,
            )
            .field(
                "max_per_stage_descriptor_input_attachments",
                &self.max_per_stage_descriptor_input_attachments,
            )
            .field("max_per_stage_resources", &self.max_per_stage_resources)
            .field("max_descriptor_set_samplers", &self.max_descriptor_set_samplers)
            .field(
                "max_descriptor_set_uniform_buffers",
                &self.max_descriptor_set_uniform_buffers,
            )
            .field(
                "max_descriptor_set_uniform_buffers_dynamic",
                &self.max_descriptor_set_uniform_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_storage_buffers",
                &self.max_descriptor_set_storage_buffers,
            )
            .field(
                "max_descriptor_set_storage_buffers_dynamic",
                &self.max_descriptor_set_storage_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_sampled_images",
                &self.max_descriptor_set_sampled_images,
            )
            .field(
                "max_descriptor_set_storage_images",
                &self.max_descriptor_set_storage_images,
            )
            .field(
                "max_descriptor_set_input_attachments",
                &self.max_descriptor_set_input_attachments,
            )
            .field("max_vertex_input_attributes", &self.max_vertex_input_attributes)
            .field("max_vertex_input_bindings", &self.max_vertex_input_bindings)
            .field(
                "max_vertex_input_attribute_offset",
                &self.max_vertex_input_attribute_offset,
            )
            .field("max_vertex_input_binding_stride", &self.max_vertex_input_binding_stride)
            .field("max_vertex_output_components", &self.max_vertex_output_components)
            .field(
                "max_tessellation_generation_level",
                &self.max_tessellation_generation_level,
            )
            .field("max_tessellation_patch_size", &self.max_tessellation_patch_size)
            .field(
                "max_tessellation_control_per_vertex_input_components",
                &self.max_tessellation_control_per_vertex_input_components,
            )
            .field(
                "max_tessellation_control_per_vertex_output_components",
                &self.max_tessellation_control_per_vertex_output_components,
            )
            .field(
                "max_tessellation_control_per_patch_output_components",
                &self.max_tessellation_control_per_patch_output_components,
            )
            .field(
                "max_tessellation_control_total_output_components",
                &self.max_tessellation_control_total_output_components,
            )
            .field(
                "max_tessellation_evaluation_input_components",
                &self.max_tessellation_evaluation_input_components,
            )
            .field(
                "max_tessellation_evaluation_output_components",
                &self.max_tessellation_evaluation_output_components,
            )
            .field("max_geometry_shader_invocations", &self.max_geometry_shader_invocations)
            .field("max_geometry_input_components", &self.max_geometry_input_components)
            .field("max_geometry_output_components", &self.max_geometry_output_components)
            .field("max_geometry_output_vertices", &self.max_geometry_output_vertices)
            .field(
                "max_geometry_total_output_components",
                &self.max_geometry_total_output_components,
            )
            .field("max_fragment_input_components", &self.max_fragment_input_components)
            .field("max_fragment_output_attachments", &self.max_fragment_output_attachments)
            .field(
                "max_fragment_dual_src_attachments",
                &self.max_fragment_dual_src_attachments,
            )
            .field(
                "max_fragment_combined_output_resources",
                &self.max_fragment_combined_output_resources,
            )
            .field("max_compute_shared_memory_size", &self.max_compute_shared_memory_size)
            .field("max_compute_work_group_count", &self.max_compute_work_group_count)
            .field(
                "max_compute_work_group_invocations",
                &self.max_compute_work_group_invocations,
            )
            .field("max_compute_work_group_size", &self.max_compute_work_group_size)
            .field("sub_pixel_precision_bits", &self.sub_pixel_precision_bits)
            .field("sub_texel_precision_bits", &self.sub_texel_precision_bits)
            .field("mipmap_precision_bits", &self.mipmap_precision_bits)
            .field("max_draw_indexed_index_value", &self.max_draw_indexed_index_value)
            .field("max_draw_indirect_count", &self.max_draw_indirect_count)
            .field("max_sampler_lod_bias", &self.max_sampler_lod_bias)
            .field("max_sampler_anisotropy", &self.max_sampler_anisotropy)
            .field("max_viewports", &self.max_viewports)
            .field("max_viewport_dimensions", &self.max_viewport_dimensions)
            .field("viewport_bounds_range", &self.viewport_bounds_range)
            .field("viewport_sub_pixel_bits", &self.viewport_sub_pixel_bits)
            .field("min_memory_map_alignment", &self.min_memory_map_alignment)
            .field(
                "min_texel_buffer_offset_alignment",
                &self.min_texel_buffer_offset_alignment,
            )
            .field(
                "min_uniform_buffer_offset_alignment",
                &self.min_uniform_buffer_offset_alignment,
            )
            .field(
                "min_storage_buffer_offset_alignment",
                &self.min_storage_buffer_offset_alignment,
            )
            .field("min_texel_offset", &self.min_texel_offset)
            .field("max_texel_offset", &self.max_texel_offset)
            .field("min_texel_gather_offset", &self.min_texel_gather_offset)
            .field("max_texel_gather_offset", &self.max_texel_gather_offset)
            .field("min_interpolation_offset", &self.min_interpolation_offset)
            .field("max_interpolation_offset", &self.max_interpolation_offset)
            .field(
                "sub_pixel_interpolation_offset_bits",
                &self.sub_pixel_interpolation_offset_bits,
            )
            .field("max_framebuffer_width", &self.max_framebuffer_width)
            .field("max_framebuffer_height", &self.max_framebuffer_height)
            .field("max_framebuffer_layers", &self.max_framebuffer_layers)
            .field("framebuffer_color_sample_counts", &self.framebuffer_color_sample_counts)
            .field("framebuffer_depth_sample_counts", &self.framebuffer_depth_sample_counts)
            .field(
                "framebuffer_stencil_sample_counts",
                &self.framebuffer_stencil_sample_counts,
            )
            .field(
                "framebuffer_no_attachments_sample_counts",
                &self.framebuffer_no_attachments_sample_counts,
            )
            .field("max_color_attachments", &self.max_color_attachments)
            .field(
                "sampled_image_color_sample_counts",
                &self.sampled_image_color_sample_counts,
            )
            .field(
                "sampled_image_integer_sample_counts",
                &self.sampled_image_integer_sample_counts,
            )
            .field(
                "sampled_image_depth_sample_counts",
                &self.sampled_image_depth_sample_counts,
            )
            .field(
                "sampled_image_stencil_sample_counts",
                &self.sampled_image_stencil_sample_counts,
            )
            .field("storage_image_sample_counts", &self.storage_image_sample_counts)
            .field("max_sample_mask_words", &self.max_sample_mask_words)
            .field("timestamp_compute_and_graphics", &self.timestamp_compute_and_graphics)
            .field("timestamp_period", &self.timestamp_period)
            .field("max_clip_distances", &self.max_clip_distances)
            .field("max_cull_distances", &self.max_cull_distances)
            .field(
                "max_combined_clip_and_cull_distances",
                &self.max_combined_clip_and_cull_distances,
            )
            .field("discrete_queue_priorities", &self.discrete_queue_priorities)
            .field("point_size_range", &self.point_size_range)
            .field("line_width_range", &self.line_width_range)
            .field("point_size_granularity", &self.point_size_granularity)
            .field("line_width_granularity", &self.line_width_granularity)
            .field("strict_lines", &self.strict_lines)
            .field("standard_sample_locations", &self.standard_sample_locations)
            .field(
                "optimal_buffer_copy_offset_alignment",
                &self.optimal_buffer_copy_offset_alignment,
            )
            .field(
                "optimal_buffer_copy_row_pitch_alignment",
                &self.optimal_buffer_copy_row_pitch_alignment,
            )
            .field("non_coherent_atom_size", &self.non_coherent_atom_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Semaphore creation flags
    pub flags: SemaphoreCreateFlags,
}
unsafe impl Send for SemaphoreCreateInfo {}
unsafe impl Sync for SemaphoreCreateInfo {}
impl Default for SemaphoreCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
        }
    }
}
impl fmt::Debug for SemaphoreCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueryPoolCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: QueryPoolCreateFlags,
    pub query_type: QueryType,
    pub query_count: u32,
    /// Optional
    pub pipeline_statistics: QueryPipelineStatisticFlags,
}
unsafe impl Send for QueryPoolCreateInfo {}
unsafe impl Sync for QueryPoolCreateInfo {}
impl Default for QueryPoolCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::QUERY_POOL_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            query_type: Default::default(),
            query_count: Default::default(),
            pipeline_statistics: Default::default(),
        }
    }
}
impl fmt::Debug for QueryPoolCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueryPoolCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("query_type", &self.query_type)
            .field("query_count", &self.query_count)
            .field("pipeline_statistics", &self.pipeline_statistics)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FramebufferCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: FramebufferCreateFlags,
    pub render_pass: Option<RenderPass>,
    pub attachment_count: u32,
    pub p_attachments: *const ImageView,
    pub width: u32,
    pub height: u32,
    pub layers: u32,
}
unsafe impl Send for FramebufferCreateInfo {}
unsafe impl Sync for FramebufferCreateInfo {}
impl Default for FramebufferCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::FRAMEBUFFER_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            render_pass: Default::default(),
            attachment_count: Default::default(),
            p_attachments: ptr::null(),
            width: Default::default(),
            height: Default::default(),
            layers: Default::default(),
        }
    }
}
impl fmt::Debug for FramebufferCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FramebufferCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("render_pass", &self.render_pass)
            .field("attachment_count", &self.attachment_count)
            .field("p_attachments", &self.p_attachments)
            .field("width", &self.width)
            .field("height", &self.height)
            .field("layers", &self.layers)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DrawIndirectCommand {
    pub vertex_count: u32,
    pub instance_count: u32,
    pub first_vertex: u32,
    pub first_instance: u32,
}
impl fmt::Debug for DrawIndirectCommand {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DrawIndirectCommand")
            .field("vertex_count", &self.vertex_count)
            .field("instance_count", &self.instance_count)
            .field("first_vertex", &self.first_vertex)
            .field("first_instance", &self.first_instance)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DrawIndexedIndirectCommand {
    pub index_count: u32,
    pub instance_count: u32,
    pub first_index: u32,
    pub vertex_offset: i32,
    pub first_instance: u32,
}
impl fmt::Debug for DrawIndexedIndirectCommand {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DrawIndexedIndirectCommand")
            .field("index_count", &self.index_count)
            .field("instance_count", &self.instance_count)
            .field("first_index", &self.first_index)
            .field("vertex_offset", &self.vertex_offset)
            .field("first_instance", &self.first_instance)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DispatchIndirectCommand {
    pub x: u32,
    pub y: u32,
    pub z: u32,
}
impl fmt::Debug for DispatchIndirectCommand {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DispatchIndirectCommand")
            .field("x", &self.x)
            .field("y", &self.y)
            .field("z", &self.z)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct MultiDrawInfoEXT {
    pub first_vertex: u32,
    pub vertex_count: u32,
}
impl fmt::Debug for MultiDrawInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MultiDrawInfoEXT")
            .field("first_vertex", &self.first_vertex)
            .field("vertex_count", &self.vertex_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct MultiDrawIndexedInfoEXT {
    pub first_index: u32,
    pub index_count: u32,
    pub vertex_offset: i32,
}
impl fmt::Debug for MultiDrawIndexedInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MultiDrawIndexedInfoEXT")
            .field("first_index", &self.first_index)
            .field("index_count", &self.index_count)
            .field("vertex_offset", &self.vertex_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_count: u32,
    pub p_wait_semaphores: *const Semaphore,
    pub p_wait_dst_stage_mask: *const PipelineStageFlags,
    pub command_buffer_count: u32,
    pub p_command_buffers: *const CommandBuffer,
    pub signal_semaphore_count: u32,
    pub p_signal_semaphores: *const Semaphore,
}
unsafe impl Send for SubmitInfo {}
unsafe impl Sync for SubmitInfo {}
impl Default for SubmitInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBMIT_INFO,
            p_next: ptr::null(),
            wait_semaphore_count: Default::default(),
            p_wait_semaphores: ptr::null(),
            p_wait_dst_stage_mask: ptr::null(),
            command_buffer_count: Default::default(),
            p_command_buffers: ptr::null(),
            signal_semaphore_count: Default::default(),
            p_signal_semaphores: ptr::null(),
        }
    }
}
impl fmt::Debug for SubmitInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubmitInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("wait_semaphore_count", &self.wait_semaphore_count)
            .field("p_wait_semaphores", &self.p_wait_semaphores)
            .field("p_wait_dst_stage_mask", &self.p_wait_dst_stage_mask)
            .field("command_buffer_count", &self.command_buffer_count)
            .field("p_command_buffers", &self.p_command_buffers)
            .field("signal_semaphore_count", &self.signal_semaphore_count)
            .field("p_signal_semaphores", &self.p_signal_semaphores)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayPropertiesKHR {
    /// Handle of the display object
    pub display: Option<DisplayKHR>,
    /// Name of the display
    pub display_name: *const c_char,
    /// In millimeters?
    pub physical_dimensions: Extent2D,
    /// Max resolution for CRT?
    pub physical_resolution: Extent2D,
    /// one or more bits from VkSurfaceTransformFlagsKHR
    pub supported_transforms: SurfaceTransformFlagsKHR,
    /// VK_TRUE if the overlay plane's z-order can be changed on this display.
    pub plane_reorder_possible: Bool32,
    /// VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering.
    pub persistent_content: Bool32,
}
unsafe impl Send for DisplayPropertiesKHR {}
unsafe impl Sync for DisplayPropertiesKHR {}
impl Default for DisplayPropertiesKHR {
    fn default() -> Self {
        Self {
            display: Default::default(),
            display_name: ptr::null(),
            physical_dimensions: Default::default(),
            physical_resolution: Default::default(),
            supported_transforms: Default::default(),
            plane_reorder_possible: Default::default(),
            persistent_content: Default::default(),
        }
    }
}
impl fmt::Debug for DisplayPropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPropertiesKHR")
            .field("display", &self.display)
            .field("display_name", &self.display_name)
            .field("physical_dimensions", &self.physical_dimensions)
            .field("physical_resolution", &self.physical_resolution)
            .field("supported_transforms", &self.supported_transforms)
            .field("plane_reorder_possible", &self.plane_reorder_possible)
            .field("persistent_content", &self.persistent_content)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct DisplayPlanePropertiesKHR {
    /// Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use.
    pub current_display: Option<DisplayKHR>,
    /// Current z-order of the plane.
    pub current_stack_index: u32,
}
impl fmt::Debug for DisplayPlanePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPlanePropertiesKHR")
            .field("current_display", &self.current_display)
            .field("current_stack_index", &self.current_stack_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DisplayModeParametersKHR {
    /// Visible scanout region.
    pub visible_region: Extent2D,
    /// Number of times per second the display is updated.
    pub refresh_rate: u32,
}
impl fmt::Debug for DisplayModeParametersKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayModeParametersKHR")
            .field("visible_region", &self.visible_region)
            .field("refresh_rate", &self.refresh_rate)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct DisplayModePropertiesKHR {
    /// Handle of this display mode.
    pub display_mode: Option<DisplayModeKHR>,
    /// The parameters this mode uses.
    pub parameters: DisplayModeParametersKHR,
}
impl fmt::Debug for DisplayModePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayModePropertiesKHR")
            .field("display_mode", &self.display_mode)
            .field("parameters", &self.parameters)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayModeCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DisplayModeCreateFlagsKHR,
    /// The parameters this mode uses.
    pub parameters: DisplayModeParametersKHR,
}
unsafe impl Send for DisplayModeCreateInfoKHR {}
unsafe impl Sync for DisplayModeCreateInfoKHR {}
impl Default for DisplayModeCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_MODE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: Default::default(),
            parameters: Default::default(),
        }
    }
}
impl fmt::Debug for DisplayModeCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayModeCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("parameters", &self.parameters)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DisplayPlaneCapabilitiesKHR {
    /// Types of alpha blending supported, if any.
    pub supported_alpha: DisplayPlaneAlphaFlagsKHR,
    /// Does the plane have any position and extent restrictions?
    pub min_src_position: Offset2D,
    pub max_src_position: Offset2D,
    pub min_src_extent: Extent2D,
    pub max_src_extent: Extent2D,
    pub min_dst_position: Offset2D,
    pub max_dst_position: Offset2D,
    pub min_dst_extent: Extent2D,
    pub max_dst_extent: Extent2D,
}
impl fmt::Debug for DisplayPlaneCapabilitiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPlaneCapabilitiesKHR")
            .field("supported_alpha", &self.supported_alpha)
            .field("min_src_position", &self.min_src_position)
            .field("max_src_position", &self.max_src_position)
            .field("min_src_extent", &self.min_src_extent)
            .field("max_src_extent", &self.max_src_extent)
            .field("min_dst_position", &self.min_dst_position)
            .field("max_dst_position", &self.max_dst_position)
            .field("min_dst_extent", &self.min_dst_extent)
            .field("max_dst_extent", &self.max_dst_extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplaySurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DisplaySurfaceCreateFlagsKHR,
    /// The mode to use when displaying this surface
    pub display_mode: Option<DisplayModeKHR>,
    /// The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.
    pub plane_index: u32,
    /// The z-order of the plane.
    pub plane_stack_index: u32,
    /// Transform to apply to the images as part of the scanout operation
    pub transform: SurfaceTransformFlagsKHR,
    /// Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR
    pub global_alpha: f32,
    /// What type of alpha blending to use.  Must be a bit from vkGetDisplayPlanePropertiesKHR::supportedAlpha.
    pub alpha_mode: DisplayPlaneAlphaFlagsKHR,
    /// size of the images to use with this surface
    pub image_extent: Extent2D,
}
unsafe impl Send for DisplaySurfaceCreateInfoKHR {}
unsafe impl Sync for DisplaySurfaceCreateInfoKHR {}
impl Default for DisplaySurfaceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_SURFACE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: Default::default(),
            display_mode: Default::default(),
            plane_index: Default::default(),
            plane_stack_index: Default::default(),
            transform: Default::default(),
            global_alpha: Default::default(),
            alpha_mode: Default::default(),
            image_extent: Default::default(),
        }
    }
}
impl fmt::Debug for DisplaySurfaceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplaySurfaceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("display_mode", &self.display_mode)
            .field("plane_index", &self.plane_index)
            .field("plane_stack_index", &self.plane_stack_index)
            .field("transform", &self.transform)
            .field("global_alpha", &self.global_alpha)
            .field("alpha_mode", &self.alpha_mode)
            .field("image_extent", &self.image_extent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayPresentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Rectangle within the presentable image to read pixel data from when presenting to the display.
    pub src_rect: Rect2D,
    /// Rectangle within the current display mode's visible region to display srcRectangle in.
    pub dst_rect: Rect2D,
    /// For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE.
    pub persistent: Bool32,
}
unsafe impl Send for DisplayPresentInfoKHR {}
unsafe impl Sync for DisplayPresentInfoKHR {}
impl Default for DisplayPresentInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_PRESENT_INFO_KHR,
            p_next: ptr::null(),
            src_rect: Default::default(),
            dst_rect: Default::default(),
            persistent: Default::default(),
        }
    }
}
impl fmt::Debug for DisplayPresentInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPresentInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_rect", &self.src_rect)
            .field("dst_rect", &self.dst_rect)
            .field("persistent", &self.persistent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SurfaceCapabilitiesKHR {
    /// Supported minimum number of images for the surface
    pub min_image_count: u32,
    /// Supported maximum number of images for the surface, 0 for unlimited
    pub max_image_count: u32,
    /// Current image width and height for the surface, (0, 0) if undefined
    pub current_extent: Extent2D,
    /// Supported minimum image width and height for the surface
    pub min_image_extent: Extent2D,
    /// Supported maximum image width and height for the surface
    pub max_image_extent: Extent2D,
    /// Supported maximum number of image layers for the surface
    pub max_image_array_layers: u32,
    /// 1 or more bits representing the transforms supported
    pub supported_transforms: SurfaceTransformFlagsKHR,
    /// The surface's current transform relative to the device's natural orientation
    pub current_transform: SurfaceTransformFlagsKHR,
    /// 1 or more bits representing the alpha compositing modes supported
    pub supported_composite_alpha: CompositeAlphaFlagsKHR,
    /// Supported image usage flags for the surface
    pub supported_usage_flags: ImageUsageFlags,
}
impl fmt::Debug for SurfaceCapabilitiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceCapabilitiesKHR")
            .field("min_image_count", &self.min_image_count)
            .field("max_image_count", &self.max_image_count)
            .field("current_extent", &self.current_extent)
            .field("min_image_extent", &self.min_image_extent)
            .field("max_image_extent", &self.max_image_extent)
            .field("max_image_array_layers", &self.max_image_array_layers)
            .field("supported_transforms", &self.supported_transforms)
            .field("current_transform", &self.current_transform)
            .field("supported_composite_alpha", &self.supported_composite_alpha)
            .field("supported_usage_flags", &self.supported_usage_flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AndroidSurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: AndroidSurfaceCreateFlagsKHR,
    pub window: *mut ANativeWindow,
}
unsafe impl Send for AndroidSurfaceCreateInfoKHR {}
unsafe impl Sync for AndroidSurfaceCreateInfoKHR {}
impl Default for AndroidSurfaceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ANDROID_SURFACE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: Default::default(),
            window: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for AndroidSurfaceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AndroidSurfaceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("window", &self.window)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ViSurfaceCreateInfoNN {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ViSurfaceCreateFlagsNN,
    pub window: *mut c_void,
}
unsafe impl Send for ViSurfaceCreateInfoNN {}
unsafe impl Sync for ViSurfaceCreateInfoNN {}
impl Default for ViSurfaceCreateInfoNN {
    fn default() -> Self {
        Self {
            s_type: StructureType::VI_SURFACE_CREATE_INFO_NN,
            p_next: ptr::null(),
            flags: Default::default(),
            window: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for ViSurfaceCreateInfoNN {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ViSurfaceCreateInfoNN")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("window", &self.window)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WaylandSurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: WaylandSurfaceCreateFlagsKHR,
    pub display: *mut wl_display,
    pub surface: *mut wl_surface,
}
unsafe impl Send for WaylandSurfaceCreateInfoKHR {}
unsafe impl Sync for WaylandSurfaceCreateInfoKHR {}
impl Default for WaylandSurfaceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::WAYLAND_SURFACE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: Default::default(),
            display: ptr::null_mut(),
            surface: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for WaylandSurfaceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("WaylandSurfaceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("display", &self.display)
            .field("surface", &self.surface)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Win32SurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: Win32SurfaceCreateFlagsKHR,
    pub hinstance: HINSTANCE,
    pub hwnd: HWND,
}
unsafe impl Send for Win32SurfaceCreateInfoKHR {}
unsafe impl Sync for Win32SurfaceCreateInfoKHR {}
impl Default for Win32SurfaceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::WIN32_SURFACE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: Default::default(),
            hinstance: unsafe { mem::zeroed() },
            hwnd: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for Win32SurfaceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Win32SurfaceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("hinstance", &self.hinstance)
            .field("hwnd", &self.hwnd)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XlibSurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: XlibSurfaceCreateFlagsKHR,
    pub dpy: *mut Display,
    pub window: Window,
}
unsafe impl Send for XlibSurfaceCreateInfoKHR {}
unsafe impl Sync for XlibSurfaceCreateInfoKHR {}
impl Default for XlibSurfaceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::XLIB_SURFACE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: Default::default(),
            dpy: ptr::null_mut(),
            window: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for XlibSurfaceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("XlibSurfaceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("dpy", &self.dpy)
            .field("window", &self.window)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XcbSurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: XcbSurfaceCreateFlagsKHR,
    pub connection: *mut xcb_connection_t,
    pub window: xcb_window_t,
}
unsafe impl Send for XcbSurfaceCreateInfoKHR {}
unsafe impl Sync for XcbSurfaceCreateInfoKHR {}
impl Default for XcbSurfaceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::XCB_SURFACE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: Default::default(),
            connection: ptr::null_mut(),
            window: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for XcbSurfaceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("XcbSurfaceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("connection", &self.connection)
            .field("window", &self.window)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DirectFBSurfaceCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DirectFBSurfaceCreateFlagsEXT,
    pub dfb: *mut IDirectFB,
    pub surface: *mut IDirectFBSurface,
}
unsafe impl Send for DirectFBSurfaceCreateInfoEXT {}
unsafe impl Sync for DirectFBSurfaceCreateInfoEXT {}
impl Default for DirectFBSurfaceCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DIRECTFB_SURFACE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: Default::default(),
            dfb: ptr::null_mut(),
            surface: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for DirectFBSurfaceCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DirectFBSurfaceCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("dfb", &self.dfb)
            .field("surface", &self.surface)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImagePipeSurfaceCreateInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImagePipeSurfaceCreateFlagsFUCHSIA,
    pub image_pipe_handle: zx_handle_t,
}
unsafe impl Send for ImagePipeSurfaceCreateInfoFUCHSIA {}
unsafe impl Sync for ImagePipeSurfaceCreateInfoFUCHSIA {}
impl Default for ImagePipeSurfaceCreateInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA,
            p_next: ptr::null(),
            flags: Default::default(),
            image_pipe_handle: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImagePipeSurfaceCreateInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImagePipeSurfaceCreateInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("image_pipe_handle", &self.image_pipe_handle)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SurfaceFormatKHR {
    /// Supported pair of rendering format
    pub format: Format,
    /// and color space for the surface
    pub color_space: ColorSpaceKHR,
}
impl fmt::Debug for SurfaceFormatKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceFormatKHR")
            .field("format", &self.format)
            .field("color_space", &self.color_space)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SwapchainCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SwapchainCreateFlagsKHR,
    /// The swapchain's target surface
    pub surface: Option<SurfaceKHR>,
    /// Minimum number of presentation images the application needs
    pub min_image_count: u32,
    /// Format of the presentation images
    pub image_format: Format,
    /// Colorspace of the presentation images
    pub image_color_space: ColorSpaceKHR,
    /// Dimensions of the presentation images
    pub image_extent: Extent2D,
    /// Determines the number of views for multiview/stereo presentation
    pub image_array_layers: u32,
    /// Bits indicating how the presentation images will be used
    pub image_usage: ImageUsageFlags,
    /// Sharing mode used for the presentation images
    pub image_sharing_mode: SharingMode,
    /// Number of queue families having access to the images in case of concurrent sharing mode
    pub queue_family_index_count: u32,
    /// Array of queue family indices having access to the images in case of concurrent sharing mode
    pub p_queue_family_indices: *const u32,
    /// The transform, relative to the device's natural orientation, applied to the image content prior to presentation
    pub pre_transform: SurfaceTransformFlagsKHR,
    /// The alpha blending mode used when compositing this surface with other surfaces in the window system
    pub composite_alpha: CompositeAlphaFlagsKHR,
    /// Which presentation mode to use for presents on this swap chain
    pub present_mode: PresentModeKHR,
    /// Specifies whether presentable images may be affected by window clip regions
    pub clipped: Bool32,
    /// Existing swap chain to replace, if any
    pub old_swapchain: Option<SwapchainKHR>,
}
unsafe impl Send for SwapchainCreateInfoKHR {}
unsafe impl Sync for SwapchainCreateInfoKHR {}
impl Default for SwapchainCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SWAPCHAIN_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: Default::default(),
            surface: Default::default(),
            min_image_count: Default::default(),
            image_format: Default::default(),
            image_color_space: Default::default(),
            image_extent: Default::default(),
            image_array_layers: Default::default(),
            image_usage: Default::default(),
            image_sharing_mode: Default::default(),
            queue_family_index_count: Default::default(),
            p_queue_family_indices: ptr::null(),
            pre_transform: Default::default(),
            composite_alpha: Default::default(),
            present_mode: Default::default(),
            clipped: Default::default(),
            old_swapchain: Default::default(),
        }
    }
}
impl fmt::Debug for SwapchainCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SwapchainCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("surface", &self.surface)
            .field("min_image_count", &self.min_image_count)
            .field("image_format", &self.image_format)
            .field("image_color_space", &self.image_color_space)
            .field("image_extent", &self.image_extent)
            .field("image_array_layers", &self.image_array_layers)
            .field("image_usage", &self.image_usage)
            .field("image_sharing_mode", &self.image_sharing_mode)
            .field("queue_family_index_count", &self.queue_family_index_count)
            .field("p_queue_family_indices", &self.p_queue_family_indices)
            .field("pre_transform", &self.pre_transform)
            .field("composite_alpha", &self.composite_alpha)
            .field("present_mode", &self.present_mode)
            .field("clipped", &self.clipped)
            .field("old_swapchain", &self.old_swapchain)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PresentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Number of semaphores to wait for before presenting
    pub wait_semaphore_count: u32,
    /// Semaphores to wait for before presenting
    pub p_wait_semaphores: *const Semaphore,
    /// Number of swapchains to present in this call
    pub swapchain_count: u32,
    /// Swapchains to present an image from
    pub p_swapchains: *const SwapchainKHR,
    /// Indices of which presentable images to present
    pub p_image_indices: *const u32,
    /// Optional (i.e. if non-NULL) VkResult for each swapchain
    pub p_results: *mut Result,
}
unsafe impl Send for PresentInfoKHR {}
unsafe impl Sync for PresentInfoKHR {}
impl Default for PresentInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PRESENT_INFO_KHR,
            p_next: ptr::null(),
            wait_semaphore_count: Default::default(),
            p_wait_semaphores: ptr::null(),
            swapchain_count: Default::default(),
            p_swapchains: ptr::null(),
            p_image_indices: ptr::null(),
            p_results: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for PresentInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PresentInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("wait_semaphore_count", &self.wait_semaphore_count)
            .field("p_wait_semaphores", &self.p_wait_semaphores)
            .field("swapchain_count", &self.swapchain_count)
            .field("p_swapchains", &self.p_swapchains)
            .field("p_image_indices", &self.p_image_indices)
            .field("p_results", &self.p_results)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugReportCallbackCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Indicates which events call this callback
    pub flags: DebugReportFlagsEXT,
    /// Function pointer of a callback function
    pub pfn_callback: Option<FnDebugReportCallbackEXT>,
    /// User data provided to callback function
    pub p_user_data: *mut c_void,
}
unsafe impl Send for DebugReportCallbackCreateInfoEXT {}
unsafe impl Sync for DebugReportCallbackCreateInfoEXT {}
impl Default for DebugReportCallbackCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: Default::default(),
            pfn_callback: Default::default(),
            p_user_data: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for DebugReportCallbackCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugReportCallbackCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field(
                "pfn_callback",
                if self.pfn_callback.is_some() { &"Some" } else { &"None" },
            )
            .field("p_user_data", &self.p_user_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ValidationFlagsEXT {
    /// Must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Number of validation checks to disable
    pub disabled_validation_check_count: u32,
    /// Validation checks to disable
    pub p_disabled_validation_checks: *const ValidationCheckEXT,
}
unsafe impl Send for ValidationFlagsEXT {}
unsafe impl Sync for ValidationFlagsEXT {}
impl Default for ValidationFlagsEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::VALIDATION_FLAGS_EXT,
            p_next: ptr::null(),
            disabled_validation_check_count: Default::default(),
            p_disabled_validation_checks: ptr::null(),
        }
    }
}
impl fmt::Debug for ValidationFlagsEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ValidationFlagsEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("disabled_validation_check_count", &self.disabled_validation_check_count)
            .field("p_disabled_validation_checks", &self.p_disabled_validation_checks)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ValidationFeaturesEXT {
    /// Must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Number of validation features to enable
    pub enabled_validation_feature_count: u32,
    /// Validation features to enable
    pub p_enabled_validation_features: *const ValidationFeatureEnableEXT,
    /// Number of validation features to disable
    pub disabled_validation_feature_count: u32,
    /// Validation features to disable
    pub p_disabled_validation_features: *const ValidationFeatureDisableEXT,
}
unsafe impl Send for ValidationFeaturesEXT {}
unsafe impl Sync for ValidationFeaturesEXT {}
impl Default for ValidationFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::VALIDATION_FEATURES_EXT,
            p_next: ptr::null(),
            enabled_validation_feature_count: Default::default(),
            p_enabled_validation_features: ptr::null(),
            disabled_validation_feature_count: Default::default(),
            p_disabled_validation_features: ptr::null(),
        }
    }
}
impl fmt::Debug for ValidationFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ValidationFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "enabled_validation_feature_count",
                &self.enabled_validation_feature_count,
            )
            .field("p_enabled_validation_features", &self.p_enabled_validation_features)
            .field(
                "disabled_validation_feature_count",
                &self.disabled_validation_feature_count,
            )
            .field("p_disabled_validation_features", &self.p_disabled_validation_features)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRasterizationStateRasterizationOrderAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Rasterization order to use for the pipeline
    pub rasterization_order: RasterizationOrderAMD,
}
unsafe impl Send for PipelineRasterizationStateRasterizationOrderAMD {}
unsafe impl Sync for PipelineRasterizationStateRasterizationOrderAMD {}
impl Default for PipelineRasterizationStateRasterizationOrderAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
            p_next: ptr::null(),
            rasterization_order: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineRasterizationStateRasterizationOrderAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRasterizationStateRasterizationOrderAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("rasterization_order", &self.rasterization_order)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugMarkerObjectNameInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// The type of the object
    pub object_type: DebugReportObjectTypeEXT,
    /// The handle of the object, cast to uint64_t
    pub object: u64,
    /// Name to apply to the object
    pub p_object_name: *const c_char,
}
unsafe impl Send for DebugMarkerObjectNameInfoEXT {}
unsafe impl Sync for DebugMarkerObjectNameInfoEXT {}
impl Default for DebugMarkerObjectNameInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
            p_next: ptr::null(),
            object_type: Default::default(),
            object: Default::default(),
            p_object_name: ptr::null(),
        }
    }
}
impl fmt::Debug for DebugMarkerObjectNameInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugMarkerObjectNameInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("object_type", &self.object_type)
            .field("object", &self.object)
            .field("p_object_name", &self.p_object_name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugMarkerObjectTagInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// The type of the object
    pub object_type: DebugReportObjectTypeEXT,
    /// The handle of the object, cast to uint64_t
    pub object: u64,
    /// The name of the tag to set on the object
    pub tag_name: u64,
    /// The length in bytes of the tag data
    pub tag_size: usize,
    /// Tag data to attach to the object
    pub p_tag: *const c_void,
}
unsafe impl Send for DebugMarkerObjectTagInfoEXT {}
unsafe impl Sync for DebugMarkerObjectTagInfoEXT {}
impl Default for DebugMarkerObjectTagInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
            p_next: ptr::null(),
            object_type: Default::default(),
            object: Default::default(),
            tag_name: Default::default(),
            tag_size: Default::default(),
            p_tag: ptr::null(),
        }
    }
}
impl fmt::Debug for DebugMarkerObjectTagInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugMarkerObjectTagInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("object_type", &self.object_type)
            .field("object", &self.object)
            .field("tag_name", &self.tag_name)
            .field("tag_size", &self.tag_size)
            .field("p_tag", &self.p_tag)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugMarkerMarkerInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Name of the debug marker
    pub p_marker_name: *const c_char,
    /// Optional color for debug marker
    pub color: [f32; 4],
}
unsafe impl Send for DebugMarkerMarkerInfoEXT {}
unsafe impl Sync for DebugMarkerMarkerInfoEXT {}
impl Default for DebugMarkerMarkerInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_MARKER_MARKER_INFO_EXT,
            p_next: ptr::null(),
            p_marker_name: ptr::null(),
            color: [Default::default(); 4],
        }
    }
}
impl fmt::Debug for DebugMarkerMarkerInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugMarkerMarkerInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_marker_name", &self.p_marker_name)
            .field("color", &self.color)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DedicatedAllocationImageCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Whether this image uses a dedicated allocation
    pub dedicated_allocation: Bool32,
}
unsafe impl Send for DedicatedAllocationImageCreateInfoNV {}
unsafe impl Sync for DedicatedAllocationImageCreateInfoNV {}
impl Default for DedicatedAllocationImageCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
            p_next: ptr::null(),
            dedicated_allocation: Default::default(),
        }
    }
}
impl fmt::Debug for DedicatedAllocationImageCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DedicatedAllocationImageCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("dedicated_allocation", &self.dedicated_allocation)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DedicatedAllocationBufferCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Whether this buffer uses a dedicated allocation
    pub dedicated_allocation: Bool32,
}
unsafe impl Send for DedicatedAllocationBufferCreateInfoNV {}
unsafe impl Sync for DedicatedAllocationBufferCreateInfoNV {}
impl Default for DedicatedAllocationBufferCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
            p_next: ptr::null(),
            dedicated_allocation: Default::default(),
        }
    }
}
impl fmt::Debug for DedicatedAllocationBufferCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DedicatedAllocationBufferCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("dedicated_allocation", &self.dedicated_allocation)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DedicatedAllocationMemoryAllocateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Image that this allocation will be bound to
    pub image: Option<Image>,
    /// Buffer that this allocation will be bound to
    pub buffer: Option<Buffer>,
}
unsafe impl Send for DedicatedAllocationMemoryAllocateInfoNV {}
unsafe impl Sync for DedicatedAllocationMemoryAllocateInfoNV {}
impl Default for DedicatedAllocationMemoryAllocateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
            p_next: ptr::null(),
            image: Default::default(),
            buffer: Default::default(),
        }
    }
}
impl fmt::Debug for DedicatedAllocationMemoryAllocateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DedicatedAllocationMemoryAllocateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image", &self.image)
            .field("buffer", &self.buffer)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ExternalImageFormatPropertiesNV {
    pub image_format_properties: ImageFormatProperties,
    pub external_memory_features: ExternalMemoryFeatureFlagsNV,
    pub export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNV,
    pub compatible_handle_types: ExternalMemoryHandleTypeFlagsNV,
}
impl fmt::Debug for ExternalImageFormatPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalImageFormatPropertiesNV")
            .field("image_format_properties", &self.image_format_properties)
            .field("external_memory_features", &self.external_memory_features)
            .field(
                "export_from_imported_handle_types",
                &self.export_from_imported_handle_types,
            )
            .field("compatible_handle_types", &self.compatible_handle_types)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalMemoryImageCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlagsNV,
}
unsafe impl Send for ExternalMemoryImageCreateInfoNV {}
unsafe impl Sync for ExternalMemoryImageCreateInfoNV {}
impl Default for ExternalMemoryImageCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
            p_next: ptr::null(),
            handle_types: Default::default(),
        }
    }
}
impl fmt::Debug for ExternalMemoryImageCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalMemoryImageCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_types", &self.handle_types)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMemoryAllocateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlagsNV,
}
unsafe impl Send for ExportMemoryAllocateInfoNV {}
unsafe impl Sync for ExportMemoryAllocateInfoNV {}
impl Default for ExportMemoryAllocateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_MEMORY_ALLOCATE_INFO_NV,
            p_next: ptr::null(),
            handle_types: Default::default(),
        }
    }
}
impl fmt::Debug for ExportMemoryAllocateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMemoryAllocateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_types", &self.handle_types)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMemoryWin32HandleInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlagsNV,
    pub handle: HANDLE,
}
unsafe impl Send for ImportMemoryWin32HandleInfoNV {}
unsafe impl Sync for ImportMemoryWin32HandleInfoNV {}
impl Default for ImportMemoryWin32HandleInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_MEMORY_WIN32_HANDLE_INFO_NV,
            p_next: ptr::null(),
            handle_type: Default::default(),
            handle: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportMemoryWin32HandleInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMemoryWin32HandleInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .field("handle", &self.handle)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMemoryWin32HandleInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
}
unsafe impl Send for ExportMemoryWin32HandleInfoNV {}
unsafe impl Sync for ExportMemoryWin32HandleInfoNV {}
impl Default for ExportMemoryWin32HandleInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_MEMORY_WIN32_HANDLE_INFO_NV,
            p_next: ptr::null(),
            p_attributes: ptr::null(),
            dw_access: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ExportMemoryWin32HandleInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMemoryWin32HandleInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_attributes", &self.p_attributes)
            .field("dw_access", &self.dw_access)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Win32KeyedMutexAcquireReleaseInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acquire_count: u32,
    pub p_acquire_syncs: *const DeviceMemory,
    pub p_acquire_keys: *const u64,
    pub p_acquire_timeout_milliseconds: *const u32,
    pub release_count: u32,
    pub p_release_syncs: *const DeviceMemory,
    pub p_release_keys: *const u64,
}
unsafe impl Send for Win32KeyedMutexAcquireReleaseInfoNV {}
unsafe impl Sync for Win32KeyedMutexAcquireReleaseInfoNV {}
impl Default for Win32KeyedMutexAcquireReleaseInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV,
            p_next: ptr::null(),
            acquire_count: Default::default(),
            p_acquire_syncs: ptr::null(),
            p_acquire_keys: ptr::null(),
            p_acquire_timeout_milliseconds: ptr::null(),
            release_count: Default::default(),
            p_release_syncs: ptr::null(),
            p_release_keys: ptr::null(),
        }
    }
}
impl fmt::Debug for Win32KeyedMutexAcquireReleaseInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Win32KeyedMutexAcquireReleaseInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acquire_count", &self.acquire_count)
            .field("p_acquire_syncs", &self.p_acquire_syncs)
            .field("p_acquire_keys", &self.p_acquire_keys)
            .field("p_acquire_timeout_milliseconds", &self.p_acquire_timeout_milliseconds)
            .field("release_count", &self.release_count)
            .field("p_release_syncs", &self.p_release_syncs)
            .field("p_release_keys", &self.p_release_keys)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_generated_commands: Bool32,
}
unsafe impl Send for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {}
unsafe impl Sync for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {}
impl Default for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV,
            p_next: ptr::null_mut(),
            device_generated_commands: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDeviceGeneratedCommandsFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_generated_commands", &self.device_generated_commands)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DevicePrivateDataCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub private_data_slot_request_count: u32,
}
unsafe impl Send for DevicePrivateDataCreateInfo {}
unsafe impl Sync for DevicePrivateDataCreateInfo {}
impl Default for DevicePrivateDataCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_PRIVATE_DATA_CREATE_INFO,
            p_next: ptr::null(),
            private_data_slot_request_count: Default::default(),
        }
    }
}
impl fmt::Debug for DevicePrivateDataCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DevicePrivateDataCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("private_data_slot_request_count", &self.private_data_slot_request_count)
            .finish()
    }
}
pub type DevicePrivateDataCreateInfoEXT = DevicePrivateDataCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PrivateDataSlotCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PrivateDataSlotCreateFlags,
}
unsafe impl Send for PrivateDataSlotCreateInfo {}
unsafe impl Sync for PrivateDataSlotCreateInfo {}
impl Default for PrivateDataSlotCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PRIVATE_DATA_SLOT_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
        }
    }
}
impl fmt::Debug for PrivateDataSlotCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PrivateDataSlotCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .finish()
    }
}
pub type PrivateDataSlotCreateInfoEXT = PrivateDataSlotCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePrivateDataFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub private_data: Bool32,
}
unsafe impl Send for PhysicalDevicePrivateDataFeatures {}
unsafe impl Sync for PhysicalDevicePrivateDataFeatures {}
impl Default for PhysicalDevicePrivateDataFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
            p_next: ptr::null_mut(),
            private_data: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePrivateDataFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePrivateDataFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("private_data", &self.private_data)
            .finish()
    }
}
pub type PhysicalDevicePrivateDataFeaturesEXT = PhysicalDevicePrivateDataFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_graphics_shader_group_count: u32,
    pub max_indirect_sequence_count: u32,
    pub max_indirect_commands_token_count: u32,
    pub max_indirect_commands_stream_count: u32,
    pub max_indirect_commands_token_offset: u32,
    pub max_indirect_commands_stream_stride: u32,
    pub min_sequences_count_buffer_offset_alignment: u32,
    pub min_sequences_index_buffer_offset_alignment: u32,
    pub min_indirect_commands_buffer_offset_alignment: u32,
}
unsafe impl Send for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {}
unsafe impl Sync for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {}
impl Default for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            max_graphics_shader_group_count: Default::default(),
            max_indirect_sequence_count: Default::default(),
            max_indirect_commands_token_count: Default::default(),
            max_indirect_commands_stream_count: Default::default(),
            max_indirect_commands_token_offset: Default::default(),
            max_indirect_commands_stream_stride: Default::default(),
            min_sequences_count_buffer_offset_alignment: Default::default(),
            min_sequences_index_buffer_offset_alignment: Default::default(),
            min_indirect_commands_buffer_offset_alignment: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDeviceGeneratedCommandsPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_graphics_shader_group_count", &self.max_graphics_shader_group_count)
            .field("max_indirect_sequence_count", &self.max_indirect_sequence_count)
            .field(
                "max_indirect_commands_token_count",
                &self.max_indirect_commands_token_count,
            )
            .field(
                "max_indirect_commands_stream_count",
                &self.max_indirect_commands_stream_count,
            )
            .field(
                "max_indirect_commands_token_offset",
                &self.max_indirect_commands_token_offset,
            )
            .field(
                "max_indirect_commands_stream_stride",
                &self.max_indirect_commands_stream_stride,
            )
            .field(
                "min_sequences_count_buffer_offset_alignment",
                &self.min_sequences_count_buffer_offset_alignment,
            )
            .field(
                "min_sequences_index_buffer_offset_alignment",
                &self.min_sequences_index_buffer_offset_alignment,
            )
            .field(
                "min_indirect_commands_buffer_offset_alignment",
                &self.min_indirect_commands_buffer_offset_alignment,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMultiDrawPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_multi_draw_count: u32,
}
unsafe impl Send for PhysicalDeviceMultiDrawPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceMultiDrawPropertiesEXT {}
impl Default for PhysicalDeviceMultiDrawPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            max_multi_draw_count: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMultiDrawPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMultiDrawPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_multi_draw_count", &self.max_multi_draw_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GraphicsShaderGroupCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub stage_count: u32,
    pub p_stages: *const PipelineShaderStageCreateInfo,
    pub p_vertex_input_state: *const PipelineVertexInputStateCreateInfo,
    pub p_tessellation_state: *const PipelineTessellationStateCreateInfo,
}
unsafe impl Send for GraphicsShaderGroupCreateInfoNV {}
unsafe impl Sync for GraphicsShaderGroupCreateInfoNV {}
impl Default for GraphicsShaderGroupCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::GRAPHICS_SHADER_GROUP_CREATE_INFO_NV,
            p_next: ptr::null(),
            stage_count: Default::default(),
            p_stages: ptr::null(),
            p_vertex_input_state: ptr::null(),
            p_tessellation_state: ptr::null(),
        }
    }
}
impl fmt::Debug for GraphicsShaderGroupCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GraphicsShaderGroupCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stage_count", &self.stage_count)
            .field("p_stages", &self.p_stages)
            .field("p_vertex_input_state", &self.p_vertex_input_state)
            .field("p_tessellation_state", &self.p_tessellation_state)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GraphicsPipelineShaderGroupsCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub group_count: u32,
    pub p_groups: *const GraphicsShaderGroupCreateInfoNV,
    pub pipeline_count: u32,
    pub p_pipelines: *const Pipeline,
}
unsafe impl Send for GraphicsPipelineShaderGroupsCreateInfoNV {}
unsafe impl Sync for GraphicsPipelineShaderGroupsCreateInfoNV {}
impl Default for GraphicsPipelineShaderGroupsCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV,
            p_next: ptr::null(),
            group_count: Default::default(),
            p_groups: ptr::null(),
            pipeline_count: Default::default(),
            p_pipelines: ptr::null(),
        }
    }
}
impl fmt::Debug for GraphicsPipelineShaderGroupsCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GraphicsPipelineShaderGroupsCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("group_count", &self.group_count)
            .field("p_groups", &self.p_groups)
            .field("pipeline_count", &self.pipeline_count)
            .field("p_pipelines", &self.p_pipelines)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct BindShaderGroupIndirectCommandNV {
    pub group_index: u32,
}
impl fmt::Debug for BindShaderGroupIndirectCommandNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindShaderGroupIndirectCommandNV")
            .field("group_index", &self.group_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct BindIndexBufferIndirectCommandNV {
    pub buffer_address: DeviceAddress,
    pub size: u32,
    pub index_type: IndexType,
}
impl fmt::Debug for BindIndexBufferIndirectCommandNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindIndexBufferIndirectCommandNV")
            .field("buffer_address", &self.buffer_address)
            .field("size", &self.size)
            .field("index_type", &self.index_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct BindVertexBufferIndirectCommandNV {
    pub buffer_address: DeviceAddress,
    pub size: u32,
    pub stride: u32,
}
impl fmt::Debug for BindVertexBufferIndirectCommandNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindVertexBufferIndirectCommandNV")
            .field("buffer_address", &self.buffer_address)
            .field("size", &self.size)
            .field("stride", &self.stride)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct SetStateFlagsIndirectCommandNV {
    pub data: u32,
}
impl fmt::Debug for SetStateFlagsIndirectCommandNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SetStateFlagsIndirectCommandNV")
            .field("data", &self.data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct IndirectCommandsStreamNV {
    pub buffer: Option<Buffer>,
    pub offset: DeviceSize,
}
impl fmt::Debug for IndirectCommandsStreamNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("IndirectCommandsStreamNV")
            .field("buffer", &self.buffer)
            .field("offset", &self.offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndirectCommandsLayoutTokenNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub token_type: IndirectCommandsTokenTypeNV,
    pub stream: u32,
    pub offset: u32,
    pub vertex_binding_unit: u32,
    pub vertex_dynamic_stride: Bool32,
    pub pushconstant_pipeline_layout: Option<PipelineLayout>,
    pub pushconstant_shader_stage_flags: ShaderStageFlags,
    pub pushconstant_offset: u32,
    pub pushconstant_size: u32,
    pub indirect_state_flags: IndirectStateFlagsNV,
    pub index_type_count: u32,
    pub p_index_types: *const IndexType,
    pub p_index_type_values: *const u32,
}
unsafe impl Send for IndirectCommandsLayoutTokenNV {}
unsafe impl Sync for IndirectCommandsLayoutTokenNV {}
impl Default for IndirectCommandsLayoutTokenNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::INDIRECT_COMMANDS_LAYOUT_TOKEN_NV,
            p_next: ptr::null(),
            token_type: Default::default(),
            stream: Default::default(),
            offset: Default::default(),
            vertex_binding_unit: Default::default(),
            vertex_dynamic_stride: Default::default(),
            pushconstant_pipeline_layout: Default::default(),
            pushconstant_shader_stage_flags: Default::default(),
            pushconstant_offset: Default::default(),
            pushconstant_size: Default::default(),
            indirect_state_flags: Default::default(),
            index_type_count: Default::default(),
            p_index_types: ptr::null(),
            p_index_type_values: ptr::null(),
        }
    }
}
impl fmt::Debug for IndirectCommandsLayoutTokenNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("IndirectCommandsLayoutTokenNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("token_type", &self.token_type)
            .field("stream", &self.stream)
            .field("offset", &self.offset)
            .field("vertex_binding_unit", &self.vertex_binding_unit)
            .field("vertex_dynamic_stride", &self.vertex_dynamic_stride)
            .field("pushconstant_pipeline_layout", &self.pushconstant_pipeline_layout)
            .field("pushconstant_shader_stage_flags", &self.pushconstant_shader_stage_flags)
            .field("pushconstant_offset", &self.pushconstant_offset)
            .field("pushconstant_size", &self.pushconstant_size)
            .field("indirect_state_flags", &self.indirect_state_flags)
            .field("index_type_count", &self.index_type_count)
            .field("p_index_types", &self.p_index_types)
            .field("p_index_type_values", &self.p_index_type_values)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndirectCommandsLayoutCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: IndirectCommandsLayoutUsageFlagsNV,
    pub pipeline_bind_point: PipelineBindPoint,
    pub token_count: u32,
    pub p_tokens: *const IndirectCommandsLayoutTokenNV,
    pub stream_count: u32,
    pub p_stream_strides: *const u32,
}
unsafe impl Send for IndirectCommandsLayoutCreateInfoNV {}
unsafe impl Sync for IndirectCommandsLayoutCreateInfoNV {}
impl Default for IndirectCommandsLayoutCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV,
            p_next: ptr::null(),
            flags: Default::default(),
            pipeline_bind_point: Default::default(),
            token_count: Default::default(),
            p_tokens: ptr::null(),
            stream_count: Default::default(),
            p_stream_strides: ptr::null(),
        }
    }
}
impl fmt::Debug for IndirectCommandsLayoutCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("IndirectCommandsLayoutCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("pipeline_bind_point", &self.pipeline_bind_point)
            .field("token_count", &self.token_count)
            .field("p_tokens", &self.p_tokens)
            .field("stream_count", &self.stream_count)
            .field("p_stream_strides", &self.p_stream_strides)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeneratedCommandsInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline_bind_point: PipelineBindPoint,
    pub pipeline: Option<Pipeline>,
    pub indirect_commands_layout: Option<IndirectCommandsLayoutNV>,
    pub stream_count: u32,
    pub p_streams: *const IndirectCommandsStreamNV,
    pub sequences_count: u32,
    pub preprocess_buffer: Option<Buffer>,
    pub preprocess_offset: DeviceSize,
    pub preprocess_size: DeviceSize,
    pub sequences_count_buffer: Option<Buffer>,
    pub sequences_count_offset: DeviceSize,
    pub sequences_index_buffer: Option<Buffer>,
    pub sequences_index_offset: DeviceSize,
}
unsafe impl Send for GeneratedCommandsInfoNV {}
unsafe impl Sync for GeneratedCommandsInfoNV {}
impl Default for GeneratedCommandsInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::GENERATED_COMMANDS_INFO_NV,
            p_next: ptr::null(),
            pipeline_bind_point: Default::default(),
            pipeline: Default::default(),
            indirect_commands_layout: Default::default(),
            stream_count: Default::default(),
            p_streams: ptr::null(),
            sequences_count: Default::default(),
            preprocess_buffer: Default::default(),
            preprocess_offset: Default::default(),
            preprocess_size: Default::default(),
            sequences_count_buffer: Default::default(),
            sequences_count_offset: Default::default(),
            sequences_index_buffer: Default::default(),
            sequences_index_offset: Default::default(),
        }
    }
}
impl fmt::Debug for GeneratedCommandsInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GeneratedCommandsInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline_bind_point", &self.pipeline_bind_point)
            .field("pipeline", &self.pipeline)
            .field("indirect_commands_layout", &self.indirect_commands_layout)
            .field("stream_count", &self.stream_count)
            .field("p_streams", &self.p_streams)
            .field("sequences_count", &self.sequences_count)
            .field("preprocess_buffer", &self.preprocess_buffer)
            .field("preprocess_offset", &self.preprocess_offset)
            .field("preprocess_size", &self.preprocess_size)
            .field("sequences_count_buffer", &self.sequences_count_buffer)
            .field("sequences_count_offset", &self.sequences_count_offset)
            .field("sequences_index_buffer", &self.sequences_index_buffer)
            .field("sequences_index_offset", &self.sequences_index_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeneratedCommandsMemoryRequirementsInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline_bind_point: PipelineBindPoint,
    pub pipeline: Option<Pipeline>,
    pub indirect_commands_layout: Option<IndirectCommandsLayoutNV>,
    pub max_sequences_count: u32,
}
unsafe impl Send for GeneratedCommandsMemoryRequirementsInfoNV {}
unsafe impl Sync for GeneratedCommandsMemoryRequirementsInfoNV {}
impl Default for GeneratedCommandsMemoryRequirementsInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV,
            p_next: ptr::null(),
            pipeline_bind_point: Default::default(),
            pipeline: Default::default(),
            indirect_commands_layout: Default::default(),
            max_sequences_count: Default::default(),
        }
    }
}
impl fmt::Debug for GeneratedCommandsMemoryRequirementsInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GeneratedCommandsMemoryRequirementsInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline_bind_point", &self.pipeline_bind_point)
            .field("pipeline", &self.pipeline)
            .field("indirect_commands_layout", &self.indirect_commands_layout)
            .field("max_sequences_count", &self.max_sequences_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFeatures2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub features: PhysicalDeviceFeatures,
}
unsafe impl Send for PhysicalDeviceFeatures2 {}
unsafe impl Sync for PhysicalDeviceFeatures2 {}
impl Default for PhysicalDeviceFeatures2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FEATURES_2,
            p_next: ptr::null_mut(),
            features: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFeatures2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFeatures2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("features", &self.features)
            .finish()
    }
}
pub type PhysicalDeviceFeatures2KHR = PhysicalDeviceFeatures2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub properties: PhysicalDeviceProperties,
}
unsafe impl Send for PhysicalDeviceProperties2 {}
unsafe impl Sync for PhysicalDeviceProperties2 {}
impl Default for PhysicalDeviceProperties2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PROPERTIES_2,
            p_next: ptr::null_mut(),
            properties: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceProperties2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceProperties2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("properties", &self.properties)
            .finish()
    }
}
pub type PhysicalDeviceProperties2KHR = PhysicalDeviceProperties2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FormatProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format_properties: FormatProperties,
}
unsafe impl Send for FormatProperties2 {}
unsafe impl Sync for FormatProperties2 {}
impl Default for FormatProperties2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::FORMAT_PROPERTIES_2,
            p_next: ptr::null_mut(),
            format_properties: Default::default(),
        }
    }
}
impl fmt::Debug for FormatProperties2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FormatProperties2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format_properties", &self.format_properties)
            .finish()
    }
}
pub type FormatProperties2KHR = FormatProperties2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageFormatProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_format_properties: ImageFormatProperties,
}
unsafe impl Send for ImageFormatProperties2 {}
unsafe impl Sync for ImageFormatProperties2 {}
impl Default for ImageFormatProperties2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_FORMAT_PROPERTIES_2,
            p_next: ptr::null_mut(),
            image_format_properties: Default::default(),
        }
    }
}
impl fmt::Debug for ImageFormatProperties2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageFormatProperties2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_format_properties", &self.image_format_properties)
            .finish()
    }
}
pub type ImageFormatProperties2KHR = ImageFormatProperties2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImageFormatInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format: Format,
    pub ty: ImageType,
    pub tiling: ImageTiling,
    pub usage: ImageUsageFlags,
    pub flags: ImageCreateFlags,
}
unsafe impl Send for PhysicalDeviceImageFormatInfo2 {}
unsafe impl Sync for PhysicalDeviceImageFormatInfo2 {}
impl Default for PhysicalDeviceImageFormatInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
            p_next: ptr::null(),
            format: Default::default(),
            ty: Default::default(),
            tiling: Default::default(),
            usage: Default::default(),
            flags: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImageFormatInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImageFormatInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format", &self.format)
            .field("ty", &self.ty)
            .field("tiling", &self.tiling)
            .field("usage", &self.usage)
            .field("flags", &self.flags)
            .finish()
    }
}
pub type PhysicalDeviceImageFormatInfo2KHR = PhysicalDeviceImageFormatInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueueFamilyProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub queue_family_properties: QueueFamilyProperties,
}
unsafe impl Send for QueueFamilyProperties2 {}
unsafe impl Sync for QueueFamilyProperties2 {}
impl Default for QueueFamilyProperties2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::QUEUE_FAMILY_PROPERTIES_2,
            p_next: ptr::null_mut(),
            queue_family_properties: Default::default(),
        }
    }
}
impl fmt::Debug for QueueFamilyProperties2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueueFamilyProperties2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("queue_family_properties", &self.queue_family_properties)
            .finish()
    }
}
pub type QueueFamilyProperties2KHR = QueueFamilyProperties2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMemoryProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_properties: PhysicalDeviceMemoryProperties,
}
unsafe impl Send for PhysicalDeviceMemoryProperties2 {}
unsafe impl Sync for PhysicalDeviceMemoryProperties2 {}
impl Default for PhysicalDeviceMemoryProperties2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
            p_next: ptr::null_mut(),
            memory_properties: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMemoryProperties2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMemoryProperties2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_properties", &self.memory_properties)
            .finish()
    }
}
pub type PhysicalDeviceMemoryProperties2KHR = PhysicalDeviceMemoryProperties2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SparseImageFormatProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub properties: SparseImageFormatProperties,
}
unsafe impl Send for SparseImageFormatProperties2 {}
unsafe impl Sync for SparseImageFormatProperties2 {}
impl Default for SparseImageFormatProperties2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::SPARSE_IMAGE_FORMAT_PROPERTIES_2,
            p_next: ptr::null_mut(),
            properties: Default::default(),
        }
    }
}
impl fmt::Debug for SparseImageFormatProperties2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseImageFormatProperties2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("properties", &self.properties)
            .finish()
    }
}
pub type SparseImageFormatProperties2KHR = SparseImageFormatProperties2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSparseImageFormatInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format: Format,
    pub ty: ImageType,
    pub samples: SampleCountFlags,
    pub usage: ImageUsageFlags,
    pub tiling: ImageTiling,
}
unsafe impl Send for PhysicalDeviceSparseImageFormatInfo2 {}
unsafe impl Sync for PhysicalDeviceSparseImageFormatInfo2 {}
impl Default for PhysicalDeviceSparseImageFormatInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
            p_next: ptr::null(),
            format: Default::default(),
            ty: Default::default(),
            samples: Default::default(),
            usage: Default::default(),
            tiling: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSparseImageFormatInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSparseImageFormatInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format", &self.format)
            .field("ty", &self.ty)
            .field("samples", &self.samples)
            .field("usage", &self.usage)
            .field("tiling", &self.tiling)
            .finish()
    }
}
pub type PhysicalDeviceSparseImageFormatInfo2KHR = PhysicalDeviceSparseImageFormatInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePushDescriptorPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_push_descriptors: u32,
}
unsafe impl Send for PhysicalDevicePushDescriptorPropertiesKHR {}
unsafe impl Sync for PhysicalDevicePushDescriptorPropertiesKHR {}
impl Default for PhysicalDevicePushDescriptorPropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            max_push_descriptors: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePushDescriptorPropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePushDescriptorPropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_push_descriptors", &self.max_push_descriptors)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ConformanceVersion {
    pub major: u8,
    pub minor: u8,
    pub subminor: u8,
    pub patch: u8,
}
impl fmt::Debug for ConformanceVersion {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ConformanceVersion")
            .field("major", &self.major)
            .field("minor", &self.minor)
            .field("subminor", &self.subminor)
            .field("patch", &self.patch)
            .finish()
    }
}
pub type ConformanceVersionKHR = ConformanceVersion;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDriverProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub driver_id: DriverId,
    pub driver_name: [c_char; MAX_DRIVER_NAME_SIZE],
    pub driver_info: [c_char; MAX_DRIVER_INFO_SIZE],
    pub conformance_version: ConformanceVersion,
}
unsafe impl Send for PhysicalDeviceDriverProperties {}
unsafe impl Sync for PhysicalDeviceDriverProperties {}
impl Default for PhysicalDeviceDriverProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DRIVER_PROPERTIES,
            p_next: ptr::null_mut(),
            driver_id: Default::default(),
            driver_name: [Default::default(); MAX_DRIVER_NAME_SIZE],
            driver_info: [Default::default(); MAX_DRIVER_INFO_SIZE],
            conformance_version: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDriverProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDriverProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("driver_id", &self.driver_id)
            .field("driver_name", &unsafe { CStr::from_ptr(self.driver_name.as_ptr()) })
            .field("driver_info", &unsafe { CStr::from_ptr(self.driver_info.as_ptr()) })
            .field("conformance_version", &self.conformance_version)
            .finish()
    }
}
pub type PhysicalDeviceDriverPropertiesKHR = PhysicalDeviceDriverProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PresentRegionsKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Copy of VkPresentInfoKHR::swapchainCount
    pub swapchain_count: u32,
    /// The regions that have changed
    pub p_regions: *const PresentRegionKHR,
}
unsafe impl Send for PresentRegionsKHR {}
unsafe impl Sync for PresentRegionsKHR {}
impl Default for PresentRegionsKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PRESENT_REGIONS_KHR,
            p_next: ptr::null(),
            swapchain_count: Default::default(),
            p_regions: ptr::null(),
        }
    }
}
impl fmt::Debug for PresentRegionsKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PresentRegionsKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("swapchain_count", &self.swapchain_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PresentRegionKHR {
    /// Number of rectangles in pRectangles
    pub rectangle_count: u32,
    /// Array of rectangles that have changed in a swapchain's image(s)
    pub p_rectangles: *const RectLayerKHR,
}
unsafe impl Send for PresentRegionKHR {}
unsafe impl Sync for PresentRegionKHR {}
impl Default for PresentRegionKHR {
    fn default() -> Self {
        Self {
            rectangle_count: Default::default(),
            p_rectangles: ptr::null(),
        }
    }
}
impl fmt::Debug for PresentRegionKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PresentRegionKHR")
            .field("rectangle_count", &self.rectangle_count)
            .field("p_rectangles", &self.p_rectangles)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct RectLayerKHR {
    /// upper-left corner of a rectangle that has not changed, in pixels of a presentation images
    pub offset: Offset2D,
    /// Dimensions of a rectangle that has not changed, in pixels of a presentation images
    pub extent: Extent2D,
    /// Layer of a swapchain's image(s), for stereoscopic-3D images
    pub layer: u32,
}
impl fmt::Debug for RectLayerKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RectLayerKHR")
            .field("offset", &self.offset)
            .field("extent", &self.extent)
            .field("layer", &self.layer)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVariablePointersFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub variable_pointers_storage_buffer: Bool32,
    pub variable_pointers: Bool32,
}
unsafe impl Send for PhysicalDeviceVariablePointersFeatures {}
unsafe impl Sync for PhysicalDeviceVariablePointersFeatures {}
impl Default for PhysicalDeviceVariablePointersFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
            p_next: ptr::null_mut(),
            variable_pointers_storage_buffer: Default::default(),
            variable_pointers: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVariablePointersFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVariablePointersFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "variable_pointers_storage_buffer",
                &self.variable_pointers_storage_buffer,
            )
            .field("variable_pointers", &self.variable_pointers)
            .finish()
    }
}
pub type PhysicalDeviceVariablePointersFeaturesKHR = PhysicalDeviceVariablePointersFeatures;
pub type PhysicalDeviceVariablePointerFeaturesKHR = PhysicalDeviceVariablePointersFeatures;
pub type PhysicalDeviceVariablePointerFeatures = PhysicalDeviceVariablePointersFeatures;
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ExternalMemoryProperties {
    pub external_memory_features: ExternalMemoryFeatureFlags,
    pub export_from_imported_handle_types: ExternalMemoryHandleTypeFlags,
    pub compatible_handle_types: ExternalMemoryHandleTypeFlags,
}
impl fmt::Debug for ExternalMemoryProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalMemoryProperties")
            .field("external_memory_features", &self.external_memory_features)
            .field(
                "export_from_imported_handle_types",
                &self.export_from_imported_handle_types,
            )
            .field("compatible_handle_types", &self.compatible_handle_types)
            .finish()
    }
}
pub type ExternalMemoryPropertiesKHR = ExternalMemoryProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExternalImageFormatInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for PhysicalDeviceExternalImageFormatInfo {}
unsafe impl Sync for PhysicalDeviceExternalImageFormatInfo {}
impl Default for PhysicalDeviceExternalImageFormatInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
            p_next: ptr::null(),
            handle_type: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExternalImageFormatInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExternalImageFormatInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
pub type PhysicalDeviceExternalImageFormatInfoKHR = PhysicalDeviceExternalImageFormatInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalImageFormatProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_memory_properties: ExternalMemoryProperties,
}
unsafe impl Send for ExternalImageFormatProperties {}
unsafe impl Sync for ExternalImageFormatProperties {}
impl Default for ExternalImageFormatProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_IMAGE_FORMAT_PROPERTIES,
            p_next: ptr::null_mut(),
            external_memory_properties: Default::default(),
        }
    }
}
impl fmt::Debug for ExternalImageFormatProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalImageFormatProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("external_memory_properties", &self.external_memory_properties)
            .finish()
    }
}
pub type ExternalImageFormatPropertiesKHR = ExternalImageFormatProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExternalBufferInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: BufferCreateFlags,
    pub usage: BufferUsageFlags,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for PhysicalDeviceExternalBufferInfo {}
unsafe impl Sync for PhysicalDeviceExternalBufferInfo {}
impl Default for PhysicalDeviceExternalBufferInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            usage: Default::default(),
            handle_type: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExternalBufferInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExternalBufferInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("usage", &self.usage)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
pub type PhysicalDeviceExternalBufferInfoKHR = PhysicalDeviceExternalBufferInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalBufferProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_memory_properties: ExternalMemoryProperties,
}
unsafe impl Send for ExternalBufferProperties {}
unsafe impl Sync for ExternalBufferProperties {}
impl Default for ExternalBufferProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_BUFFER_PROPERTIES,
            p_next: ptr::null_mut(),
            external_memory_properties: Default::default(),
        }
    }
}
impl fmt::Debug for ExternalBufferProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalBufferProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("external_memory_properties", &self.external_memory_properties)
            .finish()
    }
}
pub type ExternalBufferPropertiesKHR = ExternalBufferProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceIDProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_uuid: [u8; UUID_SIZE],
    pub driver_uuid: [u8; UUID_SIZE],
    pub device_luid: [u8; LUID_SIZE],
    pub device_node_mask: u32,
    pub device_luid_valid: Bool32,
}
unsafe impl Send for PhysicalDeviceIDProperties {}
unsafe impl Sync for PhysicalDeviceIDProperties {}
impl Default for PhysicalDeviceIDProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_ID_PROPERTIES,
            p_next: ptr::null_mut(),
            device_uuid: [Default::default(); UUID_SIZE],
            driver_uuid: [Default::default(); UUID_SIZE],
            device_luid: [Default::default(); LUID_SIZE],
            device_node_mask: Default::default(),
            device_luid_valid: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceIDProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceIDProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_uuid", &self.device_uuid)
            .field("driver_uuid", &self.driver_uuid)
            .field("device_luid", &self.device_luid)
            .field("device_node_mask", &self.device_node_mask)
            .field("device_luid_valid", &self.device_luid_valid)
            .finish()
    }
}
pub type PhysicalDeviceIDPropertiesKHR = PhysicalDeviceIDProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalMemoryImageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for ExternalMemoryImageCreateInfo {}
unsafe impl Sync for ExternalMemoryImageCreateInfo {}
impl Default for ExternalMemoryImageCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
            p_next: ptr::null(),
            handle_types: Default::default(),
        }
    }
}
impl fmt::Debug for ExternalMemoryImageCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalMemoryImageCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_types", &self.handle_types)
            .finish()
    }
}
pub type ExternalMemoryImageCreateInfoKHR = ExternalMemoryImageCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalMemoryBufferCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for ExternalMemoryBufferCreateInfo {}
unsafe impl Sync for ExternalMemoryBufferCreateInfo {}
impl Default for ExternalMemoryBufferCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
            p_next: ptr::null(),
            handle_types: Default::default(),
        }
    }
}
impl fmt::Debug for ExternalMemoryBufferCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalMemoryBufferCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_types", &self.handle_types)
            .finish()
    }
}
pub type ExternalMemoryBufferCreateInfoKHR = ExternalMemoryBufferCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMemoryAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for ExportMemoryAllocateInfo {}
unsafe impl Sync for ExportMemoryAllocateInfo {}
impl Default for ExportMemoryAllocateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_MEMORY_ALLOCATE_INFO,
            p_next: ptr::null(),
            handle_types: Default::default(),
        }
    }
}
impl fmt::Debug for ExportMemoryAllocateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMemoryAllocateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_types", &self.handle_types)
            .finish()
    }
}
pub type ExportMemoryAllocateInfoKHR = ExportMemoryAllocateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMemoryWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub handle: HANDLE,
    pub name: LPCWSTR,
}
unsafe impl Send for ImportMemoryWin32HandleInfoKHR {}
unsafe impl Sync for ImportMemoryWin32HandleInfoKHR {}
impl Default for ImportMemoryWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            handle_type: Default::default(),
            handle: unsafe { mem::zeroed() },
            name: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportMemoryWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMemoryWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .field("handle", &self.handle)
            .field("name", &self.name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMemoryWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
    pub name: LPCWSTR,
}
unsafe impl Send for ExportMemoryWin32HandleInfoKHR {}
unsafe impl Sync for ExportMemoryWin32HandleInfoKHR {}
impl Default for ExportMemoryWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            p_attributes: ptr::null(),
            dw_access: unsafe { mem::zeroed() },
            name: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ExportMemoryWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMemoryWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_attributes", &self.p_attributes)
            .field("dw_access", &self.dw_access)
            .field("name", &self.name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMemoryZirconHandleInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub handle: zx_handle_t,
}
unsafe impl Send for ImportMemoryZirconHandleInfoFUCHSIA {}
unsafe impl Sync for ImportMemoryZirconHandleInfoFUCHSIA {}
impl Default for ImportMemoryZirconHandleInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA,
            p_next: ptr::null(),
            handle_type: Default::default(),
            handle: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportMemoryZirconHandleInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMemoryZirconHandleInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .field("handle", &self.handle)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryZirconHandlePropertiesFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
}
unsafe impl Send for MemoryZirconHandlePropertiesFUCHSIA {}
unsafe impl Sync for MemoryZirconHandlePropertiesFUCHSIA {}
impl Default for MemoryZirconHandlePropertiesFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA,
            p_next: ptr::null_mut(),
            memory_type_bits: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryZirconHandlePropertiesFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryZirconHandlePropertiesFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_type_bits", &self.memory_type_bits)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryGetZirconHandleInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: Option<DeviceMemory>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for MemoryGetZirconHandleInfoFUCHSIA {}
unsafe impl Sync for MemoryGetZirconHandleInfoFUCHSIA {}
impl Default for MemoryGetZirconHandleInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA,
            p_next: ptr::null(),
            memory: Default::default(),
            handle_type: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryGetZirconHandleInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryGetZirconHandleInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryWin32HandlePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
}
unsafe impl Send for MemoryWin32HandlePropertiesKHR {}
unsafe impl Sync for MemoryWin32HandlePropertiesKHR {}
impl Default for MemoryWin32HandlePropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_WIN32_HANDLE_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            memory_type_bits: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryWin32HandlePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryWin32HandlePropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_type_bits", &self.memory_type_bits)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryGetWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: Option<DeviceMemory>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for MemoryGetWin32HandleInfoKHR {}
unsafe impl Sync for MemoryGetWin32HandleInfoKHR {}
impl Default for MemoryGetWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_GET_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            memory: Default::default(),
            handle_type: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryGetWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryGetWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMemoryFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub fd: c_int,
}
unsafe impl Send for ImportMemoryFdInfoKHR {}
unsafe impl Sync for ImportMemoryFdInfoKHR {}
impl Default for ImportMemoryFdInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_MEMORY_FD_INFO_KHR,
            p_next: ptr::null(),
            handle_type: Default::default(),
            fd: Default::default(),
        }
    }
}
impl fmt::Debug for ImportMemoryFdInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMemoryFdInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .field("fd", &self.fd)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryFdPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
}
unsafe impl Send for MemoryFdPropertiesKHR {}
unsafe impl Sync for MemoryFdPropertiesKHR {}
impl Default for MemoryFdPropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_FD_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            memory_type_bits: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryFdPropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryFdPropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_type_bits", &self.memory_type_bits)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryGetFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: Option<DeviceMemory>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for MemoryGetFdInfoKHR {}
unsafe impl Sync for MemoryGetFdInfoKHR {}
impl Default for MemoryGetFdInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_GET_FD_INFO_KHR,
            p_next: ptr::null(),
            memory: Default::default(),
            handle_type: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryGetFdInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryGetFdInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Win32KeyedMutexAcquireReleaseInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acquire_count: u32,
    pub p_acquire_syncs: *const DeviceMemory,
    pub p_acquire_keys: *const u64,
    pub p_acquire_timeouts: *const u32,
    pub release_count: u32,
    pub p_release_syncs: *const DeviceMemory,
    pub p_release_keys: *const u64,
}
unsafe impl Send for Win32KeyedMutexAcquireReleaseInfoKHR {}
unsafe impl Sync for Win32KeyedMutexAcquireReleaseInfoKHR {}
impl Default for Win32KeyedMutexAcquireReleaseInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
            p_next: ptr::null(),
            acquire_count: Default::default(),
            p_acquire_syncs: ptr::null(),
            p_acquire_keys: ptr::null(),
            p_acquire_timeouts: ptr::null(),
            release_count: Default::default(),
            p_release_syncs: ptr::null(),
            p_release_keys: ptr::null(),
        }
    }
}
impl fmt::Debug for Win32KeyedMutexAcquireReleaseInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("Win32KeyedMutexAcquireReleaseInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acquire_count", &self.acquire_count)
            .field("p_acquire_syncs", &self.p_acquire_syncs)
            .field("p_acquire_keys", &self.p_acquire_keys)
            .field("p_acquire_timeouts", &self.p_acquire_timeouts)
            .field("release_count", &self.release_count)
            .field("p_release_syncs", &self.p_release_syncs)
            .field("p_release_keys", &self.p_release_keys)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExternalSemaphoreInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
}
unsafe impl Send for PhysicalDeviceExternalSemaphoreInfo {}
unsafe impl Sync for PhysicalDeviceExternalSemaphoreInfo {}
impl Default for PhysicalDeviceExternalSemaphoreInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
            p_next: ptr::null(),
            handle_type: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExternalSemaphoreInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExternalSemaphoreInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
pub type PhysicalDeviceExternalSemaphoreInfoKHR = PhysicalDeviceExternalSemaphoreInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalSemaphoreProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlags,
    pub compatible_handle_types: ExternalSemaphoreHandleTypeFlags,
    pub external_semaphore_features: ExternalSemaphoreFeatureFlags,
}
unsafe impl Send for ExternalSemaphoreProperties {}
unsafe impl Sync for ExternalSemaphoreProperties {}
impl Default for ExternalSemaphoreProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_SEMAPHORE_PROPERTIES,
            p_next: ptr::null_mut(),
            export_from_imported_handle_types: Default::default(),
            compatible_handle_types: Default::default(),
            external_semaphore_features: Default::default(),
        }
    }
}
impl fmt::Debug for ExternalSemaphoreProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalSemaphoreProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "export_from_imported_handle_types",
                &self.export_from_imported_handle_types,
            )
            .field("compatible_handle_types", &self.compatible_handle_types)
            .field("external_semaphore_features", &self.external_semaphore_features)
            .finish()
    }
}
pub type ExternalSemaphorePropertiesKHR = ExternalSemaphoreProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportSemaphoreCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalSemaphoreHandleTypeFlags,
}
unsafe impl Send for ExportSemaphoreCreateInfo {}
unsafe impl Sync for ExportSemaphoreCreateInfo {}
impl Default for ExportSemaphoreCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_SEMAPHORE_CREATE_INFO,
            p_next: ptr::null(),
            handle_types: Default::default(),
        }
    }
}
impl fmt::Debug for ExportSemaphoreCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportSemaphoreCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_types", &self.handle_types)
            .finish()
    }
}
pub type ExportSemaphoreCreateInfoKHR = ExportSemaphoreCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportSemaphoreWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub handle: HANDLE,
    pub name: LPCWSTR,
}
unsafe impl Send for ImportSemaphoreWin32HandleInfoKHR {}
unsafe impl Sync for ImportSemaphoreWin32HandleInfoKHR {}
impl Default for ImportSemaphoreWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            semaphore: Default::default(),
            flags: Default::default(),
            handle_type: Default::default(),
            handle: unsafe { mem::zeroed() },
            name: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportSemaphoreWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportSemaphoreWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("flags", &self.flags)
            .field("handle_type", &self.handle_type)
            .field("handle", &self.handle)
            .field("name", &self.name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportSemaphoreWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
    pub name: LPCWSTR,
}
unsafe impl Send for ExportSemaphoreWin32HandleInfoKHR {}
unsafe impl Sync for ExportSemaphoreWin32HandleInfoKHR {}
impl Default for ExportSemaphoreWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            p_attributes: ptr::null(),
            dw_access: unsafe { mem::zeroed() },
            name: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ExportSemaphoreWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportSemaphoreWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_attributes", &self.p_attributes)
            .field("dw_access", &self.dw_access)
            .field("name", &self.name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct D3D12FenceSubmitInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_values_count: u32,
    pub p_wait_semaphore_values: *const u64,
    pub signal_semaphore_values_count: u32,
    pub p_signal_semaphore_values: *const u64,
}
unsafe impl Send for D3D12FenceSubmitInfoKHR {}
unsafe impl Sync for D3D12FenceSubmitInfoKHR {}
impl Default for D3D12FenceSubmitInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::D3D12_FENCE_SUBMIT_INFO_KHR,
            p_next: ptr::null(),
            wait_semaphore_values_count: Default::default(),
            p_wait_semaphore_values: ptr::null(),
            signal_semaphore_values_count: Default::default(),
            p_signal_semaphore_values: ptr::null(),
        }
    }
}
impl fmt::Debug for D3D12FenceSubmitInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("D3D12FenceSubmitInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("wait_semaphore_values_count", &self.wait_semaphore_values_count)
            .field("p_wait_semaphore_values", &self.p_wait_semaphore_values)
            .field("signal_semaphore_values_count", &self.signal_semaphore_values_count)
            .field("p_signal_semaphore_values", &self.p_signal_semaphore_values)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreGetWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
}
unsafe impl Send for SemaphoreGetWin32HandleInfoKHR {}
unsafe impl Sync for SemaphoreGetWin32HandleInfoKHR {}
impl Default for SemaphoreGetWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            semaphore: Default::default(),
            handle_type: Default::default(),
        }
    }
}
impl fmt::Debug for SemaphoreGetWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreGetWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportSemaphoreFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub fd: c_int,
}
unsafe impl Send for ImportSemaphoreFdInfoKHR {}
unsafe impl Sync for ImportSemaphoreFdInfoKHR {}
impl Default for ImportSemaphoreFdInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_SEMAPHORE_FD_INFO_KHR,
            p_next: ptr::null(),
            semaphore: Default::default(),
            flags: Default::default(),
            handle_type: Default::default(),
            fd: Default::default(),
        }
    }
}
impl fmt::Debug for ImportSemaphoreFdInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportSemaphoreFdInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("flags", &self.flags)
            .field("handle_type", &self.handle_type)
            .field("fd", &self.fd)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreGetFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
}
unsafe impl Send for SemaphoreGetFdInfoKHR {}
unsafe impl Sync for SemaphoreGetFdInfoKHR {}
impl Default for SemaphoreGetFdInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_GET_FD_INFO_KHR,
            p_next: ptr::null(),
            semaphore: Default::default(),
            handle_type: Default::default(),
        }
    }
}
impl fmt::Debug for SemaphoreGetFdInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreGetFdInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportSemaphoreZirconHandleInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub zircon_handle: zx_handle_t,
}
unsafe impl Send for ImportSemaphoreZirconHandleInfoFUCHSIA {}
unsafe impl Sync for ImportSemaphoreZirconHandleInfoFUCHSIA {}
impl Default for ImportSemaphoreZirconHandleInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA,
            p_next: ptr::null(),
            semaphore: Default::default(),
            flags: Default::default(),
            handle_type: Default::default(),
            zircon_handle: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportSemaphoreZirconHandleInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportSemaphoreZirconHandleInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("flags", &self.flags)
            .field("handle_type", &self.handle_type)
            .field("zircon_handle", &self.zircon_handle)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreGetZirconHandleInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
}
unsafe impl Send for SemaphoreGetZirconHandleInfoFUCHSIA {}
unsafe impl Sync for SemaphoreGetZirconHandleInfoFUCHSIA {}
impl Default for SemaphoreGetZirconHandleInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA,
            p_next: ptr::null(),
            semaphore: Default::default(),
            handle_type: Default::default(),
        }
    }
}
impl fmt::Debug for SemaphoreGetZirconHandleInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreGetZirconHandleInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExternalFenceInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalFenceHandleTypeFlags,
}
unsafe impl Send for PhysicalDeviceExternalFenceInfo {}
unsafe impl Sync for PhysicalDeviceExternalFenceInfo {}
impl Default for PhysicalDeviceExternalFenceInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
            p_next: ptr::null(),
            handle_type: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExternalFenceInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExternalFenceInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
pub type PhysicalDeviceExternalFenceInfoKHR = PhysicalDeviceExternalFenceInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalFenceProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub export_from_imported_handle_types: ExternalFenceHandleTypeFlags,
    pub compatible_handle_types: ExternalFenceHandleTypeFlags,
    pub external_fence_features: ExternalFenceFeatureFlags,
}
unsafe impl Send for ExternalFenceProperties {}
unsafe impl Sync for ExternalFenceProperties {}
impl Default for ExternalFenceProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_FENCE_PROPERTIES,
            p_next: ptr::null_mut(),
            export_from_imported_handle_types: Default::default(),
            compatible_handle_types: Default::default(),
            external_fence_features: Default::default(),
        }
    }
}
impl fmt::Debug for ExternalFenceProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalFenceProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "export_from_imported_handle_types",
                &self.export_from_imported_handle_types,
            )
            .field("compatible_handle_types", &self.compatible_handle_types)
            .field("external_fence_features", &self.external_fence_features)
            .finish()
    }
}
pub type ExternalFencePropertiesKHR = ExternalFenceProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportFenceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalFenceHandleTypeFlags,
}
unsafe impl Send for ExportFenceCreateInfo {}
unsafe impl Sync for ExportFenceCreateInfo {}
impl Default for ExportFenceCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_FENCE_CREATE_INFO,
            p_next: ptr::null(),
            handle_types: Default::default(),
        }
    }
}
impl fmt::Debug for ExportFenceCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportFenceCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_types", &self.handle_types)
            .finish()
    }
}
pub type ExportFenceCreateInfoKHR = ExportFenceCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportFenceWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Option<Fence>,
    pub flags: FenceImportFlags,
    pub handle_type: ExternalFenceHandleTypeFlags,
    pub handle: HANDLE,
    pub name: LPCWSTR,
}
unsafe impl Send for ImportFenceWin32HandleInfoKHR {}
unsafe impl Sync for ImportFenceWin32HandleInfoKHR {}
impl Default for ImportFenceWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_FENCE_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            fence: Default::default(),
            flags: Default::default(),
            handle_type: Default::default(),
            handle: unsafe { mem::zeroed() },
            name: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportFenceWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportFenceWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fence", &self.fence)
            .field("flags", &self.flags)
            .field("handle_type", &self.handle_type)
            .field("handle", &self.handle)
            .field("name", &self.name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportFenceWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
    pub name: LPCWSTR,
}
unsafe impl Send for ExportFenceWin32HandleInfoKHR {}
unsafe impl Sync for ExportFenceWin32HandleInfoKHR {}
impl Default for ExportFenceWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            p_attributes: ptr::null(),
            dw_access: unsafe { mem::zeroed() },
            name: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ExportFenceWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportFenceWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_attributes", &self.p_attributes)
            .field("dw_access", &self.dw_access)
            .field("name", &self.name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FenceGetWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Option<Fence>,
    pub handle_type: ExternalFenceHandleTypeFlags,
}
unsafe impl Send for FenceGetWin32HandleInfoKHR {}
unsafe impl Sync for FenceGetWin32HandleInfoKHR {}
impl Default for FenceGetWin32HandleInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::FENCE_GET_WIN32_HANDLE_INFO_KHR,
            p_next: ptr::null(),
            fence: Default::default(),
            handle_type: Default::default(),
        }
    }
}
impl fmt::Debug for FenceGetWin32HandleInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FenceGetWin32HandleInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fence", &self.fence)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportFenceFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Option<Fence>,
    pub flags: FenceImportFlags,
    pub handle_type: ExternalFenceHandleTypeFlags,
    pub fd: c_int,
}
unsafe impl Send for ImportFenceFdInfoKHR {}
unsafe impl Sync for ImportFenceFdInfoKHR {}
impl Default for ImportFenceFdInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_FENCE_FD_INFO_KHR,
            p_next: ptr::null(),
            fence: Default::default(),
            flags: Default::default(),
            handle_type: Default::default(),
            fd: Default::default(),
        }
    }
}
impl fmt::Debug for ImportFenceFdInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportFenceFdInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fence", &self.fence)
            .field("flags", &self.flags)
            .field("handle_type", &self.handle_type)
            .field("fd", &self.fd)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FenceGetFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Option<Fence>,
    pub handle_type: ExternalFenceHandleTypeFlags,
}
unsafe impl Send for FenceGetFdInfoKHR {}
unsafe impl Sync for FenceGetFdInfoKHR {}
impl Default for FenceGetFdInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::FENCE_GET_FD_INFO_KHR,
            p_next: ptr::null(),
            fence: Default::default(),
            handle_type: Default::default(),
        }
    }
}
impl fmt::Debug for FenceGetFdInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FenceGetFdInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fence", &self.fence)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMultiviewFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// Multiple views in a renderpass
    pub multiview: Bool32,
    /// Multiple views in a renderpass w/ geometry shader
    pub multiview_geometry_shader: Bool32,
    /// Multiple views in a renderpass w/ tessellation shader
    pub multiview_tessellation_shader: Bool32,
}
unsafe impl Send for PhysicalDeviceMultiviewFeatures {}
unsafe impl Sync for PhysicalDeviceMultiviewFeatures {}
impl Default for PhysicalDeviceMultiviewFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
            p_next: ptr::null_mut(),
            multiview: Default::default(),
            multiview_geometry_shader: Default::default(),
            multiview_tessellation_shader: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMultiviewFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMultiviewFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("multiview", &self.multiview)
            .field("multiview_geometry_shader", &self.multiview_geometry_shader)
            .field("multiview_tessellation_shader", &self.multiview_tessellation_shader)
            .finish()
    }
}
pub type PhysicalDeviceMultiviewFeaturesKHR = PhysicalDeviceMultiviewFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMultiviewProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// max number of views in a subpass
    pub max_multiview_view_count: u32,
    /// max instance index for a draw in a multiview subpass
    pub max_multiview_instance_index: u32,
}
unsafe impl Send for PhysicalDeviceMultiviewProperties {}
unsafe impl Sync for PhysicalDeviceMultiviewProperties {}
impl Default for PhysicalDeviceMultiviewProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
            p_next: ptr::null_mut(),
            max_multiview_view_count: Default::default(),
            max_multiview_instance_index: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMultiviewProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMultiviewProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_multiview_view_count", &self.max_multiview_view_count)
            .field("max_multiview_instance_index", &self.max_multiview_instance_index)
            .finish()
    }
}
pub type PhysicalDeviceMultiviewPropertiesKHR = PhysicalDeviceMultiviewProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassMultiviewCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub subpass_count: u32,
    pub p_view_masks: *const u32,
    pub dependency_count: u32,
    pub p_view_offsets: *const i32,
    pub correlation_mask_count: u32,
    pub p_correlation_masks: *const u32,
}
unsafe impl Send for RenderPassMultiviewCreateInfo {}
unsafe impl Sync for RenderPassMultiviewCreateInfo {}
impl Default for RenderPassMultiviewCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_MULTIVIEW_CREATE_INFO,
            p_next: ptr::null(),
            subpass_count: Default::default(),
            p_view_masks: ptr::null(),
            dependency_count: Default::default(),
            p_view_offsets: ptr::null(),
            correlation_mask_count: Default::default(),
            p_correlation_masks: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderPassMultiviewCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassMultiviewCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("subpass_count", &self.subpass_count)
            .field("p_view_masks", &self.p_view_masks)
            .field("dependency_count", &self.dependency_count)
            .field("p_view_offsets", &self.p_view_offsets)
            .field("correlation_mask_count", &self.correlation_mask_count)
            .field("p_correlation_masks", &self.p_correlation_masks)
            .finish()
    }
}
pub type RenderPassMultiviewCreateInfoKHR = RenderPassMultiviewCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SurfaceCapabilities2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// Supported minimum number of images for the surface
    pub min_image_count: u32,
    /// Supported maximum number of images for the surface, 0 for unlimited
    pub max_image_count: u32,
    /// Current image width and height for the surface, (0, 0) if undefined
    pub current_extent: Extent2D,
    /// Supported minimum image width and height for the surface
    pub min_image_extent: Extent2D,
    /// Supported maximum image width and height for the surface
    pub max_image_extent: Extent2D,
    /// Supported maximum number of image layers for the surface
    pub max_image_array_layers: u32,
    /// 1 or more bits representing the transforms supported
    pub supported_transforms: SurfaceTransformFlagsKHR,
    /// The surface's current transform relative to the device's natural orientation
    pub current_transform: SurfaceTransformFlagsKHR,
    /// 1 or more bits representing the alpha compositing modes supported
    pub supported_composite_alpha: CompositeAlphaFlagsKHR,
    /// Supported image usage flags for the surface
    pub supported_usage_flags: ImageUsageFlags,
    pub supported_surface_counters: SurfaceCounterFlagsEXT,
}
unsafe impl Send for SurfaceCapabilities2EXT {}
unsafe impl Sync for SurfaceCapabilities2EXT {}
impl Default for SurfaceCapabilities2EXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SURFACE_CAPABILITIES_2_EXT,
            p_next: ptr::null_mut(),
            min_image_count: Default::default(),
            max_image_count: Default::default(),
            current_extent: Default::default(),
            min_image_extent: Default::default(),
            max_image_extent: Default::default(),
            max_image_array_layers: Default::default(),
            supported_transforms: Default::default(),
            current_transform: Default::default(),
            supported_composite_alpha: Default::default(),
            supported_usage_flags: Default::default(),
            supported_surface_counters: Default::default(),
        }
    }
}
impl fmt::Debug for SurfaceCapabilities2EXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceCapabilities2EXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_image_count", &self.min_image_count)
            .field("max_image_count", &self.max_image_count)
            .field("current_extent", &self.current_extent)
            .field("min_image_extent", &self.min_image_extent)
            .field("max_image_extent", &self.max_image_extent)
            .field("max_image_array_layers", &self.max_image_array_layers)
            .field("supported_transforms", &self.supported_transforms)
            .field("current_transform", &self.current_transform)
            .field("supported_composite_alpha", &self.supported_composite_alpha)
            .field("supported_usage_flags", &self.supported_usage_flags)
            .field("supported_surface_counters", &self.supported_surface_counters)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayPowerInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub power_state: DisplayPowerStateEXT,
}
unsafe impl Send for DisplayPowerInfoEXT {}
unsafe impl Sync for DisplayPowerInfoEXT {}
impl Default for DisplayPowerInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_POWER_INFO_EXT,
            p_next: ptr::null(),
            power_state: Default::default(),
        }
    }
}
impl fmt::Debug for DisplayPowerInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPowerInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("power_state", &self.power_state)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceEventInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_event: DeviceEventTypeEXT,
}
unsafe impl Send for DeviceEventInfoEXT {}
unsafe impl Sync for DeviceEventInfoEXT {}
impl Default for DeviceEventInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_EVENT_INFO_EXT,
            p_next: ptr::null(),
            device_event: Default::default(),
        }
    }
}
impl fmt::Debug for DeviceEventInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceEventInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_event", &self.device_event)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayEventInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub display_event: DisplayEventTypeEXT,
}
unsafe impl Send for DisplayEventInfoEXT {}
unsafe impl Sync for DisplayEventInfoEXT {}
impl Default for DisplayEventInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_EVENT_INFO_EXT,
            p_next: ptr::null(),
            display_event: Default::default(),
        }
    }
}
impl fmt::Debug for DisplayEventInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayEventInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("display_event", &self.display_event)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SwapchainCounterCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub surface_counters: SurfaceCounterFlagsEXT,
}
unsafe impl Send for SwapchainCounterCreateInfoEXT {}
unsafe impl Sync for SwapchainCounterCreateInfoEXT {}
impl Default for SwapchainCounterCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
            p_next: ptr::null(),
            surface_counters: Default::default(),
        }
    }
}
impl fmt::Debug for SwapchainCounterCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SwapchainCounterCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("surface_counters", &self.surface_counters)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceGroupProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub physical_device_count: u32,
    pub physical_devices: [Option<PhysicalDevice>; MAX_DEVICE_GROUP_SIZE],
    pub subset_allocation: Bool32,
}
unsafe impl Send for PhysicalDeviceGroupProperties {}
unsafe impl Sync for PhysicalDeviceGroupProperties {}
impl Default for PhysicalDeviceGroupProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_GROUP_PROPERTIES,
            p_next: ptr::null_mut(),
            physical_device_count: Default::default(),
            physical_devices: [Default::default(); MAX_DEVICE_GROUP_SIZE],
            subset_allocation: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceGroupProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceGroupProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("physical_device_count", &self.physical_device_count)
            .field("physical_devices", &self.physical_devices)
            .field("subset_allocation", &self.subset_allocation)
            .finish()
    }
}
pub type PhysicalDeviceGroupPropertiesKHR = PhysicalDeviceGroupProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryAllocateFlagsInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: MemoryAllocateFlags,
    pub device_mask: u32,
}
unsafe impl Send for MemoryAllocateFlagsInfo {}
unsafe impl Sync for MemoryAllocateFlagsInfo {}
impl Default for MemoryAllocateFlagsInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_ALLOCATE_FLAGS_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            device_mask: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryAllocateFlagsInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryAllocateFlagsInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("device_mask", &self.device_mask)
            .finish()
    }
}
pub type MemoryAllocateFlagsInfoKHR = MemoryAllocateFlagsInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindBufferMemoryInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Option<Buffer>,
    pub memory: Option<DeviceMemory>,
    pub memory_offset: DeviceSize,
}
unsafe impl Send for BindBufferMemoryInfo {}
unsafe impl Sync for BindBufferMemoryInfo {}
impl Default for BindBufferMemoryInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_BUFFER_MEMORY_INFO,
            p_next: ptr::null(),
            buffer: Default::default(),
            memory: Default::default(),
            memory_offset: Default::default(),
        }
    }
}
impl fmt::Debug for BindBufferMemoryInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindBufferMemoryInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer", &self.buffer)
            .field("memory", &self.memory)
            .field("memory_offset", &self.memory_offset)
            .finish()
    }
}
pub type BindBufferMemoryInfoKHR = BindBufferMemoryInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindBufferMemoryDeviceGroupInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_index_count: u32,
    pub p_device_indices: *const u32,
}
unsafe impl Send for BindBufferMemoryDeviceGroupInfo {}
unsafe impl Sync for BindBufferMemoryDeviceGroupInfo {}
impl Default for BindBufferMemoryDeviceGroupInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
            p_next: ptr::null(),
            device_index_count: Default::default(),
            p_device_indices: ptr::null(),
        }
    }
}
impl fmt::Debug for BindBufferMemoryDeviceGroupInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindBufferMemoryDeviceGroupInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_index_count", &self.device_index_count)
            .field("p_device_indices", &self.p_device_indices)
            .finish()
    }
}
pub type BindBufferMemoryDeviceGroupInfoKHR = BindBufferMemoryDeviceGroupInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindImageMemoryInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Option<Image>,
    pub memory: Option<DeviceMemory>,
    pub memory_offset: DeviceSize,
}
unsafe impl Send for BindImageMemoryInfo {}
unsafe impl Sync for BindImageMemoryInfo {}
impl Default for BindImageMemoryInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_IMAGE_MEMORY_INFO,
            p_next: ptr::null(),
            image: Default::default(),
            memory: Default::default(),
            memory_offset: Default::default(),
        }
    }
}
impl fmt::Debug for BindImageMemoryInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindImageMemoryInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image", &self.image)
            .field("memory", &self.memory)
            .field("memory_offset", &self.memory_offset)
            .finish()
    }
}
pub type BindImageMemoryInfoKHR = BindImageMemoryInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindImageMemoryDeviceGroupInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_index_count: u32,
    pub p_device_indices: *const u32,
    pub split_instance_bind_region_count: u32,
    pub p_split_instance_bind_regions: *const Rect2D,
}
unsafe impl Send for BindImageMemoryDeviceGroupInfo {}
unsafe impl Sync for BindImageMemoryDeviceGroupInfo {}
impl Default for BindImageMemoryDeviceGroupInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
            p_next: ptr::null(),
            device_index_count: Default::default(),
            p_device_indices: ptr::null(),
            split_instance_bind_region_count: Default::default(),
            p_split_instance_bind_regions: ptr::null(),
        }
    }
}
impl fmt::Debug for BindImageMemoryDeviceGroupInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindImageMemoryDeviceGroupInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_index_count", &self.device_index_count)
            .field("p_device_indices", &self.p_device_indices)
            .field(
                "split_instance_bind_region_count",
                &self.split_instance_bind_region_count,
            )
            .field("p_split_instance_bind_regions", &self.p_split_instance_bind_regions)
            .finish()
    }
}
pub type BindImageMemoryDeviceGroupInfoKHR = BindImageMemoryDeviceGroupInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupRenderPassBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_mask: u32,
    pub device_render_area_count: u32,
    pub p_device_render_areas: *const Rect2D,
}
unsafe impl Send for DeviceGroupRenderPassBeginInfo {}
unsafe impl Sync for DeviceGroupRenderPassBeginInfo {}
impl Default for DeviceGroupRenderPassBeginInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            p_next: ptr::null(),
            device_mask: Default::default(),
            device_render_area_count: Default::default(),
            p_device_render_areas: ptr::null(),
        }
    }
}
impl fmt::Debug for DeviceGroupRenderPassBeginInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupRenderPassBeginInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_mask", &self.device_mask)
            .field("device_render_area_count", &self.device_render_area_count)
            .field("p_device_render_areas", &self.p_device_render_areas)
            .finish()
    }
}
pub type DeviceGroupRenderPassBeginInfoKHR = DeviceGroupRenderPassBeginInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupCommandBufferBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_mask: u32,
}
unsafe impl Send for DeviceGroupCommandBufferBeginInfo {}
unsafe impl Sync for DeviceGroupCommandBufferBeginInfo {}
impl Default for DeviceGroupCommandBufferBeginInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
            p_next: ptr::null(),
            device_mask: Default::default(),
        }
    }
}
impl fmt::Debug for DeviceGroupCommandBufferBeginInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupCommandBufferBeginInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_mask", &self.device_mask)
            .finish()
    }
}
pub type DeviceGroupCommandBufferBeginInfoKHR = DeviceGroupCommandBufferBeginInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupSubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_count: u32,
    pub p_wait_semaphore_device_indices: *const u32,
    pub command_buffer_count: u32,
    pub p_command_buffer_device_masks: *const u32,
    pub signal_semaphore_count: u32,
    pub p_signal_semaphore_device_indices: *const u32,
}
unsafe impl Send for DeviceGroupSubmitInfo {}
unsafe impl Sync for DeviceGroupSubmitInfo {}
impl Default for DeviceGroupSubmitInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_SUBMIT_INFO,
            p_next: ptr::null(),
            wait_semaphore_count: Default::default(),
            p_wait_semaphore_device_indices: ptr::null(),
            command_buffer_count: Default::default(),
            p_command_buffer_device_masks: ptr::null(),
            signal_semaphore_count: Default::default(),
            p_signal_semaphore_device_indices: ptr::null(),
        }
    }
}
impl fmt::Debug for DeviceGroupSubmitInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupSubmitInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("wait_semaphore_count", &self.wait_semaphore_count)
            .field("p_wait_semaphore_device_indices", &self.p_wait_semaphore_device_indices)
            .field("command_buffer_count", &self.command_buffer_count)
            .field("p_command_buffer_device_masks", &self.p_command_buffer_device_masks)
            .field("signal_semaphore_count", &self.signal_semaphore_count)
            .field(
                "p_signal_semaphore_device_indices",
                &self.p_signal_semaphore_device_indices,
            )
            .finish()
    }
}
pub type DeviceGroupSubmitInfoKHR = DeviceGroupSubmitInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupBindSparseInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub resource_device_index: u32,
    pub memory_device_index: u32,
}
unsafe impl Send for DeviceGroupBindSparseInfo {}
unsafe impl Sync for DeviceGroupBindSparseInfo {}
impl Default for DeviceGroupBindSparseInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_BIND_SPARSE_INFO,
            p_next: ptr::null(),
            resource_device_index: Default::default(),
            memory_device_index: Default::default(),
        }
    }
}
impl fmt::Debug for DeviceGroupBindSparseInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupBindSparseInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("resource_device_index", &self.resource_device_index)
            .field("memory_device_index", &self.memory_device_index)
            .finish()
    }
}
pub type DeviceGroupBindSparseInfoKHR = DeviceGroupBindSparseInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupPresentCapabilitiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub present_mask: [u32; MAX_DEVICE_GROUP_SIZE],
    pub modes: DeviceGroupPresentModeFlagsKHR,
}
unsafe impl Send for DeviceGroupPresentCapabilitiesKHR {}
unsafe impl Sync for DeviceGroupPresentCapabilitiesKHR {}
impl Default for DeviceGroupPresentCapabilitiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
            p_next: ptr::null_mut(),
            present_mask: [Default::default(); MAX_DEVICE_GROUP_SIZE],
            modes: Default::default(),
        }
    }
}
impl fmt::Debug for DeviceGroupPresentCapabilitiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupPresentCapabilitiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("present_mask", &self.present_mask)
            .field("modes", &self.modes)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageSwapchainCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain: Option<SwapchainKHR>,
}
unsafe impl Send for ImageSwapchainCreateInfoKHR {}
unsafe impl Sync for ImageSwapchainCreateInfoKHR {}
impl Default for ImageSwapchainCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
            p_next: ptr::null(),
            swapchain: Default::default(),
        }
    }
}
impl fmt::Debug for ImageSwapchainCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageSwapchainCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("swapchain", &self.swapchain)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindImageMemorySwapchainInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain: Option<SwapchainKHR>,
    pub image_index: u32,
}
unsafe impl Send for BindImageMemorySwapchainInfoKHR {}
unsafe impl Sync for BindImageMemorySwapchainInfoKHR {}
impl Default for BindImageMemorySwapchainInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
            p_next: ptr::null(),
            swapchain: Default::default(),
            image_index: Default::default(),
        }
    }
}
impl fmt::Debug for BindImageMemorySwapchainInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindImageMemorySwapchainInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("swapchain", &self.swapchain)
            .field("image_index", &self.image_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AcquireNextImageInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain: Option<SwapchainKHR>,
    pub timeout: u64,
    pub semaphore: Option<Semaphore>,
    pub fence: Option<Fence>,
    pub device_mask: u32,
}
unsafe impl Send for AcquireNextImageInfoKHR {}
unsafe impl Sync for AcquireNextImageInfoKHR {}
impl Default for AcquireNextImageInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACQUIRE_NEXT_IMAGE_INFO_KHR,
            p_next: ptr::null(),
            swapchain: Default::default(),
            timeout: Default::default(),
            semaphore: Default::default(),
            fence: Default::default(),
            device_mask: Default::default(),
        }
    }
}
impl fmt::Debug for AcquireNextImageInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AcquireNextImageInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("swapchain", &self.swapchain)
            .field("timeout", &self.timeout)
            .field("semaphore", &self.semaphore)
            .field("fence", &self.fence)
            .field("device_mask", &self.device_mask)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupPresentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain_count: u32,
    pub p_device_masks: *const u32,
    pub mode: DeviceGroupPresentModeFlagsKHR,
}
unsafe impl Send for DeviceGroupPresentInfoKHR {}
unsafe impl Sync for DeviceGroupPresentInfoKHR {}
impl Default for DeviceGroupPresentInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_PRESENT_INFO_KHR,
            p_next: ptr::null(),
            swapchain_count: Default::default(),
            p_device_masks: ptr::null(),
            mode: Default::default(),
        }
    }
}
impl fmt::Debug for DeviceGroupPresentInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupPresentInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("swapchain_count", &self.swapchain_count)
            .field("p_device_masks", &self.p_device_masks)
            .field("mode", &self.mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupDeviceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub physical_device_count: u32,
    pub p_physical_devices: *const PhysicalDevice,
}
unsafe impl Send for DeviceGroupDeviceCreateInfo {}
unsafe impl Sync for DeviceGroupDeviceCreateInfo {}
impl Default for DeviceGroupDeviceCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_DEVICE_CREATE_INFO,
            p_next: ptr::null(),
            physical_device_count: Default::default(),
            p_physical_devices: ptr::null(),
        }
    }
}
impl fmt::Debug for DeviceGroupDeviceCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupDeviceCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("physical_device_count", &self.physical_device_count)
            .field("p_physical_devices", &self.p_physical_devices)
            .finish()
    }
}
pub type DeviceGroupDeviceCreateInfoKHR = DeviceGroupDeviceCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupSwapchainCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub modes: DeviceGroupPresentModeFlagsKHR,
}
unsafe impl Send for DeviceGroupSwapchainCreateInfoKHR {}
unsafe impl Sync for DeviceGroupSwapchainCreateInfoKHR {}
impl Default for DeviceGroupSwapchainCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
            p_next: ptr::null(),
            modes: Default::default(),
        }
    }
}
impl fmt::Debug for DeviceGroupSwapchainCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceGroupSwapchainCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("modes", &self.modes)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DescriptorUpdateTemplateEntry {
    /// Binding within the destination descriptor set to write
    pub dst_binding: u32,
    /// Array element within the destination binding to write
    pub dst_array_element: u32,
    /// Number of descriptors to write
    pub descriptor_count: u32,
    /// Descriptor type to write
    pub descriptor_type: DescriptorType,
    /// Offset into pData where the descriptors to update are stored
    pub offset: usize,
    /// Stride between two descriptors in pData when writing more than one descriptor
    pub stride: usize,
}
impl fmt::Debug for DescriptorUpdateTemplateEntry {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorUpdateTemplateEntry")
            .field("dst_binding", &self.dst_binding)
            .field("dst_array_element", &self.dst_array_element)
            .field("descriptor_count", &self.descriptor_count)
            .field("descriptor_type", &self.descriptor_type)
            .field("offset", &self.offset)
            .field("stride", &self.stride)
            .finish()
    }
}
pub type DescriptorUpdateTemplateEntryKHR = DescriptorUpdateTemplateEntry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorUpdateTemplateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DescriptorUpdateTemplateCreateFlags,
    /// Number of descriptor update entries to use for the update template
    pub descriptor_update_entry_count: u32,
    /// Descriptor update entries for the template
    pub p_descriptor_update_entries: *const DescriptorUpdateTemplateEntry,
    pub template_type: DescriptorUpdateTemplateType,
    pub descriptor_set_layout: Option<DescriptorSetLayout>,
    pub pipeline_bind_point: PipelineBindPoint,
    /// If used for push descriptors, this is the only allowed layout
    pub pipeline_layout: Option<PipelineLayout>,
    pub set: u32,
}
unsafe impl Send for DescriptorUpdateTemplateCreateInfo {}
unsafe impl Sync for DescriptorUpdateTemplateCreateInfo {}
impl Default for DescriptorUpdateTemplateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            descriptor_update_entry_count: Default::default(),
            p_descriptor_update_entries: ptr::null(),
            template_type: Default::default(),
            descriptor_set_layout: Default::default(),
            pipeline_bind_point: Default::default(),
            pipeline_layout: Default::default(),
            set: Default::default(),
        }
    }
}
impl fmt::Debug for DescriptorUpdateTemplateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorUpdateTemplateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("descriptor_update_entry_count", &self.descriptor_update_entry_count)
            .field("p_descriptor_update_entries", &self.p_descriptor_update_entries)
            .field("template_type", &self.template_type)
            .field("descriptor_set_layout", &self.descriptor_set_layout)
            .field("pipeline_bind_point", &self.pipeline_bind_point)
            .field("pipeline_layout", &self.pipeline_layout)
            .field("set", &self.set)
            .finish()
    }
}
pub type DescriptorUpdateTemplateCreateInfoKHR = DescriptorUpdateTemplateCreateInfo;
/// Chromaticity coordinate
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct XYColorEXT {
    pub x: f32,
    pub y: f32,
}
impl fmt::Debug for XYColorEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("XYColorEXT")
            .field("x", &self.x)
            .field("y", &self.y)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePresentIdFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// Present ID in VkPresentInfoKHR
    pub present_id: Bool32,
}
unsafe impl Send for PhysicalDevicePresentIdFeaturesKHR {}
unsafe impl Sync for PhysicalDevicePresentIdFeaturesKHR {}
impl Default for PhysicalDevicePresentIdFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
            p_next: ptr::null_mut(),
            present_id: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePresentIdFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePresentIdFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("present_id", &self.present_id)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PresentIdKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Copy of VkPresentInfoKHR::swapchainCount
    pub swapchain_count: u32,
    /// Present ID values for each swapchain
    pub p_present_ids: *const u64,
}
unsafe impl Send for PresentIdKHR {}
unsafe impl Sync for PresentIdKHR {}
impl Default for PresentIdKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PRESENT_ID_KHR,
            p_next: ptr::null(),
            swapchain_count: Default::default(),
            p_present_ids: ptr::null(),
        }
    }
}
impl fmt::Debug for PresentIdKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PresentIdKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("swapchain_count", &self.swapchain_count)
            .field("p_present_ids", &self.p_present_ids)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePresentWaitFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// vkWaitForPresentKHR is supported
    pub present_wait: Bool32,
}
unsafe impl Send for PhysicalDevicePresentWaitFeaturesKHR {}
unsafe impl Sync for PhysicalDevicePresentWaitFeaturesKHR {}
impl Default for PhysicalDevicePresentWaitFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
            p_next: ptr::null_mut(),
            present_wait: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePresentWaitFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePresentWaitFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("present_wait", &self.present_wait)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdrMetadataEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Display primary's Red
    pub display_primary_red: XYColorEXT,
    /// Display primary's Green
    pub display_primary_green: XYColorEXT,
    /// Display primary's Blue
    pub display_primary_blue: XYColorEXT,
    /// Display primary's Blue
    pub white_point: XYColorEXT,
    /// Display maximum luminance
    pub max_luminance: f32,
    /// Display minimum luminance
    pub min_luminance: f32,
    /// Content maximum luminance
    pub max_content_light_level: f32,
    pub max_frame_average_light_level: f32,
}
unsafe impl Send for HdrMetadataEXT {}
unsafe impl Sync for HdrMetadataEXT {}
impl Default for HdrMetadataEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::HDR_METADATA_EXT,
            p_next: ptr::null(),
            display_primary_red: Default::default(),
            display_primary_green: Default::default(),
            display_primary_blue: Default::default(),
            white_point: Default::default(),
            max_luminance: Default::default(),
            min_luminance: Default::default(),
            max_content_light_level: Default::default(),
            max_frame_average_light_level: Default::default(),
        }
    }
}
impl fmt::Debug for HdrMetadataEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("HdrMetadataEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("display_primary_red", &self.display_primary_red)
            .field("display_primary_green", &self.display_primary_green)
            .field("display_primary_blue", &self.display_primary_blue)
            .field("white_point", &self.white_point)
            .field("max_luminance", &self.max_luminance)
            .field("min_luminance", &self.min_luminance)
            .field("max_content_light_level", &self.max_content_light_level)
            .field("max_frame_average_light_level", &self.max_frame_average_light_level)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayNativeHdrSurfaceCapabilitiesAMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub local_dimming_support: Bool32,
}
unsafe impl Send for DisplayNativeHdrSurfaceCapabilitiesAMD {}
unsafe impl Sync for DisplayNativeHdrSurfaceCapabilitiesAMD {}
impl Default for DisplayNativeHdrSurfaceCapabilitiesAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD,
            p_next: ptr::null_mut(),
            local_dimming_support: Default::default(),
        }
    }
}
impl fmt::Debug for DisplayNativeHdrSurfaceCapabilitiesAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayNativeHdrSurfaceCapabilitiesAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("local_dimming_support", &self.local_dimming_support)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SwapchainDisplayNativeHdrCreateInfoAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub local_dimming_enable: Bool32,
}
unsafe impl Send for SwapchainDisplayNativeHdrCreateInfoAMD {}
unsafe impl Sync for SwapchainDisplayNativeHdrCreateInfoAMD {}
impl Default for SwapchainDisplayNativeHdrCreateInfoAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
            p_next: ptr::null(),
            local_dimming_enable: Default::default(),
        }
    }
}
impl fmt::Debug for SwapchainDisplayNativeHdrCreateInfoAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SwapchainDisplayNativeHdrCreateInfoAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("local_dimming_enable", &self.local_dimming_enable)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct RefreshCycleDurationGOOGLE {
    /// Number of nanoseconds from the start of one refresh cycle to the next
    pub refresh_duration: u64,
}
impl fmt::Debug for RefreshCycleDurationGOOGLE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RefreshCycleDurationGOOGLE")
            .field("refresh_duration", &self.refresh_duration)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PastPresentationTimingGOOGLE {
    /// Application-provided identifier, previously given to vkQueuePresentKHR
    pub present_id: u32,
    /// Earliest time an image should have been presented, previously given to vkQueuePresentKHR
    pub desired_present_time: u64,
    /// Time the image was actually displayed
    pub actual_present_time: u64,
    /// Earliest time the image could have been displayed
    pub earliest_present_time: u64,
    /// How early vkQueuePresentKHR was processed vs. how soon it needed to be and make earliestPresentTime
    pub present_margin: u64,
}
impl fmt::Debug for PastPresentationTimingGOOGLE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PastPresentationTimingGOOGLE")
            .field("present_id", &self.present_id)
            .field("desired_present_time", &self.desired_present_time)
            .field("actual_present_time", &self.actual_present_time)
            .field("earliest_present_time", &self.earliest_present_time)
            .field("present_margin", &self.present_margin)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PresentTimesInfoGOOGLE {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Copy of VkPresentInfoKHR::swapchainCount
    pub swapchain_count: u32,
    /// The earliest times to present images
    pub p_times: *const PresentTimeGOOGLE,
}
unsafe impl Send for PresentTimesInfoGOOGLE {}
unsafe impl Sync for PresentTimesInfoGOOGLE {}
impl Default for PresentTimesInfoGOOGLE {
    fn default() -> Self {
        Self {
            s_type: StructureType::PRESENT_TIMES_INFO_GOOGLE,
            p_next: ptr::null(),
            swapchain_count: Default::default(),
            p_times: ptr::null(),
        }
    }
}
impl fmt::Debug for PresentTimesInfoGOOGLE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PresentTimesInfoGOOGLE")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("swapchain_count", &self.swapchain_count)
            .field("p_times", &self.p_times)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PresentTimeGOOGLE {
    /// Application-provided identifier
    pub present_id: u32,
    /// Earliest time an image should be presented
    pub desired_present_time: u64,
}
impl fmt::Debug for PresentTimeGOOGLE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PresentTimeGOOGLE")
            .field("present_id", &self.present_id)
            .field("desired_present_time", &self.desired_present_time)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IOSSurfaceCreateInfoMVK {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: IOSSurfaceCreateFlagsMVK,
    pub p_view: *const c_void,
}
unsafe impl Send for IOSSurfaceCreateInfoMVK {}
unsafe impl Sync for IOSSurfaceCreateInfoMVK {}
impl Default for IOSSurfaceCreateInfoMVK {
    fn default() -> Self {
        Self {
            s_type: StructureType::IOS_SURFACE_CREATE_INFO_MVK,
            p_next: ptr::null(),
            flags: Default::default(),
            p_view: ptr::null(),
        }
    }
}
impl fmt::Debug for IOSSurfaceCreateInfoMVK {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("IOSSurfaceCreateInfoMVK")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("p_view", &self.p_view)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MacOSSurfaceCreateInfoMVK {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: MacOSSurfaceCreateFlagsMVK,
    pub p_view: *const c_void,
}
unsafe impl Send for MacOSSurfaceCreateInfoMVK {}
unsafe impl Sync for MacOSSurfaceCreateInfoMVK {}
impl Default for MacOSSurfaceCreateInfoMVK {
    fn default() -> Self {
        Self {
            s_type: StructureType::MACOS_SURFACE_CREATE_INFO_MVK,
            p_next: ptr::null(),
            flags: Default::default(),
            p_view: ptr::null(),
        }
    }
}
impl fmt::Debug for MacOSSurfaceCreateInfoMVK {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MacOSSurfaceCreateInfoMVK")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("p_view", &self.p_view)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MetalSurfaceCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: MetalSurfaceCreateFlagsEXT,
    pub p_layer: *const CAMetalLayer,
}
unsafe impl Send for MetalSurfaceCreateInfoEXT {}
unsafe impl Sync for MetalSurfaceCreateInfoEXT {}
impl Default for MetalSurfaceCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::METAL_SURFACE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: Default::default(),
            p_layer: ptr::null(),
        }
    }
}
impl fmt::Debug for MetalSurfaceCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MetalSurfaceCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("p_layer", &self.p_layer)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct ViewportWScalingNV {
    pub xcoeff: f32,
    pub ycoeff: f32,
}
impl fmt::Debug for ViewportWScalingNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ViewportWScalingNV")
            .field("xcoeff", &self.xcoeff)
            .field("ycoeff", &self.ycoeff)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineViewportWScalingStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub viewport_w_scaling_enable: Bool32,
    pub viewport_count: u32,
    pub p_viewport_w_scalings: *const ViewportWScalingNV,
}
unsafe impl Send for PipelineViewportWScalingStateCreateInfoNV {}
unsafe impl Sync for PipelineViewportWScalingStateCreateInfoNV {}
impl Default for PipelineViewportWScalingStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            viewport_w_scaling_enable: Default::default(),
            viewport_count: Default::default(),
            p_viewport_w_scalings: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineViewportWScalingStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineViewportWScalingStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("viewport_w_scaling_enable", &self.viewport_w_scaling_enable)
            .field("viewport_count", &self.viewport_count)
            .field("p_viewport_w_scalings", &self.p_viewport_w_scalings)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ViewportSwizzleNV {
    pub x: ViewportCoordinateSwizzleNV,
    pub y: ViewportCoordinateSwizzleNV,
    pub z: ViewportCoordinateSwizzleNV,
    pub w: ViewportCoordinateSwizzleNV,
}
impl fmt::Debug for ViewportSwizzleNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ViewportSwizzleNV")
            .field("x", &self.x)
            .field("y", &self.y)
            .field("z", &self.z)
            .field("w", &self.w)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineViewportSwizzleStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineViewportSwizzleStateCreateFlagsNV,
    pub viewport_count: u32,
    pub p_viewport_swizzles: *const ViewportSwizzleNV,
}
unsafe impl Send for PipelineViewportSwizzleStateCreateInfoNV {}
unsafe impl Sync for PipelineViewportSwizzleStateCreateInfoNV {}
impl Default for PipelineViewportSwizzleStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            flags: Default::default(),
            viewport_count: Default::default(),
            p_viewport_swizzles: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineViewportSwizzleStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineViewportSwizzleStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("viewport_count", &self.viewport_count)
            .field("p_viewport_swizzles", &self.p_viewport_swizzles)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDiscardRectanglePropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// max number of active discard rectangles
    pub max_discard_rectangles: u32,
}
unsafe impl Send for PhysicalDeviceDiscardRectanglePropertiesEXT {}
unsafe impl Sync for PhysicalDeviceDiscardRectanglePropertiesEXT {}
impl Default for PhysicalDeviceDiscardRectanglePropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            max_discard_rectangles: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDiscardRectanglePropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDiscardRectanglePropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_discard_rectangles", &self.max_discard_rectangles)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineDiscardRectangleStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineDiscardRectangleStateCreateFlagsEXT,
    pub discard_rectangle_mode: DiscardRectangleModeEXT,
    pub discard_rectangle_count: u32,
    pub p_discard_rectangles: *const Rect2D,
}
unsafe impl Send for PipelineDiscardRectangleStateCreateInfoEXT {}
unsafe impl Sync for PipelineDiscardRectangleStateCreateInfoEXT {}
impl Default for PipelineDiscardRectangleStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: Default::default(),
            discard_rectangle_mode: Default::default(),
            discard_rectangle_count: Default::default(),
            p_discard_rectangles: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineDiscardRectangleStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineDiscardRectangleStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("discard_rectangle_mode", &self.discard_rectangle_mode)
            .field("discard_rectangle_count", &self.discard_rectangle_count)
            .field("p_discard_rectangles", &self.p_discard_rectangles)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub per_view_position_all_components: Bool32,
}
unsafe impl Send for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {}
unsafe impl Sync for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {}
impl Default for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
            p_next: ptr::null_mut(),
            per_view_position_all_components: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "per_view_position_all_components",
                &self.per_view_position_all_components,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct InputAttachmentAspectReference {
    pub subpass: u32,
    pub input_attachment_index: u32,
    pub aspect_mask: ImageAspectFlags,
}
impl fmt::Debug for InputAttachmentAspectReference {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("InputAttachmentAspectReference")
            .field("subpass", &self.subpass)
            .field("input_attachment_index", &self.input_attachment_index)
            .field("aspect_mask", &self.aspect_mask)
            .finish()
    }
}
pub type InputAttachmentAspectReferenceKHR = InputAttachmentAspectReference;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassInputAttachmentAspectCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub aspect_reference_count: u32,
    pub p_aspect_references: *const InputAttachmentAspectReference,
}
unsafe impl Send for RenderPassInputAttachmentAspectCreateInfo {}
unsafe impl Sync for RenderPassInputAttachmentAspectCreateInfo {}
impl Default for RenderPassInputAttachmentAspectCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
            p_next: ptr::null(),
            aspect_reference_count: Default::default(),
            p_aspect_references: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderPassInputAttachmentAspectCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassInputAttachmentAspectCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("aspect_reference_count", &self.aspect_reference_count)
            .field("p_aspect_references", &self.p_aspect_references)
            .finish()
    }
}
pub type RenderPassInputAttachmentAspectCreateInfoKHR = RenderPassInputAttachmentAspectCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSurfaceInfo2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub surface: Option<SurfaceKHR>,
}
unsafe impl Send for PhysicalDeviceSurfaceInfo2KHR {}
unsafe impl Sync for PhysicalDeviceSurfaceInfo2KHR {}
impl Default for PhysicalDeviceSurfaceInfo2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
            p_next: ptr::null(),
            surface: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSurfaceInfo2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSurfaceInfo2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("surface", &self.surface)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SurfaceCapabilities2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub surface_capabilities: SurfaceCapabilitiesKHR,
}
unsafe impl Send for SurfaceCapabilities2KHR {}
unsafe impl Sync for SurfaceCapabilities2KHR {}
impl Default for SurfaceCapabilities2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SURFACE_CAPABILITIES_2_KHR,
            p_next: ptr::null_mut(),
            surface_capabilities: Default::default(),
        }
    }
}
impl fmt::Debug for SurfaceCapabilities2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceCapabilities2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("surface_capabilities", &self.surface_capabilities)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SurfaceFormat2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub surface_format: SurfaceFormatKHR,
}
unsafe impl Send for SurfaceFormat2KHR {}
unsafe impl Sync for SurfaceFormat2KHR {}
impl Default for SurfaceFormat2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SURFACE_FORMAT_2_KHR,
            p_next: ptr::null_mut(),
            surface_format: Default::default(),
        }
    }
}
impl fmt::Debug for SurfaceFormat2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceFormat2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("surface_format", &self.surface_format)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayProperties2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub display_properties: DisplayPropertiesKHR,
}
unsafe impl Send for DisplayProperties2KHR {}
unsafe impl Sync for DisplayProperties2KHR {}
impl Default for DisplayProperties2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_PROPERTIES_2_KHR,
            p_next: ptr::null_mut(),
            display_properties: Default::default(),
        }
    }
}
impl fmt::Debug for DisplayProperties2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayProperties2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("display_properties", &self.display_properties)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayPlaneProperties2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub display_plane_properties: DisplayPlanePropertiesKHR,
}
unsafe impl Send for DisplayPlaneProperties2KHR {}
unsafe impl Sync for DisplayPlaneProperties2KHR {}
impl Default for DisplayPlaneProperties2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_PLANE_PROPERTIES_2_KHR,
            p_next: ptr::null_mut(),
            display_plane_properties: Default::default(),
        }
    }
}
impl fmt::Debug for DisplayPlaneProperties2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPlaneProperties2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("display_plane_properties", &self.display_plane_properties)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayModeProperties2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub display_mode_properties: DisplayModePropertiesKHR,
}
unsafe impl Send for DisplayModeProperties2KHR {}
unsafe impl Sync for DisplayModeProperties2KHR {}
impl Default for DisplayModeProperties2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_MODE_PROPERTIES_2_KHR,
            p_next: ptr::null_mut(),
            display_mode_properties: Default::default(),
        }
    }
}
impl fmt::Debug for DisplayModeProperties2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayModeProperties2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("display_mode_properties", &self.display_mode_properties)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayPlaneInfo2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mode: Option<DisplayModeKHR>,
    pub plane_index: u32,
}
unsafe impl Send for DisplayPlaneInfo2KHR {}
unsafe impl Sync for DisplayPlaneInfo2KHR {}
impl Default for DisplayPlaneInfo2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_PLANE_INFO_2_KHR,
            p_next: ptr::null(),
            mode: Default::default(),
            plane_index: Default::default(),
        }
    }
}
impl fmt::Debug for DisplayPlaneInfo2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPlaneInfo2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("mode", &self.mode)
            .field("plane_index", &self.plane_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DisplayPlaneCapabilities2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub capabilities: DisplayPlaneCapabilitiesKHR,
}
unsafe impl Send for DisplayPlaneCapabilities2KHR {}
unsafe impl Sync for DisplayPlaneCapabilities2KHR {}
impl Default for DisplayPlaneCapabilities2KHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DISPLAY_PLANE_CAPABILITIES_2_KHR,
            p_next: ptr::null_mut(),
            capabilities: Default::default(),
        }
    }
}
impl fmt::Debug for DisplayPlaneCapabilities2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DisplayPlaneCapabilities2KHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("capabilities", &self.capabilities)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SharedPresentSurfaceCapabilitiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// Supported image usage flags if swapchain created using a shared present mode
    pub shared_present_supported_usage_flags: ImageUsageFlags,
}
unsafe impl Send for SharedPresentSurfaceCapabilitiesKHR {}
unsafe impl Sync for SharedPresentSurfaceCapabilitiesKHR {}
impl Default for SharedPresentSurfaceCapabilitiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
            p_next: ptr::null_mut(),
            shared_present_supported_usage_flags: Default::default(),
        }
    }
}
impl fmt::Debug for SharedPresentSurfaceCapabilitiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SharedPresentSurfaceCapabilitiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "shared_present_supported_usage_flags",
                &self.shared_present_supported_usage_flags,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevice16BitStorageFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// 16-bit integer/floating-point variables supported in BufferBlock
    pub storage_buffer16_bit_access: Bool32,
    /// 16-bit integer/floating-point variables supported in BufferBlock and Block
    pub uniform_and_storage_buffer16_bit_access: Bool32,
    /// 16-bit integer/floating-point variables supported in PushConstant
    pub storage_push_constant16: Bool32,
    /// 16-bit integer/floating-point variables supported in shader inputs and outputs
    pub storage_input_output16: Bool32,
}
unsafe impl Send for PhysicalDevice16BitStorageFeatures {}
unsafe impl Sync for PhysicalDevice16BitStorageFeatures {}
impl Default for PhysicalDevice16BitStorageFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
            p_next: ptr::null_mut(),
            storage_buffer16_bit_access: Default::default(),
            uniform_and_storage_buffer16_bit_access: Default::default(),
            storage_push_constant16: Default::default(),
            storage_input_output16: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevice16BitStorageFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevice16BitStorageFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("storage_buffer16_bit_access", &self.storage_buffer16_bit_access)
            .field(
                "uniform_and_storage_buffer16_bit_access",
                &self.uniform_and_storage_buffer16_bit_access,
            )
            .field("storage_push_constant16", &self.storage_push_constant16)
            .field("storage_input_output16", &self.storage_input_output16)
            .finish()
    }
}
pub type PhysicalDevice16BitStorageFeaturesKHR = PhysicalDevice16BitStorageFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSubgroupProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// The size of a subgroup for this queue.
    pub subgroup_size: u32,
    /// Bitfield of what shader stages support subgroup operations
    pub supported_stages: ShaderStageFlags,
    /// Bitfield of what subgroup operations are supported.
    pub supported_operations: SubgroupFeatureFlags,
    /// Flag to specify whether quad operations are available in all stages.
    pub quad_operations_in_all_stages: Bool32,
}
unsafe impl Send for PhysicalDeviceSubgroupProperties {}
unsafe impl Sync for PhysicalDeviceSubgroupProperties {}
impl Default for PhysicalDeviceSubgroupProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
            p_next: ptr::null_mut(),
            subgroup_size: Default::default(),
            supported_stages: Default::default(),
            supported_operations: Default::default(),
            quad_operations_in_all_stages: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSubgroupProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSubgroupProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("subgroup_size", &self.subgroup_size)
            .field("supported_stages", &self.supported_stages)
            .field("supported_operations", &self.supported_operations)
            .field("quad_operations_in_all_stages", &self.quad_operations_in_all_stages)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// Flag to specify whether subgroup operations with extended types are supported
    pub shader_subgroup_extended_types: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderSubgroupExtendedTypesFeatures {}
unsafe impl Sync for PhysicalDeviceShaderSubgroupExtendedTypesFeatures {}
impl Default for PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
            p_next: ptr::null_mut(),
            shader_subgroup_extended_types: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderSubgroupExtendedTypesFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_subgroup_extended_types", &self.shader_subgroup_extended_types)
            .finish()
    }
}
pub type PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferMemoryRequirementsInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Option<Buffer>,
}
unsafe impl Send for BufferMemoryRequirementsInfo2 {}
unsafe impl Sync for BufferMemoryRequirementsInfo2 {}
impl Default for BufferMemoryRequirementsInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_MEMORY_REQUIREMENTS_INFO_2,
            p_next: ptr::null(),
            buffer: Default::default(),
        }
    }
}
impl fmt::Debug for BufferMemoryRequirementsInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferMemoryRequirementsInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer", &self.buffer)
            .finish()
    }
}
pub type BufferMemoryRequirementsInfo2KHR = BufferMemoryRequirementsInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceBufferMemoryRequirements {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_create_info: *const BufferCreateInfo,
}
unsafe impl Send for DeviceBufferMemoryRequirements {}
unsafe impl Sync for DeviceBufferMemoryRequirements {}
impl Default for DeviceBufferMemoryRequirements {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_BUFFER_MEMORY_REQUIREMENTS,
            p_next: ptr::null(),
            p_create_info: ptr::null(),
        }
    }
}
impl fmt::Debug for DeviceBufferMemoryRequirements {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceBufferMemoryRequirements")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_create_info", &self.p_create_info)
            .finish()
    }
}
pub type DeviceBufferMemoryRequirementsKHR = DeviceBufferMemoryRequirements;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageMemoryRequirementsInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Option<Image>,
}
unsafe impl Send for ImageMemoryRequirementsInfo2 {}
unsafe impl Sync for ImageMemoryRequirementsInfo2 {}
impl Default for ImageMemoryRequirementsInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_MEMORY_REQUIREMENTS_INFO_2,
            p_next: ptr::null(),
            image: Default::default(),
        }
    }
}
impl fmt::Debug for ImageMemoryRequirementsInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageMemoryRequirementsInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image", &self.image)
            .finish()
    }
}
pub type ImageMemoryRequirementsInfo2KHR = ImageMemoryRequirementsInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageSparseMemoryRequirementsInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Option<Image>,
}
unsafe impl Send for ImageSparseMemoryRequirementsInfo2 {}
unsafe impl Sync for ImageSparseMemoryRequirementsInfo2 {}
impl Default for ImageSparseMemoryRequirementsInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
            p_next: ptr::null(),
            image: Default::default(),
        }
    }
}
impl fmt::Debug for ImageSparseMemoryRequirementsInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageSparseMemoryRequirementsInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image", &self.image)
            .finish()
    }
}
pub type ImageSparseMemoryRequirementsInfo2KHR = ImageSparseMemoryRequirementsInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceImageMemoryRequirements {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_create_info: *const ImageCreateInfo,
    pub plane_aspect: ImageAspectFlags,
}
unsafe impl Send for DeviceImageMemoryRequirements {}
unsafe impl Sync for DeviceImageMemoryRequirements {}
impl Default for DeviceImageMemoryRequirements {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_IMAGE_MEMORY_REQUIREMENTS,
            p_next: ptr::null(),
            p_create_info: ptr::null(),
            plane_aspect: Default::default(),
        }
    }
}
impl fmt::Debug for DeviceImageMemoryRequirements {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceImageMemoryRequirements")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_create_info", &self.p_create_info)
            .field("plane_aspect", &self.plane_aspect)
            .finish()
    }
}
pub type DeviceImageMemoryRequirementsKHR = DeviceImageMemoryRequirements;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryRequirements2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_requirements: MemoryRequirements,
}
unsafe impl Send for MemoryRequirements2 {}
unsafe impl Sync for MemoryRequirements2 {}
impl Default for MemoryRequirements2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_REQUIREMENTS_2,
            p_next: ptr::null_mut(),
            memory_requirements: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryRequirements2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryRequirements2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_requirements", &self.memory_requirements)
            .finish()
    }
}
pub type MemoryRequirements2KHR = MemoryRequirements2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SparseImageMemoryRequirements2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_requirements: SparseImageMemoryRequirements,
}
unsafe impl Send for SparseImageMemoryRequirements2 {}
unsafe impl Sync for SparseImageMemoryRequirements2 {}
impl Default for SparseImageMemoryRequirements2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
            p_next: ptr::null_mut(),
            memory_requirements: Default::default(),
        }
    }
}
impl fmt::Debug for SparseImageMemoryRequirements2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SparseImageMemoryRequirements2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_requirements", &self.memory_requirements)
            .finish()
    }
}
pub type SparseImageMemoryRequirements2KHR = SparseImageMemoryRequirements2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePointClippingProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub point_clipping_behavior: PointClippingBehavior,
}
unsafe impl Send for PhysicalDevicePointClippingProperties {}
unsafe impl Sync for PhysicalDevicePointClippingProperties {}
impl Default for PhysicalDevicePointClippingProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
            p_next: ptr::null_mut(),
            point_clipping_behavior: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePointClippingProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePointClippingProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("point_clipping_behavior", &self.point_clipping_behavior)
            .finish()
    }
}
pub type PhysicalDevicePointClippingPropertiesKHR = PhysicalDevicePointClippingProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryDedicatedRequirements {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub prefers_dedicated_allocation: Bool32,
    pub requires_dedicated_allocation: Bool32,
}
unsafe impl Send for MemoryDedicatedRequirements {}
unsafe impl Sync for MemoryDedicatedRequirements {}
impl Default for MemoryDedicatedRequirements {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_DEDICATED_REQUIREMENTS,
            p_next: ptr::null_mut(),
            prefers_dedicated_allocation: Default::default(),
            requires_dedicated_allocation: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryDedicatedRequirements {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryDedicatedRequirements")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("prefers_dedicated_allocation", &self.prefers_dedicated_allocation)
            .field("requires_dedicated_allocation", &self.requires_dedicated_allocation)
            .finish()
    }
}
pub type MemoryDedicatedRequirementsKHR = MemoryDedicatedRequirements;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryDedicatedAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Image that this allocation will be bound to
    pub image: Option<Image>,
    /// Buffer that this allocation will be bound to
    pub buffer: Option<Buffer>,
}
unsafe impl Send for MemoryDedicatedAllocateInfo {}
unsafe impl Sync for MemoryDedicatedAllocateInfo {}
impl Default for MemoryDedicatedAllocateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_DEDICATED_ALLOCATE_INFO,
            p_next: ptr::null(),
            image: Default::default(),
            buffer: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryDedicatedAllocateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryDedicatedAllocateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image", &self.image)
            .field("buffer", &self.buffer)
            .finish()
    }
}
pub type MemoryDedicatedAllocateInfoKHR = MemoryDedicatedAllocateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageViewUsageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub usage: ImageUsageFlags,
}
unsafe impl Send for ImageViewUsageCreateInfo {}
unsafe impl Sync for ImageViewUsageCreateInfo {}
impl Default for ImageViewUsageCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_VIEW_USAGE_CREATE_INFO,
            p_next: ptr::null(),
            usage: Default::default(),
        }
    }
}
impl fmt::Debug for ImageViewUsageCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageViewUsageCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("usage", &self.usage)
            .finish()
    }
}
pub type ImageViewUsageCreateInfoKHR = ImageViewUsageCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineTessellationDomainOriginStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub domain_origin: TessellationDomainOrigin,
}
unsafe impl Send for PipelineTessellationDomainOriginStateCreateInfo {}
unsafe impl Sync for PipelineTessellationDomainOriginStateCreateInfo {}
impl Default for PipelineTessellationDomainOriginStateCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
            p_next: ptr::null(),
            domain_origin: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineTessellationDomainOriginStateCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineTessellationDomainOriginStateCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("domain_origin", &self.domain_origin)
            .finish()
    }
}
pub type PipelineTessellationDomainOriginStateCreateInfoKHR = PipelineTessellationDomainOriginStateCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplerYcbcrConversionInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub conversion: Option<SamplerYcbcrConversion>,
}
unsafe impl Send for SamplerYcbcrConversionInfo {}
unsafe impl Sync for SamplerYcbcrConversionInfo {}
impl Default for SamplerYcbcrConversionInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLER_YCBCR_CONVERSION_INFO,
            p_next: ptr::null(),
            conversion: Default::default(),
        }
    }
}
impl fmt::Debug for SamplerYcbcrConversionInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerYcbcrConversionInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("conversion", &self.conversion)
            .finish()
    }
}
pub type SamplerYcbcrConversionInfoKHR = SamplerYcbcrConversionInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplerYcbcrConversionCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format: Format,
    pub ycbcr_model: SamplerYcbcrModelConversion,
    pub ycbcr_range: SamplerYcbcrRange,
    pub components: ComponentMapping,
    pub x_chroma_offset: ChromaLocation,
    pub y_chroma_offset: ChromaLocation,
    pub chroma_filter: Filter,
    pub force_explicit_reconstruction: Bool32,
}
unsafe impl Send for SamplerYcbcrConversionCreateInfo {}
unsafe impl Sync for SamplerYcbcrConversionCreateInfo {}
impl Default for SamplerYcbcrConversionCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
            p_next: ptr::null(),
            format: Default::default(),
            ycbcr_model: Default::default(),
            ycbcr_range: Default::default(),
            components: Default::default(),
            x_chroma_offset: Default::default(),
            y_chroma_offset: Default::default(),
            chroma_filter: Default::default(),
            force_explicit_reconstruction: Default::default(),
        }
    }
}
impl fmt::Debug for SamplerYcbcrConversionCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerYcbcrConversionCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format", &self.format)
            .field("ycbcr_model", &self.ycbcr_model)
            .field("ycbcr_range", &self.ycbcr_range)
            .field("components", &self.components)
            .field("x_chroma_offset", &self.x_chroma_offset)
            .field("y_chroma_offset", &self.y_chroma_offset)
            .field("chroma_filter", &self.chroma_filter)
            .field("force_explicit_reconstruction", &self.force_explicit_reconstruction)
            .finish()
    }
}
pub type SamplerYcbcrConversionCreateInfoKHR = SamplerYcbcrConversionCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindImagePlaneMemoryInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub plane_aspect: ImageAspectFlags,
}
unsafe impl Send for BindImagePlaneMemoryInfo {}
unsafe impl Sync for BindImagePlaneMemoryInfo {}
impl Default for BindImagePlaneMemoryInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_IMAGE_PLANE_MEMORY_INFO,
            p_next: ptr::null(),
            plane_aspect: Default::default(),
        }
    }
}
impl fmt::Debug for BindImagePlaneMemoryInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindImagePlaneMemoryInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("plane_aspect", &self.plane_aspect)
            .finish()
    }
}
pub type BindImagePlaneMemoryInfoKHR = BindImagePlaneMemoryInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImagePlaneMemoryRequirementsInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub plane_aspect: ImageAspectFlags,
}
unsafe impl Send for ImagePlaneMemoryRequirementsInfo {}
unsafe impl Sync for ImagePlaneMemoryRequirementsInfo {}
impl Default for ImagePlaneMemoryRequirementsInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
            p_next: ptr::null(),
            plane_aspect: Default::default(),
        }
    }
}
impl fmt::Debug for ImagePlaneMemoryRequirementsInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImagePlaneMemoryRequirementsInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("plane_aspect", &self.plane_aspect)
            .finish()
    }
}
pub type ImagePlaneMemoryRequirementsInfoKHR = ImagePlaneMemoryRequirementsInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSamplerYcbcrConversionFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// Sampler color conversion supported
    pub sampler_ycbcr_conversion: Bool32,
}
unsafe impl Send for PhysicalDeviceSamplerYcbcrConversionFeatures {}
unsafe impl Sync for PhysicalDeviceSamplerYcbcrConversionFeatures {}
impl Default for PhysicalDeviceSamplerYcbcrConversionFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
            p_next: ptr::null_mut(),
            sampler_ycbcr_conversion: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSamplerYcbcrConversionFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSamplerYcbcrConversionFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("sampler_ycbcr_conversion", &self.sampler_ycbcr_conversion)
            .finish()
    }
}
pub type PhysicalDeviceSamplerYcbcrConversionFeaturesKHR = PhysicalDeviceSamplerYcbcrConversionFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplerYcbcrConversionImageFormatProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub combined_image_sampler_descriptor_count: u32,
}
unsafe impl Send for SamplerYcbcrConversionImageFormatProperties {}
unsafe impl Sync for SamplerYcbcrConversionImageFormatProperties {}
impl Default for SamplerYcbcrConversionImageFormatProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
            p_next: ptr::null_mut(),
            combined_image_sampler_descriptor_count: Default::default(),
        }
    }
}
impl fmt::Debug for SamplerYcbcrConversionImageFormatProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerYcbcrConversionImageFormatProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "combined_image_sampler_descriptor_count",
                &self.combined_image_sampler_descriptor_count,
            )
            .finish()
    }
}
pub type SamplerYcbcrConversionImageFormatPropertiesKHR = SamplerYcbcrConversionImageFormatProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TextureLODGatherFormatPropertiesAMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub supports_texture_gather_lod_bias_amd: Bool32,
}
unsafe impl Send for TextureLODGatherFormatPropertiesAMD {}
unsafe impl Sync for TextureLODGatherFormatPropertiesAMD {}
impl Default for TextureLODGatherFormatPropertiesAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD,
            p_next: ptr::null_mut(),
            supports_texture_gather_lod_bias_amd: Default::default(),
        }
    }
}
impl fmt::Debug for TextureLODGatherFormatPropertiesAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("TextureLODGatherFormatPropertiesAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "supports_texture_gather_lod_bias_amd",
                &self.supports_texture_gather_lod_bias_amd,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ConditionalRenderingBeginInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Option<Buffer>,
    pub offset: DeviceSize,
    pub flags: ConditionalRenderingFlagsEXT,
}
unsafe impl Send for ConditionalRenderingBeginInfoEXT {}
unsafe impl Sync for ConditionalRenderingBeginInfoEXT {}
impl Default for ConditionalRenderingBeginInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::CONDITIONAL_RENDERING_BEGIN_INFO_EXT,
            p_next: ptr::null(),
            buffer: Default::default(),
            offset: Default::default(),
            flags: Default::default(),
        }
    }
}
impl fmt::Debug for ConditionalRenderingBeginInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ConditionalRenderingBeginInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer", &self.buffer)
            .field("offset", &self.offset)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ProtectedSubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Submit protected command buffers
    pub protected_submit: Bool32,
}
unsafe impl Send for ProtectedSubmitInfo {}
unsafe impl Sync for ProtectedSubmitInfo {}
impl Default for ProtectedSubmitInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PROTECTED_SUBMIT_INFO,
            p_next: ptr::null(),
            protected_submit: Default::default(),
        }
    }
}
impl fmt::Debug for ProtectedSubmitInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ProtectedSubmitInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("protected_submit", &self.protected_submit)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceProtectedMemoryFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub protected_memory: Bool32,
}
unsafe impl Send for PhysicalDeviceProtectedMemoryFeatures {}
unsafe impl Sync for PhysicalDeviceProtectedMemoryFeatures {}
impl Default for PhysicalDeviceProtectedMemoryFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
            p_next: ptr::null_mut(),
            protected_memory: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceProtectedMemoryFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceProtectedMemoryFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("protected_memory", &self.protected_memory)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceProtectedMemoryProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub protected_no_fault: Bool32,
}
unsafe impl Send for PhysicalDeviceProtectedMemoryProperties {}
unsafe impl Sync for PhysicalDeviceProtectedMemoryProperties {}
impl Default for PhysicalDeviceProtectedMemoryProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
            p_next: ptr::null_mut(),
            protected_no_fault: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceProtectedMemoryProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceProtectedMemoryProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("protected_no_fault", &self.protected_no_fault)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceQueueInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceQueueCreateFlags,
    pub queue_family_index: u32,
    pub queue_index: u32,
}
unsafe impl Send for DeviceQueueInfo2 {}
unsafe impl Sync for DeviceQueueInfo2 {}
impl Default for DeviceQueueInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_QUEUE_INFO_2,
            p_next: ptr::null(),
            flags: Default::default(),
            queue_family_index: Default::default(),
            queue_index: Default::default(),
        }
    }
}
impl fmt::Debug for DeviceQueueInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceQueueInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("queue_family_index", &self.queue_family_index)
            .field("queue_index", &self.queue_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineCoverageToColorStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCoverageToColorStateCreateFlagsNV,
    pub coverage_to_color_enable: Bool32,
    pub coverage_to_color_location: u32,
}
unsafe impl Send for PipelineCoverageToColorStateCreateInfoNV {}
unsafe impl Sync for PipelineCoverageToColorStateCreateInfoNV {}
impl Default for PipelineCoverageToColorStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            flags: Default::default(),
            coverage_to_color_enable: Default::default(),
            coverage_to_color_location: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineCoverageToColorStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCoverageToColorStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("coverage_to_color_enable", &self.coverage_to_color_enable)
            .field("coverage_to_color_location", &self.coverage_to_color_location)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSamplerFilterMinmaxProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub filter_minmax_single_component_formats: Bool32,
    pub filter_minmax_image_component_mapping: Bool32,
}
unsafe impl Send for PhysicalDeviceSamplerFilterMinmaxProperties {}
unsafe impl Sync for PhysicalDeviceSamplerFilterMinmaxProperties {}
impl Default for PhysicalDeviceSamplerFilterMinmaxProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
            p_next: ptr::null_mut(),
            filter_minmax_single_component_formats: Default::default(),
            filter_minmax_image_component_mapping: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSamplerFilterMinmaxProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSamplerFilterMinmaxProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "filter_minmax_single_component_formats",
                &self.filter_minmax_single_component_formats,
            )
            .field(
                "filter_minmax_image_component_mapping",
                &self.filter_minmax_image_component_mapping,
            )
            .finish()
    }
}
pub type PhysicalDeviceSamplerFilterMinmaxPropertiesEXT = PhysicalDeviceSamplerFilterMinmaxProperties;
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct SampleLocationEXT {
    pub x: f32,
    pub y: f32,
}
impl fmt::Debug for SampleLocationEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SampleLocationEXT")
            .field("x", &self.x)
            .field("y", &self.y)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SampleLocationsInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sample_locations_per_pixel: SampleCountFlags,
    pub sample_location_grid_size: Extent2D,
    pub sample_locations_count: u32,
    pub p_sample_locations: *const SampleLocationEXT,
}
unsafe impl Send for SampleLocationsInfoEXT {}
unsafe impl Sync for SampleLocationsInfoEXT {}
impl Default for SampleLocationsInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLE_LOCATIONS_INFO_EXT,
            p_next: ptr::null(),
            sample_locations_per_pixel: Default::default(),
            sample_location_grid_size: Default::default(),
            sample_locations_count: Default::default(),
            p_sample_locations: ptr::null(),
        }
    }
}
impl fmt::Debug for SampleLocationsInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SampleLocationsInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("sample_locations_per_pixel", &self.sample_locations_per_pixel)
            .field("sample_location_grid_size", &self.sample_location_grid_size)
            .field("sample_locations_count", &self.sample_locations_count)
            .field("p_sample_locations", &self.p_sample_locations)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct AttachmentSampleLocationsEXT {
    pub attachment_index: u32,
    pub sample_locations_info: SampleLocationsInfoEXT,
}
impl fmt::Debug for AttachmentSampleLocationsEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentSampleLocationsEXT")
            .field("attachment_index", &self.attachment_index)
            .field("sample_locations_info", &self.sample_locations_info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct SubpassSampleLocationsEXT {
    pub subpass_index: u32,
    pub sample_locations_info: SampleLocationsInfoEXT,
}
impl fmt::Debug for SubpassSampleLocationsEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassSampleLocationsEXT")
            .field("subpass_index", &self.subpass_index)
            .field("sample_locations_info", &self.sample_locations_info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassSampleLocationsBeginInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment_initial_sample_locations_count: u32,
    pub p_attachment_initial_sample_locations: *const AttachmentSampleLocationsEXT,
    pub post_subpass_sample_locations_count: u32,
    pub p_post_subpass_sample_locations: *const SubpassSampleLocationsEXT,
}
unsafe impl Send for RenderPassSampleLocationsBeginInfoEXT {}
unsafe impl Sync for RenderPassSampleLocationsBeginInfoEXT {}
impl Default for RenderPassSampleLocationsBeginInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
            p_next: ptr::null(),
            attachment_initial_sample_locations_count: Default::default(),
            p_attachment_initial_sample_locations: ptr::null(),
            post_subpass_sample_locations_count: Default::default(),
            p_post_subpass_sample_locations: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderPassSampleLocationsBeginInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassSampleLocationsBeginInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "attachment_initial_sample_locations_count",
                &self.attachment_initial_sample_locations_count,
            )
            .field(
                "p_attachment_initial_sample_locations",
                &self.p_attachment_initial_sample_locations,
            )
            .field(
                "post_subpass_sample_locations_count",
                &self.post_subpass_sample_locations_count,
            )
            .field("p_post_subpass_sample_locations", &self.p_post_subpass_sample_locations)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineSampleLocationsStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sample_locations_enable: Bool32,
    pub sample_locations_info: SampleLocationsInfoEXT,
}
unsafe impl Send for PipelineSampleLocationsStateCreateInfoEXT {}
unsafe impl Sync for PipelineSampleLocationsStateCreateInfoEXT {}
impl Default for PipelineSampleLocationsStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            sample_locations_enable: Default::default(),
            sample_locations_info: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineSampleLocationsStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineSampleLocationsStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("sample_locations_enable", &self.sample_locations_enable)
            .field("sample_locations_info", &self.sample_locations_info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSampleLocationsPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub sample_location_sample_counts: SampleCountFlags,
    pub max_sample_location_grid_size: Extent2D,
    pub sample_location_coordinate_range: [f32; 2],
    pub sample_location_sub_pixel_bits: u32,
    pub variable_sample_locations: Bool32,
}
unsafe impl Send for PhysicalDeviceSampleLocationsPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceSampleLocationsPropertiesEXT {}
impl Default for PhysicalDeviceSampleLocationsPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            sample_location_sample_counts: Default::default(),
            max_sample_location_grid_size: Default::default(),
            sample_location_coordinate_range: [Default::default(); 2],
            sample_location_sub_pixel_bits: Default::default(),
            variable_sample_locations: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSampleLocationsPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSampleLocationsPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("sample_location_sample_counts", &self.sample_location_sample_counts)
            .field("max_sample_location_grid_size", &self.max_sample_location_grid_size)
            .field(
                "sample_location_coordinate_range",
                &self.sample_location_coordinate_range,
            )
            .field("sample_location_sub_pixel_bits", &self.sample_location_sub_pixel_bits)
            .field("variable_sample_locations", &self.variable_sample_locations)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MultisamplePropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_sample_location_grid_size: Extent2D,
}
unsafe impl Send for MultisamplePropertiesEXT {}
unsafe impl Sync for MultisamplePropertiesEXT {}
impl Default for MultisamplePropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::MULTISAMPLE_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            max_sample_location_grid_size: Default::default(),
        }
    }
}
impl fmt::Debug for MultisamplePropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MultisamplePropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_sample_location_grid_size", &self.max_sample_location_grid_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplerReductionModeCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub reduction_mode: SamplerReductionMode,
}
unsafe impl Send for SamplerReductionModeCreateInfo {}
unsafe impl Sync for SamplerReductionModeCreateInfo {}
impl Default for SamplerReductionModeCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLER_REDUCTION_MODE_CREATE_INFO,
            p_next: ptr::null(),
            reduction_mode: Default::default(),
        }
    }
}
impl fmt::Debug for SamplerReductionModeCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerReductionModeCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("reduction_mode", &self.reduction_mode)
            .finish()
    }
}
pub type SamplerReductionModeCreateInfoEXT = SamplerReductionModeCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub advanced_blend_coherent_operations: Bool32,
}
unsafe impl Send for PhysicalDeviceBlendOperationAdvancedFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceBlendOperationAdvancedFeaturesEXT {}
impl Default for PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
            p_next: ptr::null_mut(),
            advanced_blend_coherent_operations: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceBlendOperationAdvancedFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "advanced_blend_coherent_operations",
                &self.advanced_blend_coherent_operations,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMultiDrawFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub multi_draw: Bool32,
}
unsafe impl Send for PhysicalDeviceMultiDrawFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceMultiDrawFeaturesEXT {}
impl Default for PhysicalDeviceMultiDrawFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
            p_next: ptr::null_mut(),
            multi_draw: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMultiDrawFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMultiDrawFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("multi_draw", &self.multi_draw)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub advanced_blend_max_color_attachments: u32,
    pub advanced_blend_independent_blend: Bool32,
    pub advanced_blend_non_premultiplied_src_color: Bool32,
    pub advanced_blend_non_premultiplied_dst_color: Bool32,
    pub advanced_blend_correlated_overlap: Bool32,
    pub advanced_blend_all_operations: Bool32,
}
unsafe impl Send for PhysicalDeviceBlendOperationAdvancedPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceBlendOperationAdvancedPropertiesEXT {}
impl Default for PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            advanced_blend_max_color_attachments: Default::default(),
            advanced_blend_independent_blend: Default::default(),
            advanced_blend_non_premultiplied_src_color: Default::default(),
            advanced_blend_non_premultiplied_dst_color: Default::default(),
            advanced_blend_correlated_overlap: Default::default(),
            advanced_blend_all_operations: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceBlendOperationAdvancedPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "advanced_blend_max_color_attachments",
                &self.advanced_blend_max_color_attachments,
            )
            .field(
                "advanced_blend_independent_blend",
                &self.advanced_blend_independent_blend,
            )
            .field(
                "advanced_blend_non_premultiplied_src_color",
                &self.advanced_blend_non_premultiplied_src_color,
            )
            .field(
                "advanced_blend_non_premultiplied_dst_color",
                &self.advanced_blend_non_premultiplied_dst_color,
            )
            .field(
                "advanced_blend_correlated_overlap",
                &self.advanced_blend_correlated_overlap,
            )
            .field("advanced_blend_all_operations", &self.advanced_blend_all_operations)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineColorBlendAdvancedStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_premultiplied: Bool32,
    pub dst_premultiplied: Bool32,
    pub blend_overlap: BlendOverlapEXT,
}
unsafe impl Send for PipelineColorBlendAdvancedStateCreateInfoEXT {}
unsafe impl Sync for PipelineColorBlendAdvancedStateCreateInfoEXT {}
impl Default for PipelineColorBlendAdvancedStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            src_premultiplied: Default::default(),
            dst_premultiplied: Default::default(),
            blend_overlap: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineColorBlendAdvancedStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineColorBlendAdvancedStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_premultiplied", &self.src_premultiplied)
            .field("dst_premultiplied", &self.dst_premultiplied)
            .field("blend_overlap", &self.blend_overlap)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceInlineUniformBlockFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub inline_uniform_block: Bool32,
    pub descriptor_binding_inline_uniform_block_update_after_bind: Bool32,
}
unsafe impl Send for PhysicalDeviceInlineUniformBlockFeatures {}
unsafe impl Sync for PhysicalDeviceInlineUniformBlockFeatures {}
impl Default for PhysicalDeviceInlineUniformBlockFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
            p_next: ptr::null_mut(),
            inline_uniform_block: Default::default(),
            descriptor_binding_inline_uniform_block_update_after_bind: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceInlineUniformBlockFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceInlineUniformBlockFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("inline_uniform_block", &self.inline_uniform_block)
            .field(
                "descriptor_binding_inline_uniform_block_update_after_bind",
                &self.descriptor_binding_inline_uniform_block_update_after_bind,
            )
            .finish()
    }
}
pub type PhysicalDeviceInlineUniformBlockFeaturesEXT = PhysicalDeviceInlineUniformBlockFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceInlineUniformBlockProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_inline_uniform_block_size: u32,
    pub max_per_stage_descriptor_inline_uniform_blocks: u32,
    pub max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    pub max_descriptor_set_inline_uniform_blocks: u32,
    pub max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
}
unsafe impl Send for PhysicalDeviceInlineUniformBlockProperties {}
unsafe impl Sync for PhysicalDeviceInlineUniformBlockProperties {}
impl Default for PhysicalDeviceInlineUniformBlockProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
            p_next: ptr::null_mut(),
            max_inline_uniform_block_size: Default::default(),
            max_per_stage_descriptor_inline_uniform_blocks: Default::default(),
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: Default::default(),
            max_descriptor_set_inline_uniform_blocks: Default::default(),
            max_descriptor_set_update_after_bind_inline_uniform_blocks: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceInlineUniformBlockProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceInlineUniformBlockProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_inline_uniform_block_size", &self.max_inline_uniform_block_size)
            .field(
                "max_per_stage_descriptor_inline_uniform_blocks",
                &self.max_per_stage_descriptor_inline_uniform_blocks,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_inline_uniform_blocks",
                &self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks,
            )
            .field(
                "max_descriptor_set_inline_uniform_blocks",
                &self.max_descriptor_set_inline_uniform_blocks,
            )
            .field(
                "max_descriptor_set_update_after_bind_inline_uniform_blocks",
                &self.max_descriptor_set_update_after_bind_inline_uniform_blocks,
            )
            .finish()
    }
}
pub type PhysicalDeviceInlineUniformBlockPropertiesEXT = PhysicalDeviceInlineUniformBlockProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WriteDescriptorSetInlineUniformBlock {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub data_size: u32,
    pub p_data: *const c_void,
}
unsafe impl Send for WriteDescriptorSetInlineUniformBlock {}
unsafe impl Sync for WriteDescriptorSetInlineUniformBlock {}
impl Default for WriteDescriptorSetInlineUniformBlock {
    fn default() -> Self {
        Self {
            s_type: StructureType::WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
            p_next: ptr::null(),
            data_size: Default::default(),
            p_data: ptr::null(),
        }
    }
}
impl fmt::Debug for WriteDescriptorSetInlineUniformBlock {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("WriteDescriptorSetInlineUniformBlock")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("data_size", &self.data_size)
            .field("p_data", &self.p_data)
            .finish()
    }
}
pub type WriteDescriptorSetInlineUniformBlockEXT = WriteDescriptorSetInlineUniformBlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorPoolInlineUniformBlockCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_inline_uniform_block_bindings: u32,
}
unsafe impl Send for DescriptorPoolInlineUniformBlockCreateInfo {}
unsafe impl Sync for DescriptorPoolInlineUniformBlockCreateInfo {}
impl Default for DescriptorPoolInlineUniformBlockCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
            p_next: ptr::null(),
            max_inline_uniform_block_bindings: Default::default(),
        }
    }
}
impl fmt::Debug for DescriptorPoolInlineUniformBlockCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorPoolInlineUniformBlockCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "max_inline_uniform_block_bindings",
                &self.max_inline_uniform_block_bindings,
            )
            .finish()
    }
}
pub type DescriptorPoolInlineUniformBlockCreateInfoEXT = DescriptorPoolInlineUniformBlockCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineCoverageModulationStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCoverageModulationStateCreateFlagsNV,
    pub coverage_modulation_mode: CoverageModulationModeNV,
    pub coverage_modulation_table_enable: Bool32,
    pub coverage_modulation_table_count: u32,
    pub p_coverage_modulation_table: *const f32,
}
unsafe impl Send for PipelineCoverageModulationStateCreateInfoNV {}
unsafe impl Sync for PipelineCoverageModulationStateCreateInfoNV {}
impl Default for PipelineCoverageModulationStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            flags: Default::default(),
            coverage_modulation_mode: Default::default(),
            coverage_modulation_table_enable: Default::default(),
            coverage_modulation_table_count: Default::default(),
            p_coverage_modulation_table: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineCoverageModulationStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCoverageModulationStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("coverage_modulation_mode", &self.coverage_modulation_mode)
            .field(
                "coverage_modulation_table_enable",
                &self.coverage_modulation_table_enable,
            )
            .field("coverage_modulation_table_count", &self.coverage_modulation_table_count)
            .field("p_coverage_modulation_table", &self.p_coverage_modulation_table)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageFormatListCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub view_format_count: u32,
    pub p_view_formats: *const Format,
}
unsafe impl Send for ImageFormatListCreateInfo {}
unsafe impl Sync for ImageFormatListCreateInfo {}
impl Default for ImageFormatListCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_FORMAT_LIST_CREATE_INFO,
            p_next: ptr::null(),
            view_format_count: Default::default(),
            p_view_formats: ptr::null(),
        }
    }
}
impl fmt::Debug for ImageFormatListCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageFormatListCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("view_format_count", &self.view_format_count)
            .field("p_view_formats", &self.p_view_formats)
            .finish()
    }
}
pub type ImageFormatListCreateInfoKHR = ImageFormatListCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ValidationCacheCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ValidationCacheCreateFlagsEXT,
    pub initial_data_size: usize,
    pub p_initial_data: *const c_void,
}
unsafe impl Send for ValidationCacheCreateInfoEXT {}
unsafe impl Sync for ValidationCacheCreateInfoEXT {}
impl Default for ValidationCacheCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::VALIDATION_CACHE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: Default::default(),
            initial_data_size: Default::default(),
            p_initial_data: ptr::null(),
        }
    }
}
impl fmt::Debug for ValidationCacheCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ValidationCacheCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("initial_data_size", &self.initial_data_size)
            .field("p_initial_data", &self.p_initial_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ShaderModuleValidationCacheCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub validation_cache: Option<ValidationCacheEXT>,
}
unsafe impl Send for ShaderModuleValidationCacheCreateInfoEXT {}
unsafe impl Sync for ShaderModuleValidationCacheCreateInfoEXT {}
impl Default for ShaderModuleValidationCacheCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            validation_cache: Default::default(),
        }
    }
}
impl fmt::Debug for ShaderModuleValidationCacheCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ShaderModuleValidationCacheCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("validation_cache", &self.validation_cache)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMaintenance3Properties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_per_set_descriptors: u32,
    pub max_memory_allocation_size: DeviceSize,
}
unsafe impl Send for PhysicalDeviceMaintenance3Properties {}
unsafe impl Sync for PhysicalDeviceMaintenance3Properties {}
impl Default for PhysicalDeviceMaintenance3Properties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
            p_next: ptr::null_mut(),
            max_per_set_descriptors: Default::default(),
            max_memory_allocation_size: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMaintenance3Properties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMaintenance3Properties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_per_set_descriptors", &self.max_per_set_descriptors)
            .field("max_memory_allocation_size", &self.max_memory_allocation_size)
            .finish()
    }
}
pub type PhysicalDeviceMaintenance3PropertiesKHR = PhysicalDeviceMaintenance3Properties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMaintenance4Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub maintenance4: Bool32,
}
unsafe impl Send for PhysicalDeviceMaintenance4Features {}
unsafe impl Sync for PhysicalDeviceMaintenance4Features {}
impl Default for PhysicalDeviceMaintenance4Features {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
            p_next: ptr::null_mut(),
            maintenance4: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMaintenance4Features {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMaintenance4Features")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("maintenance4", &self.maintenance4)
            .finish()
    }
}
pub type PhysicalDeviceMaintenance4FeaturesKHR = PhysicalDeviceMaintenance4Features;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMaintenance4Properties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_buffer_size: DeviceSize,
}
unsafe impl Send for PhysicalDeviceMaintenance4Properties {}
unsafe impl Sync for PhysicalDeviceMaintenance4Properties {}
impl Default for PhysicalDeviceMaintenance4Properties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
            p_next: ptr::null_mut(),
            max_buffer_size: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMaintenance4Properties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMaintenance4Properties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_buffer_size", &self.max_buffer_size)
            .finish()
    }
}
pub type PhysicalDeviceMaintenance4PropertiesKHR = PhysicalDeviceMaintenance4Properties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetLayoutSupport {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub supported: Bool32,
}
unsafe impl Send for DescriptorSetLayoutSupport {}
unsafe impl Sync for DescriptorSetLayoutSupport {}
impl Default for DescriptorSetLayoutSupport {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_SET_LAYOUT_SUPPORT,
            p_next: ptr::null_mut(),
            supported: Default::default(),
        }
    }
}
impl fmt::Debug for DescriptorSetLayoutSupport {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetLayoutSupport")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("supported", &self.supported)
            .finish()
    }
}
pub type DescriptorSetLayoutSupportKHR = DescriptorSetLayoutSupport;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderDrawParametersFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_draw_parameters: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderDrawParametersFeatures {}
unsafe impl Sync for PhysicalDeviceShaderDrawParametersFeatures {}
impl Default for PhysicalDeviceShaderDrawParametersFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
            p_next: ptr::null_mut(),
            shader_draw_parameters: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderDrawParametersFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderDrawParametersFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_draw_parameters", &self.shader_draw_parameters)
            .finish()
    }
}
pub type PhysicalDeviceShaderDrawParameterFeatures = PhysicalDeviceShaderDrawParametersFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderFloat16Int8Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// 16-bit floats (halfs) in shaders
    pub shader_float16: Bool32,
    /// 8-bit integers in shaders
    pub shader_int8: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderFloat16Int8Features {}
unsafe impl Sync for PhysicalDeviceShaderFloat16Int8Features {}
impl Default for PhysicalDeviceShaderFloat16Int8Features {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
            p_next: ptr::null_mut(),
            shader_float16: Default::default(),
            shader_int8: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderFloat16Int8Features {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderFloat16Int8Features")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_float16", &self.shader_float16)
            .field("shader_int8", &self.shader_int8)
            .finish()
    }
}
pub type PhysicalDeviceShaderFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;
pub type PhysicalDeviceFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFloatControlsProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub denorm_behavior_independence: ShaderFloatControlsIndependence,
    pub rounding_mode_independence: ShaderFloatControlsIndependence,
    /// An implementation can preserve signed zero, nan, inf
    pub shader_signed_zero_inf_nan_preserve_float16: Bool32,
    /// An implementation can preserve signed zero, nan, inf
    pub shader_signed_zero_inf_nan_preserve_float32: Bool32,
    /// An implementation can preserve signed zero, nan, inf
    pub shader_signed_zero_inf_nan_preserve_float64: Bool32,
    /// An implementation can preserve  denormals
    pub shader_denorm_preserve_float16: Bool32,
    /// An implementation can preserve  denormals
    pub shader_denorm_preserve_float32: Bool32,
    /// An implementation can preserve  denormals
    pub shader_denorm_preserve_float64: Bool32,
    /// An implementation can flush to zero  denormals
    pub shader_denorm_flush_to_zero_float16: Bool32,
    /// An implementation can flush to zero  denormals
    pub shader_denorm_flush_to_zero_float32: Bool32,
    /// An implementation can flush to zero  denormals
    pub shader_denorm_flush_to_zero_float64: Bool32,
    /// An implementation can support RTE
    pub shader_rounding_mode_rte_float16: Bool32,
    /// An implementation can support RTE
    pub shader_rounding_mode_rte_float32: Bool32,
    /// An implementation can support RTE
    pub shader_rounding_mode_rte_float64: Bool32,
    /// An implementation can support RTZ
    pub shader_rounding_mode_rtz_float16: Bool32,
    /// An implementation can support RTZ
    pub shader_rounding_mode_rtz_float32: Bool32,
    /// An implementation can support RTZ
    pub shader_rounding_mode_rtz_float64: Bool32,
}
unsafe impl Send for PhysicalDeviceFloatControlsProperties {}
unsafe impl Sync for PhysicalDeviceFloatControlsProperties {}
impl Default for PhysicalDeviceFloatControlsProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
            p_next: ptr::null_mut(),
            denorm_behavior_independence: Default::default(),
            rounding_mode_independence: Default::default(),
            shader_signed_zero_inf_nan_preserve_float16: Default::default(),
            shader_signed_zero_inf_nan_preserve_float32: Default::default(),
            shader_signed_zero_inf_nan_preserve_float64: Default::default(),
            shader_denorm_preserve_float16: Default::default(),
            shader_denorm_preserve_float32: Default::default(),
            shader_denorm_preserve_float64: Default::default(),
            shader_denorm_flush_to_zero_float16: Default::default(),
            shader_denorm_flush_to_zero_float32: Default::default(),
            shader_denorm_flush_to_zero_float64: Default::default(),
            shader_rounding_mode_rte_float16: Default::default(),
            shader_rounding_mode_rte_float32: Default::default(),
            shader_rounding_mode_rte_float64: Default::default(),
            shader_rounding_mode_rtz_float16: Default::default(),
            shader_rounding_mode_rtz_float32: Default::default(),
            shader_rounding_mode_rtz_float64: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFloatControlsProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFloatControlsProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("denorm_behavior_independence", &self.denorm_behavior_independence)
            .field("rounding_mode_independence", &self.rounding_mode_independence)
            .field(
                "shader_signed_zero_inf_nan_preserve_float16",
                &self.shader_signed_zero_inf_nan_preserve_float16,
            )
            .field(
                "shader_signed_zero_inf_nan_preserve_float32",
                &self.shader_signed_zero_inf_nan_preserve_float32,
            )
            .field(
                "shader_signed_zero_inf_nan_preserve_float64",
                &self.shader_signed_zero_inf_nan_preserve_float64,
            )
            .field("shader_denorm_preserve_float16", &self.shader_denorm_preserve_float16)
            .field("shader_denorm_preserve_float32", &self.shader_denorm_preserve_float32)
            .field("shader_denorm_preserve_float64", &self.shader_denorm_preserve_float64)
            .field(
                "shader_denorm_flush_to_zero_float16",
                &self.shader_denorm_flush_to_zero_float16,
            )
            .field(
                "shader_denorm_flush_to_zero_float32",
                &self.shader_denorm_flush_to_zero_float32,
            )
            .field(
                "shader_denorm_flush_to_zero_float64",
                &self.shader_denorm_flush_to_zero_float64,
            )
            .field(
                "shader_rounding_mode_rte_float16",
                &self.shader_rounding_mode_rte_float16,
            )
            .field(
                "shader_rounding_mode_rte_float32",
                &self.shader_rounding_mode_rte_float32,
            )
            .field(
                "shader_rounding_mode_rte_float64",
                &self.shader_rounding_mode_rte_float64,
            )
            .field(
                "shader_rounding_mode_rtz_float16",
                &self.shader_rounding_mode_rtz_float16,
            )
            .field(
                "shader_rounding_mode_rtz_float32",
                &self.shader_rounding_mode_rtz_float32,
            )
            .field(
                "shader_rounding_mode_rtz_float64",
                &self.shader_rounding_mode_rtz_float64,
            )
            .finish()
    }
}
pub type PhysicalDeviceFloatControlsPropertiesKHR = PhysicalDeviceFloatControlsProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceHostQueryResetFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub host_query_reset: Bool32,
}
unsafe impl Send for PhysicalDeviceHostQueryResetFeatures {}
unsafe impl Sync for PhysicalDeviceHostQueryResetFeatures {}
impl Default for PhysicalDeviceHostQueryResetFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
            p_next: ptr::null_mut(),
            host_query_reset: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceHostQueryResetFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceHostQueryResetFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("host_query_reset", &self.host_query_reset)
            .finish()
    }
}
pub type PhysicalDeviceHostQueryResetFeaturesEXT = PhysicalDeviceHostQueryResetFeatures;
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct ShaderResourceUsageAMD {
    pub num_used_vgprs: u32,
    pub num_used_sgprs: u32,
    pub lds_size_per_local_work_group: u32,
    pub lds_usage_size_in_bytes: usize,
    pub scratch_mem_usage_in_bytes: usize,
}
impl fmt::Debug for ShaderResourceUsageAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ShaderResourceUsageAMD")
            .field("num_used_vgprs", &self.num_used_vgprs)
            .field("num_used_sgprs", &self.num_used_sgprs)
            .field("lds_size_per_local_work_group", &self.lds_size_per_local_work_group)
            .field("lds_usage_size_in_bytes", &self.lds_usage_size_in_bytes)
            .field("scratch_mem_usage_in_bytes", &self.scratch_mem_usage_in_bytes)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct ShaderStatisticsInfoAMD {
    pub shader_stage_mask: ShaderStageFlags,
    pub resource_usage: ShaderResourceUsageAMD,
    pub num_physical_vgprs: u32,
    pub num_physical_sgprs: u32,
    pub num_available_vgprs: u32,
    pub num_available_sgprs: u32,
    pub compute_work_group_size: [u32; 3],
}
impl fmt::Debug for ShaderStatisticsInfoAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ShaderStatisticsInfoAMD")
            .field("shader_stage_mask", &self.shader_stage_mask)
            .field("resource_usage", &self.resource_usage)
            .field("num_physical_vgprs", &self.num_physical_vgprs)
            .field("num_physical_sgprs", &self.num_physical_sgprs)
            .field("num_available_vgprs", &self.num_available_vgprs)
            .field("num_available_sgprs", &self.num_available_sgprs)
            .field("compute_work_group_size", &self.compute_work_group_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceQueueGlobalPriorityCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub global_priority: QueueGlobalPriorityKHR,
}
unsafe impl Send for DeviceQueueGlobalPriorityCreateInfoKHR {}
unsafe impl Sync for DeviceQueueGlobalPriorityCreateInfoKHR {}
impl Default for DeviceQueueGlobalPriorityCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR,
            p_next: ptr::null(),
            global_priority: Default::default(),
        }
    }
}
impl fmt::Debug for DeviceQueueGlobalPriorityCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceQueueGlobalPriorityCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("global_priority", &self.global_priority)
            .finish()
    }
}
pub type DeviceQueueGlobalPriorityCreateInfoEXT = DeviceQueueGlobalPriorityCreateInfoKHR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceGlobalPriorityQueryFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub global_priority_query: Bool32,
}
unsafe impl Send for PhysicalDeviceGlobalPriorityQueryFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceGlobalPriorityQueryFeaturesKHR {}
impl Default for PhysicalDeviceGlobalPriorityQueryFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR,
            p_next: ptr::null_mut(),
            global_priority_query: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceGlobalPriorityQueryFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceGlobalPriorityQueryFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("global_priority_query", &self.global_priority_query)
            .finish()
    }
}
pub type PhysicalDeviceGlobalPriorityQueryFeaturesEXT = PhysicalDeviceGlobalPriorityQueryFeaturesKHR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueueFamilyGlobalPriorityPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub priority_count: u32,
    pub priorities: [QueueGlobalPriorityKHR; MAX_GLOBAL_PRIORITY_SIZE_KHR],
}
unsafe impl Send for QueueFamilyGlobalPriorityPropertiesKHR {}
unsafe impl Sync for QueueFamilyGlobalPriorityPropertiesKHR {}
impl Default for QueueFamilyGlobalPriorityPropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            priority_count: Default::default(),
            priorities: [Default::default(); MAX_GLOBAL_PRIORITY_SIZE_KHR],
        }
    }
}
impl fmt::Debug for QueueFamilyGlobalPriorityPropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueueFamilyGlobalPriorityPropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("priority_count", &self.priority_count)
            .field("priorities", &self.priorities)
            .finish()
    }
}
pub type QueueFamilyGlobalPriorityPropertiesEXT = QueueFamilyGlobalPriorityPropertiesKHR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugUtilsObjectNameInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub p_object_name: *const c_char,
}
unsafe impl Send for DebugUtilsObjectNameInfoEXT {}
unsafe impl Sync for DebugUtilsObjectNameInfoEXT {}
impl Default for DebugUtilsObjectNameInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
            p_next: ptr::null(),
            object_type: Default::default(),
            object_handle: Default::default(),
            p_object_name: ptr::null(),
        }
    }
}
impl fmt::Debug for DebugUtilsObjectNameInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugUtilsObjectNameInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("object_type", &self.object_type)
            .field("object_handle", &self.object_handle)
            .field("p_object_name", &self.p_object_name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugUtilsObjectTagInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub tag_name: u64,
    pub tag_size: usize,
    pub p_tag: *const c_void,
}
unsafe impl Send for DebugUtilsObjectTagInfoEXT {}
unsafe impl Sync for DebugUtilsObjectTagInfoEXT {}
impl Default for DebugUtilsObjectTagInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
            p_next: ptr::null(),
            object_type: Default::default(),
            object_handle: Default::default(),
            tag_name: Default::default(),
            tag_size: Default::default(),
            p_tag: ptr::null(),
        }
    }
}
impl fmt::Debug for DebugUtilsObjectTagInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugUtilsObjectTagInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("object_type", &self.object_type)
            .field("object_handle", &self.object_handle)
            .field("tag_name", &self.tag_name)
            .field("tag_size", &self.tag_size)
            .field("p_tag", &self.p_tag)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugUtilsLabelEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_label_name: *const c_char,
    pub color: [f32; 4],
}
unsafe impl Send for DebugUtilsLabelEXT {}
unsafe impl Sync for DebugUtilsLabelEXT {}
impl Default for DebugUtilsLabelEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_UTILS_LABEL_EXT,
            p_next: ptr::null(),
            p_label_name: ptr::null(),
            color: [Default::default(); 4],
        }
    }
}
impl fmt::Debug for DebugUtilsLabelEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugUtilsLabelEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_label_name", &self.p_label_name)
            .field("color", &self.color)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugUtilsMessengerCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DebugUtilsMessengerCreateFlagsEXT,
    pub message_severity: DebugUtilsMessageSeverityFlagsEXT,
    pub message_type: DebugUtilsMessageTypeFlagsEXT,
    pub pfn_user_callback: Option<FnDebugUtilsMessengerCallbackEXT>,
    pub p_user_data: *mut c_void,
}
unsafe impl Send for DebugUtilsMessengerCreateInfoEXT {}
unsafe impl Sync for DebugUtilsMessengerCreateInfoEXT {}
impl Default for DebugUtilsMessengerCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: Default::default(),
            message_severity: Default::default(),
            message_type: Default::default(),
            pfn_user_callback: Default::default(),
            p_user_data: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for DebugUtilsMessengerCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugUtilsMessengerCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("message_severity", &self.message_severity)
            .field("message_type", &self.message_type)
            .field(
                "pfn_user_callback",
                if self.pfn_user_callback.is_some() {
                    &"Some"
                } else {
                    &"None"
                },
            )
            .field("p_user_data", &self.p_user_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugUtilsMessengerCallbackDataEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DebugUtilsMessengerCallbackDataFlagsEXT,
    pub p_message_id_name: *const c_char,
    pub message_id_number: i32,
    pub p_message: *const c_char,
    pub queue_label_count: u32,
    pub p_queue_labels: *const DebugUtilsLabelEXT,
    pub cmd_buf_label_count: u32,
    pub p_cmd_buf_labels: *const DebugUtilsLabelEXT,
    pub object_count: u32,
    pub p_objects: *const DebugUtilsObjectNameInfoEXT,
}
unsafe impl Send for DebugUtilsMessengerCallbackDataEXT {}
unsafe impl Sync for DebugUtilsMessengerCallbackDataEXT {}
impl Default for DebugUtilsMessengerCallbackDataEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
            p_next: ptr::null(),
            flags: Default::default(),
            p_message_id_name: ptr::null(),
            message_id_number: Default::default(),
            p_message: ptr::null(),
            queue_label_count: Default::default(),
            p_queue_labels: ptr::null(),
            cmd_buf_label_count: Default::default(),
            p_cmd_buf_labels: ptr::null(),
            object_count: Default::default(),
            p_objects: ptr::null(),
        }
    }
}
impl fmt::Debug for DebugUtilsMessengerCallbackDataEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugUtilsMessengerCallbackDataEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("p_message_id_name", &self.p_message_id_name)
            .field("message_id_number", &self.message_id_number)
            .field("p_message", &self.p_message)
            .field("queue_label_count", &self.queue_label_count)
            .field("p_queue_labels", &self.p_queue_labels)
            .field("cmd_buf_label_count", &self.cmd_buf_label_count)
            .field("p_cmd_buf_labels", &self.p_cmd_buf_labels)
            .field("object_count", &self.object_count)
            .field("p_objects", &self.p_objects)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDeviceMemoryReportFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_memory_report: Bool32,
}
unsafe impl Send for PhysicalDeviceDeviceMemoryReportFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceDeviceMemoryReportFeaturesEXT {}
impl Default for PhysicalDeviceDeviceMemoryReportFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
            p_next: ptr::null_mut(),
            device_memory_report: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDeviceMemoryReportFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDeviceMemoryReportFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_memory_report", &self.device_memory_report)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceDeviceMemoryReportCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceMemoryReportFlagsEXT,
    pub pfn_user_callback: Option<FnDeviceMemoryReportCallbackEXT>,
    pub p_user_data: *mut c_void,
}
unsafe impl Send for DeviceDeviceMemoryReportCreateInfoEXT {}
unsafe impl Sync for DeviceDeviceMemoryReportCreateInfoEXT {}
impl Default for DeviceDeviceMemoryReportCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: Default::default(),
            pfn_user_callback: Default::default(),
            p_user_data: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for DeviceDeviceMemoryReportCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceDeviceMemoryReportCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field(
                "pfn_user_callback",
                if self.pfn_user_callback.is_some() {
                    &"Some"
                } else {
                    &"None"
                },
            )
            .field("p_user_data", &self.p_user_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceMemoryReportCallbackDataEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: DeviceMemoryReportFlagsEXT,
    pub ty: DeviceMemoryReportEventTypeEXT,
    pub memory_object_id: u64,
    pub size: DeviceSize,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub heap_index: u32,
}
unsafe impl Send for DeviceMemoryReportCallbackDataEXT {}
unsafe impl Sync for DeviceMemoryReportCallbackDataEXT {}
impl Default for DeviceMemoryReportCallbackDataEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT,
            p_next: ptr::null_mut(),
            flags: Default::default(),
            ty: Default::default(),
            memory_object_id: Default::default(),
            size: Default::default(),
            object_type: Default::default(),
            object_handle: Default::default(),
            heap_index: Default::default(),
        }
    }
}
impl fmt::Debug for DeviceMemoryReportCallbackDataEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceMemoryReportCallbackDataEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("ty", &self.ty)
            .field("memory_object_id", &self.memory_object_id)
            .field("size", &self.size)
            .field("object_type", &self.object_type)
            .field("object_handle", &self.object_handle)
            .field("heap_index", &self.heap_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMemoryHostPointerInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub p_host_pointer: *mut c_void,
}
unsafe impl Send for ImportMemoryHostPointerInfoEXT {}
unsafe impl Sync for ImportMemoryHostPointerInfoEXT {}
impl Default for ImportMemoryHostPointerInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
            p_next: ptr::null(),
            handle_type: Default::default(),
            p_host_pointer: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for ImportMemoryHostPointerInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMemoryHostPointerInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("handle_type", &self.handle_type)
            .field("p_host_pointer", &self.p_host_pointer)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryHostPointerPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
}
unsafe impl Send for MemoryHostPointerPropertiesEXT {}
unsafe impl Sync for MemoryHostPointerPropertiesEXT {}
impl Default for MemoryHostPointerPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_HOST_POINTER_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            memory_type_bits: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryHostPointerPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryHostPointerPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_type_bits", &self.memory_type_bits)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExternalMemoryHostPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_imported_host_pointer_alignment: DeviceSize,
}
unsafe impl Send for PhysicalDeviceExternalMemoryHostPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceExternalMemoryHostPropertiesEXT {}
impl Default for PhysicalDeviceExternalMemoryHostPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            min_imported_host_pointer_alignment: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExternalMemoryHostPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExternalMemoryHostPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "min_imported_host_pointer_alignment",
                &self.min_imported_host_pointer_alignment,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceConservativeRasterizationPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// The size in pixels the primitive is enlarged at each edge during conservative rasterization
    pub primitive_overestimation_size: f32,
    /// The maximum additional overestimation the client can specify in the pipeline state
    pub max_extra_primitive_overestimation_size: f32,
    /// The granularity of extra overestimation sizes the implementations supports between 0 and maxExtraOverestimationSize
    pub extra_primitive_overestimation_size_granularity: f32,
    /// true if the implementation supports conservative rasterization underestimation mode
    pub primitive_underestimation: Bool32,
    /// true if conservative rasterization also applies to points and lines
    pub conservative_point_and_line_rasterization: Bool32,
    /// true if degenerate triangles (those with zero area after snap) are rasterized
    pub degenerate_triangles_rasterized: Bool32,
    /// true if degenerate lines (those with zero length after snap) are rasterized
    pub degenerate_lines_rasterized: Bool32,
    /// true if the implementation supports the FullyCoveredEXT SPIR-V builtin fragment shader input variable
    pub fully_covered_fragment_shader_input_variable: Bool32,
    /// true if the implementation supports both conservative rasterization and post depth coverage sample coverage mask
    pub conservative_rasterization_post_depth_coverage: Bool32,
}
unsafe impl Send for PhysicalDeviceConservativeRasterizationPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceConservativeRasterizationPropertiesEXT {}
impl Default for PhysicalDeviceConservativeRasterizationPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            primitive_overestimation_size: Default::default(),
            max_extra_primitive_overestimation_size: Default::default(),
            extra_primitive_overestimation_size_granularity: Default::default(),
            primitive_underestimation: Default::default(),
            conservative_point_and_line_rasterization: Default::default(),
            degenerate_triangles_rasterized: Default::default(),
            degenerate_lines_rasterized: Default::default(),
            fully_covered_fragment_shader_input_variable: Default::default(),
            conservative_rasterization_post_depth_coverage: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceConservativeRasterizationPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceConservativeRasterizationPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("primitive_overestimation_size", &self.primitive_overestimation_size)
            .field(
                "max_extra_primitive_overestimation_size",
                &self.max_extra_primitive_overestimation_size,
            )
            .field(
                "extra_primitive_overestimation_size_granularity",
                &self.extra_primitive_overestimation_size_granularity,
            )
            .field("primitive_underestimation", &self.primitive_underestimation)
            .field(
                "conservative_point_and_line_rasterization",
                &self.conservative_point_and_line_rasterization,
            )
            .field("degenerate_triangles_rasterized", &self.degenerate_triangles_rasterized)
            .field("degenerate_lines_rasterized", &self.degenerate_lines_rasterized)
            .field(
                "fully_covered_fragment_shader_input_variable",
                &self.fully_covered_fragment_shader_input_variable,
            )
            .field(
                "conservative_rasterization_post_depth_coverage",
                &self.conservative_rasterization_post_depth_coverage,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CalibratedTimestampInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub time_domain: TimeDomainEXT,
}
unsafe impl Send for CalibratedTimestampInfoEXT {}
unsafe impl Sync for CalibratedTimestampInfoEXT {}
impl Default for CalibratedTimestampInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::CALIBRATED_TIMESTAMP_INFO_EXT,
            p_next: ptr::null(),
            time_domain: Default::default(),
        }
    }
}
impl fmt::Debug for CalibratedTimestampInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CalibratedTimestampInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("time_domain", &self.time_domain)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderCorePropertiesAMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// number of shader engines
    pub shader_engine_count: u32,
    /// number of shader arrays
    pub shader_arrays_per_engine_count: u32,
    /// number of physical CUs per shader array
    pub compute_units_per_shader_array: u32,
    /// number of SIMDs per compute unit
    pub simd_per_compute_unit: u32,
    /// number of wavefront slots in each SIMD
    pub wavefronts_per_simd: u32,
    /// maximum number of threads per wavefront
    pub wavefront_size: u32,
    /// number of physical SGPRs per SIMD
    pub sgprs_per_simd: u32,
    /// minimum number of SGPRs that can be allocated by a wave
    pub min_sgpr_allocation: u32,
    /// number of available SGPRs
    pub max_sgpr_allocation: u32,
    /// SGPRs are allocated in groups of this size
    pub sgpr_allocation_granularity: u32,
    /// number of physical VGPRs per SIMD
    pub vgprs_per_simd: u32,
    /// minimum number of VGPRs that can be allocated by a wave
    pub min_vgpr_allocation: u32,
    /// number of available VGPRs
    pub max_vgpr_allocation: u32,
    /// VGPRs are allocated in groups of this size
    pub vgpr_allocation_granularity: u32,
}
unsafe impl Send for PhysicalDeviceShaderCorePropertiesAMD {}
unsafe impl Sync for PhysicalDeviceShaderCorePropertiesAMD {}
impl Default for PhysicalDeviceShaderCorePropertiesAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
            p_next: ptr::null_mut(),
            shader_engine_count: Default::default(),
            shader_arrays_per_engine_count: Default::default(),
            compute_units_per_shader_array: Default::default(),
            simd_per_compute_unit: Default::default(),
            wavefronts_per_simd: Default::default(),
            wavefront_size: Default::default(),
            sgprs_per_simd: Default::default(),
            min_sgpr_allocation: Default::default(),
            max_sgpr_allocation: Default::default(),
            sgpr_allocation_granularity: Default::default(),
            vgprs_per_simd: Default::default(),
            min_vgpr_allocation: Default::default(),
            max_vgpr_allocation: Default::default(),
            vgpr_allocation_granularity: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderCorePropertiesAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderCorePropertiesAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_engine_count", &self.shader_engine_count)
            .field("shader_arrays_per_engine_count", &self.shader_arrays_per_engine_count)
            .field("compute_units_per_shader_array", &self.compute_units_per_shader_array)
            .field("simd_per_compute_unit", &self.simd_per_compute_unit)
            .field("wavefronts_per_simd", &self.wavefronts_per_simd)
            .field("wavefront_size", &self.wavefront_size)
            .field("sgprs_per_simd", &self.sgprs_per_simd)
            .field("min_sgpr_allocation", &self.min_sgpr_allocation)
            .field("max_sgpr_allocation", &self.max_sgpr_allocation)
            .field("sgpr_allocation_granularity", &self.sgpr_allocation_granularity)
            .field("vgprs_per_simd", &self.vgprs_per_simd)
            .field("min_vgpr_allocation", &self.min_vgpr_allocation)
            .field("max_vgpr_allocation", &self.max_vgpr_allocation)
            .field("vgpr_allocation_granularity", &self.vgpr_allocation_granularity)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderCoreProperties2AMD {
    pub s_type: StructureType,
    /// Pointer to next structure
    pub p_next: *mut c_void,
    /// features supported by the shader core
    pub shader_core_features: ShaderCorePropertiesFlagsAMD,
    /// number of active compute units across all shader engines/arrays
    pub active_compute_unit_count: u32,
}
unsafe impl Send for PhysicalDeviceShaderCoreProperties2AMD {}
unsafe impl Sync for PhysicalDeviceShaderCoreProperties2AMD {}
impl Default for PhysicalDeviceShaderCoreProperties2AMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD,
            p_next: ptr::null_mut(),
            shader_core_features: Default::default(),
            active_compute_unit_count: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderCoreProperties2AMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderCoreProperties2AMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_core_features", &self.shader_core_features)
            .field("active_compute_unit_count", &self.active_compute_unit_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRasterizationConservativeStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Reserved
    pub flags: PipelineRasterizationConservativeStateCreateFlagsEXT,
    /// Conservative rasterization mode
    pub conservative_rasterization_mode: ConservativeRasterizationModeEXT,
    /// Extra overestimation to add to the primitive
    pub extra_primitive_overestimation_size: f32,
}
unsafe impl Send for PipelineRasterizationConservativeStateCreateInfoEXT {}
unsafe impl Sync for PipelineRasterizationConservativeStateCreateInfoEXT {}
impl Default for PipelineRasterizationConservativeStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: Default::default(),
            conservative_rasterization_mode: Default::default(),
            extra_primitive_overestimation_size: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineRasterizationConservativeStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRasterizationConservativeStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("conservative_rasterization_mode", &self.conservative_rasterization_mode)
            .field(
                "extra_primitive_overestimation_size",
                &self.extra_primitive_overestimation_size,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDescriptorIndexingFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_input_attachment_array_dynamic_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_storage_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_uniform_buffer_array_non_uniform_indexing: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_image_array_non_uniform_indexing: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_texel_buffer_array_non_uniform_indexing: Bool32,
    pub descriptor_binding_uniform_buffer_update_after_bind: Bool32,
    pub descriptor_binding_sampled_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_buffer_update_after_bind: Bool32,
    pub descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_storage_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_update_unused_while_pending: Bool32,
    pub descriptor_binding_partially_bound: Bool32,
    pub descriptor_binding_variable_descriptor_count: Bool32,
    pub runtime_descriptor_array: Bool32,
}
unsafe impl Send for PhysicalDeviceDescriptorIndexingFeatures {}
unsafe impl Sync for PhysicalDeviceDescriptorIndexingFeatures {}
impl Default for PhysicalDeviceDescriptorIndexingFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
            p_next: ptr::null_mut(),
            shader_input_attachment_array_dynamic_indexing: Default::default(),
            shader_uniform_texel_buffer_array_dynamic_indexing: Default::default(),
            shader_storage_texel_buffer_array_dynamic_indexing: Default::default(),
            shader_uniform_buffer_array_non_uniform_indexing: Default::default(),
            shader_sampled_image_array_non_uniform_indexing: Default::default(),
            shader_storage_buffer_array_non_uniform_indexing: Default::default(),
            shader_storage_image_array_non_uniform_indexing: Default::default(),
            shader_input_attachment_array_non_uniform_indexing: Default::default(),
            shader_uniform_texel_buffer_array_non_uniform_indexing: Default::default(),
            shader_storage_texel_buffer_array_non_uniform_indexing: Default::default(),
            descriptor_binding_uniform_buffer_update_after_bind: Default::default(),
            descriptor_binding_sampled_image_update_after_bind: Default::default(),
            descriptor_binding_storage_image_update_after_bind: Default::default(),
            descriptor_binding_storage_buffer_update_after_bind: Default::default(),
            descriptor_binding_uniform_texel_buffer_update_after_bind: Default::default(),
            descriptor_binding_storage_texel_buffer_update_after_bind: Default::default(),
            descriptor_binding_update_unused_while_pending: Default::default(),
            descriptor_binding_partially_bound: Default::default(),
            descriptor_binding_variable_descriptor_count: Default::default(),
            runtime_descriptor_array: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDescriptorIndexingFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDescriptorIndexingFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "shader_input_attachment_array_dynamic_indexing",
                &self.shader_input_attachment_array_dynamic_indexing,
            )
            .field(
                "shader_uniform_texel_buffer_array_dynamic_indexing",
                &self.shader_uniform_texel_buffer_array_dynamic_indexing,
            )
            .field(
                "shader_storage_texel_buffer_array_dynamic_indexing",
                &self.shader_storage_texel_buffer_array_dynamic_indexing,
            )
            .field(
                "shader_uniform_buffer_array_non_uniform_indexing",
                &self.shader_uniform_buffer_array_non_uniform_indexing,
            )
            .field(
                "shader_sampled_image_array_non_uniform_indexing",
                &self.shader_sampled_image_array_non_uniform_indexing,
            )
            .field(
                "shader_storage_buffer_array_non_uniform_indexing",
                &self.shader_storage_buffer_array_non_uniform_indexing,
            )
            .field(
                "shader_storage_image_array_non_uniform_indexing",
                &self.shader_storage_image_array_non_uniform_indexing,
            )
            .field(
                "shader_input_attachment_array_non_uniform_indexing",
                &self.shader_input_attachment_array_non_uniform_indexing,
            )
            .field(
                "shader_uniform_texel_buffer_array_non_uniform_indexing",
                &self.shader_uniform_texel_buffer_array_non_uniform_indexing,
            )
            .field(
                "shader_storage_texel_buffer_array_non_uniform_indexing",
                &self.shader_storage_texel_buffer_array_non_uniform_indexing,
            )
            .field(
                "descriptor_binding_uniform_buffer_update_after_bind",
                &self.descriptor_binding_uniform_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_sampled_image_update_after_bind",
                &self.descriptor_binding_sampled_image_update_after_bind,
            )
            .field(
                "descriptor_binding_storage_image_update_after_bind",
                &self.descriptor_binding_storage_image_update_after_bind,
            )
            .field(
                "descriptor_binding_storage_buffer_update_after_bind",
                &self.descriptor_binding_storage_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_uniform_texel_buffer_update_after_bind",
                &self.descriptor_binding_uniform_texel_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_storage_texel_buffer_update_after_bind",
                &self.descriptor_binding_storage_texel_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_update_unused_while_pending",
                &self.descriptor_binding_update_unused_while_pending,
            )
            .field(
                "descriptor_binding_partially_bound",
                &self.descriptor_binding_partially_bound,
            )
            .field(
                "descriptor_binding_variable_descriptor_count",
                &self.descriptor_binding_variable_descriptor_count,
            )
            .field("runtime_descriptor_array", &self.runtime_descriptor_array)
            .finish()
    }
}
pub type PhysicalDeviceDescriptorIndexingFeaturesEXT = PhysicalDeviceDescriptorIndexingFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDescriptorIndexingProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_update_after_bind_descriptors_in_all_pools: u32,
    pub shader_uniform_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_image_array_non_uniform_indexing_native: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing_native: Bool32,
    pub robust_buffer_access_update_after_bind: Bool32,
    pub quad_divergent_implicit_lod: Bool32,
    pub max_per_stage_descriptor_update_after_bind_samplers: u32,
    pub max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_images: u32,
    pub max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    pub max_per_stage_update_after_bind_resources: u32,
    pub max_descriptor_set_update_after_bind_samplers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_sampled_images: u32,
    pub max_descriptor_set_update_after_bind_storage_images: u32,
    pub max_descriptor_set_update_after_bind_input_attachments: u32,
}
unsafe impl Send for PhysicalDeviceDescriptorIndexingProperties {}
unsafe impl Sync for PhysicalDeviceDescriptorIndexingProperties {}
impl Default for PhysicalDeviceDescriptorIndexingProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
            p_next: ptr::null_mut(),
            max_update_after_bind_descriptors_in_all_pools: Default::default(),
            shader_uniform_buffer_array_non_uniform_indexing_native: Default::default(),
            shader_sampled_image_array_non_uniform_indexing_native: Default::default(),
            shader_storage_buffer_array_non_uniform_indexing_native: Default::default(),
            shader_storage_image_array_non_uniform_indexing_native: Default::default(),
            shader_input_attachment_array_non_uniform_indexing_native: Default::default(),
            robust_buffer_access_update_after_bind: Default::default(),
            quad_divergent_implicit_lod: Default::default(),
            max_per_stage_descriptor_update_after_bind_samplers: Default::default(),
            max_per_stage_descriptor_update_after_bind_uniform_buffers: Default::default(),
            max_per_stage_descriptor_update_after_bind_storage_buffers: Default::default(),
            max_per_stage_descriptor_update_after_bind_sampled_images: Default::default(),
            max_per_stage_descriptor_update_after_bind_storage_images: Default::default(),
            max_per_stage_descriptor_update_after_bind_input_attachments: Default::default(),
            max_per_stage_update_after_bind_resources: Default::default(),
            max_descriptor_set_update_after_bind_samplers: Default::default(),
            max_descriptor_set_update_after_bind_uniform_buffers: Default::default(),
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic: Default::default(),
            max_descriptor_set_update_after_bind_storage_buffers: Default::default(),
            max_descriptor_set_update_after_bind_storage_buffers_dynamic: Default::default(),
            max_descriptor_set_update_after_bind_sampled_images: Default::default(),
            max_descriptor_set_update_after_bind_storage_images: Default::default(),
            max_descriptor_set_update_after_bind_input_attachments: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDescriptorIndexingProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDescriptorIndexingProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "max_update_after_bind_descriptors_in_all_pools",
                &self.max_update_after_bind_descriptors_in_all_pools,
            )
            .field(
                "shader_uniform_buffer_array_non_uniform_indexing_native",
                &self.shader_uniform_buffer_array_non_uniform_indexing_native,
            )
            .field(
                "shader_sampled_image_array_non_uniform_indexing_native",
                &self.shader_sampled_image_array_non_uniform_indexing_native,
            )
            .field(
                "shader_storage_buffer_array_non_uniform_indexing_native",
                &self.shader_storage_buffer_array_non_uniform_indexing_native,
            )
            .field(
                "shader_storage_image_array_non_uniform_indexing_native",
                &self.shader_storage_image_array_non_uniform_indexing_native,
            )
            .field(
                "shader_input_attachment_array_non_uniform_indexing_native",
                &self.shader_input_attachment_array_non_uniform_indexing_native,
            )
            .field(
                "robust_buffer_access_update_after_bind",
                &self.robust_buffer_access_update_after_bind,
            )
            .field("quad_divergent_implicit_lod", &self.quad_divergent_implicit_lod)
            .field(
                "max_per_stage_descriptor_update_after_bind_samplers",
                &self.max_per_stage_descriptor_update_after_bind_samplers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_uniform_buffers",
                &self.max_per_stage_descriptor_update_after_bind_uniform_buffers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_storage_buffers",
                &self.max_per_stage_descriptor_update_after_bind_storage_buffers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_sampled_images",
                &self.max_per_stage_descriptor_update_after_bind_sampled_images,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_storage_images",
                &self.max_per_stage_descriptor_update_after_bind_storage_images,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_input_attachments",
                &self.max_per_stage_descriptor_update_after_bind_input_attachments,
            )
            .field(
                "max_per_stage_update_after_bind_resources",
                &self.max_per_stage_update_after_bind_resources,
            )
            .field(
                "max_descriptor_set_update_after_bind_samplers",
                &self.max_descriptor_set_update_after_bind_samplers,
            )
            .field(
                "max_descriptor_set_update_after_bind_uniform_buffers",
                &self.max_descriptor_set_update_after_bind_uniform_buffers,
            )
            .field(
                "max_descriptor_set_update_after_bind_uniform_buffers_dynamic",
                &self.max_descriptor_set_update_after_bind_uniform_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_buffers",
                &self.max_descriptor_set_update_after_bind_storage_buffers,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_buffers_dynamic",
                &self.max_descriptor_set_update_after_bind_storage_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_update_after_bind_sampled_images",
                &self.max_descriptor_set_update_after_bind_sampled_images,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_images",
                &self.max_descriptor_set_update_after_bind_storage_images,
            )
            .field(
                "max_descriptor_set_update_after_bind_input_attachments",
                &self.max_descriptor_set_update_after_bind_input_attachments,
            )
            .finish()
    }
}
pub type PhysicalDeviceDescriptorIndexingPropertiesEXT = PhysicalDeviceDescriptorIndexingProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetLayoutBindingFlagsCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub binding_count: u32,
    pub p_binding_flags: *const DescriptorBindingFlags,
}
unsafe impl Send for DescriptorSetLayoutBindingFlagsCreateInfo {}
unsafe impl Sync for DescriptorSetLayoutBindingFlagsCreateInfo {}
impl Default for DescriptorSetLayoutBindingFlagsCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
            p_next: ptr::null(),
            binding_count: Default::default(),
            p_binding_flags: ptr::null(),
        }
    }
}
impl fmt::Debug for DescriptorSetLayoutBindingFlagsCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetLayoutBindingFlagsCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("binding_count", &self.binding_count)
            .field("p_binding_flags", &self.p_binding_flags)
            .finish()
    }
}
pub type DescriptorSetLayoutBindingFlagsCreateInfoEXT = DescriptorSetLayoutBindingFlagsCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetVariableDescriptorCountAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub descriptor_set_count: u32,
    pub p_descriptor_counts: *const u32,
}
unsafe impl Send for DescriptorSetVariableDescriptorCountAllocateInfo {}
unsafe impl Sync for DescriptorSetVariableDescriptorCountAllocateInfo {}
impl Default for DescriptorSetVariableDescriptorCountAllocateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
            p_next: ptr::null(),
            descriptor_set_count: Default::default(),
            p_descriptor_counts: ptr::null(),
        }
    }
}
impl fmt::Debug for DescriptorSetVariableDescriptorCountAllocateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetVariableDescriptorCountAllocateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("descriptor_set_count", &self.descriptor_set_count)
            .field("p_descriptor_counts", &self.p_descriptor_counts)
            .finish()
    }
}
pub type DescriptorSetVariableDescriptorCountAllocateInfoEXT = DescriptorSetVariableDescriptorCountAllocateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetVariableDescriptorCountLayoutSupport {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_variable_descriptor_count: u32,
}
unsafe impl Send for DescriptorSetVariableDescriptorCountLayoutSupport {}
unsafe impl Sync for DescriptorSetVariableDescriptorCountLayoutSupport {}
impl Default for DescriptorSetVariableDescriptorCountLayoutSupport {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
            p_next: ptr::null_mut(),
            max_variable_descriptor_count: Default::default(),
        }
    }
}
impl fmt::Debug for DescriptorSetVariableDescriptorCountLayoutSupport {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetVariableDescriptorCountLayoutSupport")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_variable_descriptor_count", &self.max_variable_descriptor_count)
            .finish()
    }
}
pub type DescriptorSetVariableDescriptorCountLayoutSupportEXT = DescriptorSetVariableDescriptorCountLayoutSupport;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AttachmentDescription2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: AttachmentDescriptionFlags,
    pub format: Format,
    pub samples: SampleCountFlags,
    /// Load operation for color or depth data
    pub load_op: AttachmentLoadOp,
    /// Store operation for color or depth data
    pub store_op: AttachmentStoreOp,
    /// Load operation for stencil data
    pub stencil_load_op: AttachmentLoadOp,
    /// Store operation for stencil data
    pub stencil_store_op: AttachmentStoreOp,
    pub initial_layout: ImageLayout,
    pub final_layout: ImageLayout,
}
unsafe impl Send for AttachmentDescription2 {}
unsafe impl Sync for AttachmentDescription2 {}
impl Default for AttachmentDescription2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::ATTACHMENT_DESCRIPTION_2,
            p_next: ptr::null(),
            flags: Default::default(),
            format: Default::default(),
            samples: Default::default(),
            load_op: Default::default(),
            store_op: Default::default(),
            stencil_load_op: Default::default(),
            stencil_store_op: Default::default(),
            initial_layout: Default::default(),
            final_layout: Default::default(),
        }
    }
}
impl fmt::Debug for AttachmentDescription2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentDescription2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("format", &self.format)
            .field("samples", &self.samples)
            .field("load_op", &self.load_op)
            .field("store_op", &self.store_op)
            .field("stencil_load_op", &self.stencil_load_op)
            .field("stencil_store_op", &self.stencil_store_op)
            .field("initial_layout", &self.initial_layout)
            .field("final_layout", &self.final_layout)
            .finish()
    }
}
pub type AttachmentDescription2KHR = AttachmentDescription2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AttachmentReference2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment: u32,
    pub layout: ImageLayout,
    pub aspect_mask: ImageAspectFlags,
}
unsafe impl Send for AttachmentReference2 {}
unsafe impl Sync for AttachmentReference2 {}
impl Default for AttachmentReference2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::ATTACHMENT_REFERENCE_2,
            p_next: ptr::null(),
            attachment: Default::default(),
            layout: Default::default(),
            aspect_mask: Default::default(),
        }
    }
}
impl fmt::Debug for AttachmentReference2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentReference2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("attachment", &self.attachment)
            .field("layout", &self.layout)
            .field("aspect_mask", &self.aspect_mask)
            .finish()
    }
}
pub type AttachmentReference2KHR = AttachmentReference2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassDescription2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SubpassDescriptionFlags,
    pub pipeline_bind_point: PipelineBindPoint,
    pub view_mask: u32,
    pub input_attachment_count: u32,
    pub p_input_attachments: *const AttachmentReference2,
    pub color_attachment_count: u32,
    pub p_color_attachments: *const AttachmentReference2,
    pub p_resolve_attachments: *const AttachmentReference2,
    pub p_depth_stencil_attachment: *const AttachmentReference2,
    pub preserve_attachment_count: u32,
    pub p_preserve_attachments: *const u32,
}
unsafe impl Send for SubpassDescription2 {}
unsafe impl Sync for SubpassDescription2 {}
impl Default for SubpassDescription2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBPASS_DESCRIPTION_2,
            p_next: ptr::null(),
            flags: Default::default(),
            pipeline_bind_point: Default::default(),
            view_mask: Default::default(),
            input_attachment_count: Default::default(),
            p_input_attachments: ptr::null(),
            color_attachment_count: Default::default(),
            p_color_attachments: ptr::null(),
            p_resolve_attachments: ptr::null(),
            p_depth_stencil_attachment: ptr::null(),
            preserve_attachment_count: Default::default(),
            p_preserve_attachments: ptr::null(),
        }
    }
}
impl fmt::Debug for SubpassDescription2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassDescription2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("pipeline_bind_point", &self.pipeline_bind_point)
            .field("view_mask", &self.view_mask)
            .field("input_attachment_count", &self.input_attachment_count)
            .field("p_input_attachments", &self.p_input_attachments)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachments", &self.p_color_attachments)
            .field("p_resolve_attachments", &self.p_resolve_attachments)
            .field("p_depth_stencil_attachment", &self.p_depth_stencil_attachment)
            .field("preserve_attachment_count", &self.preserve_attachment_count)
            .field("p_preserve_attachments", &self.p_preserve_attachments)
            .finish()
    }
}
pub type SubpassDescription2KHR = SubpassDescription2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassDependency2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subpass: u32,
    pub dst_subpass: u32,
    pub src_stage_mask: PipelineStageFlags,
    pub dst_stage_mask: PipelineStageFlags,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub dependency_flags: DependencyFlags,
    pub view_offset: i32,
}
unsafe impl Send for SubpassDependency2 {}
unsafe impl Sync for SubpassDependency2 {}
impl Default for SubpassDependency2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBPASS_DEPENDENCY_2,
            p_next: ptr::null(),
            src_subpass: Default::default(),
            dst_subpass: Default::default(),
            src_stage_mask: Default::default(),
            dst_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_access_mask: Default::default(),
            dependency_flags: Default::default(),
            view_offset: Default::default(),
        }
    }
}
impl fmt::Debug for SubpassDependency2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassDependency2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_subpass", &self.src_subpass)
            .field("dst_subpass", &self.dst_subpass)
            .field("src_stage_mask", &self.src_stage_mask)
            .field("dst_stage_mask", &self.dst_stage_mask)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .field("dependency_flags", &self.dependency_flags)
            .field("view_offset", &self.view_offset)
            .finish()
    }
}
pub type SubpassDependency2KHR = SubpassDependency2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassCreateInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderPassCreateFlags,
    pub attachment_count: u32,
    pub p_attachments: *const AttachmentDescription2,
    pub subpass_count: u32,
    pub p_subpasses: *const SubpassDescription2,
    pub dependency_count: u32,
    pub p_dependencies: *const SubpassDependency2,
    pub correlated_view_mask_count: u32,
    pub p_correlated_view_masks: *const u32,
}
unsafe impl Send for RenderPassCreateInfo2 {}
unsafe impl Sync for RenderPassCreateInfo2 {}
impl Default for RenderPassCreateInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_CREATE_INFO_2,
            p_next: ptr::null(),
            flags: Default::default(),
            attachment_count: Default::default(),
            p_attachments: ptr::null(),
            subpass_count: Default::default(),
            p_subpasses: ptr::null(),
            dependency_count: Default::default(),
            p_dependencies: ptr::null(),
            correlated_view_mask_count: Default::default(),
            p_correlated_view_masks: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderPassCreateInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassCreateInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("attachment_count", &self.attachment_count)
            .field("p_attachments", &self.p_attachments)
            .field("subpass_count", &self.subpass_count)
            .field("p_subpasses", &self.p_subpasses)
            .field("dependency_count", &self.dependency_count)
            .field("p_dependencies", &self.p_dependencies)
            .field("correlated_view_mask_count", &self.correlated_view_mask_count)
            .field("p_correlated_view_masks", &self.p_correlated_view_masks)
            .finish()
    }
}
pub type RenderPassCreateInfo2KHR = RenderPassCreateInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub contents: SubpassContents,
}
unsafe impl Send for SubpassBeginInfo {}
unsafe impl Sync for SubpassBeginInfo {}
impl Default for SubpassBeginInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBPASS_BEGIN_INFO,
            p_next: ptr::null(),
            contents: Default::default(),
        }
    }
}
impl fmt::Debug for SubpassBeginInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassBeginInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("contents", &self.contents)
            .finish()
    }
}
pub type SubpassBeginInfoKHR = SubpassBeginInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassEndInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
}
unsafe impl Send for SubpassEndInfo {}
unsafe impl Sync for SubpassEndInfo {}
impl Default for SubpassEndInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBPASS_END_INFO,
            p_next: ptr::null(),
        }
    }
}
impl fmt::Debug for SubpassEndInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassEndInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .finish()
    }
}
pub type SubpassEndInfoKHR = SubpassEndInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceTimelineSemaphoreFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub timeline_semaphore: Bool32,
}
unsafe impl Send for PhysicalDeviceTimelineSemaphoreFeatures {}
unsafe impl Sync for PhysicalDeviceTimelineSemaphoreFeatures {}
impl Default for PhysicalDeviceTimelineSemaphoreFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
            p_next: ptr::null_mut(),
            timeline_semaphore: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceTimelineSemaphoreFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceTimelineSemaphoreFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("timeline_semaphore", &self.timeline_semaphore)
            .finish()
    }
}
pub type PhysicalDeviceTimelineSemaphoreFeaturesKHR = PhysicalDeviceTimelineSemaphoreFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceTimelineSemaphoreProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_timeline_semaphore_value_difference: u64,
}
unsafe impl Send for PhysicalDeviceTimelineSemaphoreProperties {}
unsafe impl Sync for PhysicalDeviceTimelineSemaphoreProperties {}
impl Default for PhysicalDeviceTimelineSemaphoreProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
            p_next: ptr::null_mut(),
            max_timeline_semaphore_value_difference: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceTimelineSemaphoreProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceTimelineSemaphoreProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "max_timeline_semaphore_value_difference",
                &self.max_timeline_semaphore_value_difference,
            )
            .finish()
    }
}
pub type PhysicalDeviceTimelineSemaphorePropertiesKHR = PhysicalDeviceTimelineSemaphoreProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreTypeCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore_type: SemaphoreType,
    pub initial_value: u64,
}
unsafe impl Send for SemaphoreTypeCreateInfo {}
unsafe impl Sync for SemaphoreTypeCreateInfo {}
impl Default for SemaphoreTypeCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_TYPE_CREATE_INFO,
            p_next: ptr::null(),
            semaphore_type: Default::default(),
            initial_value: Default::default(),
        }
    }
}
impl fmt::Debug for SemaphoreTypeCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreTypeCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore_type", &self.semaphore_type)
            .field("initial_value", &self.initial_value)
            .finish()
    }
}
pub type SemaphoreTypeCreateInfoKHR = SemaphoreTypeCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TimelineSemaphoreSubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_value_count: u32,
    pub p_wait_semaphore_values: *const u64,
    pub signal_semaphore_value_count: u32,
    pub p_signal_semaphore_values: *const u64,
}
unsafe impl Send for TimelineSemaphoreSubmitInfo {}
unsafe impl Sync for TimelineSemaphoreSubmitInfo {}
impl Default for TimelineSemaphoreSubmitInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::TIMELINE_SEMAPHORE_SUBMIT_INFO,
            p_next: ptr::null(),
            wait_semaphore_value_count: Default::default(),
            p_wait_semaphore_values: ptr::null(),
            signal_semaphore_value_count: Default::default(),
            p_signal_semaphore_values: ptr::null(),
        }
    }
}
impl fmt::Debug for TimelineSemaphoreSubmitInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("TimelineSemaphoreSubmitInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("wait_semaphore_value_count", &self.wait_semaphore_value_count)
            .field("p_wait_semaphore_values", &self.p_wait_semaphore_values)
            .field("signal_semaphore_value_count", &self.signal_semaphore_value_count)
            .field("p_signal_semaphore_values", &self.p_signal_semaphore_values)
            .finish()
    }
}
pub type TimelineSemaphoreSubmitInfoKHR = TimelineSemaphoreSubmitInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreWaitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SemaphoreWaitFlags,
    pub semaphore_count: u32,
    pub p_semaphores: *const Semaphore,
    pub p_values: *const u64,
}
unsafe impl Send for SemaphoreWaitInfo {}
unsafe impl Sync for SemaphoreWaitInfo {}
impl Default for SemaphoreWaitInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_WAIT_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            semaphore_count: Default::default(),
            p_semaphores: ptr::null(),
            p_values: ptr::null(),
        }
    }
}
impl fmt::Debug for SemaphoreWaitInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreWaitInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("semaphore_count", &self.semaphore_count)
            .field("p_semaphores", &self.p_semaphores)
            .field("p_values", &self.p_values)
            .finish()
    }
}
pub type SemaphoreWaitInfoKHR = SemaphoreWaitInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreSignalInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub value: u64,
}
unsafe impl Send for SemaphoreSignalInfo {}
unsafe impl Sync for SemaphoreSignalInfo {}
impl Default for SemaphoreSignalInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_SIGNAL_INFO,
            p_next: ptr::null(),
            semaphore: Default::default(),
            value: Default::default(),
        }
    }
}
impl fmt::Debug for SemaphoreSignalInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreSignalInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("value", &self.value)
            .finish()
    }
}
pub type SemaphoreSignalInfoKHR = SemaphoreSignalInfo;
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct VertexInputBindingDivisorDescriptionEXT {
    pub binding: u32,
    pub divisor: u32,
}
impl fmt::Debug for VertexInputBindingDivisorDescriptionEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("VertexInputBindingDivisorDescriptionEXT")
            .field("binding", &self.binding)
            .field("divisor", &self.divisor)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineVertexInputDivisorStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_binding_divisor_count: u32,
    pub p_vertex_binding_divisors: *const VertexInputBindingDivisorDescriptionEXT,
}
unsafe impl Send for PipelineVertexInputDivisorStateCreateInfoEXT {}
unsafe impl Sync for PipelineVertexInputDivisorStateCreateInfoEXT {}
impl Default for PipelineVertexInputDivisorStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            vertex_binding_divisor_count: Default::default(),
            p_vertex_binding_divisors: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineVertexInputDivisorStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineVertexInputDivisorStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vertex_binding_divisor_count", &self.vertex_binding_divisor_count)
            .field("p_vertex_binding_divisors", &self.p_vertex_binding_divisors)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// max value of vertex attribute divisor
    pub max_vertex_attrib_divisor: u32,
}
unsafe impl Send for PhysicalDeviceVertexAttributeDivisorPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceVertexAttributeDivisorPropertiesEXT {}
impl Default for PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            max_vertex_attrib_divisor: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVertexAttributeDivisorPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_vertex_attrib_divisor", &self.max_vertex_attrib_divisor)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePCIBusInfoPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pci_domain: u32,
    pub pci_bus: u32,
    pub pci_device: u32,
    pub pci_function: u32,
}
unsafe impl Send for PhysicalDevicePCIBusInfoPropertiesEXT {}
unsafe impl Sync for PhysicalDevicePCIBusInfoPropertiesEXT {}
impl Default for PhysicalDevicePCIBusInfoPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            pci_domain: Default::default(),
            pci_bus: Default::default(),
            pci_device: Default::default(),
            pci_function: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePCIBusInfoPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePCIBusInfoPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pci_domain", &self.pci_domain)
            .field("pci_bus", &self.pci_bus)
            .field("pci_device", &self.pci_device)
            .field("pci_function", &self.pci_function)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportAndroidHardwareBufferInfoANDROID {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: *mut AHardwareBuffer,
}
unsafe impl Send for ImportAndroidHardwareBufferInfoANDROID {}
unsafe impl Sync for ImportAndroidHardwareBufferInfoANDROID {}
impl Default for ImportAndroidHardwareBufferInfoANDROID {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
            p_next: ptr::null(),
            buffer: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for ImportAndroidHardwareBufferInfoANDROID {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportAndroidHardwareBufferInfoANDROID")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer", &self.buffer)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AndroidHardwareBufferUsageANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub android_hardware_buffer_usage: u64,
}
unsafe impl Send for AndroidHardwareBufferUsageANDROID {}
unsafe impl Sync for AndroidHardwareBufferUsageANDROID {}
impl Default for AndroidHardwareBufferUsageANDROID {
    fn default() -> Self {
        Self {
            s_type: StructureType::ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
            p_next: ptr::null_mut(),
            android_hardware_buffer_usage: Default::default(),
        }
    }
}
impl fmt::Debug for AndroidHardwareBufferUsageANDROID {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AndroidHardwareBufferUsageANDROID")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("android_hardware_buffer_usage", &self.android_hardware_buffer_usage)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AndroidHardwareBufferPropertiesANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub allocation_size: DeviceSize,
    pub memory_type_bits: u32,
}
unsafe impl Send for AndroidHardwareBufferPropertiesANDROID {}
unsafe impl Sync for AndroidHardwareBufferPropertiesANDROID {}
impl Default for AndroidHardwareBufferPropertiesANDROID {
    fn default() -> Self {
        Self {
            s_type: StructureType::ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
            p_next: ptr::null_mut(),
            allocation_size: Default::default(),
            memory_type_bits: Default::default(),
        }
    }
}
impl fmt::Debug for AndroidHardwareBufferPropertiesANDROID {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AndroidHardwareBufferPropertiesANDROID")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("allocation_size", &self.allocation_size)
            .field("memory_type_bits", &self.memory_type_bits)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryGetAndroidHardwareBufferInfoANDROID {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: Option<DeviceMemory>,
}
unsafe impl Send for MemoryGetAndroidHardwareBufferInfoANDROID {}
unsafe impl Sync for MemoryGetAndroidHardwareBufferInfoANDROID {}
impl Default for MemoryGetAndroidHardwareBufferInfoANDROID {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
            p_next: ptr::null(),
            memory: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryGetAndroidHardwareBufferInfoANDROID {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryGetAndroidHardwareBufferInfoANDROID")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AndroidHardwareBufferFormatPropertiesANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format: Format,
    pub external_format: u64,
    pub format_features: FormatFeatureFlags,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_x_chroma_offset: ChromaLocation,
    pub suggested_y_chroma_offset: ChromaLocation,
}
unsafe impl Send for AndroidHardwareBufferFormatPropertiesANDROID {}
unsafe impl Sync for AndroidHardwareBufferFormatPropertiesANDROID {}
impl Default for AndroidHardwareBufferFormatPropertiesANDROID {
    fn default() -> Self {
        Self {
            s_type: StructureType::ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
            p_next: ptr::null_mut(),
            format: Default::default(),
            external_format: Default::default(),
            format_features: Default::default(),
            sampler_ycbcr_conversion_components: Default::default(),
            suggested_ycbcr_model: Default::default(),
            suggested_ycbcr_range: Default::default(),
            suggested_x_chroma_offset: Default::default(),
            suggested_y_chroma_offset: Default::default(),
        }
    }
}
impl fmt::Debug for AndroidHardwareBufferFormatPropertiesANDROID {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AndroidHardwareBufferFormatPropertiesANDROID")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format", &self.format)
            .field("external_format", &self.external_format)
            .field("format_features", &self.format_features)
            .field(
                "sampler_ycbcr_conversion_components",
                &self.sampler_ycbcr_conversion_components,
            )
            .field("suggested_ycbcr_model", &self.suggested_ycbcr_model)
            .field("suggested_ycbcr_range", &self.suggested_ycbcr_range)
            .field("suggested_x_chroma_offset", &self.suggested_x_chroma_offset)
            .field("suggested_y_chroma_offset", &self.suggested_y_chroma_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferInheritanceConditionalRenderingInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Whether this secondary command buffer may be executed during an active conditional rendering
    pub conditional_rendering_enable: Bool32,
}
unsafe impl Send for CommandBufferInheritanceConditionalRenderingInfoEXT {}
unsafe impl Sync for CommandBufferInheritanceConditionalRenderingInfoEXT {}
impl Default for CommandBufferInheritanceConditionalRenderingInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
            p_next: ptr::null(),
            conditional_rendering_enable: Default::default(),
        }
    }
}
impl fmt::Debug for CommandBufferInheritanceConditionalRenderingInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferInheritanceConditionalRenderingInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("conditional_rendering_enable", &self.conditional_rendering_enable)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExternalFormatANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_format: u64,
}
unsafe impl Send for ExternalFormatANDROID {}
unsafe impl Sync for ExternalFormatANDROID {}
impl Default for ExternalFormatANDROID {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXTERNAL_FORMAT_ANDROID,
            p_next: ptr::null_mut(),
            external_format: Default::default(),
        }
    }
}
impl fmt::Debug for ExternalFormatANDROID {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExternalFormatANDROID")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("external_format", &self.external_format)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevice8BitStorageFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// 8-bit integer variables supported in StorageBuffer
    pub storage_buffer8_bit_access: Bool32,
    /// 8-bit integer variables supported in StorageBuffer and Uniform
    pub uniform_and_storage_buffer8_bit_access: Bool32,
    /// 8-bit integer variables supported in PushConstant
    pub storage_push_constant8: Bool32,
}
unsafe impl Send for PhysicalDevice8BitStorageFeatures {}
unsafe impl Sync for PhysicalDevice8BitStorageFeatures {}
impl Default for PhysicalDevice8BitStorageFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
            p_next: ptr::null_mut(),
            storage_buffer8_bit_access: Default::default(),
            uniform_and_storage_buffer8_bit_access: Default::default(),
            storage_push_constant8: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevice8BitStorageFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevice8BitStorageFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("storage_buffer8_bit_access", &self.storage_buffer8_bit_access)
            .field(
                "uniform_and_storage_buffer8_bit_access",
                &self.uniform_and_storage_buffer8_bit_access,
            )
            .field("storage_push_constant8", &self.storage_push_constant8)
            .finish()
    }
}
pub type PhysicalDevice8BitStorageFeaturesKHR = PhysicalDevice8BitStorageFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceConditionalRenderingFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub conditional_rendering: Bool32,
    pub inherited_conditional_rendering: Bool32,
}
unsafe impl Send for PhysicalDeviceConditionalRenderingFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceConditionalRenderingFeaturesEXT {}
impl Default for PhysicalDeviceConditionalRenderingFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
            p_next: ptr::null_mut(),
            conditional_rendering: Default::default(),
            inherited_conditional_rendering: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceConditionalRenderingFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceConditionalRenderingFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("conditional_rendering", &self.conditional_rendering)
            .field("inherited_conditional_rendering", &self.inherited_conditional_rendering)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVulkanMemoryModelFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub vulkan_memory_model: Bool32,
    pub vulkan_memory_model_device_scope: Bool32,
    pub vulkan_memory_model_availability_visibility_chains: Bool32,
}
unsafe impl Send for PhysicalDeviceVulkanMemoryModelFeatures {}
unsafe impl Sync for PhysicalDeviceVulkanMemoryModelFeatures {}
impl Default for PhysicalDeviceVulkanMemoryModelFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
            p_next: ptr::null_mut(),
            vulkan_memory_model: Default::default(),
            vulkan_memory_model_device_scope: Default::default(),
            vulkan_memory_model_availability_visibility_chains: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVulkanMemoryModelFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVulkanMemoryModelFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vulkan_memory_model", &self.vulkan_memory_model)
            .field(
                "vulkan_memory_model_device_scope",
                &self.vulkan_memory_model_device_scope,
            )
            .field(
                "vulkan_memory_model_availability_visibility_chains",
                &self.vulkan_memory_model_availability_visibility_chains,
            )
            .finish()
    }
}
pub type PhysicalDeviceVulkanMemoryModelFeaturesKHR = PhysicalDeviceVulkanMemoryModelFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderAtomicInt64Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_buffer_int64_atomics: Bool32,
    pub shader_shared_int64_atomics: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderAtomicInt64Features {}
unsafe impl Sync for PhysicalDeviceShaderAtomicInt64Features {}
impl Default for PhysicalDeviceShaderAtomicInt64Features {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
            p_next: ptr::null_mut(),
            shader_buffer_int64_atomics: Default::default(),
            shader_shared_int64_atomics: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderAtomicInt64Features {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderAtomicInt64Features")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_buffer_int64_atomics", &self.shader_buffer_int64_atomics)
            .field("shader_shared_int64_atomics", &self.shader_shared_int64_atomics)
            .finish()
    }
}
pub type PhysicalDeviceShaderAtomicInt64FeaturesKHR = PhysicalDeviceShaderAtomicInt64Features;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_buffer_float32_atomics: Bool32,
    pub shader_buffer_float32_atomic_add: Bool32,
    pub shader_buffer_float64_atomics: Bool32,
    pub shader_buffer_float64_atomic_add: Bool32,
    pub shader_shared_float32_atomics: Bool32,
    pub shader_shared_float32_atomic_add: Bool32,
    pub shader_shared_float64_atomics: Bool32,
    pub shader_shared_float64_atomic_add: Bool32,
    pub shader_image_float32_atomics: Bool32,
    pub shader_image_float32_atomic_add: Bool32,
    pub sparse_image_float32_atomics: Bool32,
    pub sparse_image_float32_atomic_add: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderAtomicFloatFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceShaderAtomicFloatFeaturesEXT {}
impl Default for PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
            p_next: ptr::null_mut(),
            shader_buffer_float32_atomics: Default::default(),
            shader_buffer_float32_atomic_add: Default::default(),
            shader_buffer_float64_atomics: Default::default(),
            shader_buffer_float64_atomic_add: Default::default(),
            shader_shared_float32_atomics: Default::default(),
            shader_shared_float32_atomic_add: Default::default(),
            shader_shared_float64_atomics: Default::default(),
            shader_shared_float64_atomic_add: Default::default(),
            shader_image_float32_atomics: Default::default(),
            shader_image_float32_atomic_add: Default::default(),
            sparse_image_float32_atomics: Default::default(),
            sparse_image_float32_atomic_add: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderAtomicFloatFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_buffer_float32_atomics", &self.shader_buffer_float32_atomics)
            .field(
                "shader_buffer_float32_atomic_add",
                &self.shader_buffer_float32_atomic_add,
            )
            .field("shader_buffer_float64_atomics", &self.shader_buffer_float64_atomics)
            .field(
                "shader_buffer_float64_atomic_add",
                &self.shader_buffer_float64_atomic_add,
            )
            .field("shader_shared_float32_atomics", &self.shader_shared_float32_atomics)
            .field(
                "shader_shared_float32_atomic_add",
                &self.shader_shared_float32_atomic_add,
            )
            .field("shader_shared_float64_atomics", &self.shader_shared_float64_atomics)
            .field(
                "shader_shared_float64_atomic_add",
                &self.shader_shared_float64_atomic_add,
            )
            .field("shader_image_float32_atomics", &self.shader_image_float32_atomics)
            .field("shader_image_float32_atomic_add", &self.shader_image_float32_atomic_add)
            .field("sparse_image_float32_atomics", &self.sparse_image_float32_atomics)
            .field("sparse_image_float32_atomic_add", &self.sparse_image_float32_atomic_add)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_buffer_float16_atomics: Bool32,
    pub shader_buffer_float16_atomic_add: Bool32,
    pub shader_buffer_float16_atomic_min_max: Bool32,
    pub shader_buffer_float32_atomic_min_max: Bool32,
    pub shader_buffer_float64_atomic_min_max: Bool32,
    pub shader_shared_float16_atomics: Bool32,
    pub shader_shared_float16_atomic_add: Bool32,
    pub shader_shared_float16_atomic_min_max: Bool32,
    pub shader_shared_float32_atomic_min_max: Bool32,
    pub shader_shared_float64_atomic_min_max: Bool32,
    pub shader_image_float32_atomic_min_max: Bool32,
    pub sparse_image_float32_atomic_min_max: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {}
unsafe impl Sync for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {}
impl Default for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT,
            p_next: ptr::null_mut(),
            shader_buffer_float16_atomics: Default::default(),
            shader_buffer_float16_atomic_add: Default::default(),
            shader_buffer_float16_atomic_min_max: Default::default(),
            shader_buffer_float32_atomic_min_max: Default::default(),
            shader_buffer_float64_atomic_min_max: Default::default(),
            shader_shared_float16_atomics: Default::default(),
            shader_shared_float16_atomic_add: Default::default(),
            shader_shared_float16_atomic_min_max: Default::default(),
            shader_shared_float32_atomic_min_max: Default::default(),
            shader_shared_float64_atomic_min_max: Default::default(),
            shader_image_float32_atomic_min_max: Default::default(),
            sparse_image_float32_atomic_min_max: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderAtomicFloat2FeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_buffer_float16_atomics", &self.shader_buffer_float16_atomics)
            .field(
                "shader_buffer_float16_atomic_add",
                &self.shader_buffer_float16_atomic_add,
            )
            .field(
                "shader_buffer_float16_atomic_min_max",
                &self.shader_buffer_float16_atomic_min_max,
            )
            .field(
                "shader_buffer_float32_atomic_min_max",
                &self.shader_buffer_float32_atomic_min_max,
            )
            .field(
                "shader_buffer_float64_atomic_min_max",
                &self.shader_buffer_float64_atomic_min_max,
            )
            .field("shader_shared_float16_atomics", &self.shader_shared_float16_atomics)
            .field(
                "shader_shared_float16_atomic_add",
                &self.shader_shared_float16_atomic_add,
            )
            .field(
                "shader_shared_float16_atomic_min_max",
                &self.shader_shared_float16_atomic_min_max,
            )
            .field(
                "shader_shared_float32_atomic_min_max",
                &self.shader_shared_float32_atomic_min_max,
            )
            .field(
                "shader_shared_float64_atomic_min_max",
                &self.shader_shared_float64_atomic_min_max,
            )
            .field(
                "shader_image_float32_atomic_min_max",
                &self.shader_image_float32_atomic_min_max,
            )
            .field(
                "sparse_image_float32_atomic_min_max",
                &self.sparse_image_float32_atomic_min_max,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub vertex_attribute_instance_rate_divisor: Bool32,
    pub vertex_attribute_instance_rate_zero_divisor: Bool32,
}
unsafe impl Send for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {}
impl Default for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT,
            p_next: ptr::null_mut(),
            vertex_attribute_instance_rate_divisor: Default::default(),
            vertex_attribute_instance_rate_zero_divisor: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVertexAttributeDivisorFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "vertex_attribute_instance_rate_divisor",
                &self.vertex_attribute_instance_rate_divisor,
            )
            .field(
                "vertex_attribute_instance_rate_zero_divisor",
                &self.vertex_attribute_instance_rate_zero_divisor,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueueFamilyCheckpointPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub checkpoint_execution_stage_mask: PipelineStageFlags,
}
unsafe impl Send for QueueFamilyCheckpointPropertiesNV {}
unsafe impl Sync for QueueFamilyCheckpointPropertiesNV {}
impl Default for QueueFamilyCheckpointPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            checkpoint_execution_stage_mask: Default::default(),
        }
    }
}
impl fmt::Debug for QueueFamilyCheckpointPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueueFamilyCheckpointPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("checkpoint_execution_stage_mask", &self.checkpoint_execution_stage_mask)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CheckpointDataNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stage: PipelineStageFlags,
    pub p_checkpoint_marker: *mut c_void,
}
unsafe impl Send for CheckpointDataNV {}
unsafe impl Sync for CheckpointDataNV {}
impl Default for CheckpointDataNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::CHECKPOINT_DATA_NV,
            p_next: ptr::null_mut(),
            stage: Default::default(),
            p_checkpoint_marker: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for CheckpointDataNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CheckpointDataNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stage", &self.stage)
            .field("p_checkpoint_marker", &self.p_checkpoint_marker)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDepthStencilResolveProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// supported depth resolve modes
    pub supported_depth_resolve_modes: ResolveModeFlags,
    /// supported stencil resolve modes
    pub supported_stencil_resolve_modes: ResolveModeFlags,
    /// depth and stencil resolve modes can be set independently if one of them is none
    pub independent_resolve_none: Bool32,
    /// depth and stencil resolve modes can be set independently
    pub independent_resolve: Bool32,
}
unsafe impl Send for PhysicalDeviceDepthStencilResolveProperties {}
unsafe impl Sync for PhysicalDeviceDepthStencilResolveProperties {}
impl Default for PhysicalDeviceDepthStencilResolveProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
            p_next: ptr::null_mut(),
            supported_depth_resolve_modes: Default::default(),
            supported_stencil_resolve_modes: Default::default(),
            independent_resolve_none: Default::default(),
            independent_resolve: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDepthStencilResolveProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDepthStencilResolveProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("supported_depth_resolve_modes", &self.supported_depth_resolve_modes)
            .field("supported_stencil_resolve_modes", &self.supported_stencil_resolve_modes)
            .field("independent_resolve_none", &self.independent_resolve_none)
            .field("independent_resolve", &self.independent_resolve)
            .finish()
    }
}
pub type PhysicalDeviceDepthStencilResolvePropertiesKHR = PhysicalDeviceDepthStencilResolveProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassDescriptionDepthStencilResolve {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// depth resolve mode
    pub depth_resolve_mode: ResolveModeFlags,
    /// stencil resolve mode
    pub stencil_resolve_mode: ResolveModeFlags,
    /// depth/stencil resolve attachment
    pub p_depth_stencil_resolve_attachment: *const AttachmentReference2,
}
unsafe impl Send for SubpassDescriptionDepthStencilResolve {}
unsafe impl Sync for SubpassDescriptionDepthStencilResolve {}
impl Default for SubpassDescriptionDepthStencilResolve {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
            p_next: ptr::null(),
            depth_resolve_mode: Default::default(),
            stencil_resolve_mode: Default::default(),
            p_depth_stencil_resolve_attachment: ptr::null(),
        }
    }
}
impl fmt::Debug for SubpassDescriptionDepthStencilResolve {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassDescriptionDepthStencilResolve")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("depth_resolve_mode", &self.depth_resolve_mode)
            .field("stencil_resolve_mode", &self.stencil_resolve_mode)
            .field(
                "p_depth_stencil_resolve_attachment",
                &self.p_depth_stencil_resolve_attachment,
            )
            .finish()
    }
}
pub type SubpassDescriptionDepthStencilResolveKHR = SubpassDescriptionDepthStencilResolve;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageViewASTCDecodeModeEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub decode_mode: Format,
}
unsafe impl Send for ImageViewASTCDecodeModeEXT {}
unsafe impl Sync for ImageViewASTCDecodeModeEXT {}
impl Default for ImageViewASTCDecodeModeEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
            p_next: ptr::null(),
            decode_mode: Default::default(),
        }
    }
}
impl fmt::Debug for ImageViewASTCDecodeModeEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageViewASTCDecodeModeEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("decode_mode", &self.decode_mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceASTCDecodeFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub decode_mode_shared_exponent: Bool32,
}
unsafe impl Send for PhysicalDeviceASTCDecodeFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceASTCDecodeFeaturesEXT {}
impl Default for PhysicalDeviceASTCDecodeFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
            p_next: ptr::null_mut(),
            decode_mode_shared_exponent: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceASTCDecodeFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceASTCDecodeFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("decode_mode_shared_exponent", &self.decode_mode_shared_exponent)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceTransformFeedbackFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub transform_feedback: Bool32,
    pub geometry_streams: Bool32,
}
unsafe impl Send for PhysicalDeviceTransformFeedbackFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceTransformFeedbackFeaturesEXT {}
impl Default for PhysicalDeviceTransformFeedbackFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
            p_next: ptr::null_mut(),
            transform_feedback: Default::default(),
            geometry_streams: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceTransformFeedbackFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceTransformFeedbackFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("transform_feedback", &self.transform_feedback)
            .field("geometry_streams", &self.geometry_streams)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceTransformFeedbackPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_transform_feedback_streams: u32,
    pub max_transform_feedback_buffers: u32,
    pub max_transform_feedback_buffer_size: DeviceSize,
    pub max_transform_feedback_stream_data_size: u32,
    pub max_transform_feedback_buffer_data_size: u32,
    pub max_transform_feedback_buffer_data_stride: u32,
    pub transform_feedback_queries: Bool32,
    pub transform_feedback_streams_lines_triangles: Bool32,
    pub transform_feedback_rasterization_stream_select: Bool32,
    pub transform_feedback_draw: Bool32,
}
unsafe impl Send for PhysicalDeviceTransformFeedbackPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceTransformFeedbackPropertiesEXT {}
impl Default for PhysicalDeviceTransformFeedbackPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            max_transform_feedback_streams: Default::default(),
            max_transform_feedback_buffers: Default::default(),
            max_transform_feedback_buffer_size: Default::default(),
            max_transform_feedback_stream_data_size: Default::default(),
            max_transform_feedback_buffer_data_size: Default::default(),
            max_transform_feedback_buffer_data_stride: Default::default(),
            transform_feedback_queries: Default::default(),
            transform_feedback_streams_lines_triangles: Default::default(),
            transform_feedback_rasterization_stream_select: Default::default(),
            transform_feedback_draw: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceTransformFeedbackPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceTransformFeedbackPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_transform_feedback_streams", &self.max_transform_feedback_streams)
            .field("max_transform_feedback_buffers", &self.max_transform_feedback_buffers)
            .field(
                "max_transform_feedback_buffer_size",
                &self.max_transform_feedback_buffer_size,
            )
            .field(
                "max_transform_feedback_stream_data_size",
                &self.max_transform_feedback_stream_data_size,
            )
            .field(
                "max_transform_feedback_buffer_data_size",
                &self.max_transform_feedback_buffer_data_size,
            )
            .field(
                "max_transform_feedback_buffer_data_stride",
                &self.max_transform_feedback_buffer_data_stride,
            )
            .field("transform_feedback_queries", &self.transform_feedback_queries)
            .field(
                "transform_feedback_streams_lines_triangles",
                &self.transform_feedback_streams_lines_triangles,
            )
            .field(
                "transform_feedback_rasterization_stream_select",
                &self.transform_feedback_rasterization_stream_select,
            )
            .field("transform_feedback_draw", &self.transform_feedback_draw)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRasterizationStateStreamCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineRasterizationStateStreamCreateFlagsEXT,
    pub rasterization_stream: u32,
}
unsafe impl Send for PipelineRasterizationStateStreamCreateInfoEXT {}
unsafe impl Sync for PipelineRasterizationStateStreamCreateInfoEXT {}
impl Default for PipelineRasterizationStateStreamCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: Default::default(),
            rasterization_stream: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineRasterizationStateStreamCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRasterizationStateStreamCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("rasterization_stream", &self.rasterization_stream)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub representative_fragment_test: Bool32,
}
unsafe impl Send for PhysicalDeviceRepresentativeFragmentTestFeaturesNV {}
unsafe impl Sync for PhysicalDeviceRepresentativeFragmentTestFeaturesNV {}
impl Default for PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
            p_next: ptr::null_mut(),
            representative_fragment_test: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRepresentativeFragmentTestFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("representative_fragment_test", &self.representative_fragment_test)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRepresentativeFragmentTestStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub representative_fragment_test_enable: Bool32,
}
unsafe impl Send for PipelineRepresentativeFragmentTestStateCreateInfoNV {}
unsafe impl Sync for PipelineRepresentativeFragmentTestStateCreateInfoNV {}
impl Default for PipelineRepresentativeFragmentTestStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            representative_fragment_test_enable: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineRepresentativeFragmentTestStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRepresentativeFragmentTestStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "representative_fragment_test_enable",
                &self.representative_fragment_test_enable,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExclusiveScissorFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub exclusive_scissor: Bool32,
}
unsafe impl Send for PhysicalDeviceExclusiveScissorFeaturesNV {}
unsafe impl Sync for PhysicalDeviceExclusiveScissorFeaturesNV {}
impl Default for PhysicalDeviceExclusiveScissorFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
            p_next: ptr::null_mut(),
            exclusive_scissor: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExclusiveScissorFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExclusiveScissorFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("exclusive_scissor", &self.exclusive_scissor)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineViewportExclusiveScissorStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub exclusive_scissor_count: u32,
    pub p_exclusive_scissors: *const Rect2D,
}
unsafe impl Send for PipelineViewportExclusiveScissorStateCreateInfoNV {}
unsafe impl Sync for PipelineViewportExclusiveScissorStateCreateInfoNV {}
impl Default for PipelineViewportExclusiveScissorStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            exclusive_scissor_count: Default::default(),
            p_exclusive_scissors: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineViewportExclusiveScissorStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineViewportExclusiveScissorStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("exclusive_scissor_count", &self.exclusive_scissor_count)
            .field("p_exclusive_scissors", &self.p_exclusive_scissors)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceCornerSampledImageFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub corner_sampled_image: Bool32,
}
unsafe impl Send for PhysicalDeviceCornerSampledImageFeaturesNV {}
unsafe impl Sync for PhysicalDeviceCornerSampledImageFeaturesNV {}
impl Default for PhysicalDeviceCornerSampledImageFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
            p_next: ptr::null_mut(),
            corner_sampled_image: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceCornerSampledImageFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceCornerSampledImageFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("corner_sampled_image", &self.corner_sampled_image)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceComputeShaderDerivativesFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub compute_derivative_group_quads: Bool32,
    pub compute_derivative_group_linear: Bool32,
}
unsafe impl Send for PhysicalDeviceComputeShaderDerivativesFeaturesNV {}
unsafe impl Sync for PhysicalDeviceComputeShaderDerivativesFeaturesNV {}
impl Default for PhysicalDeviceComputeShaderDerivativesFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV,
            p_next: ptr::null_mut(),
            compute_derivative_group_quads: Default::default(),
            compute_derivative_group_linear: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceComputeShaderDerivativesFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceComputeShaderDerivativesFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("compute_derivative_group_quads", &self.compute_derivative_group_quads)
            .field("compute_derivative_group_linear", &self.compute_derivative_group_linear)
            .finish()
    }
}
pub type PhysicalDeviceFragmentShaderBarycentricFeaturesNV = PhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderImageFootprintFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_footprint: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderImageFootprintFeaturesNV {}
unsafe impl Sync for PhysicalDeviceShaderImageFootprintFeaturesNV {}
impl Default for PhysicalDeviceShaderImageFootprintFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
            p_next: ptr::null_mut(),
            image_footprint: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderImageFootprintFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderImageFootprintFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_footprint", &self.image_footprint)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub dedicated_allocation_image_aliasing: Bool32,
}
unsafe impl Send for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {}
unsafe impl Sync for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {}
impl Default for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
            p_next: ptr::null_mut(),
            dedicated_allocation_image_aliasing: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "dedicated_allocation_image_aliasing",
                &self.dedicated_allocation_image_aliasing,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ShadingRatePaletteNV {
    pub shading_rate_palette_entry_count: u32,
    pub p_shading_rate_palette_entries: *const ShadingRatePaletteEntryNV,
}
unsafe impl Send for ShadingRatePaletteNV {}
unsafe impl Sync for ShadingRatePaletteNV {}
impl Default for ShadingRatePaletteNV {
    fn default() -> Self {
        Self {
            shading_rate_palette_entry_count: Default::default(),
            p_shading_rate_palette_entries: ptr::null(),
        }
    }
}
impl fmt::Debug for ShadingRatePaletteNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ShadingRatePaletteNV")
            .field(
                "shading_rate_palette_entry_count",
                &self.shading_rate_palette_entry_count,
            )
            .field("p_shading_rate_palette_entries", &self.p_shading_rate_palette_entries)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineViewportShadingRateImageStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub shading_rate_image_enable: Bool32,
    pub viewport_count: u32,
    pub p_shading_rate_palettes: *const ShadingRatePaletteNV,
}
unsafe impl Send for PipelineViewportShadingRateImageStateCreateInfoNV {}
unsafe impl Sync for PipelineViewportShadingRateImageStateCreateInfoNV {}
impl Default for PipelineViewportShadingRateImageStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            shading_rate_image_enable: Default::default(),
            viewport_count: Default::default(),
            p_shading_rate_palettes: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineViewportShadingRateImageStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineViewportShadingRateImageStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shading_rate_image_enable", &self.shading_rate_image_enable)
            .field("viewport_count", &self.viewport_count)
            .field("p_shading_rate_palettes", &self.p_shading_rate_palettes)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShadingRateImageFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shading_rate_image: Bool32,
    pub shading_rate_coarse_sample_order: Bool32,
}
unsafe impl Send for PhysicalDeviceShadingRateImageFeaturesNV {}
unsafe impl Sync for PhysicalDeviceShadingRateImageFeaturesNV {}
impl Default for PhysicalDeviceShadingRateImageFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
            p_next: ptr::null_mut(),
            shading_rate_image: Default::default(),
            shading_rate_coarse_sample_order: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShadingRateImageFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShadingRateImageFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shading_rate_image", &self.shading_rate_image)
            .field(
                "shading_rate_coarse_sample_order",
                &self.shading_rate_coarse_sample_order,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShadingRateImagePropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shading_rate_texel_size: Extent2D,
    pub shading_rate_palette_size: u32,
    pub shading_rate_max_coarse_samples: u32,
}
unsafe impl Send for PhysicalDeviceShadingRateImagePropertiesNV {}
unsafe impl Sync for PhysicalDeviceShadingRateImagePropertiesNV {}
impl Default for PhysicalDeviceShadingRateImagePropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            shading_rate_texel_size: Default::default(),
            shading_rate_palette_size: Default::default(),
            shading_rate_max_coarse_samples: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShadingRateImagePropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShadingRateImagePropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shading_rate_texel_size", &self.shading_rate_texel_size)
            .field("shading_rate_palette_size", &self.shading_rate_palette_size)
            .field("shading_rate_max_coarse_samples", &self.shading_rate_max_coarse_samples)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceInvocationMaskFeaturesHUAWEI {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub invocation_mask: Bool32,
}
unsafe impl Send for PhysicalDeviceInvocationMaskFeaturesHUAWEI {}
unsafe impl Sync for PhysicalDeviceInvocationMaskFeaturesHUAWEI {}
impl Default for PhysicalDeviceInvocationMaskFeaturesHUAWEI {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
            p_next: ptr::null_mut(),
            invocation_mask: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceInvocationMaskFeaturesHUAWEI {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceInvocationMaskFeaturesHUAWEI")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("invocation_mask", &self.invocation_mask)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct CoarseSampleLocationNV {
    pub pixel_x: u32,
    pub pixel_y: u32,
    pub sample: u32,
}
impl fmt::Debug for CoarseSampleLocationNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CoarseSampleLocationNV")
            .field("pixel_x", &self.pixel_x)
            .field("pixel_y", &self.pixel_y)
            .field("sample", &self.sample)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoarseSampleOrderCustomNV {
    pub shading_rate: ShadingRatePaletteEntryNV,
    pub sample_count: u32,
    pub sample_location_count: u32,
    pub p_sample_locations: *const CoarseSampleLocationNV,
}
unsafe impl Send for CoarseSampleOrderCustomNV {}
unsafe impl Sync for CoarseSampleOrderCustomNV {}
impl Default for CoarseSampleOrderCustomNV {
    fn default() -> Self {
        Self {
            shading_rate: Default::default(),
            sample_count: Default::default(),
            sample_location_count: Default::default(),
            p_sample_locations: ptr::null(),
        }
    }
}
impl fmt::Debug for CoarseSampleOrderCustomNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CoarseSampleOrderCustomNV")
            .field("shading_rate", &self.shading_rate)
            .field("sample_count", &self.sample_count)
            .field("sample_location_count", &self.sample_location_count)
            .field("p_sample_locations", &self.p_sample_locations)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineViewportCoarseSampleOrderStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sample_order_type: CoarseSampleOrderTypeNV,
    pub custom_sample_order_count: u32,
    pub p_custom_sample_orders: *const CoarseSampleOrderCustomNV,
}
unsafe impl Send for PipelineViewportCoarseSampleOrderStateCreateInfoNV {}
unsafe impl Sync for PipelineViewportCoarseSampleOrderStateCreateInfoNV {}
impl Default for PipelineViewportCoarseSampleOrderStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            sample_order_type: Default::default(),
            custom_sample_order_count: Default::default(),
            p_custom_sample_orders: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineViewportCoarseSampleOrderStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineViewportCoarseSampleOrderStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("sample_order_type", &self.sample_order_type)
            .field("custom_sample_order_count", &self.custom_sample_order_count)
            .field("p_custom_sample_orders", &self.p_custom_sample_orders)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMeshShaderFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub task_shader: Bool32,
    pub mesh_shader: Bool32,
}
unsafe impl Send for PhysicalDeviceMeshShaderFeaturesNV {}
unsafe impl Sync for PhysicalDeviceMeshShaderFeaturesNV {}
impl Default for PhysicalDeviceMeshShaderFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
            p_next: ptr::null_mut(),
            task_shader: Default::default(),
            mesh_shader: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMeshShaderFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMeshShaderFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("task_shader", &self.task_shader)
            .field("mesh_shader", &self.mesh_shader)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMeshShaderPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_draw_mesh_tasks_count: u32,
    pub max_task_work_group_invocations: u32,
    pub max_task_work_group_size: [u32; 3],
    pub max_task_total_memory_size: u32,
    pub max_task_output_count: u32,
    pub max_mesh_work_group_invocations: u32,
    pub max_mesh_work_group_size: [u32; 3],
    pub max_mesh_total_memory_size: u32,
    pub max_mesh_output_vertices: u32,
    pub max_mesh_output_primitives: u32,
    pub max_mesh_multiview_view_count: u32,
    pub mesh_output_per_vertex_granularity: u32,
    pub mesh_output_per_primitive_granularity: u32,
}
unsafe impl Send for PhysicalDeviceMeshShaderPropertiesNV {}
unsafe impl Sync for PhysicalDeviceMeshShaderPropertiesNV {}
impl Default for PhysicalDeviceMeshShaderPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            max_draw_mesh_tasks_count: Default::default(),
            max_task_work_group_invocations: Default::default(),
            max_task_work_group_size: [Default::default(); 3],
            max_task_total_memory_size: Default::default(),
            max_task_output_count: Default::default(),
            max_mesh_work_group_invocations: Default::default(),
            max_mesh_work_group_size: [Default::default(); 3],
            max_mesh_total_memory_size: Default::default(),
            max_mesh_output_vertices: Default::default(),
            max_mesh_output_primitives: Default::default(),
            max_mesh_multiview_view_count: Default::default(),
            mesh_output_per_vertex_granularity: Default::default(),
            mesh_output_per_primitive_granularity: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMeshShaderPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMeshShaderPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_draw_mesh_tasks_count", &self.max_draw_mesh_tasks_count)
            .field("max_task_work_group_invocations", &self.max_task_work_group_invocations)
            .field("max_task_work_group_size", &self.max_task_work_group_size)
            .field("max_task_total_memory_size", &self.max_task_total_memory_size)
            .field("max_task_output_count", &self.max_task_output_count)
            .field("max_mesh_work_group_invocations", &self.max_mesh_work_group_invocations)
            .field("max_mesh_work_group_size", &self.max_mesh_work_group_size)
            .field("max_mesh_total_memory_size", &self.max_mesh_total_memory_size)
            .field("max_mesh_output_vertices", &self.max_mesh_output_vertices)
            .field("max_mesh_output_primitives", &self.max_mesh_output_primitives)
            .field("max_mesh_multiview_view_count", &self.max_mesh_multiview_view_count)
            .field(
                "mesh_output_per_vertex_granularity",
                &self.mesh_output_per_vertex_granularity,
            )
            .field(
                "mesh_output_per_primitive_granularity",
                &self.mesh_output_per_primitive_granularity,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DrawMeshTasksIndirectCommandNV {
    pub task_count: u32,
    pub first_task: u32,
}
impl fmt::Debug for DrawMeshTasksIndirectCommandNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DrawMeshTasksIndirectCommandNV")
            .field("task_count", &self.task_count)
            .field("first_task", &self.first_task)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RayTracingShaderGroupCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: RayTracingShaderGroupTypeKHR,
    pub general_shader: u32,
    pub closest_hit_shader: u32,
    pub any_hit_shader: u32,
    pub intersection_shader: u32,
}
unsafe impl Send for RayTracingShaderGroupCreateInfoNV {}
unsafe impl Sync for RayTracingShaderGroupCreateInfoNV {}
impl Default for RayTracingShaderGroupCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV,
            p_next: ptr::null(),
            ty: Default::default(),
            general_shader: Default::default(),
            closest_hit_shader: Default::default(),
            any_hit_shader: Default::default(),
            intersection_shader: Default::default(),
        }
    }
}
impl fmt::Debug for RayTracingShaderGroupCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RayTracingShaderGroupCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("general_shader", &self.general_shader)
            .field("closest_hit_shader", &self.closest_hit_shader)
            .field("any_hit_shader", &self.any_hit_shader)
            .field("intersection_shader", &self.intersection_shader)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RayTracingShaderGroupCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: RayTracingShaderGroupTypeKHR,
    pub general_shader: u32,
    pub closest_hit_shader: u32,
    pub any_hit_shader: u32,
    pub intersection_shader: u32,
    pub p_shader_group_capture_replay_handle: *const c_void,
}
unsafe impl Send for RayTracingShaderGroupCreateInfoKHR {}
unsafe impl Sync for RayTracingShaderGroupCreateInfoKHR {}
impl Default for RayTracingShaderGroupCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR,
            p_next: ptr::null(),
            ty: Default::default(),
            general_shader: Default::default(),
            closest_hit_shader: Default::default(),
            any_hit_shader: Default::default(),
            intersection_shader: Default::default(),
            p_shader_group_capture_replay_handle: ptr::null(),
        }
    }
}
impl fmt::Debug for RayTracingShaderGroupCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RayTracingShaderGroupCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("general_shader", &self.general_shader)
            .field("closest_hit_shader", &self.closest_hit_shader)
            .field("any_hit_shader", &self.any_hit_shader)
            .field("intersection_shader", &self.intersection_shader)
            .field(
                "p_shader_group_capture_replay_handle",
                &self.p_shader_group_capture_replay_handle,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RayTracingPipelineCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Pipeline creation flags
    pub flags: PipelineCreateFlags,
    pub stage_count: u32,
    /// One entry for each active shader stage
    pub p_stages: *const PipelineShaderStageCreateInfo,
    pub group_count: u32,
    pub p_groups: *const RayTracingShaderGroupCreateInfoNV,
    pub max_recursion_depth: u32,
    /// Interface layout of the pipeline
    pub layout: Option<PipelineLayout>,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    pub base_pipeline_handle: Option<Pipeline>,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    pub base_pipeline_index: i32,
}
unsafe impl Send for RayTracingPipelineCreateInfoNV {}
unsafe impl Sync for RayTracingPipelineCreateInfoNV {}
impl Default for RayTracingPipelineCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::RAY_TRACING_PIPELINE_CREATE_INFO_NV,
            p_next: ptr::null(),
            flags: Default::default(),
            stage_count: Default::default(),
            p_stages: ptr::null(),
            group_count: Default::default(),
            p_groups: ptr::null(),
            max_recursion_depth: Default::default(),
            layout: Default::default(),
            base_pipeline_handle: Default::default(),
            base_pipeline_index: Default::default(),
        }
    }
}
impl fmt::Debug for RayTracingPipelineCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RayTracingPipelineCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("stage_count", &self.stage_count)
            .field("p_stages", &self.p_stages)
            .field("group_count", &self.group_count)
            .field("p_groups", &self.p_groups)
            .field("max_recursion_depth", &self.max_recursion_depth)
            .field("layout", &self.layout)
            .field("base_pipeline_handle", &self.base_pipeline_handle)
            .field("base_pipeline_index", &self.base_pipeline_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RayTracingPipelineCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Pipeline creation flags
    pub flags: PipelineCreateFlags,
    pub stage_count: u32,
    /// One entry for each active shader stage
    pub p_stages: *const PipelineShaderStageCreateInfo,
    pub group_count: u32,
    pub p_groups: *const RayTracingShaderGroupCreateInfoKHR,
    pub max_pipeline_ray_recursion_depth: u32,
    pub p_library_info: *const PipelineLibraryCreateInfoKHR,
    pub p_library_interface: *const RayTracingPipelineInterfaceCreateInfoKHR,
    pub p_dynamic_state: *const PipelineDynamicStateCreateInfo,
    /// Interface layout of the pipeline
    pub layout: Option<PipelineLayout>,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    pub base_pipeline_handle: Option<Pipeline>,
    /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    pub base_pipeline_index: i32,
}
unsafe impl Send for RayTracingPipelineCreateInfoKHR {}
unsafe impl Sync for RayTracingPipelineCreateInfoKHR {}
impl Default for RayTracingPipelineCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            flags: Default::default(),
            stage_count: Default::default(),
            p_stages: ptr::null(),
            group_count: Default::default(),
            p_groups: ptr::null(),
            max_pipeline_ray_recursion_depth: Default::default(),
            p_library_info: ptr::null(),
            p_library_interface: ptr::null(),
            p_dynamic_state: ptr::null(),
            layout: Default::default(),
            base_pipeline_handle: Default::default(),
            base_pipeline_index: Default::default(),
        }
    }
}
impl fmt::Debug for RayTracingPipelineCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RayTracingPipelineCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("stage_count", &self.stage_count)
            .field("p_stages", &self.p_stages)
            .field("group_count", &self.group_count)
            .field("p_groups", &self.p_groups)
            .field(
                "max_pipeline_ray_recursion_depth",
                &self.max_pipeline_ray_recursion_depth,
            )
            .field("p_library_info", &self.p_library_info)
            .field("p_library_interface", &self.p_library_interface)
            .field("p_dynamic_state", &self.p_dynamic_state)
            .field("layout", &self.layout)
            .field("base_pipeline_handle", &self.base_pipeline_handle)
            .field("base_pipeline_index", &self.base_pipeline_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeometryTrianglesNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_data: Option<Buffer>,
    pub vertex_offset: DeviceSize,
    pub vertex_count: u32,
    pub vertex_stride: DeviceSize,
    pub vertex_format: Format,
    pub index_data: Option<Buffer>,
    pub index_offset: DeviceSize,
    pub index_count: u32,
    pub index_type: IndexType,
    /// Optional reference to array of floats representing a 3x4 row major affine transformation matrix.
    pub transform_data: Option<Buffer>,
    pub transform_offset: DeviceSize,
}
unsafe impl Send for GeometryTrianglesNV {}
unsafe impl Sync for GeometryTrianglesNV {}
impl Default for GeometryTrianglesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::GEOMETRY_TRIANGLES_NV,
            p_next: ptr::null(),
            vertex_data: Default::default(),
            vertex_offset: Default::default(),
            vertex_count: Default::default(),
            vertex_stride: Default::default(),
            vertex_format: Default::default(),
            index_data: Default::default(),
            index_offset: Default::default(),
            index_count: Default::default(),
            index_type: Default::default(),
            transform_data: Default::default(),
            transform_offset: Default::default(),
        }
    }
}
impl fmt::Debug for GeometryTrianglesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GeometryTrianglesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vertex_data", &self.vertex_data)
            .field("vertex_offset", &self.vertex_offset)
            .field("vertex_count", &self.vertex_count)
            .field("vertex_stride", &self.vertex_stride)
            .field("vertex_format", &self.vertex_format)
            .field("index_data", &self.index_data)
            .field("index_offset", &self.index_offset)
            .field("index_count", &self.index_count)
            .field("index_type", &self.index_type)
            .field("transform_data", &self.transform_data)
            .field("transform_offset", &self.transform_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeometryAABBNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub aabb_data: Option<Buffer>,
    pub num_aab_bs: u32,
    /// Stride in bytes between AABBs
    pub stride: u32,
    /// Offset in bytes of the first AABB in aabbData
    pub offset: DeviceSize,
}
unsafe impl Send for GeometryAABBNV {}
unsafe impl Sync for GeometryAABBNV {}
impl Default for GeometryAABBNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::GEOMETRY_AABB_NV,
            p_next: ptr::null(),
            aabb_data: Default::default(),
            num_aab_bs: Default::default(),
            stride: Default::default(),
            offset: Default::default(),
        }
    }
}
impl fmt::Debug for GeometryAABBNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GeometryAABBNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("aabb_data", &self.aabb_data)
            .field("num_aab_bs", &self.num_aab_bs)
            .field("stride", &self.stride)
            .field("offset", &self.offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct GeometryDataNV {
    pub triangles: GeometryTrianglesNV,
    pub aabbs: GeometryAABBNV,
}
impl fmt::Debug for GeometryDataNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GeometryDataNV")
            .field("triangles", &self.triangles)
            .field("aabbs", &self.aabbs)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeometryNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub geometry_type: GeometryTypeKHR,
    pub geometry: GeometryDataNV,
    pub flags: GeometryFlagsKHR,
}
unsafe impl Send for GeometryNV {}
unsafe impl Sync for GeometryNV {}
impl Default for GeometryNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::GEOMETRY_NV,
            p_next: ptr::null(),
            geometry_type: Default::default(),
            geometry: Default::default(),
            flags: Default::default(),
        }
    }
}
impl fmt::Debug for GeometryNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GeometryNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("geometry_type", &self.geometry_type)
            .field("geometry", &self.geometry)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: AccelerationStructureTypeNV,
    pub flags: BuildAccelerationStructureFlagsNV,
    pub instance_count: u32,
    pub geometry_count: u32,
    pub p_geometries: *const GeometryNV,
}
unsafe impl Send for AccelerationStructureInfoNV {}
unsafe impl Sync for AccelerationStructureInfoNV {}
impl Default for AccelerationStructureInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_INFO_NV,
            p_next: ptr::null(),
            ty: Default::default(),
            flags: Default::default(),
            instance_count: Default::default(),
            geometry_count: Default::default(),
            p_geometries: ptr::null(),
        }
    }
}
impl fmt::Debug for AccelerationStructureInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("flags", &self.flags)
            .field("instance_count", &self.instance_count)
            .field("geometry_count", &self.geometry_count)
            .field("p_geometries", &self.p_geometries)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub compacted_size: DeviceSize,
    pub info: AccelerationStructureInfoNV,
}
unsafe impl Send for AccelerationStructureCreateInfoNV {}
unsafe impl Sync for AccelerationStructureCreateInfoNV {}
impl Default for AccelerationStructureCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_CREATE_INFO_NV,
            p_next: ptr::null(),
            compacted_size: Default::default(),
            info: Default::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("compacted_size", &self.compacted_size)
            .field("info", &self.info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BindAccelerationStructureMemoryInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure: Option<AccelerationStructureNV>,
    pub memory: Option<DeviceMemory>,
    pub memory_offset: DeviceSize,
    pub device_index_count: u32,
    pub p_device_indices: *const u32,
}
unsafe impl Send for BindAccelerationStructureMemoryInfoNV {}
unsafe impl Sync for BindAccelerationStructureMemoryInfoNV {}
impl Default for BindAccelerationStructureMemoryInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV,
            p_next: ptr::null(),
            acceleration_structure: Default::default(),
            memory: Default::default(),
            memory_offset: Default::default(),
            device_index_count: Default::default(),
            p_device_indices: ptr::null(),
        }
    }
}
impl fmt::Debug for BindAccelerationStructureMemoryInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BindAccelerationStructureMemoryInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acceleration_structure", &self.acceleration_structure)
            .field("memory", &self.memory)
            .field("memory_offset", &self.memory_offset)
            .field("device_index_count", &self.device_index_count)
            .field("p_device_indices", &self.p_device_indices)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WriteDescriptorSetAccelerationStructureKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure_count: u32,
    pub p_acceleration_structures: *const AccelerationStructureKHR,
}
unsafe impl Send for WriteDescriptorSetAccelerationStructureKHR {}
unsafe impl Sync for WriteDescriptorSetAccelerationStructureKHR {}
impl Default for WriteDescriptorSetAccelerationStructureKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
            p_next: ptr::null(),
            acceleration_structure_count: Default::default(),
            p_acceleration_structures: ptr::null(),
        }
    }
}
impl fmt::Debug for WriteDescriptorSetAccelerationStructureKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("WriteDescriptorSetAccelerationStructureKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acceleration_structure_count", &self.acceleration_structure_count)
            .field("p_acceleration_structures", &self.p_acceleration_structures)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WriteDescriptorSetAccelerationStructureNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure_count: u32,
    pub p_acceleration_structures: *const AccelerationStructureNV,
}
unsafe impl Send for WriteDescriptorSetAccelerationStructureNV {}
unsafe impl Sync for WriteDescriptorSetAccelerationStructureNV {}
impl Default for WriteDescriptorSetAccelerationStructureNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
            p_next: ptr::null(),
            acceleration_structure_count: Default::default(),
            p_acceleration_structures: ptr::null(),
        }
    }
}
impl fmt::Debug for WriteDescriptorSetAccelerationStructureNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("WriteDescriptorSetAccelerationStructureNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acceleration_structure_count", &self.acceleration_structure_count)
            .field("p_acceleration_structures", &self.p_acceleration_structures)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureMemoryRequirementsInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: AccelerationStructureMemoryRequirementsTypeNV,
    pub acceleration_structure: Option<AccelerationStructureNV>,
}
unsafe impl Send for AccelerationStructureMemoryRequirementsInfoNV {}
unsafe impl Sync for AccelerationStructureMemoryRequirementsInfoNV {}
impl Default for AccelerationStructureMemoryRequirementsInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV,
            p_next: ptr::null(),
            ty: Default::default(),
            acceleration_structure: Default::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureMemoryRequirementsInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureMemoryRequirementsInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("acceleration_structure", &self.acceleration_structure)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceAccelerationStructureFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub acceleration_structure: Bool32,
    pub acceleration_structure_capture_replay: Bool32,
    pub acceleration_structure_indirect_build: Bool32,
    pub acceleration_structure_host_commands: Bool32,
    pub descriptor_binding_acceleration_structure_update_after_bind: Bool32,
}
unsafe impl Send for PhysicalDeviceAccelerationStructureFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceAccelerationStructureFeaturesKHR {}
impl Default for PhysicalDeviceAccelerationStructureFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
            p_next: ptr::null_mut(),
            acceleration_structure: Default::default(),
            acceleration_structure_capture_replay: Default::default(),
            acceleration_structure_indirect_build: Default::default(),
            acceleration_structure_host_commands: Default::default(),
            descriptor_binding_acceleration_structure_update_after_bind: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceAccelerationStructureFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceAccelerationStructureFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acceleration_structure", &self.acceleration_structure)
            .field(
                "acceleration_structure_capture_replay",
                &self.acceleration_structure_capture_replay,
            )
            .field(
                "acceleration_structure_indirect_build",
                &self.acceleration_structure_indirect_build,
            )
            .field(
                "acceleration_structure_host_commands",
                &self.acceleration_structure_host_commands,
            )
            .field(
                "descriptor_binding_acceleration_structure_update_after_bind",
                &self.descriptor_binding_acceleration_structure_update_after_bind,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRayTracingPipelineFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_tracing_pipeline: Bool32,
    pub ray_tracing_pipeline_shader_group_handle_capture_replay: Bool32,
    pub ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: Bool32,
    pub ray_tracing_pipeline_trace_rays_indirect: Bool32,
    pub ray_traversal_primitive_culling: Bool32,
}
unsafe impl Send for PhysicalDeviceRayTracingPipelineFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceRayTracingPipelineFeaturesKHR {}
impl Default for PhysicalDeviceRayTracingPipelineFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
            p_next: ptr::null_mut(),
            ray_tracing_pipeline: Default::default(),
            ray_tracing_pipeline_shader_group_handle_capture_replay: Default::default(),
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: Default::default(),
            ray_tracing_pipeline_trace_rays_indirect: Default::default(),
            ray_traversal_primitive_culling: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRayTracingPipelineFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRayTracingPipelineFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ray_tracing_pipeline", &self.ray_tracing_pipeline)
            .field(
                "ray_tracing_pipeline_shader_group_handle_capture_replay",
                &self.ray_tracing_pipeline_shader_group_handle_capture_replay,
            )
            .field(
                "ray_tracing_pipeline_shader_group_handle_capture_replay_mixed",
                &self.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed,
            )
            .field(
                "ray_tracing_pipeline_trace_rays_indirect",
                &self.ray_tracing_pipeline_trace_rays_indirect,
            )
            .field("ray_traversal_primitive_culling", &self.ray_traversal_primitive_culling)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRayQueryFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_query: Bool32,
}
unsafe impl Send for PhysicalDeviceRayQueryFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceRayQueryFeaturesKHR {}
impl Default for PhysicalDeviceRayQueryFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
            p_next: ptr::null_mut(),
            ray_query: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRayQueryFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRayQueryFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ray_query", &self.ray_query)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceAccelerationStructurePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_geometry_count: u64,
    pub max_instance_count: u64,
    pub max_primitive_count: u64,
    pub max_per_stage_descriptor_acceleration_structures: u32,
    pub max_per_stage_descriptor_update_after_bind_acceleration_structures: u32,
    pub max_descriptor_set_acceleration_structures: u32,
    pub max_descriptor_set_update_after_bind_acceleration_structures: u32,
    pub min_acceleration_structure_scratch_offset_alignment: u32,
}
unsafe impl Send for PhysicalDeviceAccelerationStructurePropertiesKHR {}
unsafe impl Sync for PhysicalDeviceAccelerationStructurePropertiesKHR {}
impl Default for PhysicalDeviceAccelerationStructurePropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            max_geometry_count: Default::default(),
            max_instance_count: Default::default(),
            max_primitive_count: Default::default(),
            max_per_stage_descriptor_acceleration_structures: Default::default(),
            max_per_stage_descriptor_update_after_bind_acceleration_structures: Default::default(),
            max_descriptor_set_acceleration_structures: Default::default(),
            max_descriptor_set_update_after_bind_acceleration_structures: Default::default(),
            min_acceleration_structure_scratch_offset_alignment: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceAccelerationStructurePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceAccelerationStructurePropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_geometry_count", &self.max_geometry_count)
            .field("max_instance_count", &self.max_instance_count)
            .field("max_primitive_count", &self.max_primitive_count)
            .field(
                "max_per_stage_descriptor_acceleration_structures",
                &self.max_per_stage_descriptor_acceleration_structures,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_acceleration_structures",
                &self.max_per_stage_descriptor_update_after_bind_acceleration_structures,
            )
            .field(
                "max_descriptor_set_acceleration_structures",
                &self.max_descriptor_set_acceleration_structures,
            )
            .field(
                "max_descriptor_set_update_after_bind_acceleration_structures",
                &self.max_descriptor_set_update_after_bind_acceleration_structures,
            )
            .field(
                "min_acceleration_structure_scratch_offset_alignment",
                &self.min_acceleration_structure_scratch_offset_alignment,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRayTracingPipelinePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_group_handle_size: u32,
    pub max_ray_recursion_depth: u32,
    pub max_shader_group_stride: u32,
    pub shader_group_base_alignment: u32,
    pub shader_group_handle_capture_replay_size: u32,
    pub max_ray_dispatch_invocation_count: u32,
    pub shader_group_handle_alignment: u32,
    pub max_ray_hit_attribute_size: u32,
}
unsafe impl Send for PhysicalDeviceRayTracingPipelinePropertiesKHR {}
unsafe impl Sync for PhysicalDeviceRayTracingPipelinePropertiesKHR {}
impl Default for PhysicalDeviceRayTracingPipelinePropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            shader_group_handle_size: Default::default(),
            max_ray_recursion_depth: Default::default(),
            max_shader_group_stride: Default::default(),
            shader_group_base_alignment: Default::default(),
            shader_group_handle_capture_replay_size: Default::default(),
            max_ray_dispatch_invocation_count: Default::default(),
            shader_group_handle_alignment: Default::default(),
            max_ray_hit_attribute_size: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRayTracingPipelinePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRayTracingPipelinePropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_group_handle_size", &self.shader_group_handle_size)
            .field("max_ray_recursion_depth", &self.max_ray_recursion_depth)
            .field("max_shader_group_stride", &self.max_shader_group_stride)
            .field("shader_group_base_alignment", &self.shader_group_base_alignment)
            .field(
                "shader_group_handle_capture_replay_size",
                &self.shader_group_handle_capture_replay_size,
            )
            .field(
                "max_ray_dispatch_invocation_count",
                &self.max_ray_dispatch_invocation_count,
            )
            .field("shader_group_handle_alignment", &self.shader_group_handle_alignment)
            .field("max_ray_hit_attribute_size", &self.max_ray_hit_attribute_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRayTracingPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_group_handle_size: u32,
    pub max_recursion_depth: u32,
    pub max_shader_group_stride: u32,
    pub shader_group_base_alignment: u32,
    pub max_geometry_count: u64,
    pub max_instance_count: u64,
    pub max_triangle_count: u64,
    pub max_descriptor_set_acceleration_structures: u32,
}
unsafe impl Send for PhysicalDeviceRayTracingPropertiesNV {}
unsafe impl Sync for PhysicalDeviceRayTracingPropertiesNV {}
impl Default for PhysicalDeviceRayTracingPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            shader_group_handle_size: Default::default(),
            max_recursion_depth: Default::default(),
            max_shader_group_stride: Default::default(),
            shader_group_base_alignment: Default::default(),
            max_geometry_count: Default::default(),
            max_instance_count: Default::default(),
            max_triangle_count: Default::default(),
            max_descriptor_set_acceleration_structures: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRayTracingPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRayTracingPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_group_handle_size", &self.shader_group_handle_size)
            .field("max_recursion_depth", &self.max_recursion_depth)
            .field("max_shader_group_stride", &self.max_shader_group_stride)
            .field("shader_group_base_alignment", &self.shader_group_base_alignment)
            .field("max_geometry_count", &self.max_geometry_count)
            .field("max_instance_count", &self.max_instance_count)
            .field("max_triangle_count", &self.max_triangle_count)
            .field(
                "max_descriptor_set_acceleration_structures",
                &self.max_descriptor_set_acceleration_structures,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct StridedDeviceAddressRegionKHR {
    pub device_address: DeviceAddress,
    pub stride: DeviceSize,
    pub size: DeviceSize,
}
impl fmt::Debug for StridedDeviceAddressRegionKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("StridedDeviceAddressRegionKHR")
            .field("device_address", &self.device_address)
            .field("stride", &self.stride)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct TraceRaysIndirectCommandKHR {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
impl fmt::Debug for TraceRaysIndirectCommandKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("TraceRaysIndirectCommandKHR")
            .field("width", &self.width)
            .field("height", &self.height)
            .field("depth", &self.depth)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct TraceRaysIndirectCommand2KHR {
    pub raygen_shader_record_address: DeviceAddress,
    pub raygen_shader_record_size: DeviceSize,
    pub miss_shader_binding_table_address: DeviceAddress,
    pub miss_shader_binding_table_size: DeviceSize,
    pub miss_shader_binding_table_stride: DeviceSize,
    pub hit_shader_binding_table_address: DeviceAddress,
    pub hit_shader_binding_table_size: DeviceSize,
    pub hit_shader_binding_table_stride: DeviceSize,
    pub callable_shader_binding_table_address: DeviceAddress,
    pub callable_shader_binding_table_size: DeviceSize,
    pub callable_shader_binding_table_stride: DeviceSize,
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
impl fmt::Debug for TraceRaysIndirectCommand2KHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("TraceRaysIndirectCommand2KHR")
            .field("raygen_shader_record_address", &self.raygen_shader_record_address)
            .field("raygen_shader_record_size", &self.raygen_shader_record_size)
            .field(
                "miss_shader_binding_table_address",
                &self.miss_shader_binding_table_address,
            )
            .field("miss_shader_binding_table_size", &self.miss_shader_binding_table_size)
            .field(
                "miss_shader_binding_table_stride",
                &self.miss_shader_binding_table_stride,
            )
            .field(
                "hit_shader_binding_table_address",
                &self.hit_shader_binding_table_address,
            )
            .field("hit_shader_binding_table_size", &self.hit_shader_binding_table_size)
            .field("hit_shader_binding_table_stride", &self.hit_shader_binding_table_stride)
            .field(
                "callable_shader_binding_table_address",
                &self.callable_shader_binding_table_address,
            )
            .field(
                "callable_shader_binding_table_size",
                &self.callable_shader_binding_table_size,
            )
            .field(
                "callable_shader_binding_table_stride",
                &self.callable_shader_binding_table_stride,
            )
            .field("width", &self.width)
            .field("height", &self.height)
            .field("depth", &self.depth)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRayTracingMaintenance1FeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_tracing_maintenance1: Bool32,
    pub ray_tracing_pipeline_trace_rays_indirect2: Bool32,
}
unsafe impl Send for PhysicalDeviceRayTracingMaintenance1FeaturesKHR {}
unsafe impl Sync for PhysicalDeviceRayTracingMaintenance1FeaturesKHR {}
impl Default for PhysicalDeviceRayTracingMaintenance1FeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR,
            p_next: ptr::null_mut(),
            ray_tracing_maintenance1: Default::default(),
            ray_tracing_pipeline_trace_rays_indirect2: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRayTracingMaintenance1FeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRayTracingMaintenance1FeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ray_tracing_maintenance1", &self.ray_tracing_maintenance1)
            .field(
                "ray_tracing_pipeline_trace_rays_indirect2",
                &self.ray_tracing_pipeline_trace_rays_indirect2,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DrmFormatModifierPropertiesListEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub drm_format_modifier_count: u32,
    pub p_drm_format_modifier_properties: *mut DrmFormatModifierPropertiesEXT,
}
unsafe impl Send for DrmFormatModifierPropertiesListEXT {}
unsafe impl Sync for DrmFormatModifierPropertiesListEXT {}
impl Default for DrmFormatModifierPropertiesListEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
            p_next: ptr::null_mut(),
            drm_format_modifier_count: Default::default(),
            p_drm_format_modifier_properties: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for DrmFormatModifierPropertiesListEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DrmFormatModifierPropertiesListEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("drm_format_modifier_count", &self.drm_format_modifier_count)
            .field(
                "p_drm_format_modifier_properties",
                &self.p_drm_format_modifier_properties,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DrmFormatModifierPropertiesEXT {
    pub drm_format_modifier: u64,
    pub drm_format_modifier_plane_count: u32,
    pub drm_format_modifier_tiling_features: FormatFeatureFlags,
}
impl fmt::Debug for DrmFormatModifierPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DrmFormatModifierPropertiesEXT")
            .field("drm_format_modifier", &self.drm_format_modifier)
            .field("drm_format_modifier_plane_count", &self.drm_format_modifier_plane_count)
            .field(
                "drm_format_modifier_tiling_features",
                &self.drm_format_modifier_tiling_features,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImageDrmFormatModifierInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub drm_format_modifier: u64,
    pub sharing_mode: SharingMode,
    pub queue_family_index_count: u32,
    pub p_queue_family_indices: *const u32,
}
unsafe impl Send for PhysicalDeviceImageDrmFormatModifierInfoEXT {}
unsafe impl Sync for PhysicalDeviceImageDrmFormatModifierInfoEXT {}
impl Default for PhysicalDeviceImageDrmFormatModifierInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
            p_next: ptr::null(),
            drm_format_modifier: Default::default(),
            sharing_mode: Default::default(),
            queue_family_index_count: Default::default(),
            p_queue_family_indices: ptr::null(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImageDrmFormatModifierInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImageDrmFormatModifierInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("drm_format_modifier", &self.drm_format_modifier)
            .field("sharing_mode", &self.sharing_mode)
            .field("queue_family_index_count", &self.queue_family_index_count)
            .field("p_queue_family_indices", &self.p_queue_family_indices)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageDrmFormatModifierListCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub drm_format_modifier_count: u32,
    pub p_drm_format_modifiers: *const u64,
}
unsafe impl Send for ImageDrmFormatModifierListCreateInfoEXT {}
unsafe impl Sync for ImageDrmFormatModifierListCreateInfoEXT {}
impl Default for ImageDrmFormatModifierListCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
            p_next: ptr::null(),
            drm_format_modifier_count: Default::default(),
            p_drm_format_modifiers: ptr::null(),
        }
    }
}
impl fmt::Debug for ImageDrmFormatModifierListCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageDrmFormatModifierListCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("drm_format_modifier_count", &self.drm_format_modifier_count)
            .field("p_drm_format_modifiers", &self.p_drm_format_modifiers)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageDrmFormatModifierExplicitCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub drm_format_modifier: u64,
    pub drm_format_modifier_plane_count: u32,
    pub p_plane_layouts: *const SubresourceLayout,
}
unsafe impl Send for ImageDrmFormatModifierExplicitCreateInfoEXT {}
unsafe impl Sync for ImageDrmFormatModifierExplicitCreateInfoEXT {}
impl Default for ImageDrmFormatModifierExplicitCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
            p_next: ptr::null(),
            drm_format_modifier: Default::default(),
            drm_format_modifier_plane_count: Default::default(),
            p_plane_layouts: ptr::null(),
        }
    }
}
impl fmt::Debug for ImageDrmFormatModifierExplicitCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageDrmFormatModifierExplicitCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("drm_format_modifier", &self.drm_format_modifier)
            .field("drm_format_modifier_plane_count", &self.drm_format_modifier_plane_count)
            .field("p_plane_layouts", &self.p_plane_layouts)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageDrmFormatModifierPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub drm_format_modifier: u64,
}
unsafe impl Send for ImageDrmFormatModifierPropertiesEXT {}
unsafe impl Sync for ImageDrmFormatModifierPropertiesEXT {}
impl Default for ImageDrmFormatModifierPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            drm_format_modifier: Default::default(),
        }
    }
}
impl fmt::Debug for ImageDrmFormatModifierPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageDrmFormatModifierPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("drm_format_modifier", &self.drm_format_modifier)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageStencilUsageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub stencil_usage: ImageUsageFlags,
}
unsafe impl Send for ImageStencilUsageCreateInfo {}
unsafe impl Sync for ImageStencilUsageCreateInfo {}
impl Default for ImageStencilUsageCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_STENCIL_USAGE_CREATE_INFO,
            p_next: ptr::null(),
            stencil_usage: Default::default(),
        }
    }
}
impl fmt::Debug for ImageStencilUsageCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageStencilUsageCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stencil_usage", &self.stencil_usage)
            .finish()
    }
}
pub type ImageStencilUsageCreateInfoEXT = ImageStencilUsageCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceMemoryOverallocationCreateInfoAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub overallocation_behavior: MemoryOverallocationBehaviorAMD,
}
unsafe impl Send for DeviceMemoryOverallocationCreateInfoAMD {}
unsafe impl Sync for DeviceMemoryOverallocationCreateInfoAMD {}
impl Default for DeviceMemoryOverallocationCreateInfoAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
            p_next: ptr::null(),
            overallocation_behavior: Default::default(),
        }
    }
}
impl fmt::Debug for DeviceMemoryOverallocationCreateInfoAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceMemoryOverallocationCreateInfoAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("overallocation_behavior", &self.overallocation_behavior)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentDensityMapFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_density_map: Bool32,
    pub fragment_density_map_dynamic: Bool32,
    pub fragment_density_map_non_subsampled_images: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentDensityMapFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceFragmentDensityMapFeaturesEXT {}
impl Default for PhysicalDeviceFragmentDensityMapFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
            p_next: ptr::null_mut(),
            fragment_density_map: Default::default(),
            fragment_density_map_dynamic: Default::default(),
            fragment_density_map_non_subsampled_images: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentDensityMapFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentDensityMapFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fragment_density_map", &self.fragment_density_map)
            .field("fragment_density_map_dynamic", &self.fragment_density_map_dynamic)
            .field(
                "fragment_density_map_non_subsampled_images",
                &self.fragment_density_map_non_subsampled_images,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentDensityMap2FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_density_map_deferred: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentDensityMap2FeaturesEXT {}
unsafe impl Sync for PhysicalDeviceFragmentDensityMap2FeaturesEXT {}
impl Default for PhysicalDeviceFragmentDensityMap2FeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
            p_next: ptr::null_mut(),
            fragment_density_map_deferred: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentDensityMap2FeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentDensityMap2FeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fragment_density_map_deferred", &self.fragment_density_map_deferred)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_density_map_offset: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {}
unsafe impl Sync for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {}
impl Default for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM,
            p_next: ptr::null_mut(),
            fragment_density_map_offset: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fragment_density_map_offset", &self.fragment_density_map_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentDensityMapPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_fragment_density_texel_size: Extent2D,
    pub max_fragment_density_texel_size: Extent2D,
    pub fragment_density_invocations: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentDensityMapPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceFragmentDensityMapPropertiesEXT {}
impl Default for PhysicalDeviceFragmentDensityMapPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            min_fragment_density_texel_size: Default::default(),
            max_fragment_density_texel_size: Default::default(),
            fragment_density_invocations: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentDensityMapPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentDensityMapPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_fragment_density_texel_size", &self.min_fragment_density_texel_size)
            .field("max_fragment_density_texel_size", &self.max_fragment_density_texel_size)
            .field("fragment_density_invocations", &self.fragment_density_invocations)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentDensityMap2PropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subsampled_loads: Bool32,
    pub subsampled_coarse_reconstruction_early_access: Bool32,
    pub max_subsampled_array_layers: u32,
    pub max_descriptor_set_subsampled_samplers: u32,
}
unsafe impl Send for PhysicalDeviceFragmentDensityMap2PropertiesEXT {}
unsafe impl Sync for PhysicalDeviceFragmentDensityMap2PropertiesEXT {}
impl Default for PhysicalDeviceFragmentDensityMap2PropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            subsampled_loads: Default::default(),
            subsampled_coarse_reconstruction_early_access: Default::default(),
            max_subsampled_array_layers: Default::default(),
            max_descriptor_set_subsampled_samplers: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentDensityMap2PropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentDensityMap2PropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("subsampled_loads", &self.subsampled_loads)
            .field(
                "subsampled_coarse_reconstruction_early_access",
                &self.subsampled_coarse_reconstruction_early_access,
            )
            .field("max_subsampled_array_layers", &self.max_subsampled_array_layers)
            .field(
                "max_descriptor_set_subsampled_samplers",
                &self.max_descriptor_set_subsampled_samplers,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_density_offset_granularity: Extent2D,
}
unsafe impl Send for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {}
unsafe impl Sync for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {}
impl Default for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM,
            p_next: ptr::null_mut(),
            fragment_density_offset_granularity: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "fragment_density_offset_granularity",
                &self.fragment_density_offset_granularity,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassFragmentDensityMapCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fragment_density_map_attachment: AttachmentReference,
}
unsafe impl Send for RenderPassFragmentDensityMapCreateInfoEXT {}
unsafe impl Sync for RenderPassFragmentDensityMapCreateInfoEXT {}
impl Default for RenderPassFragmentDensityMapCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
            p_next: ptr::null(),
            fragment_density_map_attachment: Default::default(),
        }
    }
}
impl fmt::Debug for RenderPassFragmentDensityMapCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassFragmentDensityMapCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fragment_density_map_attachment", &self.fragment_density_map_attachment)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassFragmentDensityMapOffsetEndInfoQCOM {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fragment_density_offset_count: u32,
    pub p_fragment_density_offsets: *const Offset2D,
}
unsafe impl Send for SubpassFragmentDensityMapOffsetEndInfoQCOM {}
unsafe impl Sync for SubpassFragmentDensityMapOffsetEndInfoQCOM {}
impl Default for SubpassFragmentDensityMapOffsetEndInfoQCOM {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM,
            p_next: ptr::null(),
            fragment_density_offset_count: Default::default(),
            p_fragment_density_offsets: ptr::null(),
        }
    }
}
impl fmt::Debug for SubpassFragmentDensityMapOffsetEndInfoQCOM {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassFragmentDensityMapOffsetEndInfoQCOM")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fragment_density_offset_count", &self.fragment_density_offset_count)
            .field("p_fragment_density_offsets", &self.p_fragment_density_offsets)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceScalarBlockLayoutFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub scalar_block_layout: Bool32,
}
unsafe impl Send for PhysicalDeviceScalarBlockLayoutFeatures {}
unsafe impl Sync for PhysicalDeviceScalarBlockLayoutFeatures {}
impl Default for PhysicalDeviceScalarBlockLayoutFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
            p_next: ptr::null_mut(),
            scalar_block_layout: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceScalarBlockLayoutFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceScalarBlockLayoutFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("scalar_block_layout", &self.scalar_block_layout)
            .finish()
    }
}
pub type PhysicalDeviceScalarBlockLayoutFeaturesEXT = PhysicalDeviceScalarBlockLayoutFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SurfaceProtectedCapabilitiesKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Represents if surface can be protected
    pub supports_protected: Bool32,
}
unsafe impl Send for SurfaceProtectedCapabilitiesKHR {}
unsafe impl Sync for SurfaceProtectedCapabilitiesKHR {}
impl Default for SurfaceProtectedCapabilitiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::SURFACE_PROTECTED_CAPABILITIES_KHR,
            p_next: ptr::null(),
            supports_protected: Default::default(),
        }
    }
}
impl fmt::Debug for SurfaceProtectedCapabilitiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceProtectedCapabilitiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("supports_protected", &self.supports_protected)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceUniformBufferStandardLayoutFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub uniform_buffer_standard_layout: Bool32,
}
unsafe impl Send for PhysicalDeviceUniformBufferStandardLayoutFeatures {}
unsafe impl Sync for PhysicalDeviceUniformBufferStandardLayoutFeatures {}
impl Default for PhysicalDeviceUniformBufferStandardLayoutFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
            p_next: ptr::null_mut(),
            uniform_buffer_standard_layout: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceUniformBufferStandardLayoutFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceUniformBufferStandardLayoutFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("uniform_buffer_standard_layout", &self.uniform_buffer_standard_layout)
            .finish()
    }
}
pub type PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = PhysicalDeviceUniformBufferStandardLayoutFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDepthClipEnableFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub depth_clip_enable: Bool32,
}
unsafe impl Send for PhysicalDeviceDepthClipEnableFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceDepthClipEnableFeaturesEXT {}
impl Default for PhysicalDeviceDepthClipEnableFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
            p_next: ptr::null_mut(),
            depth_clip_enable: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDepthClipEnableFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDepthClipEnableFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("depth_clip_enable", &self.depth_clip_enable)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRasterizationDepthClipStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Reserved
    pub flags: PipelineRasterizationDepthClipStateCreateFlagsEXT,
    pub depth_clip_enable: Bool32,
}
unsafe impl Send for PipelineRasterizationDepthClipStateCreateInfoEXT {}
unsafe impl Sync for PipelineRasterizationDepthClipStateCreateInfoEXT {}
impl Default for PipelineRasterizationDepthClipStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: Default::default(),
            depth_clip_enable: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineRasterizationDepthClipStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRasterizationDepthClipStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("depth_clip_enable", &self.depth_clip_enable)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMemoryBudgetPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub heap_budget: [DeviceSize; MAX_MEMORY_HEAPS],
    pub heap_usage: [DeviceSize; MAX_MEMORY_HEAPS],
}
unsafe impl Send for PhysicalDeviceMemoryBudgetPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceMemoryBudgetPropertiesEXT {}
impl Default for PhysicalDeviceMemoryBudgetPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            heap_budget: [Default::default(); MAX_MEMORY_HEAPS],
            heap_usage: [Default::default(); MAX_MEMORY_HEAPS],
        }
    }
}
impl fmt::Debug for PhysicalDeviceMemoryBudgetPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMemoryBudgetPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("heap_budget", &self.heap_budget)
            .field("heap_usage", &self.heap_usage)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMemoryPriorityFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_priority: Bool32,
}
unsafe impl Send for PhysicalDeviceMemoryPriorityFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceMemoryPriorityFeaturesEXT {}
impl Default for PhysicalDeviceMemoryPriorityFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
            p_next: ptr::null_mut(),
            memory_priority: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMemoryPriorityFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMemoryPriorityFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_priority", &self.memory_priority)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryPriorityAllocateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub priority: f32,
}
unsafe impl Send for MemoryPriorityAllocateInfoEXT {}
unsafe impl Sync for MemoryPriorityAllocateInfoEXT {}
impl Default for MemoryPriorityAllocateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
            p_next: ptr::null(),
            priority: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryPriorityAllocateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryPriorityAllocateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("priority", &self.priority)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pageable_device_local_memory: Bool32,
}
unsafe impl Send for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {}
unsafe impl Sync for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {}
impl Default for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT,
            p_next: ptr::null_mut(),
            pageable_device_local_memory: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pageable_device_local_memory", &self.pageable_device_local_memory)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceBufferDeviceAddressFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
}
unsafe impl Send for PhysicalDeviceBufferDeviceAddressFeatures {}
unsafe impl Sync for PhysicalDeviceBufferDeviceAddressFeatures {}
impl Default for PhysicalDeviceBufferDeviceAddressFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
            p_next: ptr::null_mut(),
            buffer_device_address: Default::default(),
            buffer_device_address_capture_replay: Default::default(),
            buffer_device_address_multi_device: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceBufferDeviceAddressFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceBufferDeviceAddressFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer_device_address", &self.buffer_device_address)
            .field(
                "buffer_device_address_capture_replay",
                &self.buffer_device_address_capture_replay,
            )
            .field(
                "buffer_device_address_multi_device",
                &self.buffer_device_address_multi_device,
            )
            .finish()
    }
}
pub type PhysicalDeviceBufferDeviceAddressFeaturesKHR = PhysicalDeviceBufferDeviceAddressFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceBufferDeviceAddressFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
}
unsafe impl Send for PhysicalDeviceBufferDeviceAddressFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceBufferDeviceAddressFeaturesEXT {}
impl Default for PhysicalDeviceBufferDeviceAddressFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
            p_next: ptr::null_mut(),
            buffer_device_address: Default::default(),
            buffer_device_address_capture_replay: Default::default(),
            buffer_device_address_multi_device: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceBufferDeviceAddressFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceBufferDeviceAddressFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer_device_address", &self.buffer_device_address)
            .field(
                "buffer_device_address_capture_replay",
                &self.buffer_device_address_capture_replay,
            )
            .field(
                "buffer_device_address_multi_device",
                &self.buffer_device_address_multi_device,
            )
            .finish()
    }
}
pub type PhysicalDeviceBufferAddressFeaturesEXT = PhysicalDeviceBufferDeviceAddressFeaturesEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferDeviceAddressInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Option<Buffer>,
}
unsafe impl Send for BufferDeviceAddressInfo {}
unsafe impl Sync for BufferDeviceAddressInfo {}
impl Default for BufferDeviceAddressInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_DEVICE_ADDRESS_INFO,
            p_next: ptr::null(),
            buffer: Default::default(),
        }
    }
}
impl fmt::Debug for BufferDeviceAddressInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferDeviceAddressInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer", &self.buffer)
            .finish()
    }
}
pub type BufferDeviceAddressInfoKHR = BufferDeviceAddressInfo;
pub type BufferDeviceAddressInfoEXT = BufferDeviceAddressInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferOpaqueCaptureAddressCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub opaque_capture_address: u64,
}
unsafe impl Send for BufferOpaqueCaptureAddressCreateInfo {}
unsafe impl Sync for BufferOpaqueCaptureAddressCreateInfo {}
impl Default for BufferOpaqueCaptureAddressCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
            p_next: ptr::null(),
            opaque_capture_address: Default::default(),
        }
    }
}
impl fmt::Debug for BufferOpaqueCaptureAddressCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferOpaqueCaptureAddressCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("opaque_capture_address", &self.opaque_capture_address)
            .finish()
    }
}
pub type BufferOpaqueCaptureAddressCreateInfoKHR = BufferOpaqueCaptureAddressCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferDeviceAddressCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_address: DeviceAddress,
}
unsafe impl Send for BufferDeviceAddressCreateInfoEXT {}
unsafe impl Sync for BufferDeviceAddressCreateInfoEXT {}
impl Default for BufferDeviceAddressCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
            p_next: ptr::null(),
            device_address: Default::default(),
        }
    }
}
impl fmt::Debug for BufferDeviceAddressCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferDeviceAddressCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_address", &self.device_address)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImageViewImageFormatInfoEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_view_type: ImageViewType,
}
unsafe impl Send for PhysicalDeviceImageViewImageFormatInfoEXT {}
unsafe impl Sync for PhysicalDeviceImageViewImageFormatInfoEXT {}
impl Default for PhysicalDeviceImageViewImageFormatInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
            p_next: ptr::null_mut(),
            image_view_type: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImageViewImageFormatInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImageViewImageFormatInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_view_type", &self.image_view_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FilterCubicImageViewImageFormatPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// The combinations of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT
    pub filter_cubic: Bool32,
    /// The combination of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT and ReductionMode of Min or Max
    pub filter_cubic_minmax: Bool32,
}
unsafe impl Send for FilterCubicImageViewImageFormatPropertiesEXT {}
unsafe impl Sync for FilterCubicImageViewImageFormatPropertiesEXT {}
impl Default for FilterCubicImageViewImageFormatPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            filter_cubic: Default::default(),
            filter_cubic_minmax: Default::default(),
        }
    }
}
impl fmt::Debug for FilterCubicImageViewImageFormatPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FilterCubicImageViewImageFormatPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("filter_cubic", &self.filter_cubic)
            .field("filter_cubic_minmax", &self.filter_cubic_minmax)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImagelessFramebufferFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub imageless_framebuffer: Bool32,
}
unsafe impl Send for PhysicalDeviceImagelessFramebufferFeatures {}
unsafe impl Sync for PhysicalDeviceImagelessFramebufferFeatures {}
impl Default for PhysicalDeviceImagelessFramebufferFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
            p_next: ptr::null_mut(),
            imageless_framebuffer: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImagelessFramebufferFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImagelessFramebufferFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("imageless_framebuffer", &self.imageless_framebuffer)
            .finish()
    }
}
pub type PhysicalDeviceImagelessFramebufferFeaturesKHR = PhysicalDeviceImagelessFramebufferFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FramebufferAttachmentsCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment_image_info_count: u32,
    pub p_attachment_image_infos: *const FramebufferAttachmentImageInfo,
}
unsafe impl Send for FramebufferAttachmentsCreateInfo {}
unsafe impl Sync for FramebufferAttachmentsCreateInfo {}
impl Default for FramebufferAttachmentsCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
            p_next: ptr::null(),
            attachment_image_info_count: Default::default(),
            p_attachment_image_infos: ptr::null(),
        }
    }
}
impl fmt::Debug for FramebufferAttachmentsCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FramebufferAttachmentsCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("attachment_image_info_count", &self.attachment_image_info_count)
            .field("p_attachment_image_infos", &self.p_attachment_image_infos)
            .finish()
    }
}
pub type FramebufferAttachmentsCreateInfoKHR = FramebufferAttachmentsCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FramebufferAttachmentImageInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Image creation flags
    pub flags: ImageCreateFlags,
    /// Image usage flags
    pub usage: ImageUsageFlags,
    pub width: u32,
    pub height: u32,
    pub layer_count: u32,
    pub view_format_count: u32,
    pub p_view_formats: *const Format,
}
unsafe impl Send for FramebufferAttachmentImageInfo {}
unsafe impl Sync for FramebufferAttachmentImageInfo {}
impl Default for FramebufferAttachmentImageInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            usage: Default::default(),
            width: Default::default(),
            height: Default::default(),
            layer_count: Default::default(),
            view_format_count: Default::default(),
            p_view_formats: ptr::null(),
        }
    }
}
impl fmt::Debug for FramebufferAttachmentImageInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FramebufferAttachmentImageInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("usage", &self.usage)
            .field("width", &self.width)
            .field("height", &self.height)
            .field("layer_count", &self.layer_count)
            .field("view_format_count", &self.view_format_count)
            .field("p_view_formats", &self.p_view_formats)
            .finish()
    }
}
pub type FramebufferAttachmentImageInfoKHR = FramebufferAttachmentImageInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassAttachmentBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment_count: u32,
    pub p_attachments: *const ImageView,
}
unsafe impl Send for RenderPassAttachmentBeginInfo {}
unsafe impl Sync for RenderPassAttachmentBeginInfo {}
impl Default for RenderPassAttachmentBeginInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_ATTACHMENT_BEGIN_INFO,
            p_next: ptr::null(),
            attachment_count: Default::default(),
            p_attachments: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderPassAttachmentBeginInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassAttachmentBeginInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("attachment_count", &self.attachment_count)
            .field("p_attachments", &self.p_attachments)
            .finish()
    }
}
pub type RenderPassAttachmentBeginInfoKHR = RenderPassAttachmentBeginInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceTextureCompressionASTCHDRFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub texture_compression_astc_hdr: Bool32,
}
unsafe impl Send for PhysicalDeviceTextureCompressionASTCHDRFeatures {}
unsafe impl Sync for PhysicalDeviceTextureCompressionASTCHDRFeatures {}
impl Default for PhysicalDeviceTextureCompressionASTCHDRFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
            p_next: ptr::null_mut(),
            texture_compression_astc_hdr: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceTextureCompressionASTCHDRFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceTextureCompressionASTCHDRFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("texture_compression_astc_hdr", &self.texture_compression_astc_hdr)
            .finish()
    }
}
pub type PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = PhysicalDeviceTextureCompressionASTCHDRFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceCooperativeMatrixFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub cooperative_matrix: Bool32,
    pub cooperative_matrix_robust_buffer_access: Bool32,
}
unsafe impl Send for PhysicalDeviceCooperativeMatrixFeaturesNV {}
unsafe impl Sync for PhysicalDeviceCooperativeMatrixFeaturesNV {}
impl Default for PhysicalDeviceCooperativeMatrixFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV,
            p_next: ptr::null_mut(),
            cooperative_matrix: Default::default(),
            cooperative_matrix_robust_buffer_access: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceCooperativeMatrixFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceCooperativeMatrixFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("cooperative_matrix", &self.cooperative_matrix)
            .field(
                "cooperative_matrix_robust_buffer_access",
                &self.cooperative_matrix_robust_buffer_access,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceCooperativeMatrixPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub cooperative_matrix_supported_stages: ShaderStageFlags,
}
unsafe impl Send for PhysicalDeviceCooperativeMatrixPropertiesNV {}
unsafe impl Sync for PhysicalDeviceCooperativeMatrixPropertiesNV {}
impl Default for PhysicalDeviceCooperativeMatrixPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            cooperative_matrix_supported_stages: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceCooperativeMatrixPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceCooperativeMatrixPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "cooperative_matrix_supported_stages",
                &self.cooperative_matrix_supported_stages,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CooperativeMatrixPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub m_size: u32,
    pub n_size: u32,
    pub k_size: u32,
    pub a_type: ComponentTypeNV,
    pub b_type: ComponentTypeNV,
    pub c_type: ComponentTypeNV,
    pub d_type: ComponentTypeNV,
    pub scope: ScopeNV,
}
unsafe impl Send for CooperativeMatrixPropertiesNV {}
unsafe impl Sync for CooperativeMatrixPropertiesNV {}
impl Default for CooperativeMatrixPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::COOPERATIVE_MATRIX_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            m_size: Default::default(),
            n_size: Default::default(),
            k_size: Default::default(),
            a_type: Default::default(),
            b_type: Default::default(),
            c_type: Default::default(),
            d_type: Default::default(),
            scope: Default::default(),
        }
    }
}
impl fmt::Debug for CooperativeMatrixPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CooperativeMatrixPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("m_size", &self.m_size)
            .field("n_size", &self.n_size)
            .field("k_size", &self.k_size)
            .field("a_type", &self.a_type)
            .field("b_type", &self.b_type)
            .field("c_type", &self.c_type)
            .field("d_type", &self.d_type)
            .field("scope", &self.scope)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceYcbcrImageArraysFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ycbcr_image_arrays: Bool32,
}
unsafe impl Send for PhysicalDeviceYcbcrImageArraysFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceYcbcrImageArraysFeaturesEXT {}
impl Default for PhysicalDeviceYcbcrImageArraysFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
            p_next: ptr::null_mut(),
            ycbcr_image_arrays: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceYcbcrImageArraysFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceYcbcrImageArraysFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ycbcr_image_arrays", &self.ycbcr_image_arrays)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageViewHandleInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: Option<ImageView>,
    pub descriptor_type: DescriptorType,
    pub sampler: Option<Sampler>,
}
unsafe impl Send for ImageViewHandleInfoNVX {}
unsafe impl Sync for ImageViewHandleInfoNVX {}
impl Default for ImageViewHandleInfoNVX {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_VIEW_HANDLE_INFO_NVX,
            p_next: ptr::null(),
            image_view: Default::default(),
            descriptor_type: Default::default(),
            sampler: Default::default(),
        }
    }
}
impl fmt::Debug for ImageViewHandleInfoNVX {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageViewHandleInfoNVX")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_view", &self.image_view)
            .field("descriptor_type", &self.descriptor_type)
            .field("sampler", &self.sampler)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageViewAddressPropertiesNVX {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_address: DeviceAddress,
    pub size: DeviceSize,
}
unsafe impl Send for ImageViewAddressPropertiesNVX {}
unsafe impl Sync for ImageViewAddressPropertiesNVX {}
impl Default for ImageViewAddressPropertiesNVX {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_VIEW_ADDRESS_PROPERTIES_NVX,
            p_next: ptr::null_mut(),
            device_address: Default::default(),
            size: Default::default(),
        }
    }
}
impl fmt::Debug for ImageViewAddressPropertiesNVX {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageViewAddressPropertiesNVX")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_address", &self.device_address)
            .field("size", &self.size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct PipelineCreationFeedback {
    pub flags: PipelineCreationFeedbackFlags,
    pub duration: u64,
}
impl fmt::Debug for PipelineCreationFeedback {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCreationFeedback")
            .field("flags", &self.flags)
            .field("duration", &self.duration)
            .finish()
    }
}
pub type PipelineCreationFeedbackEXT = PipelineCreationFeedback;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineCreationFeedbackCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Output pipeline creation feedback.
    pub p_pipeline_creation_feedback: *mut PipelineCreationFeedback,
    pub pipeline_stage_creation_feedback_count: u32,
    /// One entry for each shader stage specified in the parent Vk*PipelineCreateInfo struct
    pub p_pipeline_stage_creation_feedbacks: *mut PipelineCreationFeedback,
}
unsafe impl Send for PipelineCreationFeedbackCreateInfo {}
unsafe impl Sync for PipelineCreationFeedbackCreateInfo {}
impl Default for PipelineCreationFeedbackCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
            p_next: ptr::null(),
            p_pipeline_creation_feedback: ptr::null_mut(),
            pipeline_stage_creation_feedback_count: Default::default(),
            p_pipeline_stage_creation_feedbacks: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for PipelineCreationFeedbackCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCreationFeedbackCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_pipeline_creation_feedback", &self.p_pipeline_creation_feedback)
            .field(
                "pipeline_stage_creation_feedback_count",
                &self.pipeline_stage_creation_feedback_count,
            )
            .field(
                "p_pipeline_stage_creation_feedbacks",
                &self.p_pipeline_stage_creation_feedbacks,
            )
            .finish()
    }
}
pub type PipelineCreationFeedbackCreateInfoEXT = PipelineCreationFeedbackCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SurfaceFullScreenExclusiveInfoEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub full_screen_exclusive: FullScreenExclusiveEXT,
}
unsafe impl Send for SurfaceFullScreenExclusiveInfoEXT {}
unsafe impl Sync for SurfaceFullScreenExclusiveInfoEXT {}
impl Default for SurfaceFullScreenExclusiveInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            p_next: ptr::null_mut(),
            full_screen_exclusive: Default::default(),
        }
    }
}
impl fmt::Debug for SurfaceFullScreenExclusiveInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceFullScreenExclusiveInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("full_screen_exclusive", &self.full_screen_exclusive)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SurfaceFullScreenExclusiveWin32InfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub hmonitor: HMONITOR,
}
unsafe impl Send for SurfaceFullScreenExclusiveWin32InfoEXT {}
unsafe impl Sync for SurfaceFullScreenExclusiveWin32InfoEXT {}
impl Default for SurfaceFullScreenExclusiveWin32InfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
            p_next: ptr::null(),
            hmonitor: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for SurfaceFullScreenExclusiveWin32InfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceFullScreenExclusiveWin32InfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("hmonitor", &self.hmonitor)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SurfaceCapabilitiesFullScreenExclusiveEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub full_screen_exclusive_supported: Bool32,
}
unsafe impl Send for SurfaceCapabilitiesFullScreenExclusiveEXT {}
unsafe impl Sync for SurfaceCapabilitiesFullScreenExclusiveEXT {}
impl Default for SurfaceCapabilitiesFullScreenExclusiveEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
            p_next: ptr::null_mut(),
            full_screen_exclusive_supported: Default::default(),
        }
    }
}
impl fmt::Debug for SurfaceCapabilitiesFullScreenExclusiveEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SurfaceCapabilitiesFullScreenExclusiveEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("full_screen_exclusive_supported", &self.full_screen_exclusive_supported)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePerformanceQueryFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// performance counters supported in query pools
    pub performance_counter_query_pools: Bool32,
    /// performance counters from multiple query pools can be accessed in the same primary command buffer
    pub performance_counter_multiple_query_pools: Bool32,
}
unsafe impl Send for PhysicalDevicePerformanceQueryFeaturesKHR {}
unsafe impl Sync for PhysicalDevicePerformanceQueryFeaturesKHR {}
impl Default for PhysicalDevicePerformanceQueryFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
            p_next: ptr::null_mut(),
            performance_counter_query_pools: Default::default(),
            performance_counter_multiple_query_pools: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePerformanceQueryFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePerformanceQueryFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("performance_counter_query_pools", &self.performance_counter_query_pools)
            .field(
                "performance_counter_multiple_query_pools",
                &self.performance_counter_multiple_query_pools,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePerformanceQueryPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// Flag to specify whether performance queries are allowed to be used in vkCmdCopyQueryPoolResults
    pub allow_command_buffer_query_copies: Bool32,
}
unsafe impl Send for PhysicalDevicePerformanceQueryPropertiesKHR {}
unsafe impl Sync for PhysicalDevicePerformanceQueryPropertiesKHR {}
impl Default for PhysicalDevicePerformanceQueryPropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            allow_command_buffer_query_copies: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePerformanceQueryPropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePerformanceQueryPropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "allow_command_buffer_query_copies",
                &self.allow_command_buffer_query_copies,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceCounterKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub unit: PerformanceCounterUnitKHR,
    pub scope: PerformanceCounterScopeKHR,
    pub storage: PerformanceCounterStorageKHR,
    pub uuid: [u8; UUID_SIZE],
}
unsafe impl Send for PerformanceCounterKHR {}
unsafe impl Sync for PerformanceCounterKHR {}
impl Default for PerformanceCounterKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PERFORMANCE_COUNTER_KHR,
            p_next: ptr::null_mut(),
            unit: Default::default(),
            scope: Default::default(),
            storage: Default::default(),
            uuid: [Default::default(); UUID_SIZE],
        }
    }
}
impl fmt::Debug for PerformanceCounterKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceCounterKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("unit", &self.unit)
            .field("scope", &self.scope)
            .field("storage", &self.storage)
            .field("uuid", &self.uuid)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceCounterDescriptionKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: PerformanceCounterDescriptionFlagsKHR,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub category: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
}
unsafe impl Send for PerformanceCounterDescriptionKHR {}
unsafe impl Sync for PerformanceCounterDescriptionKHR {}
impl Default for PerformanceCounterDescriptionKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PERFORMANCE_COUNTER_DESCRIPTION_KHR,
            p_next: ptr::null_mut(),
            flags: Default::default(),
            name: [Default::default(); MAX_DESCRIPTION_SIZE],
            category: [Default::default(); MAX_DESCRIPTION_SIZE],
            description: [Default::default(); MAX_DESCRIPTION_SIZE],
        }
    }
}
impl fmt::Debug for PerformanceCounterDescriptionKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceCounterDescriptionKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("name", &unsafe { CStr::from_ptr(self.name.as_ptr()) })
            .field("category", &unsafe { CStr::from_ptr(self.category.as_ptr()) })
            .field("description", &unsafe { CStr::from_ptr(self.description.as_ptr()) })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueryPoolPerformanceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub queue_family_index: u32,
    pub counter_index_count: u32,
    pub p_counter_indices: *const u32,
}
unsafe impl Send for QueryPoolPerformanceCreateInfoKHR {}
unsafe impl Sync for QueryPoolPerformanceCreateInfoKHR {}
impl Default for QueryPoolPerformanceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            queue_family_index: Default::default(),
            counter_index_count: Default::default(),
            p_counter_indices: ptr::null(),
        }
    }
}
impl fmt::Debug for QueryPoolPerformanceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueryPoolPerformanceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("queue_family_index", &self.queue_family_index)
            .field("counter_index_count", &self.counter_index_count)
            .field("p_counter_indices", &self.p_counter_indices)
            .finish()
    }
}
///  Union of all the possible return types a counter result could return
#[repr(C)]
#[derive(Copy, Clone)]
pub union PerformanceCounterResultKHR {
    pub int32: i32,
    pub int64: i64,
    pub uint32: u32,
    pub uint64: u64,
    pub float32: f32,
    pub float64: f64,
}
impl Default for PerformanceCounterResultKHR {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for PerformanceCounterResultKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceCounterResultKHR")
            .field("int32", unsafe { &self.int32 })
            .field("int64", unsafe { &self.int64 })
            .field("uint32", unsafe { &self.uint32 })
            .field("uint64", unsafe { &self.uint64 })
            .field("float32", unsafe { &self.float32 })
            .field("float64", unsafe { &self.float64 })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AcquireProfilingLockInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Acquire profiling lock flags
    pub flags: AcquireProfilingLockFlagsKHR,
    pub timeout: u64,
}
unsafe impl Send for AcquireProfilingLockInfoKHR {}
unsafe impl Sync for AcquireProfilingLockInfoKHR {}
impl Default for AcquireProfilingLockInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACQUIRE_PROFILING_LOCK_INFO_KHR,
            p_next: ptr::null(),
            flags: Default::default(),
            timeout: Default::default(),
        }
    }
}
impl fmt::Debug for AcquireProfilingLockInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AcquireProfilingLockInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("timeout", &self.timeout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceQuerySubmitInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Index for which counter pass to submit
    pub counter_pass_index: u32,
}
unsafe impl Send for PerformanceQuerySubmitInfoKHR {}
unsafe impl Sync for PerformanceQuerySubmitInfoKHR {}
impl Default for PerformanceQuerySubmitInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
            p_next: ptr::null(),
            counter_pass_index: Default::default(),
        }
    }
}
impl fmt::Debug for PerformanceQuerySubmitInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceQuerySubmitInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("counter_pass_index", &self.counter_pass_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HeadlessSurfaceCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: HeadlessSurfaceCreateFlagsEXT,
}
unsafe impl Send for HeadlessSurfaceCreateInfoEXT {}
unsafe impl Sync for HeadlessSurfaceCreateInfoEXT {}
impl Default for HeadlessSurfaceCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::HEADLESS_SURFACE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            flags: Default::default(),
        }
    }
}
impl fmt::Debug for HeadlessSurfaceCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("HeadlessSurfaceCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceCoverageReductionModeFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub coverage_reduction_mode: Bool32,
}
unsafe impl Send for PhysicalDeviceCoverageReductionModeFeaturesNV {}
unsafe impl Sync for PhysicalDeviceCoverageReductionModeFeaturesNV {}
impl Default for PhysicalDeviceCoverageReductionModeFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV,
            p_next: ptr::null_mut(),
            coverage_reduction_mode: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceCoverageReductionModeFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceCoverageReductionModeFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("coverage_reduction_mode", &self.coverage_reduction_mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineCoverageReductionStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCoverageReductionStateCreateFlagsNV,
    pub coverage_reduction_mode: CoverageReductionModeNV,
}
unsafe impl Send for PipelineCoverageReductionStateCreateInfoNV {}
unsafe impl Sync for PipelineCoverageReductionStateCreateInfoNV {}
impl Default for PipelineCoverageReductionStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            flags: Default::default(),
            coverage_reduction_mode: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineCoverageReductionStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCoverageReductionStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("coverage_reduction_mode", &self.coverage_reduction_mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FramebufferMixedSamplesCombinationNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub coverage_reduction_mode: CoverageReductionModeNV,
    pub rasterization_samples: SampleCountFlags,
    pub depth_stencil_samples: SampleCountFlags,
    pub color_samples: SampleCountFlags,
}
unsafe impl Send for FramebufferMixedSamplesCombinationNV {}
unsafe impl Sync for FramebufferMixedSamplesCombinationNV {}
impl Default for FramebufferMixedSamplesCombinationNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV,
            p_next: ptr::null_mut(),
            coverage_reduction_mode: Default::default(),
            rasterization_samples: Default::default(),
            depth_stencil_samples: Default::default(),
            color_samples: Default::default(),
        }
    }
}
impl fmt::Debug for FramebufferMixedSamplesCombinationNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FramebufferMixedSamplesCombinationNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("coverage_reduction_mode", &self.coverage_reduction_mode)
            .field("rasterization_samples", &self.rasterization_samples)
            .field("depth_stencil_samples", &self.depth_stencil_samples)
            .field("color_samples", &self.color_samples)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_integer_functions2: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {}
unsafe impl Sync for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {}
impl Default for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
            p_next: ptr::null_mut(),
            shader_integer_functions2: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_integer_functions2", &self.shader_integer_functions2)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PerformanceValueDataINTEL {
    pub value32: u32,
    pub value64: u64,
    pub value_float: f32,
    pub value_bool: Bool32,
    pub value_string: *const c_char,
}
unsafe impl Send for PerformanceValueDataINTEL {}
unsafe impl Sync for PerformanceValueDataINTEL {}
impl Default for PerformanceValueDataINTEL {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for PerformanceValueDataINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceValueDataINTEL")
            .field("value32", unsafe { &self.value32 })
            .field("value64", unsafe { &self.value64 })
            .field("value_float", unsafe { &self.value_float })
            .field("value_bool", unsafe { &self.value_bool })
            .field("value_string", unsafe { &self.value_string })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct PerformanceValueINTEL {
    pub ty: PerformanceValueTypeINTEL,
    pub data: PerformanceValueDataINTEL,
}
impl fmt::Debug for PerformanceValueINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceValueINTEL")
            .field("ty", &self.ty)
            .field("data", &self.data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct InitializePerformanceApiInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_user_data: *mut c_void,
}
unsafe impl Send for InitializePerformanceApiInfoINTEL {}
unsafe impl Sync for InitializePerformanceApiInfoINTEL {}
impl Default for InitializePerformanceApiInfoINTEL {
    fn default() -> Self {
        Self {
            s_type: StructureType::INITIALIZE_PERFORMANCE_API_INFO_INTEL,
            p_next: ptr::null(),
            p_user_data: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for InitializePerformanceApiInfoINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("InitializePerformanceApiInfoINTEL")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_user_data", &self.p_user_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueryPoolPerformanceQueryCreateInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub performance_counters_sampling: QueryPoolSamplingModeINTEL,
}
unsafe impl Send for QueryPoolPerformanceQueryCreateInfoINTEL {}
unsafe impl Sync for QueryPoolPerformanceQueryCreateInfoINTEL {}
impl Default for QueryPoolPerformanceQueryCreateInfoINTEL {
    fn default() -> Self {
        Self {
            s_type: StructureType::QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
            p_next: ptr::null(),
            performance_counters_sampling: Default::default(),
        }
    }
}
impl fmt::Debug for QueryPoolPerformanceQueryCreateInfoINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueryPoolPerformanceQueryCreateInfoINTEL")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("performance_counters_sampling", &self.performance_counters_sampling)
            .finish()
    }
}
pub type QueryPoolCreateInfoINTEL = QueryPoolPerformanceQueryCreateInfoINTEL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceMarkerInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub marker: u64,
}
unsafe impl Send for PerformanceMarkerInfoINTEL {}
unsafe impl Sync for PerformanceMarkerInfoINTEL {}
impl Default for PerformanceMarkerInfoINTEL {
    fn default() -> Self {
        Self {
            s_type: StructureType::PERFORMANCE_MARKER_INFO_INTEL,
            p_next: ptr::null(),
            marker: Default::default(),
        }
    }
}
impl fmt::Debug for PerformanceMarkerInfoINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceMarkerInfoINTEL")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("marker", &self.marker)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceStreamMarkerInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub marker: u32,
}
unsafe impl Send for PerformanceStreamMarkerInfoINTEL {}
unsafe impl Sync for PerformanceStreamMarkerInfoINTEL {}
impl Default for PerformanceStreamMarkerInfoINTEL {
    fn default() -> Self {
        Self {
            s_type: StructureType::PERFORMANCE_STREAM_MARKER_INFO_INTEL,
            p_next: ptr::null(),
            marker: Default::default(),
        }
    }
}
impl fmt::Debug for PerformanceStreamMarkerInfoINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceStreamMarkerInfoINTEL")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("marker", &self.marker)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceOverrideInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: PerformanceOverrideTypeINTEL,
    pub enable: Bool32,
    pub parameter: u64,
}
unsafe impl Send for PerformanceOverrideInfoINTEL {}
unsafe impl Sync for PerformanceOverrideInfoINTEL {}
impl Default for PerformanceOverrideInfoINTEL {
    fn default() -> Self {
        Self {
            s_type: StructureType::PERFORMANCE_OVERRIDE_INFO_INTEL,
            p_next: ptr::null(),
            ty: Default::default(),
            enable: Default::default(),
            parameter: Default::default(),
        }
    }
}
impl fmt::Debug for PerformanceOverrideInfoINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceOverrideInfoINTEL")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("enable", &self.enable)
            .field("parameter", &self.parameter)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PerformanceConfigurationAcquireInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: PerformanceConfigurationTypeINTEL,
}
unsafe impl Send for PerformanceConfigurationAcquireInfoINTEL {}
unsafe impl Sync for PerformanceConfigurationAcquireInfoINTEL {}
impl Default for PerformanceConfigurationAcquireInfoINTEL {
    fn default() -> Self {
        Self {
            s_type: StructureType::PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL,
            p_next: ptr::null(),
            ty: Default::default(),
        }
    }
}
impl fmt::Debug for PerformanceConfigurationAcquireInfoINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceConfigurationAcquireInfoINTEL")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderClockFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_subgroup_clock: Bool32,
    pub shader_device_clock: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderClockFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceShaderClockFeaturesKHR {}
impl Default for PhysicalDeviceShaderClockFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
            p_next: ptr::null_mut(),
            shader_subgroup_clock: Default::default(),
            shader_device_clock: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderClockFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderClockFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_subgroup_clock", &self.shader_subgroup_clock)
            .field("shader_device_clock", &self.shader_device_clock)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceIndexTypeUint8FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub index_type_uint8: Bool32,
}
unsafe impl Send for PhysicalDeviceIndexTypeUint8FeaturesEXT {}
unsafe impl Sync for PhysicalDeviceIndexTypeUint8FeaturesEXT {}
impl Default for PhysicalDeviceIndexTypeUint8FeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT,
            p_next: ptr::null_mut(),
            index_type_uint8: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceIndexTypeUint8FeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceIndexTypeUint8FeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("index_type_uint8", &self.index_type_uint8)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderSMBuiltinsPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_sm_count: u32,
    pub shader_warps_per_sm: u32,
}
unsafe impl Send for PhysicalDeviceShaderSMBuiltinsPropertiesNV {}
unsafe impl Sync for PhysicalDeviceShaderSMBuiltinsPropertiesNV {}
impl Default for PhysicalDeviceShaderSMBuiltinsPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            shader_sm_count: Default::default(),
            shader_warps_per_sm: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderSMBuiltinsPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderSMBuiltinsPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_sm_count", &self.shader_sm_count)
            .field("shader_warps_per_sm", &self.shader_warps_per_sm)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderSMBuiltinsFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_sm_builtins: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderSMBuiltinsFeaturesNV {}
unsafe impl Sync for PhysicalDeviceShaderSMBuiltinsFeaturesNV {}
impl Default for PhysicalDeviceShaderSMBuiltinsFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV,
            p_next: ptr::null_mut(),
            shader_sm_builtins: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderSMBuiltinsFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderSMBuiltinsFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_sm_builtins", &self.shader_sm_builtins)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    pub s_type: StructureType,
    /// Pointer to next structure
    pub p_next: *mut c_void,
    pub fragment_shader_sample_interlock: Bool32,
    pub fragment_shader_pixel_interlock: Bool32,
    pub fragment_shader_shading_rate_interlock: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentShaderInterlockFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceFragmentShaderInterlockFeaturesEXT {}
impl Default for PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
            p_next: ptr::null_mut(),
            fragment_shader_sample_interlock: Default::default(),
            fragment_shader_pixel_interlock: Default::default(),
            fragment_shader_shading_rate_interlock: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShaderInterlockFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "fragment_shader_sample_interlock",
                &self.fragment_shader_sample_interlock,
            )
            .field("fragment_shader_pixel_interlock", &self.fragment_shader_pixel_interlock)
            .field(
                "fragment_shader_shading_rate_interlock",
                &self.fragment_shader_shading_rate_interlock,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub separate_depth_stencil_layouts: Bool32,
}
unsafe impl Send for PhysicalDeviceSeparateDepthStencilLayoutsFeatures {}
unsafe impl Sync for PhysicalDeviceSeparateDepthStencilLayoutsFeatures {}
impl Default for PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
            p_next: ptr::null_mut(),
            separate_depth_stencil_layouts: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSeparateDepthStencilLayoutsFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("separate_depth_stencil_layouts", &self.separate_depth_stencil_layouts)
            .finish()
    }
}
pub type PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AttachmentReferenceStencilLayout {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stencil_layout: ImageLayout,
}
unsafe impl Send for AttachmentReferenceStencilLayout {}
unsafe impl Sync for AttachmentReferenceStencilLayout {}
impl Default for AttachmentReferenceStencilLayout {
    fn default() -> Self {
        Self {
            s_type: StructureType::ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
            p_next: ptr::null_mut(),
            stencil_layout: Default::default(),
        }
    }
}
impl fmt::Debug for AttachmentReferenceStencilLayout {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentReferenceStencilLayout")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stencil_layout", &self.stencil_layout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub primitive_topology_list_restart: Bool32,
    pub primitive_topology_patch_list_restart: Bool32,
}
unsafe impl Send for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {}
unsafe impl Sync for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {}
impl Default for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT,
            p_next: ptr::null_mut(),
            primitive_topology_list_restart: Default::default(),
            primitive_topology_patch_list_restart: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("primitive_topology_list_restart", &self.primitive_topology_list_restart)
            .field(
                "primitive_topology_patch_list_restart",
                &self.primitive_topology_patch_list_restart,
            )
            .finish()
    }
}
pub type AttachmentReferenceStencilLayoutKHR = AttachmentReferenceStencilLayout;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AttachmentDescriptionStencilLayout {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stencil_initial_layout: ImageLayout,
    pub stencil_final_layout: ImageLayout,
}
unsafe impl Send for AttachmentDescriptionStencilLayout {}
unsafe impl Sync for AttachmentDescriptionStencilLayout {}
impl Default for AttachmentDescriptionStencilLayout {
    fn default() -> Self {
        Self {
            s_type: StructureType::ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
            p_next: ptr::null_mut(),
            stencil_initial_layout: Default::default(),
            stencil_final_layout: Default::default(),
        }
    }
}
impl fmt::Debug for AttachmentDescriptionStencilLayout {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentDescriptionStencilLayout")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stencil_initial_layout", &self.stencil_initial_layout)
            .field("stencil_final_layout", &self.stencil_final_layout)
            .finish()
    }
}
pub type AttachmentDescriptionStencilLayoutKHR = AttachmentDescriptionStencilLayout;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_executable_info: Bool32,
}
unsafe impl Send for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {}
unsafe impl Sync for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {}
impl Default for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
            p_next: ptr::null_mut(),
            pipeline_executable_info: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePipelineExecutablePropertiesFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline_executable_info", &self.pipeline_executable_info)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline: Option<Pipeline>,
}
unsafe impl Send for PipelineInfoKHR {}
unsafe impl Sync for PipelineInfoKHR {}
impl Default for PipelineInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_INFO_KHR,
            p_next: ptr::null(),
            pipeline: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline", &self.pipeline)
            .finish()
    }
}
pub type PipelineInfoEXT = PipelineInfoKHR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineExecutablePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stages: ShaderStageFlags,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub subgroup_size: u32,
}
unsafe impl Send for PipelineExecutablePropertiesKHR {}
unsafe impl Sync for PipelineExecutablePropertiesKHR {}
impl Default for PipelineExecutablePropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_EXECUTABLE_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            stages: Default::default(),
            name: [Default::default(); MAX_DESCRIPTION_SIZE],
            description: [Default::default(); MAX_DESCRIPTION_SIZE],
            subgroup_size: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineExecutablePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutablePropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stages", &self.stages)
            .field("name", &unsafe { CStr::from_ptr(self.name.as_ptr()) })
            .field("description", &unsafe { CStr::from_ptr(self.description.as_ptr()) })
            .field("subgroup_size", &self.subgroup_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineExecutableInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline: Option<Pipeline>,
    pub executable_index: u32,
}
unsafe impl Send for PipelineExecutableInfoKHR {}
unsafe impl Sync for PipelineExecutableInfoKHR {}
impl Default for PipelineExecutableInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_EXECUTABLE_INFO_KHR,
            p_next: ptr::null(),
            pipeline: Default::default(),
            executable_index: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineExecutableInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutableInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline", &self.pipeline)
            .field("executable_index", &self.executable_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PipelineExecutableStatisticValueKHR {
    pub b32: Bool32,
    pub i64: i64,
    pub u64: u64,
    pub f64: f64,
}
impl Default for PipelineExecutableStatisticValueKHR {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for PipelineExecutableStatisticValueKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutableStatisticValueKHR")
            .field("b32", unsafe { &self.b32 })
            .field("i64", unsafe { &self.i64 })
            .field("u64", unsafe { &self.u64 })
            .field("f64", unsafe { &self.f64 })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineExecutableStatisticKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub format: PipelineExecutableStatisticFormatKHR,
    pub value: PipelineExecutableStatisticValueKHR,
}
unsafe impl Send for PipelineExecutableStatisticKHR {}
unsafe impl Sync for PipelineExecutableStatisticKHR {}
impl Default for PipelineExecutableStatisticKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_EXECUTABLE_STATISTIC_KHR,
            p_next: ptr::null_mut(),
            name: [Default::default(); MAX_DESCRIPTION_SIZE],
            description: [Default::default(); MAX_DESCRIPTION_SIZE],
            format: Default::default(),
            value: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineExecutableStatisticKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutableStatisticKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("name", &unsafe { CStr::from_ptr(self.name.as_ptr()) })
            .field("description", &unsafe { CStr::from_ptr(self.description.as_ptr()) })
            .field("format", &self.format)
            .field("value", &self.value)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineExecutableInternalRepresentationKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub is_text: Bool32,
    pub data_size: usize,
    pub p_data: *mut c_void,
}
unsafe impl Send for PipelineExecutableInternalRepresentationKHR {}
unsafe impl Sync for PipelineExecutableInternalRepresentationKHR {}
impl Default for PipelineExecutableInternalRepresentationKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR,
            p_next: ptr::null_mut(),
            name: [Default::default(); MAX_DESCRIPTION_SIZE],
            description: [Default::default(); MAX_DESCRIPTION_SIZE],
            is_text: Default::default(),
            data_size: Default::default(),
            p_data: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for PipelineExecutableInternalRepresentationKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutableInternalRepresentationKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("name", &unsafe { CStr::from_ptr(self.name.as_ptr()) })
            .field("description", &unsafe { CStr::from_ptr(self.description.as_ptr()) })
            .field("is_text", &self.is_text)
            .field("data_size", &self.data_size)
            .field("p_data", &self.p_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_demote_to_helper_invocation: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderDemoteToHelperInvocationFeatures {}
unsafe impl Sync for PhysicalDeviceShaderDemoteToHelperInvocationFeatures {}
impl Default for PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
            p_next: ptr::null_mut(),
            shader_demote_to_helper_invocation: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderDemoteToHelperInvocationFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "shader_demote_to_helper_invocation",
                &self.shader_demote_to_helper_invocation,
            )
            .finish()
    }
}
pub type PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = PhysicalDeviceShaderDemoteToHelperInvocationFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub texel_buffer_alignment: Bool32,
}
unsafe impl Send for PhysicalDeviceTexelBufferAlignmentFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceTexelBufferAlignmentFeaturesEXT {}
impl Default for PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
            p_next: ptr::null_mut(),
            texel_buffer_alignment: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceTexelBufferAlignmentFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("texel_buffer_alignment", &self.texel_buffer_alignment)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceTexelBufferAlignmentProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub storage_texel_buffer_offset_single_texel_alignment: Bool32,
    pub uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub uniform_texel_buffer_offset_single_texel_alignment: Bool32,
}
unsafe impl Send for PhysicalDeviceTexelBufferAlignmentProperties {}
unsafe impl Sync for PhysicalDeviceTexelBufferAlignmentProperties {}
impl Default for PhysicalDeviceTexelBufferAlignmentProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
            p_next: ptr::null_mut(),
            storage_texel_buffer_offset_alignment_bytes: Default::default(),
            storage_texel_buffer_offset_single_texel_alignment: Default::default(),
            uniform_texel_buffer_offset_alignment_bytes: Default::default(),
            uniform_texel_buffer_offset_single_texel_alignment: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceTexelBufferAlignmentProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceTexelBufferAlignmentProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "storage_texel_buffer_offset_alignment_bytes",
                &self.storage_texel_buffer_offset_alignment_bytes,
            )
            .field(
                "storage_texel_buffer_offset_single_texel_alignment",
                &self.storage_texel_buffer_offset_single_texel_alignment,
            )
            .field(
                "uniform_texel_buffer_offset_alignment_bytes",
                &self.uniform_texel_buffer_offset_alignment_bytes,
            )
            .field(
                "uniform_texel_buffer_offset_single_texel_alignment",
                &self.uniform_texel_buffer_offset_single_texel_alignment,
            )
            .finish()
    }
}
pub type PhysicalDeviceTexelBufferAlignmentPropertiesEXT = PhysicalDeviceTexelBufferAlignmentProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSubgroupSizeControlFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subgroup_size_control: Bool32,
    pub compute_full_subgroups: Bool32,
}
unsafe impl Send for PhysicalDeviceSubgroupSizeControlFeatures {}
unsafe impl Sync for PhysicalDeviceSubgroupSizeControlFeatures {}
impl Default for PhysicalDeviceSubgroupSizeControlFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
            p_next: ptr::null_mut(),
            subgroup_size_control: Default::default(),
            compute_full_subgroups: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSubgroupSizeControlFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSubgroupSizeControlFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("subgroup_size_control", &self.subgroup_size_control)
            .field("compute_full_subgroups", &self.compute_full_subgroups)
            .finish()
    }
}
pub type PhysicalDeviceSubgroupSizeControlFeaturesEXT = PhysicalDeviceSubgroupSizeControlFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSubgroupSizeControlProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// The minimum subgroup size supported by this device
    pub min_subgroup_size: u32,
    /// The maximum subgroup size supported by this device
    pub max_subgroup_size: u32,
    /// The maximum number of subgroups supported in a workgroup
    pub max_compute_workgroup_subgroups: u32,
    /// The shader stages that support specifying a subgroup size
    pub required_subgroup_size_stages: ShaderStageFlags,
}
unsafe impl Send for PhysicalDeviceSubgroupSizeControlProperties {}
unsafe impl Sync for PhysicalDeviceSubgroupSizeControlProperties {}
impl Default for PhysicalDeviceSubgroupSizeControlProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
            p_next: ptr::null_mut(),
            min_subgroup_size: Default::default(),
            max_subgroup_size: Default::default(),
            max_compute_workgroup_subgroups: Default::default(),
            required_subgroup_size_stages: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSubgroupSizeControlProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSubgroupSizeControlProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_subgroup_size", &self.min_subgroup_size)
            .field("max_subgroup_size", &self.max_subgroup_size)
            .field("max_compute_workgroup_subgroups", &self.max_compute_workgroup_subgroups)
            .field("required_subgroup_size_stages", &self.required_subgroup_size_stages)
            .finish()
    }
}
pub type PhysicalDeviceSubgroupSizeControlPropertiesEXT = PhysicalDeviceSubgroupSizeControlProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineShaderStageRequiredSubgroupSizeCreateInfo {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub required_subgroup_size: u32,
}
unsafe impl Send for PipelineShaderStageRequiredSubgroupSizeCreateInfo {}
unsafe impl Sync for PipelineShaderStageRequiredSubgroupSizeCreateInfo {}
impl Default for PipelineShaderStageRequiredSubgroupSizeCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
            p_next: ptr::null_mut(),
            required_subgroup_size: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineShaderStageRequiredSubgroupSizeCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineShaderStageRequiredSubgroupSizeCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("required_subgroup_size", &self.required_subgroup_size)
            .finish()
    }
}
pub type PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = PipelineShaderStageRequiredSubgroupSizeCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubpassShadingPipelineCreateInfoHUAWEI {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub render_pass: Option<RenderPass>,
    pub subpass: u32,
}
unsafe impl Send for SubpassShadingPipelineCreateInfoHUAWEI {}
unsafe impl Sync for SubpassShadingPipelineCreateInfoHUAWEI {}
impl Default for SubpassShadingPipelineCreateInfoHUAWEI {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI,
            p_next: ptr::null_mut(),
            render_pass: Default::default(),
            subpass: Default::default(),
        }
    }
}
impl fmt::Debug for SubpassShadingPipelineCreateInfoHUAWEI {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubpassShadingPipelineCreateInfoHUAWEI")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("render_pass", &self.render_pass)
            .field("subpass", &self.subpass)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSubpassShadingPropertiesHUAWEI {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_subpass_shading_workgroup_size_aspect_ratio: u32,
}
unsafe impl Send for PhysicalDeviceSubpassShadingPropertiesHUAWEI {}
unsafe impl Sync for PhysicalDeviceSubpassShadingPropertiesHUAWEI {}
impl Default for PhysicalDeviceSubpassShadingPropertiesHUAWEI {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI,
            p_next: ptr::null_mut(),
            max_subpass_shading_workgroup_size_aspect_ratio: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSubpassShadingPropertiesHUAWEI {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSubpassShadingPropertiesHUAWEI")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "max_subpass_shading_workgroup_size_aspect_ratio",
                &self.max_subpass_shading_workgroup_size_aspect_ratio,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryOpaqueCaptureAddressAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub opaque_capture_address: u64,
}
unsafe impl Send for MemoryOpaqueCaptureAddressAllocateInfo {}
unsafe impl Sync for MemoryOpaqueCaptureAddressAllocateInfo {}
impl Default for MemoryOpaqueCaptureAddressAllocateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
            p_next: ptr::null(),
            opaque_capture_address: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryOpaqueCaptureAddressAllocateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryOpaqueCaptureAddressAllocateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("opaque_capture_address", &self.opaque_capture_address)
            .finish()
    }
}
pub type MemoryOpaqueCaptureAddressAllocateInfoKHR = MemoryOpaqueCaptureAddressAllocateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceMemoryOpaqueCaptureAddressInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: Option<DeviceMemory>,
}
unsafe impl Send for DeviceMemoryOpaqueCaptureAddressInfo {}
unsafe impl Sync for DeviceMemoryOpaqueCaptureAddressInfo {}
impl Default for DeviceMemoryOpaqueCaptureAddressInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
            p_next: ptr::null(),
            memory: Default::default(),
        }
    }
}
impl fmt::Debug for DeviceMemoryOpaqueCaptureAddressInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceMemoryOpaqueCaptureAddressInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .finish()
    }
}
pub type DeviceMemoryOpaqueCaptureAddressInfoKHR = DeviceMemoryOpaqueCaptureAddressInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceLineRasterizationFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub rectangular_lines: Bool32,
    pub bresenham_lines: Bool32,
    pub smooth_lines: Bool32,
    pub stippled_rectangular_lines: Bool32,
    pub stippled_bresenham_lines: Bool32,
    pub stippled_smooth_lines: Bool32,
}
unsafe impl Send for PhysicalDeviceLineRasterizationFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceLineRasterizationFeaturesEXT {}
impl Default for PhysicalDeviceLineRasterizationFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT,
            p_next: ptr::null_mut(),
            rectangular_lines: Default::default(),
            bresenham_lines: Default::default(),
            smooth_lines: Default::default(),
            stippled_rectangular_lines: Default::default(),
            stippled_bresenham_lines: Default::default(),
            stippled_smooth_lines: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceLineRasterizationFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceLineRasterizationFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("rectangular_lines", &self.rectangular_lines)
            .field("bresenham_lines", &self.bresenham_lines)
            .field("smooth_lines", &self.smooth_lines)
            .field("stippled_rectangular_lines", &self.stippled_rectangular_lines)
            .field("stippled_bresenham_lines", &self.stippled_bresenham_lines)
            .field("stippled_smooth_lines", &self.stippled_smooth_lines)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceLineRasterizationPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub line_sub_pixel_precision_bits: u32,
}
unsafe impl Send for PhysicalDeviceLineRasterizationPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceLineRasterizationPropertiesEXT {}
impl Default for PhysicalDeviceLineRasterizationPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            line_sub_pixel_precision_bits: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceLineRasterizationPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceLineRasterizationPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("line_sub_pixel_precision_bits", &self.line_sub_pixel_precision_bits)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRasterizationLineStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub line_rasterization_mode: LineRasterizationModeEXT,
    pub stippled_line_enable: Bool32,
    pub line_stipple_factor: u32,
    pub line_stipple_pattern: u16,
}
unsafe impl Send for PipelineRasterizationLineStateCreateInfoEXT {}
unsafe impl Sync for PipelineRasterizationLineStateCreateInfoEXT {}
impl Default for PipelineRasterizationLineStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            line_rasterization_mode: Default::default(),
            stippled_line_enable: Default::default(),
            line_stipple_factor: Default::default(),
            line_stipple_pattern: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineRasterizationLineStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRasterizationLineStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("line_rasterization_mode", &self.line_rasterization_mode)
            .field("stippled_line_enable", &self.stippled_line_enable)
            .field("line_stipple_factor", &self.line_stipple_factor)
            .field("line_stipple_pattern", &self.line_stipple_pattern)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePipelineCreationCacheControlFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_creation_cache_control: Bool32,
}
unsafe impl Send for PhysicalDevicePipelineCreationCacheControlFeatures {}
unsafe impl Sync for PhysicalDevicePipelineCreationCacheControlFeatures {}
impl Default for PhysicalDevicePipelineCreationCacheControlFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
            p_next: ptr::null_mut(),
            pipeline_creation_cache_control: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePipelineCreationCacheControlFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePipelineCreationCacheControlFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline_creation_cache_control", &self.pipeline_creation_cache_control)
            .finish()
    }
}
pub type PhysicalDevicePipelineCreationCacheControlFeaturesEXT = PhysicalDevicePipelineCreationCacheControlFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVulkan11Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// 16-bit integer/floating-point variables supported in BufferBlock
    pub storage_buffer16_bit_access: Bool32,
    /// 16-bit integer/floating-point variables supported in BufferBlock and Block
    pub uniform_and_storage_buffer16_bit_access: Bool32,
    /// 16-bit integer/floating-point variables supported in PushConstant
    pub storage_push_constant16: Bool32,
    /// 16-bit integer/floating-point variables supported in shader inputs and outputs
    pub storage_input_output16: Bool32,
    /// Multiple views in a renderpass
    pub multiview: Bool32,
    /// Multiple views in a renderpass w/ geometry shader
    pub multiview_geometry_shader: Bool32,
    /// Multiple views in a renderpass w/ tessellation shader
    pub multiview_tessellation_shader: Bool32,
    pub variable_pointers_storage_buffer: Bool32,
    pub variable_pointers: Bool32,
    pub protected_memory: Bool32,
    /// Sampler color conversion supported
    pub sampler_ycbcr_conversion: Bool32,
    pub shader_draw_parameters: Bool32,
}
unsafe impl Send for PhysicalDeviceVulkan11Features {}
unsafe impl Sync for PhysicalDeviceVulkan11Features {}
impl Default for PhysicalDeviceVulkan11Features {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
            p_next: ptr::null_mut(),
            storage_buffer16_bit_access: Default::default(),
            uniform_and_storage_buffer16_bit_access: Default::default(),
            storage_push_constant16: Default::default(),
            storage_input_output16: Default::default(),
            multiview: Default::default(),
            multiview_geometry_shader: Default::default(),
            multiview_tessellation_shader: Default::default(),
            variable_pointers_storage_buffer: Default::default(),
            variable_pointers: Default::default(),
            protected_memory: Default::default(),
            sampler_ycbcr_conversion: Default::default(),
            shader_draw_parameters: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVulkan11Features {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVulkan11Features")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("storage_buffer16_bit_access", &self.storage_buffer16_bit_access)
            .field(
                "uniform_and_storage_buffer16_bit_access",
                &self.uniform_and_storage_buffer16_bit_access,
            )
            .field("storage_push_constant16", &self.storage_push_constant16)
            .field("storage_input_output16", &self.storage_input_output16)
            .field("multiview", &self.multiview)
            .field("multiview_geometry_shader", &self.multiview_geometry_shader)
            .field("multiview_tessellation_shader", &self.multiview_tessellation_shader)
            .field(
                "variable_pointers_storage_buffer",
                &self.variable_pointers_storage_buffer,
            )
            .field("variable_pointers", &self.variable_pointers)
            .field("protected_memory", &self.protected_memory)
            .field("sampler_ycbcr_conversion", &self.sampler_ycbcr_conversion)
            .field("shader_draw_parameters", &self.shader_draw_parameters)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVulkan11Properties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_uuid: [u8; UUID_SIZE],
    pub driver_uuid: [u8; UUID_SIZE],
    pub device_luid: [u8; LUID_SIZE],
    pub device_node_mask: u32,
    pub device_luid_valid: Bool32,
    /// The size of a subgroup for this queue.
    pub subgroup_size: u32,
    /// Bitfield of what shader stages support subgroup operations
    pub subgroup_supported_stages: ShaderStageFlags,
    /// Bitfield of what subgroup operations are supported.
    pub subgroup_supported_operations: SubgroupFeatureFlags,
    /// Flag to specify whether quad operations are available in all stages.
    pub subgroup_quad_operations_in_all_stages: Bool32,
    pub point_clipping_behavior: PointClippingBehavior,
    /// max number of views in a subpass
    pub max_multiview_view_count: u32,
    /// max instance index for a draw in a multiview subpass
    pub max_multiview_instance_index: u32,
    pub protected_no_fault: Bool32,
    pub max_per_set_descriptors: u32,
    pub max_memory_allocation_size: DeviceSize,
}
unsafe impl Send for PhysicalDeviceVulkan11Properties {}
unsafe impl Sync for PhysicalDeviceVulkan11Properties {}
impl Default for PhysicalDeviceVulkan11Properties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
            p_next: ptr::null_mut(),
            device_uuid: [Default::default(); UUID_SIZE],
            driver_uuid: [Default::default(); UUID_SIZE],
            device_luid: [Default::default(); LUID_SIZE],
            device_node_mask: Default::default(),
            device_luid_valid: Default::default(),
            subgroup_size: Default::default(),
            subgroup_supported_stages: Default::default(),
            subgroup_supported_operations: Default::default(),
            subgroup_quad_operations_in_all_stages: Default::default(),
            point_clipping_behavior: Default::default(),
            max_multiview_view_count: Default::default(),
            max_multiview_instance_index: Default::default(),
            protected_no_fault: Default::default(),
            max_per_set_descriptors: Default::default(),
            max_memory_allocation_size: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVulkan11Properties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVulkan11Properties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_uuid", &self.device_uuid)
            .field("driver_uuid", &self.driver_uuid)
            .field("device_luid", &self.device_luid)
            .field("device_node_mask", &self.device_node_mask)
            .field("device_luid_valid", &self.device_luid_valid)
            .field("subgroup_size", &self.subgroup_size)
            .field("subgroup_supported_stages", &self.subgroup_supported_stages)
            .field("subgroup_supported_operations", &self.subgroup_supported_operations)
            .field(
                "subgroup_quad_operations_in_all_stages",
                &self.subgroup_quad_operations_in_all_stages,
            )
            .field("point_clipping_behavior", &self.point_clipping_behavior)
            .field("max_multiview_view_count", &self.max_multiview_view_count)
            .field("max_multiview_instance_index", &self.max_multiview_instance_index)
            .field("protected_no_fault", &self.protected_no_fault)
            .field("max_per_set_descriptors", &self.max_per_set_descriptors)
            .field("max_memory_allocation_size", &self.max_memory_allocation_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVulkan12Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub sampler_mirror_clamp_to_edge: Bool32,
    pub draw_indirect_count: Bool32,
    /// 8-bit integer variables supported in StorageBuffer
    pub storage_buffer8_bit_access: Bool32,
    /// 8-bit integer variables supported in StorageBuffer and Uniform
    pub uniform_and_storage_buffer8_bit_access: Bool32,
    /// 8-bit integer variables supported in PushConstant
    pub storage_push_constant8: Bool32,
    pub shader_buffer_int64_atomics: Bool32,
    pub shader_shared_int64_atomics: Bool32,
    /// 16-bit floats (halfs) in shaders
    pub shader_float16: Bool32,
    /// 8-bit integers in shaders
    pub shader_int8: Bool32,
    pub descriptor_indexing: Bool32,
    pub shader_input_attachment_array_dynamic_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_storage_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_uniform_buffer_array_non_uniform_indexing: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_image_array_non_uniform_indexing: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_texel_buffer_array_non_uniform_indexing: Bool32,
    pub descriptor_binding_uniform_buffer_update_after_bind: Bool32,
    pub descriptor_binding_sampled_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_buffer_update_after_bind: Bool32,
    pub descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_storage_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_update_unused_while_pending: Bool32,
    pub descriptor_binding_partially_bound: Bool32,
    pub descriptor_binding_variable_descriptor_count: Bool32,
    pub runtime_descriptor_array: Bool32,
    pub sampler_filter_minmax: Bool32,
    pub scalar_block_layout: Bool32,
    pub imageless_framebuffer: Bool32,
    pub uniform_buffer_standard_layout: Bool32,
    pub shader_subgroup_extended_types: Bool32,
    pub separate_depth_stencil_layouts: Bool32,
    pub host_query_reset: Bool32,
    pub timeline_semaphore: Bool32,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
    pub vulkan_memory_model: Bool32,
    pub vulkan_memory_model_device_scope: Bool32,
    pub vulkan_memory_model_availability_visibility_chains: Bool32,
    pub shader_output_viewport_index: Bool32,
    pub shader_output_layer: Bool32,
    pub subgroup_broadcast_dynamic_id: Bool32,
}
unsafe impl Send for PhysicalDeviceVulkan12Features {}
unsafe impl Sync for PhysicalDeviceVulkan12Features {}
impl Default for PhysicalDeviceVulkan12Features {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
            p_next: ptr::null_mut(),
            sampler_mirror_clamp_to_edge: Default::default(),
            draw_indirect_count: Default::default(),
            storage_buffer8_bit_access: Default::default(),
            uniform_and_storage_buffer8_bit_access: Default::default(),
            storage_push_constant8: Default::default(),
            shader_buffer_int64_atomics: Default::default(),
            shader_shared_int64_atomics: Default::default(),
            shader_float16: Default::default(),
            shader_int8: Default::default(),
            descriptor_indexing: Default::default(),
            shader_input_attachment_array_dynamic_indexing: Default::default(),
            shader_uniform_texel_buffer_array_dynamic_indexing: Default::default(),
            shader_storage_texel_buffer_array_dynamic_indexing: Default::default(),
            shader_uniform_buffer_array_non_uniform_indexing: Default::default(),
            shader_sampled_image_array_non_uniform_indexing: Default::default(),
            shader_storage_buffer_array_non_uniform_indexing: Default::default(),
            shader_storage_image_array_non_uniform_indexing: Default::default(),
            shader_input_attachment_array_non_uniform_indexing: Default::default(),
            shader_uniform_texel_buffer_array_non_uniform_indexing: Default::default(),
            shader_storage_texel_buffer_array_non_uniform_indexing: Default::default(),
            descriptor_binding_uniform_buffer_update_after_bind: Default::default(),
            descriptor_binding_sampled_image_update_after_bind: Default::default(),
            descriptor_binding_storage_image_update_after_bind: Default::default(),
            descriptor_binding_storage_buffer_update_after_bind: Default::default(),
            descriptor_binding_uniform_texel_buffer_update_after_bind: Default::default(),
            descriptor_binding_storage_texel_buffer_update_after_bind: Default::default(),
            descriptor_binding_update_unused_while_pending: Default::default(),
            descriptor_binding_partially_bound: Default::default(),
            descriptor_binding_variable_descriptor_count: Default::default(),
            runtime_descriptor_array: Default::default(),
            sampler_filter_minmax: Default::default(),
            scalar_block_layout: Default::default(),
            imageless_framebuffer: Default::default(),
            uniform_buffer_standard_layout: Default::default(),
            shader_subgroup_extended_types: Default::default(),
            separate_depth_stencil_layouts: Default::default(),
            host_query_reset: Default::default(),
            timeline_semaphore: Default::default(),
            buffer_device_address: Default::default(),
            buffer_device_address_capture_replay: Default::default(),
            buffer_device_address_multi_device: Default::default(),
            vulkan_memory_model: Default::default(),
            vulkan_memory_model_device_scope: Default::default(),
            vulkan_memory_model_availability_visibility_chains: Default::default(),
            shader_output_viewport_index: Default::default(),
            shader_output_layer: Default::default(),
            subgroup_broadcast_dynamic_id: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVulkan12Features {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVulkan12Features")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("sampler_mirror_clamp_to_edge", &self.sampler_mirror_clamp_to_edge)
            .field("draw_indirect_count", &self.draw_indirect_count)
            .field("storage_buffer8_bit_access", &self.storage_buffer8_bit_access)
            .field(
                "uniform_and_storage_buffer8_bit_access",
                &self.uniform_and_storage_buffer8_bit_access,
            )
            .field("storage_push_constant8", &self.storage_push_constant8)
            .field("shader_buffer_int64_atomics", &self.shader_buffer_int64_atomics)
            .field("shader_shared_int64_atomics", &self.shader_shared_int64_atomics)
            .field("shader_float16", &self.shader_float16)
            .field("shader_int8", &self.shader_int8)
            .field("descriptor_indexing", &self.descriptor_indexing)
            .field(
                "shader_input_attachment_array_dynamic_indexing",
                &self.shader_input_attachment_array_dynamic_indexing,
            )
            .field(
                "shader_uniform_texel_buffer_array_dynamic_indexing",
                &self.shader_uniform_texel_buffer_array_dynamic_indexing,
            )
            .field(
                "shader_storage_texel_buffer_array_dynamic_indexing",
                &self.shader_storage_texel_buffer_array_dynamic_indexing,
            )
            .field(
                "shader_uniform_buffer_array_non_uniform_indexing",
                &self.shader_uniform_buffer_array_non_uniform_indexing,
            )
            .field(
                "shader_sampled_image_array_non_uniform_indexing",
                &self.shader_sampled_image_array_non_uniform_indexing,
            )
            .field(
                "shader_storage_buffer_array_non_uniform_indexing",
                &self.shader_storage_buffer_array_non_uniform_indexing,
            )
            .field(
                "shader_storage_image_array_non_uniform_indexing",
                &self.shader_storage_image_array_non_uniform_indexing,
            )
            .field(
                "shader_input_attachment_array_non_uniform_indexing",
                &self.shader_input_attachment_array_non_uniform_indexing,
            )
            .field(
                "shader_uniform_texel_buffer_array_non_uniform_indexing",
                &self.shader_uniform_texel_buffer_array_non_uniform_indexing,
            )
            .field(
                "shader_storage_texel_buffer_array_non_uniform_indexing",
                &self.shader_storage_texel_buffer_array_non_uniform_indexing,
            )
            .field(
                "descriptor_binding_uniform_buffer_update_after_bind",
                &self.descriptor_binding_uniform_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_sampled_image_update_after_bind",
                &self.descriptor_binding_sampled_image_update_after_bind,
            )
            .field(
                "descriptor_binding_storage_image_update_after_bind",
                &self.descriptor_binding_storage_image_update_after_bind,
            )
            .field(
                "descriptor_binding_storage_buffer_update_after_bind",
                &self.descriptor_binding_storage_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_uniform_texel_buffer_update_after_bind",
                &self.descriptor_binding_uniform_texel_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_storage_texel_buffer_update_after_bind",
                &self.descriptor_binding_storage_texel_buffer_update_after_bind,
            )
            .field(
                "descriptor_binding_update_unused_while_pending",
                &self.descriptor_binding_update_unused_while_pending,
            )
            .field(
                "descriptor_binding_partially_bound",
                &self.descriptor_binding_partially_bound,
            )
            .field(
                "descriptor_binding_variable_descriptor_count",
                &self.descriptor_binding_variable_descriptor_count,
            )
            .field("runtime_descriptor_array", &self.runtime_descriptor_array)
            .field("sampler_filter_minmax", &self.sampler_filter_minmax)
            .field("scalar_block_layout", &self.scalar_block_layout)
            .field("imageless_framebuffer", &self.imageless_framebuffer)
            .field("uniform_buffer_standard_layout", &self.uniform_buffer_standard_layout)
            .field("shader_subgroup_extended_types", &self.shader_subgroup_extended_types)
            .field("separate_depth_stencil_layouts", &self.separate_depth_stencil_layouts)
            .field("host_query_reset", &self.host_query_reset)
            .field("timeline_semaphore", &self.timeline_semaphore)
            .field("buffer_device_address", &self.buffer_device_address)
            .field(
                "buffer_device_address_capture_replay",
                &self.buffer_device_address_capture_replay,
            )
            .field(
                "buffer_device_address_multi_device",
                &self.buffer_device_address_multi_device,
            )
            .field("vulkan_memory_model", &self.vulkan_memory_model)
            .field(
                "vulkan_memory_model_device_scope",
                &self.vulkan_memory_model_device_scope,
            )
            .field(
                "vulkan_memory_model_availability_visibility_chains",
                &self.vulkan_memory_model_availability_visibility_chains,
            )
            .field("shader_output_viewport_index", &self.shader_output_viewport_index)
            .field("shader_output_layer", &self.shader_output_layer)
            .field("subgroup_broadcast_dynamic_id", &self.subgroup_broadcast_dynamic_id)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVulkan12Properties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub driver_id: DriverId,
    pub driver_name: [c_char; MAX_DRIVER_NAME_SIZE],
    pub driver_info: [c_char; MAX_DRIVER_INFO_SIZE],
    pub conformance_version: ConformanceVersion,
    pub denorm_behavior_independence: ShaderFloatControlsIndependence,
    pub rounding_mode_independence: ShaderFloatControlsIndependence,
    /// An implementation can preserve signed zero, nan, inf
    pub shader_signed_zero_inf_nan_preserve_float16: Bool32,
    /// An implementation can preserve signed zero, nan, inf
    pub shader_signed_zero_inf_nan_preserve_float32: Bool32,
    /// An implementation can preserve signed zero, nan, inf
    pub shader_signed_zero_inf_nan_preserve_float64: Bool32,
    /// An implementation can preserve  denormals
    pub shader_denorm_preserve_float16: Bool32,
    /// An implementation can preserve  denormals
    pub shader_denorm_preserve_float32: Bool32,
    /// An implementation can preserve  denormals
    pub shader_denorm_preserve_float64: Bool32,
    /// An implementation can flush to zero  denormals
    pub shader_denorm_flush_to_zero_float16: Bool32,
    /// An implementation can flush to zero  denormals
    pub shader_denorm_flush_to_zero_float32: Bool32,
    /// An implementation can flush to zero  denormals
    pub shader_denorm_flush_to_zero_float64: Bool32,
    /// An implementation can support RTE
    pub shader_rounding_mode_rte_float16: Bool32,
    /// An implementation can support RTE
    pub shader_rounding_mode_rte_float32: Bool32,
    /// An implementation can support RTE
    pub shader_rounding_mode_rte_float64: Bool32,
    /// An implementation can support RTZ
    pub shader_rounding_mode_rtz_float16: Bool32,
    /// An implementation can support RTZ
    pub shader_rounding_mode_rtz_float32: Bool32,
    /// An implementation can support RTZ
    pub shader_rounding_mode_rtz_float64: Bool32,
    pub max_update_after_bind_descriptors_in_all_pools: u32,
    pub shader_uniform_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_image_array_non_uniform_indexing_native: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing_native: Bool32,
    pub robust_buffer_access_update_after_bind: Bool32,
    pub quad_divergent_implicit_lod: Bool32,
    pub max_per_stage_descriptor_update_after_bind_samplers: u32,
    pub max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_images: u32,
    pub max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    pub max_per_stage_update_after_bind_resources: u32,
    pub max_descriptor_set_update_after_bind_samplers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_sampled_images: u32,
    pub max_descriptor_set_update_after_bind_storage_images: u32,
    pub max_descriptor_set_update_after_bind_input_attachments: u32,
    /// supported depth resolve modes
    pub supported_depth_resolve_modes: ResolveModeFlags,
    /// supported stencil resolve modes
    pub supported_stencil_resolve_modes: ResolveModeFlags,
    /// depth and stencil resolve modes can be set independently if one of them is none
    pub independent_resolve_none: Bool32,
    /// depth and stencil resolve modes can be set independently
    pub independent_resolve: Bool32,
    pub filter_minmax_single_component_formats: Bool32,
    pub filter_minmax_image_component_mapping: Bool32,
    pub max_timeline_semaphore_value_difference: u64,
    pub framebuffer_integer_color_sample_counts: SampleCountFlags,
}
unsafe impl Send for PhysicalDeviceVulkan12Properties {}
unsafe impl Sync for PhysicalDeviceVulkan12Properties {}
impl Default for PhysicalDeviceVulkan12Properties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
            p_next: ptr::null_mut(),
            driver_id: Default::default(),
            driver_name: [Default::default(); MAX_DRIVER_NAME_SIZE],
            driver_info: [Default::default(); MAX_DRIVER_INFO_SIZE],
            conformance_version: Default::default(),
            denorm_behavior_independence: Default::default(),
            rounding_mode_independence: Default::default(),
            shader_signed_zero_inf_nan_preserve_float16: Default::default(),
            shader_signed_zero_inf_nan_preserve_float32: Default::default(),
            shader_signed_zero_inf_nan_preserve_float64: Default::default(),
            shader_denorm_preserve_float16: Default::default(),
            shader_denorm_preserve_float32: Default::default(),
            shader_denorm_preserve_float64: Default::default(),
            shader_denorm_flush_to_zero_float16: Default::default(),
            shader_denorm_flush_to_zero_float32: Default::default(),
            shader_denorm_flush_to_zero_float64: Default::default(),
            shader_rounding_mode_rte_float16: Default::default(),
            shader_rounding_mode_rte_float32: Default::default(),
            shader_rounding_mode_rte_float64: Default::default(),
            shader_rounding_mode_rtz_float16: Default::default(),
            shader_rounding_mode_rtz_float32: Default::default(),
            shader_rounding_mode_rtz_float64: Default::default(),
            max_update_after_bind_descriptors_in_all_pools: Default::default(),
            shader_uniform_buffer_array_non_uniform_indexing_native: Default::default(),
            shader_sampled_image_array_non_uniform_indexing_native: Default::default(),
            shader_storage_buffer_array_non_uniform_indexing_native: Default::default(),
            shader_storage_image_array_non_uniform_indexing_native: Default::default(),
            shader_input_attachment_array_non_uniform_indexing_native: Default::default(),
            robust_buffer_access_update_after_bind: Default::default(),
            quad_divergent_implicit_lod: Default::default(),
            max_per_stage_descriptor_update_after_bind_samplers: Default::default(),
            max_per_stage_descriptor_update_after_bind_uniform_buffers: Default::default(),
            max_per_stage_descriptor_update_after_bind_storage_buffers: Default::default(),
            max_per_stage_descriptor_update_after_bind_sampled_images: Default::default(),
            max_per_stage_descriptor_update_after_bind_storage_images: Default::default(),
            max_per_stage_descriptor_update_after_bind_input_attachments: Default::default(),
            max_per_stage_update_after_bind_resources: Default::default(),
            max_descriptor_set_update_after_bind_samplers: Default::default(),
            max_descriptor_set_update_after_bind_uniform_buffers: Default::default(),
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic: Default::default(),
            max_descriptor_set_update_after_bind_storage_buffers: Default::default(),
            max_descriptor_set_update_after_bind_storage_buffers_dynamic: Default::default(),
            max_descriptor_set_update_after_bind_sampled_images: Default::default(),
            max_descriptor_set_update_after_bind_storage_images: Default::default(),
            max_descriptor_set_update_after_bind_input_attachments: Default::default(),
            supported_depth_resolve_modes: Default::default(),
            supported_stencil_resolve_modes: Default::default(),
            independent_resolve_none: Default::default(),
            independent_resolve: Default::default(),
            filter_minmax_single_component_formats: Default::default(),
            filter_minmax_image_component_mapping: Default::default(),
            max_timeline_semaphore_value_difference: Default::default(),
            framebuffer_integer_color_sample_counts: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVulkan12Properties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVulkan12Properties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("driver_id", &self.driver_id)
            .field("driver_name", &unsafe { CStr::from_ptr(self.driver_name.as_ptr()) })
            .field("driver_info", &unsafe { CStr::from_ptr(self.driver_info.as_ptr()) })
            .field("conformance_version", &self.conformance_version)
            .field("denorm_behavior_independence", &self.denorm_behavior_independence)
            .field("rounding_mode_independence", &self.rounding_mode_independence)
            .field(
                "shader_signed_zero_inf_nan_preserve_float16",
                &self.shader_signed_zero_inf_nan_preserve_float16,
            )
            .field(
                "shader_signed_zero_inf_nan_preserve_float32",
                &self.shader_signed_zero_inf_nan_preserve_float32,
            )
            .field(
                "shader_signed_zero_inf_nan_preserve_float64",
                &self.shader_signed_zero_inf_nan_preserve_float64,
            )
            .field("shader_denorm_preserve_float16", &self.shader_denorm_preserve_float16)
            .field("shader_denorm_preserve_float32", &self.shader_denorm_preserve_float32)
            .field("shader_denorm_preserve_float64", &self.shader_denorm_preserve_float64)
            .field(
                "shader_denorm_flush_to_zero_float16",
                &self.shader_denorm_flush_to_zero_float16,
            )
            .field(
                "shader_denorm_flush_to_zero_float32",
                &self.shader_denorm_flush_to_zero_float32,
            )
            .field(
                "shader_denorm_flush_to_zero_float64",
                &self.shader_denorm_flush_to_zero_float64,
            )
            .field(
                "shader_rounding_mode_rte_float16",
                &self.shader_rounding_mode_rte_float16,
            )
            .field(
                "shader_rounding_mode_rte_float32",
                &self.shader_rounding_mode_rte_float32,
            )
            .field(
                "shader_rounding_mode_rte_float64",
                &self.shader_rounding_mode_rte_float64,
            )
            .field(
                "shader_rounding_mode_rtz_float16",
                &self.shader_rounding_mode_rtz_float16,
            )
            .field(
                "shader_rounding_mode_rtz_float32",
                &self.shader_rounding_mode_rtz_float32,
            )
            .field(
                "shader_rounding_mode_rtz_float64",
                &self.shader_rounding_mode_rtz_float64,
            )
            .field(
                "max_update_after_bind_descriptors_in_all_pools",
                &self.max_update_after_bind_descriptors_in_all_pools,
            )
            .field(
                "shader_uniform_buffer_array_non_uniform_indexing_native",
                &self.shader_uniform_buffer_array_non_uniform_indexing_native,
            )
            .field(
                "shader_sampled_image_array_non_uniform_indexing_native",
                &self.shader_sampled_image_array_non_uniform_indexing_native,
            )
            .field(
                "shader_storage_buffer_array_non_uniform_indexing_native",
                &self.shader_storage_buffer_array_non_uniform_indexing_native,
            )
            .field(
                "shader_storage_image_array_non_uniform_indexing_native",
                &self.shader_storage_image_array_non_uniform_indexing_native,
            )
            .field(
                "shader_input_attachment_array_non_uniform_indexing_native",
                &self.shader_input_attachment_array_non_uniform_indexing_native,
            )
            .field(
                "robust_buffer_access_update_after_bind",
                &self.robust_buffer_access_update_after_bind,
            )
            .field("quad_divergent_implicit_lod", &self.quad_divergent_implicit_lod)
            .field(
                "max_per_stage_descriptor_update_after_bind_samplers",
                &self.max_per_stage_descriptor_update_after_bind_samplers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_uniform_buffers",
                &self.max_per_stage_descriptor_update_after_bind_uniform_buffers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_storage_buffers",
                &self.max_per_stage_descriptor_update_after_bind_storage_buffers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_sampled_images",
                &self.max_per_stage_descriptor_update_after_bind_sampled_images,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_storage_images",
                &self.max_per_stage_descriptor_update_after_bind_storage_images,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_input_attachments",
                &self.max_per_stage_descriptor_update_after_bind_input_attachments,
            )
            .field(
                "max_per_stage_update_after_bind_resources",
                &self.max_per_stage_update_after_bind_resources,
            )
            .field(
                "max_descriptor_set_update_after_bind_samplers",
                &self.max_descriptor_set_update_after_bind_samplers,
            )
            .field(
                "max_descriptor_set_update_after_bind_uniform_buffers",
                &self.max_descriptor_set_update_after_bind_uniform_buffers,
            )
            .field(
                "max_descriptor_set_update_after_bind_uniform_buffers_dynamic",
                &self.max_descriptor_set_update_after_bind_uniform_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_buffers",
                &self.max_descriptor_set_update_after_bind_storage_buffers,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_buffers_dynamic",
                &self.max_descriptor_set_update_after_bind_storage_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_update_after_bind_sampled_images",
                &self.max_descriptor_set_update_after_bind_sampled_images,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_images",
                &self.max_descriptor_set_update_after_bind_storage_images,
            )
            .field(
                "max_descriptor_set_update_after_bind_input_attachments",
                &self.max_descriptor_set_update_after_bind_input_attachments,
            )
            .field("supported_depth_resolve_modes", &self.supported_depth_resolve_modes)
            .field("supported_stencil_resolve_modes", &self.supported_stencil_resolve_modes)
            .field("independent_resolve_none", &self.independent_resolve_none)
            .field("independent_resolve", &self.independent_resolve)
            .field(
                "filter_minmax_single_component_formats",
                &self.filter_minmax_single_component_formats,
            )
            .field(
                "filter_minmax_image_component_mapping",
                &self.filter_minmax_image_component_mapping,
            )
            .field(
                "max_timeline_semaphore_value_difference",
                &self.max_timeline_semaphore_value_difference,
            )
            .field(
                "framebuffer_integer_color_sample_counts",
                &self.framebuffer_integer_color_sample_counts,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVulkan13Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_image_access: Bool32,
    pub inline_uniform_block: Bool32,
    pub descriptor_binding_inline_uniform_block_update_after_bind: Bool32,
    pub pipeline_creation_cache_control: Bool32,
    pub private_data: Bool32,
    pub shader_demote_to_helper_invocation: Bool32,
    pub shader_terminate_invocation: Bool32,
    pub subgroup_size_control: Bool32,
    pub compute_full_subgroups: Bool32,
    pub synchronization2: Bool32,
    pub texture_compression_astc_hdr: Bool32,
    pub shader_zero_initialize_workgroup_memory: Bool32,
    pub dynamic_rendering: Bool32,
    pub shader_integer_dot_product: Bool32,
    pub maintenance4: Bool32,
}
unsafe impl Send for PhysicalDeviceVulkan13Features {}
unsafe impl Sync for PhysicalDeviceVulkan13Features {}
impl Default for PhysicalDeviceVulkan13Features {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
            p_next: ptr::null_mut(),
            robust_image_access: Default::default(),
            inline_uniform_block: Default::default(),
            descriptor_binding_inline_uniform_block_update_after_bind: Default::default(),
            pipeline_creation_cache_control: Default::default(),
            private_data: Default::default(),
            shader_demote_to_helper_invocation: Default::default(),
            shader_terminate_invocation: Default::default(),
            subgroup_size_control: Default::default(),
            compute_full_subgroups: Default::default(),
            synchronization2: Default::default(),
            texture_compression_astc_hdr: Default::default(),
            shader_zero_initialize_workgroup_memory: Default::default(),
            dynamic_rendering: Default::default(),
            shader_integer_dot_product: Default::default(),
            maintenance4: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVulkan13Features {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVulkan13Features")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("robust_image_access", &self.robust_image_access)
            .field("inline_uniform_block", &self.inline_uniform_block)
            .field(
                "descriptor_binding_inline_uniform_block_update_after_bind",
                &self.descriptor_binding_inline_uniform_block_update_after_bind,
            )
            .field("pipeline_creation_cache_control", &self.pipeline_creation_cache_control)
            .field("private_data", &self.private_data)
            .field(
                "shader_demote_to_helper_invocation",
                &self.shader_demote_to_helper_invocation,
            )
            .field("shader_terminate_invocation", &self.shader_terminate_invocation)
            .field("subgroup_size_control", &self.subgroup_size_control)
            .field("compute_full_subgroups", &self.compute_full_subgroups)
            .field("synchronization2", &self.synchronization2)
            .field("texture_compression_astc_hdr", &self.texture_compression_astc_hdr)
            .field(
                "shader_zero_initialize_workgroup_memory",
                &self.shader_zero_initialize_workgroup_memory,
            )
            .field("dynamic_rendering", &self.dynamic_rendering)
            .field("shader_integer_dot_product", &self.shader_integer_dot_product)
            .field("maintenance4", &self.maintenance4)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVulkan13Properties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// The minimum subgroup size supported by this device
    pub min_subgroup_size: u32,
    /// The maximum subgroup size supported by this device
    pub max_subgroup_size: u32,
    /// The maximum number of subgroups supported in a workgroup
    pub max_compute_workgroup_subgroups: u32,
    /// The shader stages that support specifying a subgroup size
    pub required_subgroup_size_stages: ShaderStageFlags,
    pub max_inline_uniform_block_size: u32,
    pub max_per_stage_descriptor_inline_uniform_blocks: u32,
    pub max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    pub max_descriptor_set_inline_uniform_blocks: u32,
    pub max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    pub max_inline_uniform_total_size: u32,
    pub integer_dot_product8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product8_bit_signed_accelerated: Bool32,
    pub integer_dot_product8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product16_bit_signed_accelerated: Bool32,
    pub integer_dot_product16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product32_bit_signed_accelerated: Bool32,
    pub integer_dot_product32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product64_bit_signed_accelerated: Bool32,
    pub integer_dot_product64_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Bool32,
    pub storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub storage_texel_buffer_offset_single_texel_alignment: Bool32,
    pub uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub uniform_texel_buffer_offset_single_texel_alignment: Bool32,
    pub max_buffer_size: DeviceSize,
}
unsafe impl Send for PhysicalDeviceVulkan13Properties {}
unsafe impl Sync for PhysicalDeviceVulkan13Properties {}
impl Default for PhysicalDeviceVulkan13Properties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES,
            p_next: ptr::null_mut(),
            min_subgroup_size: Default::default(),
            max_subgroup_size: Default::default(),
            max_compute_workgroup_subgroups: Default::default(),
            required_subgroup_size_stages: Default::default(),
            max_inline_uniform_block_size: Default::default(),
            max_per_stage_descriptor_inline_uniform_blocks: Default::default(),
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: Default::default(),
            max_descriptor_set_inline_uniform_blocks: Default::default(),
            max_descriptor_set_update_after_bind_inline_uniform_blocks: Default::default(),
            max_inline_uniform_total_size: Default::default(),
            integer_dot_product8_bit_unsigned_accelerated: Default::default(),
            integer_dot_product8_bit_signed_accelerated: Default::default(),
            integer_dot_product8_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product4x8_bit_packed_unsigned_accelerated: Default::default(),
            integer_dot_product4x8_bit_packed_signed_accelerated: Default::default(),
            integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Default::default(),
            integer_dot_product16_bit_unsigned_accelerated: Default::default(),
            integer_dot_product16_bit_signed_accelerated: Default::default(),
            integer_dot_product16_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product32_bit_unsigned_accelerated: Default::default(),
            integer_dot_product32_bit_signed_accelerated: Default::default(),
            integer_dot_product32_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product64_bit_unsigned_accelerated: Default::default(),
            integer_dot_product64_bit_signed_accelerated: Default::default(),
            integer_dot_product64_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Default::default(),
            storage_texel_buffer_offset_alignment_bytes: Default::default(),
            storage_texel_buffer_offset_single_texel_alignment: Default::default(),
            uniform_texel_buffer_offset_alignment_bytes: Default::default(),
            uniform_texel_buffer_offset_single_texel_alignment: Default::default(),
            max_buffer_size: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVulkan13Properties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVulkan13Properties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_subgroup_size", &self.min_subgroup_size)
            .field("max_subgroup_size", &self.max_subgroup_size)
            .field("max_compute_workgroup_subgroups", &self.max_compute_workgroup_subgroups)
            .field("required_subgroup_size_stages", &self.required_subgroup_size_stages)
            .field("max_inline_uniform_block_size", &self.max_inline_uniform_block_size)
            .field(
                "max_per_stage_descriptor_inline_uniform_blocks",
                &self.max_per_stage_descriptor_inline_uniform_blocks,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_inline_uniform_blocks",
                &self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks,
            )
            .field(
                "max_descriptor_set_inline_uniform_blocks",
                &self.max_descriptor_set_inline_uniform_blocks,
            )
            .field(
                "max_descriptor_set_update_after_bind_inline_uniform_blocks",
                &self.max_descriptor_set_update_after_bind_inline_uniform_blocks,
            )
            .field("max_inline_uniform_total_size", &self.max_inline_uniform_total_size)
            .field(
                "integer_dot_product8_bit_unsigned_accelerated",
                &self.integer_dot_product8_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product8_bit_signed_accelerated",
                &self.integer_dot_product8_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product8_bit_mixed_signedness_accelerated",
                &self.integer_dot_product8_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product4x8_bit_packed_unsigned_accelerated",
                &self.integer_dot_product4x8_bit_packed_unsigned_accelerated,
            )
            .field(
                "integer_dot_product4x8_bit_packed_signed_accelerated",
                &self.integer_dot_product4x8_bit_packed_signed_accelerated,
            )
            .field(
                "integer_dot_product4x8_bit_packed_mixed_signedness_accelerated",
                &self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product16_bit_unsigned_accelerated",
                &self.integer_dot_product16_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product16_bit_signed_accelerated",
                &self.integer_dot_product16_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product16_bit_mixed_signedness_accelerated",
                &self.integer_dot_product16_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product32_bit_unsigned_accelerated",
                &self.integer_dot_product32_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product32_bit_signed_accelerated",
                &self.integer_dot_product32_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product32_bit_mixed_signedness_accelerated",
                &self.integer_dot_product32_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product64_bit_unsigned_accelerated",
                &self.integer_dot_product64_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product64_bit_signed_accelerated",
                &self.integer_dot_product64_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product64_bit_mixed_signedness_accelerated",
                &self.integer_dot_product64_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated,
            )
            .field(
                "storage_texel_buffer_offset_alignment_bytes",
                &self.storage_texel_buffer_offset_alignment_bytes,
            )
            .field(
                "storage_texel_buffer_offset_single_texel_alignment",
                &self.storage_texel_buffer_offset_single_texel_alignment,
            )
            .field(
                "uniform_texel_buffer_offset_alignment_bytes",
                &self.uniform_texel_buffer_offset_alignment_bytes,
            )
            .field(
                "uniform_texel_buffer_offset_single_texel_alignment",
                &self.uniform_texel_buffer_offset_single_texel_alignment,
            )
            .field("max_buffer_size", &self.max_buffer_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineCompilerControlCreateInfoAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub compiler_control_flags: PipelineCompilerControlFlagsAMD,
}
unsafe impl Send for PipelineCompilerControlCreateInfoAMD {}
unsafe impl Sync for PipelineCompilerControlCreateInfoAMD {}
impl Default for PipelineCompilerControlCreateInfoAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
            p_next: ptr::null(),
            compiler_control_flags: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineCompilerControlCreateInfoAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineCompilerControlCreateInfoAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("compiler_control_flags", &self.compiler_control_flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceCoherentMemoryFeaturesAMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_coherent_memory: Bool32,
}
unsafe impl Send for PhysicalDeviceCoherentMemoryFeaturesAMD {}
unsafe impl Sync for PhysicalDeviceCoherentMemoryFeaturesAMD {}
impl Default for PhysicalDeviceCoherentMemoryFeaturesAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD,
            p_next: ptr::null_mut(),
            device_coherent_memory: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceCoherentMemoryFeaturesAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceCoherentMemoryFeaturesAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("device_coherent_memory", &self.device_coherent_memory)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceToolProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub name: [c_char; MAX_EXTENSION_NAME_SIZE],
    pub version: [c_char; MAX_EXTENSION_NAME_SIZE],
    pub purposes: ToolPurposeFlags,
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub layer: [c_char; MAX_EXTENSION_NAME_SIZE],
}
unsafe impl Send for PhysicalDeviceToolProperties {}
unsafe impl Sync for PhysicalDeviceToolProperties {}
impl Default for PhysicalDeviceToolProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_TOOL_PROPERTIES,
            p_next: ptr::null_mut(),
            name: [Default::default(); MAX_EXTENSION_NAME_SIZE],
            version: [Default::default(); MAX_EXTENSION_NAME_SIZE],
            purposes: Default::default(),
            description: [Default::default(); MAX_DESCRIPTION_SIZE],
            layer: [Default::default(); MAX_EXTENSION_NAME_SIZE],
        }
    }
}
impl fmt::Debug for PhysicalDeviceToolProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceToolProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("name", &unsafe { CStr::from_ptr(self.name.as_ptr()) })
            .field("version", &unsafe { CStr::from_ptr(self.version.as_ptr()) })
            .field("purposes", &self.purposes)
            .field("description", &unsafe { CStr::from_ptr(self.description.as_ptr()) })
            .field("layer", &unsafe { CStr::from_ptr(self.layer.as_ptr()) })
            .finish()
    }
}
pub type PhysicalDeviceToolPropertiesEXT = PhysicalDeviceToolProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplerCustomBorderColorCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub custom_border_color: ClearColorValue,
    pub format: Format,
}
unsafe impl Send for SamplerCustomBorderColorCreateInfoEXT {}
unsafe impl Sync for SamplerCustomBorderColorCreateInfoEXT {}
impl Default for SamplerCustomBorderColorCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT,
            p_next: ptr::null(),
            custom_border_color: Default::default(),
            format: Default::default(),
        }
    }
}
impl fmt::Debug for SamplerCustomBorderColorCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerCustomBorderColorCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("custom_border_color", &self.custom_border_color)
            .field("format", &self.format)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceCustomBorderColorPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_custom_border_color_samplers: u32,
}
unsafe impl Send for PhysicalDeviceCustomBorderColorPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceCustomBorderColorPropertiesEXT {}
impl Default for PhysicalDeviceCustomBorderColorPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            max_custom_border_color_samplers: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceCustomBorderColorPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceCustomBorderColorPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "max_custom_border_color_samplers",
                &self.max_custom_border_color_samplers,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceCustomBorderColorFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub custom_border_colors: Bool32,
    pub custom_border_color_without_format: Bool32,
}
unsafe impl Send for PhysicalDeviceCustomBorderColorFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceCustomBorderColorFeaturesEXT {}
impl Default for PhysicalDeviceCustomBorderColorFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
            p_next: ptr::null_mut(),
            custom_border_colors: Default::default(),
            custom_border_color_without_format: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceCustomBorderColorFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceCustomBorderColorFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("custom_border_colors", &self.custom_border_colors)
            .field(
                "custom_border_color_without_format",
                &self.custom_border_color_without_format,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplerBorderColorComponentMappingCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub components: ComponentMapping,
    pub srgb: Bool32,
}
unsafe impl Send for SamplerBorderColorComponentMappingCreateInfoEXT {}
unsafe impl Sync for SamplerBorderColorComponentMappingCreateInfoEXT {}
impl Default for SamplerBorderColorComponentMappingCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT,
            p_next: ptr::null(),
            components: Default::default(),
            srgb: Default::default(),
        }
    }
}
impl fmt::Debug for SamplerBorderColorComponentMappingCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerBorderColorComponentMappingCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("components", &self.components)
            .field("srgb", &self.srgb)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceBorderColorSwizzleFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub border_color_swizzle: Bool32,
    pub border_color_swizzle_from_image: Bool32,
}
unsafe impl Send for PhysicalDeviceBorderColorSwizzleFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceBorderColorSwizzleFeaturesEXT {}
impl Default for PhysicalDeviceBorderColorSwizzleFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,
            p_next: ptr::null_mut(),
            border_color_swizzle: Default::default(),
            border_color_swizzle_from_image: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceBorderColorSwizzleFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceBorderColorSwizzleFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("border_color_swizzle", &self.border_color_swizzle)
            .field("border_color_swizzle_from_image", &self.border_color_swizzle_from_image)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DeviceOrHostAddressKHR {
    pub device_address: DeviceAddress,
    pub host_address: *mut c_void,
}
unsafe impl Send for DeviceOrHostAddressKHR {}
unsafe impl Sync for DeviceOrHostAddressKHR {}
impl Default for DeviceOrHostAddressKHR {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for DeviceOrHostAddressKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceOrHostAddressKHR")
            .field("device_address", unsafe { &self.device_address })
            .field("host_address", unsafe { &self.host_address })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DeviceOrHostAddressConstKHR {
    pub device_address: DeviceAddress,
    pub host_address: *const c_void,
}
unsafe impl Send for DeviceOrHostAddressConstKHR {}
unsafe impl Sync for DeviceOrHostAddressConstKHR {}
impl Default for DeviceOrHostAddressConstKHR {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for DeviceOrHostAddressConstKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceOrHostAddressConstKHR")
            .field("device_address", unsafe { &self.device_address })
            .field("host_address", unsafe { &self.host_address })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureGeometryTrianglesDataKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_format: Format,
    pub vertex_data: DeviceOrHostAddressConstKHR,
    pub vertex_stride: DeviceSize,
    pub max_vertex: u32,
    pub index_type: IndexType,
    pub index_data: DeviceOrHostAddressConstKHR,
    pub transform_data: DeviceOrHostAddressConstKHR,
}
unsafe impl Send for AccelerationStructureGeometryTrianglesDataKHR {}
unsafe impl Sync for AccelerationStructureGeometryTrianglesDataKHR {}
impl Default for AccelerationStructureGeometryTrianglesDataKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,
            p_next: ptr::null(),
            vertex_format: Default::default(),
            vertex_data: Default::default(),
            vertex_stride: Default::default(),
            max_vertex: Default::default(),
            index_type: Default::default(),
            index_data: Default::default(),
            transform_data: Default::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureGeometryTrianglesDataKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryTrianglesDataKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vertex_format", &self.vertex_format)
            .field("vertex_data", &self.vertex_data)
            .field("vertex_stride", &self.vertex_stride)
            .field("max_vertex", &self.max_vertex)
            .field("index_type", &self.index_type)
            .field("index_data", &self.index_data)
            .field("transform_data", &self.transform_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureGeometryAabbsDataKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub data: DeviceOrHostAddressConstKHR,
    pub stride: DeviceSize,
}
unsafe impl Send for AccelerationStructureGeometryAabbsDataKHR {}
unsafe impl Sync for AccelerationStructureGeometryAabbsDataKHR {}
impl Default for AccelerationStructureGeometryAabbsDataKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR,
            p_next: ptr::null(),
            data: Default::default(),
            stride: Default::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureGeometryAabbsDataKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryAabbsDataKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("data", &self.data)
            .field("stride", &self.stride)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureGeometryInstancesDataKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub array_of_pointers: Bool32,
    pub data: DeviceOrHostAddressConstKHR,
}
unsafe impl Send for AccelerationStructureGeometryInstancesDataKHR {}
unsafe impl Sync for AccelerationStructureGeometryInstancesDataKHR {}
impl Default for AccelerationStructureGeometryInstancesDataKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR,
            p_next: ptr::null(),
            array_of_pointers: Default::default(),
            data: Default::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureGeometryInstancesDataKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryInstancesDataKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("array_of_pointers", &self.array_of_pointers)
            .field("data", &self.data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AccelerationStructureGeometryDataKHR {
    pub triangles: AccelerationStructureGeometryTrianglesDataKHR,
    pub aabbs: AccelerationStructureGeometryAabbsDataKHR,
    pub instances: AccelerationStructureGeometryInstancesDataKHR,
}
impl Default for AccelerationStructureGeometryDataKHR {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for AccelerationStructureGeometryDataKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryDataKHR")
            .field("triangles", unsafe { &self.triangles })
            .field("aabbs", unsafe { &self.aabbs })
            .field("instances", unsafe { &self.instances })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureGeometryKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub geometry_type: GeometryTypeKHR,
    pub geometry: AccelerationStructureGeometryDataKHR,
    pub flags: GeometryFlagsKHR,
}
unsafe impl Send for AccelerationStructureGeometryKHR {}
unsafe impl Sync for AccelerationStructureGeometryKHR {}
impl Default for AccelerationStructureGeometryKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_GEOMETRY_KHR,
            p_next: ptr::null(),
            geometry_type: Default::default(),
            geometry: Default::default(),
            flags: Default::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureGeometryKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("geometry_type", &self.geometry_type)
            .field("geometry", &self.geometry)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureBuildGeometryInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: AccelerationStructureTypeKHR,
    pub flags: BuildAccelerationStructureFlagsKHR,
    pub mode: BuildAccelerationStructureModeKHR,
    pub src_acceleration_structure: Option<AccelerationStructureKHR>,
    pub dst_acceleration_structure: Option<AccelerationStructureKHR>,
    pub geometry_count: u32,
    pub p_geometries: *const AccelerationStructureGeometryKHR,
    pub pp_geometries: *const *const AccelerationStructureGeometryKHR,
    pub scratch_data: DeviceOrHostAddressKHR,
}
unsafe impl Send for AccelerationStructureBuildGeometryInfoKHR {}
unsafe impl Sync for AccelerationStructureBuildGeometryInfoKHR {}
impl Default for AccelerationStructureBuildGeometryInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
            p_next: ptr::null(),
            ty: Default::default(),
            flags: Default::default(),
            mode: Default::default(),
            src_acceleration_structure: Default::default(),
            dst_acceleration_structure: Default::default(),
            geometry_count: Default::default(),
            p_geometries: ptr::null(),
            pp_geometries: ptr::null(),
            scratch_data: Default::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureBuildGeometryInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureBuildGeometryInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("flags", &self.flags)
            .field("mode", &self.mode)
            .field("src_acceleration_structure", &self.src_acceleration_structure)
            .field("dst_acceleration_structure", &self.dst_acceleration_structure)
            .field("geometry_count", &self.geometry_count)
            .field("p_geometries", &self.p_geometries)
            .field("pp_geometries", &self.pp_geometries)
            .field("scratch_data", &self.scratch_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct AccelerationStructureBuildRangeInfoKHR {
    pub primitive_count: u32,
    pub primitive_offset: u32,
    pub first_vertex: u32,
    pub transform_offset: u32,
}
impl fmt::Debug for AccelerationStructureBuildRangeInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureBuildRangeInfoKHR")
            .field("primitive_count", &self.primitive_count)
            .field("primitive_offset", &self.primitive_offset)
            .field("first_vertex", &self.first_vertex)
            .field("transform_offset", &self.transform_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub create_flags: AccelerationStructureCreateFlagsKHR,
    pub buffer: Option<Buffer>,
    /// Specified in bytes
    pub offset: DeviceSize,
    pub size: DeviceSize,
    pub ty: AccelerationStructureTypeKHR,
    pub device_address: DeviceAddress,
}
unsafe impl Send for AccelerationStructureCreateInfoKHR {}
unsafe impl Sync for AccelerationStructureCreateInfoKHR {}
impl Default for AccelerationStructureCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            create_flags: Default::default(),
            buffer: Default::default(),
            offset: Default::default(),
            size: Default::default(),
            ty: Default::default(),
            device_address: Default::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("create_flags", &self.create_flags)
            .field("buffer", &self.buffer)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .field("ty", &self.ty)
            .field("device_address", &self.device_address)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct AabbPositionsKHR {
    pub min_x: f32,
    pub min_y: f32,
    pub min_z: f32,
    pub max_x: f32,
    pub max_y: f32,
    pub max_z: f32,
}
impl fmt::Debug for AabbPositionsKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AabbPositionsKHR")
            .field("min_x", &self.min_x)
            .field("min_y", &self.min_y)
            .field("min_z", &self.min_z)
            .field("max_x", &self.max_x)
            .field("max_y", &self.max_y)
            .field("max_z", &self.max_z)
            .finish()
    }
}
pub type AabbPositionsNV = AabbPositionsKHR;
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct TransformMatrixKHR {
    pub matrix: [f32; 12],
}
impl fmt::Debug for TransformMatrixKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("TransformMatrixKHR")
            .field("matrix", &self.matrix)
            .finish()
    }
}
pub type TransformMatrixNV = TransformMatrixKHR;
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct AccelerationStructureInstanceKHR {
    pub transform: TransformMatrixKHR,
    pub instance_custom_index_and_mask: u32,
    pub instance_shader_binding_table_record_offset_and_flags: u32,
    pub acceleration_structure_reference: u64,
}
impl fmt::Debug for AccelerationStructureInstanceKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureInstanceKHR")
            .field("transform", &self.transform)
            .field("instance_custom_index_and_mask", &self.instance_custom_index_and_mask)
            .field(
                "instance_shader_binding_table_record_offset_and_flags",
                &self.instance_shader_binding_table_record_offset_and_flags,
            )
            .field(
                "acceleration_structure_reference",
                &self.acceleration_structure_reference,
            )
            .finish()
    }
}
pub type AccelerationStructureInstanceNV = AccelerationStructureInstanceKHR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureDeviceAddressInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure: Option<AccelerationStructureKHR>,
}
unsafe impl Send for AccelerationStructureDeviceAddressInfoKHR {}
unsafe impl Sync for AccelerationStructureDeviceAddressInfoKHR {}
impl Default for AccelerationStructureDeviceAddressInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR,
            p_next: ptr::null(),
            acceleration_structure: Default::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureDeviceAddressInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureDeviceAddressInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acceleration_structure", &self.acceleration_structure)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureVersionInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_version_data: *const u8,
}
unsafe impl Send for AccelerationStructureVersionInfoKHR {}
unsafe impl Sync for AccelerationStructureVersionInfoKHR {}
impl Default for AccelerationStructureVersionInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_VERSION_INFO_KHR,
            p_next: ptr::null(),
            p_version_data: ptr::null(),
        }
    }
}
impl fmt::Debug for AccelerationStructureVersionInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureVersionInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_version_data", &self.p_version_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyAccelerationStructureInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: Option<AccelerationStructureKHR>,
    pub dst: Option<AccelerationStructureKHR>,
    pub mode: CopyAccelerationStructureModeKHR,
}
unsafe impl Send for CopyAccelerationStructureInfoKHR {}
unsafe impl Sync for CopyAccelerationStructureInfoKHR {}
impl Default for CopyAccelerationStructureInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_ACCELERATION_STRUCTURE_INFO_KHR,
            p_next: ptr::null(),
            src: Default::default(),
            dst: Default::default(),
            mode: Default::default(),
        }
    }
}
impl fmt::Debug for CopyAccelerationStructureInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyAccelerationStructureInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src", &self.src)
            .field("dst", &self.dst)
            .field("mode", &self.mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyAccelerationStructureToMemoryInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: Option<AccelerationStructureKHR>,
    pub dst: DeviceOrHostAddressKHR,
    pub mode: CopyAccelerationStructureModeKHR,
}
unsafe impl Send for CopyAccelerationStructureToMemoryInfoKHR {}
unsafe impl Sync for CopyAccelerationStructureToMemoryInfoKHR {}
impl Default for CopyAccelerationStructureToMemoryInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR,
            p_next: ptr::null(),
            src: Default::default(),
            dst: Default::default(),
            mode: Default::default(),
        }
    }
}
impl fmt::Debug for CopyAccelerationStructureToMemoryInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyAccelerationStructureToMemoryInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src", &self.src)
            .field("dst", &self.dst)
            .field("mode", &self.mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyMemoryToAccelerationStructureInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: DeviceOrHostAddressConstKHR,
    pub dst: Option<AccelerationStructureKHR>,
    pub mode: CopyAccelerationStructureModeKHR,
}
unsafe impl Send for CopyMemoryToAccelerationStructureInfoKHR {}
unsafe impl Sync for CopyMemoryToAccelerationStructureInfoKHR {}
impl Default for CopyMemoryToAccelerationStructureInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR,
            p_next: ptr::null(),
            src: Default::default(),
            dst: Default::default(),
            mode: Default::default(),
        }
    }
}
impl fmt::Debug for CopyMemoryToAccelerationStructureInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyMemoryToAccelerationStructureInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src", &self.src)
            .field("dst", &self.dst)
            .field("mode", &self.mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RayTracingPipelineInterfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_pipeline_ray_payload_size: u32,
    pub max_pipeline_ray_hit_attribute_size: u32,
}
unsafe impl Send for RayTracingPipelineInterfaceCreateInfoKHR {}
unsafe impl Sync for RayTracingPipelineInterfaceCreateInfoKHR {}
impl Default for RayTracingPipelineInterfaceCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            max_pipeline_ray_payload_size: Default::default(),
            max_pipeline_ray_hit_attribute_size: Default::default(),
        }
    }
}
impl fmt::Debug for RayTracingPipelineInterfaceCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RayTracingPipelineInterfaceCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_pipeline_ray_payload_size", &self.max_pipeline_ray_payload_size)
            .field(
                "max_pipeline_ray_hit_attribute_size",
                &self.max_pipeline_ray_hit_attribute_size,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineLibraryCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub library_count: u32,
    pub p_libraries: *const Pipeline,
}
unsafe impl Send for PipelineLibraryCreateInfoKHR {}
unsafe impl Sync for PipelineLibraryCreateInfoKHR {}
impl Default for PipelineLibraryCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_LIBRARY_CREATE_INFO_KHR,
            p_next: ptr::null(),
            library_count: Default::default(),
            p_libraries: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineLibraryCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineLibraryCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("library_count", &self.library_count)
            .field("p_libraries", &self.p_libraries)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExtendedDynamicStateFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub extended_dynamic_state: Bool32,
}
unsafe impl Send for PhysicalDeviceExtendedDynamicStateFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceExtendedDynamicStateFeaturesEXT {}
impl Default for PhysicalDeviceExtendedDynamicStateFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
            p_next: ptr::null_mut(),
            extended_dynamic_state: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExtendedDynamicStateFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExtendedDynamicStateFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("extended_dynamic_state", &self.extended_dynamic_state)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExtendedDynamicState2FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub extended_dynamic_state2: Bool32,
    pub extended_dynamic_state2_logic_op: Bool32,
    pub extended_dynamic_state2_patch_control_points: Bool32,
}
unsafe impl Send for PhysicalDeviceExtendedDynamicState2FeaturesEXT {}
unsafe impl Sync for PhysicalDeviceExtendedDynamicState2FeaturesEXT {}
impl Default for PhysicalDeviceExtendedDynamicState2FeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT,
            p_next: ptr::null_mut(),
            extended_dynamic_state2: Default::default(),
            extended_dynamic_state2_logic_op: Default::default(),
            extended_dynamic_state2_patch_control_points: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExtendedDynamicState2FeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExtendedDynamicState2FeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("extended_dynamic_state2", &self.extended_dynamic_state2)
            .field(
                "extended_dynamic_state2_logic_op",
                &self.extended_dynamic_state2_logic_op,
            )
            .field(
                "extended_dynamic_state2_patch_control_points",
                &self.extended_dynamic_state2_patch_control_points,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassTransformBeginInfoQCOM {
    pub s_type: StructureType,
    /// Pointer to next structure
    pub p_next: *mut c_void,
    pub transform: SurfaceTransformFlagsKHR,
}
unsafe impl Send for RenderPassTransformBeginInfoQCOM {}
unsafe impl Sync for RenderPassTransformBeginInfoQCOM {}
impl Default for RenderPassTransformBeginInfoQCOM {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM,
            p_next: ptr::null_mut(),
            transform: Default::default(),
        }
    }
}
impl fmt::Debug for RenderPassTransformBeginInfoQCOM {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassTransformBeginInfoQCOM")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("transform", &self.transform)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyCommandTransformInfoQCOM {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub transform: SurfaceTransformFlagsKHR,
}
unsafe impl Send for CopyCommandTransformInfoQCOM {}
unsafe impl Sync for CopyCommandTransformInfoQCOM {}
impl Default for CopyCommandTransformInfoQCOM {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_COMMAND_TRANSFORM_INFO_QCOM,
            p_next: ptr::null(),
            transform: Default::default(),
        }
    }
}
impl fmt::Debug for CopyCommandTransformInfoQCOM {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyCommandTransformInfoQCOM")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("transform", &self.transform)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferInheritanceRenderPassTransformInfoQCOM {
    pub s_type: StructureType,
    /// Pointer to next structure
    pub p_next: *mut c_void,
    pub transform: SurfaceTransformFlagsKHR,
    pub render_area: Rect2D,
}
unsafe impl Send for CommandBufferInheritanceRenderPassTransformInfoQCOM {}
unsafe impl Sync for CommandBufferInheritanceRenderPassTransformInfoQCOM {}
impl Default for CommandBufferInheritanceRenderPassTransformInfoQCOM {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM,
            p_next: ptr::null_mut(),
            transform: Default::default(),
            render_area: Default::default(),
        }
    }
}
impl fmt::Debug for CommandBufferInheritanceRenderPassTransformInfoQCOM {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferInheritanceRenderPassTransformInfoQCOM")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("transform", &self.transform)
            .field("render_area", &self.render_area)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDiagnosticsConfigFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub diagnostics_config: Bool32,
}
unsafe impl Send for PhysicalDeviceDiagnosticsConfigFeaturesNV {}
unsafe impl Sync for PhysicalDeviceDiagnosticsConfigFeaturesNV {}
impl Default for PhysicalDeviceDiagnosticsConfigFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV,
            p_next: ptr::null_mut(),
            diagnostics_config: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDiagnosticsConfigFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDiagnosticsConfigFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("diagnostics_config", &self.diagnostics_config)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceDiagnosticsConfigCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceDiagnosticsConfigFlagsNV,
}
unsafe impl Send for DeviceDiagnosticsConfigCreateInfoNV {}
unsafe impl Sync for DeviceDiagnosticsConfigCreateInfoNV {}
impl Default for DeviceDiagnosticsConfigCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV,
            p_next: ptr::null(),
            flags: Default::default(),
        }
    }
}
impl fmt::Debug for DeviceDiagnosticsConfigCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceDiagnosticsConfigCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_zero_initialize_workgroup_memory: Bool32,
}
unsafe impl Send for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {}
unsafe impl Sync for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {}
impl Default for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
            p_next: ptr::null_mut(),
            shader_zero_initialize_workgroup_memory: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "shader_zero_initialize_workgroup_memory",
                &self.shader_zero_initialize_workgroup_memory,
            )
            .finish()
    }
}
pub type PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_subgroup_uniform_control_flow: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {}
impl Default for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
            p_next: ptr::null_mut(),
            shader_subgroup_uniform_control_flow: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "shader_subgroup_uniform_control_flow",
                &self.shader_subgroup_uniform_control_flow,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRobustness2FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_buffer_access2: Bool32,
    pub robust_image_access2: Bool32,
    pub null_descriptor: Bool32,
}
unsafe impl Send for PhysicalDeviceRobustness2FeaturesEXT {}
unsafe impl Sync for PhysicalDeviceRobustness2FeaturesEXT {}
impl Default for PhysicalDeviceRobustness2FeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT,
            p_next: ptr::null_mut(),
            robust_buffer_access2: Default::default(),
            robust_image_access2: Default::default(),
            null_descriptor: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRobustness2FeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRobustness2FeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("robust_buffer_access2", &self.robust_buffer_access2)
            .field("robust_image_access2", &self.robust_image_access2)
            .field("null_descriptor", &self.null_descriptor)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRobustness2PropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_storage_buffer_access_size_alignment: DeviceSize,
    pub robust_uniform_buffer_access_size_alignment: DeviceSize,
}
unsafe impl Send for PhysicalDeviceRobustness2PropertiesEXT {}
unsafe impl Sync for PhysicalDeviceRobustness2PropertiesEXT {}
impl Default for PhysicalDeviceRobustness2PropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            robust_storage_buffer_access_size_alignment: Default::default(),
            robust_uniform_buffer_access_size_alignment: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRobustness2PropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRobustness2PropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "robust_storage_buffer_access_size_alignment",
                &self.robust_storage_buffer_access_size_alignment,
            )
            .field(
                "robust_uniform_buffer_access_size_alignment",
                &self.robust_uniform_buffer_access_size_alignment,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImageRobustnessFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_image_access: Bool32,
}
unsafe impl Send for PhysicalDeviceImageRobustnessFeatures {}
unsafe impl Sync for PhysicalDeviceImageRobustnessFeatures {}
impl Default for PhysicalDeviceImageRobustnessFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
            p_next: ptr::null_mut(),
            robust_image_access: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImageRobustnessFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImageRobustnessFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("robust_image_access", &self.robust_image_access)
            .finish()
    }
}
pub type PhysicalDeviceImageRobustnessFeaturesEXT = PhysicalDeviceImageRobustnessFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub workgroup_memory_explicit_layout: Bool32,
    pub workgroup_memory_explicit_layout_scalar_block_layout: Bool32,
    pub workgroup_memory_explicit_layout8_bit_access: Bool32,
    pub workgroup_memory_explicit_layout16_bit_access: Bool32,
}
unsafe impl Send for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {}
impl Default for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR,
            p_next: ptr::null_mut(),
            workgroup_memory_explicit_layout: Default::default(),
            workgroup_memory_explicit_layout_scalar_block_layout: Default::default(),
            workgroup_memory_explicit_layout8_bit_access: Default::default(),
            workgroup_memory_explicit_layout16_bit_access: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "workgroup_memory_explicit_layout",
                &self.workgroup_memory_explicit_layout,
            )
            .field(
                "workgroup_memory_explicit_layout_scalar_block_layout",
                &self.workgroup_memory_explicit_layout_scalar_block_layout,
            )
            .field(
                "workgroup_memory_explicit_layout8_bit_access",
                &self.workgroup_memory_explicit_layout8_bit_access,
            )
            .field(
                "workgroup_memory_explicit_layout16_bit_access",
                &self.workgroup_memory_explicit_layout16_bit_access,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePortabilitySubsetFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub constant_alpha_color_blend_factors: Bool32,
    pub events: Bool32,
    pub image_view_format_reinterpretation: Bool32,
    pub image_view_format_swizzle: Bool32,
    pub image_view_2d_on_3d_image: Bool32,
    pub multisample_array_image: Bool32,
    pub mutable_comparison_samplers: Bool32,
    pub point_polygons: Bool32,
    pub sampler_mip_lod_bias: Bool32,
    pub separate_stencil_mask_ref: Bool32,
    pub shader_sample_rate_interpolation_functions: Bool32,
    pub tessellation_isolines: Bool32,
    pub tessellation_point_mode: Bool32,
    pub triangle_fans: Bool32,
    pub vertex_attribute_access_beyond_stride: Bool32,
}
unsafe impl Send for PhysicalDevicePortabilitySubsetFeaturesKHR {}
unsafe impl Sync for PhysicalDevicePortabilitySubsetFeaturesKHR {}
impl Default for PhysicalDevicePortabilitySubsetFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR,
            p_next: ptr::null_mut(),
            constant_alpha_color_blend_factors: Default::default(),
            events: Default::default(),
            image_view_format_reinterpretation: Default::default(),
            image_view_format_swizzle: Default::default(),
            image_view_2d_on_3d_image: Default::default(),
            multisample_array_image: Default::default(),
            mutable_comparison_samplers: Default::default(),
            point_polygons: Default::default(),
            sampler_mip_lod_bias: Default::default(),
            separate_stencil_mask_ref: Default::default(),
            shader_sample_rate_interpolation_functions: Default::default(),
            tessellation_isolines: Default::default(),
            tessellation_point_mode: Default::default(),
            triangle_fans: Default::default(),
            vertex_attribute_access_beyond_stride: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePortabilitySubsetFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePortabilitySubsetFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "constant_alpha_color_blend_factors",
                &self.constant_alpha_color_blend_factors,
            )
            .field("events", &self.events)
            .field(
                "image_view_format_reinterpretation",
                &self.image_view_format_reinterpretation,
            )
            .field("image_view_format_swizzle", &self.image_view_format_swizzle)
            .field("image_view_2d_on_3d_image", &self.image_view_2d_on_3d_image)
            .field("multisample_array_image", &self.multisample_array_image)
            .field("mutable_comparison_samplers", &self.mutable_comparison_samplers)
            .field("point_polygons", &self.point_polygons)
            .field("sampler_mip_lod_bias", &self.sampler_mip_lod_bias)
            .field("separate_stencil_mask_ref", &self.separate_stencil_mask_ref)
            .field(
                "shader_sample_rate_interpolation_functions",
                &self.shader_sample_rate_interpolation_functions,
            )
            .field("tessellation_isolines", &self.tessellation_isolines)
            .field("tessellation_point_mode", &self.tessellation_point_mode)
            .field("triangle_fans", &self.triangle_fans)
            .field(
                "vertex_attribute_access_beyond_stride",
                &self.vertex_attribute_access_beyond_stride,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePortabilitySubsetPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_vertex_input_binding_stride_alignment: u32,
}
unsafe impl Send for PhysicalDevicePortabilitySubsetPropertiesKHR {}
unsafe impl Sync for PhysicalDevicePortabilitySubsetPropertiesKHR {}
impl Default for PhysicalDevicePortabilitySubsetPropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            min_vertex_input_binding_stride_alignment: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePortabilitySubsetPropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePortabilitySubsetPropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "min_vertex_input_binding_stride_alignment",
                &self.min_vertex_input_binding_stride_alignment,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevice4444FormatsFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format_a4r4g4b4: Bool32,
    pub format_a4b4g4r4: Bool32,
}
unsafe impl Send for PhysicalDevice4444FormatsFeaturesEXT {}
unsafe impl Sync for PhysicalDevice4444FormatsFeaturesEXT {}
impl Default for PhysicalDevice4444FormatsFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
            p_next: ptr::null_mut(),
            format_a4r4g4b4: Default::default(),
            format_a4b4g4r4: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevice4444FormatsFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevice4444FormatsFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format_a4r4g4b4", &self.format_a4r4g4b4)
            .field("format_a4b4g4r4", &self.format_a4b4g4r4)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSubpassShadingFeaturesHUAWEI {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subpass_shading: Bool32,
}
unsafe impl Send for PhysicalDeviceSubpassShadingFeaturesHUAWEI {}
unsafe impl Sync for PhysicalDeviceSubpassShadingFeaturesHUAWEI {}
impl Default for PhysicalDeviceSubpassShadingFeaturesHUAWEI {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
            p_next: ptr::null_mut(),
            subpass_shading: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSubpassShadingFeaturesHUAWEI {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSubpassShadingFeaturesHUAWEI")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("subpass_shading", &self.subpass_shading)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferCopy2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Specified in bytes
    pub src_offset: DeviceSize,
    /// Specified in bytes
    pub dst_offset: DeviceSize,
    /// Specified in bytes
    pub size: DeviceSize,
}
unsafe impl Send for BufferCopy2 {}
unsafe impl Sync for BufferCopy2 {}
impl Default for BufferCopy2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_COPY_2,
            p_next: ptr::null(),
            src_offset: Default::default(),
            dst_offset: Default::default(),
            size: Default::default(),
        }
    }
}
impl fmt::Debug for BufferCopy2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCopy2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_offset", &self.src_offset)
            .field("dst_offset", &self.dst_offset)
            .field("size", &self.size)
            .finish()
    }
}
pub type BufferCopy2KHR = BufferCopy2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageCopy2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub dst_offset: Offset3D,
    /// Specified in pixels for both compressed and uncompressed images
    pub extent: Extent3D,
}
unsafe impl Send for ImageCopy2 {}
unsafe impl Sync for ImageCopy2 {}
impl Default for ImageCopy2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_COPY_2,
            p_next: ptr::null(),
            src_subresource: Default::default(),
            src_offset: Default::default(),
            dst_subresource: Default::default(),
            dst_offset: Default::default(),
            extent: Default::default(),
        }
    }
}
impl fmt::Debug for ImageCopy2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageCopy2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_subresource", &self.src_subresource)
            .field("src_offset", &self.src_offset)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offset", &self.dst_offset)
            .field("extent", &self.extent)
            .finish()
    }
}
pub type ImageCopy2KHR = ImageCopy2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageBlit2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub src_offsets: [Offset3D; 2],
    pub dst_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub dst_offsets: [Offset3D; 2],
}
unsafe impl Send for ImageBlit2 {}
unsafe impl Sync for ImageBlit2 {}
impl Default for ImageBlit2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_BLIT_2,
            p_next: ptr::null(),
            src_subresource: Default::default(),
            src_offsets: [Default::default(); 2],
            dst_subresource: Default::default(),
            dst_offsets: [Default::default(); 2],
        }
    }
}
impl fmt::Debug for ImageBlit2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageBlit2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_subresource", &self.src_subresource)
            .field("src_offsets", &self.src_offsets)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offsets", &self.dst_offsets)
            .finish()
    }
}
pub type ImageBlit2KHR = ImageBlit2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferImageCopy2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// Specified in bytes
    pub buffer_offset: DeviceSize,
    /// Specified in texels
    pub buffer_row_length: u32,
    pub buffer_image_height: u32,
    pub image_subresource: ImageSubresourceLayers,
    /// Specified in pixels for both compressed and uncompressed images
    pub image_offset: Offset3D,
    /// Specified in pixels for both compressed and uncompressed images
    pub image_extent: Extent3D,
}
unsafe impl Send for BufferImageCopy2 {}
unsafe impl Sync for BufferImageCopy2 {}
impl Default for BufferImageCopy2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_IMAGE_COPY_2,
            p_next: ptr::null(),
            buffer_offset: Default::default(),
            buffer_row_length: Default::default(),
            buffer_image_height: Default::default(),
            image_subresource: Default::default(),
            image_offset: Default::default(),
            image_extent: Default::default(),
        }
    }
}
impl fmt::Debug for BufferImageCopy2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferImageCopy2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("buffer_offset", &self.buffer_offset)
            .field("buffer_row_length", &self.buffer_row_length)
            .field("buffer_image_height", &self.buffer_image_height)
            .field("image_subresource", &self.image_subresource)
            .field("image_offset", &self.image_offset)
            .field("image_extent", &self.image_extent)
            .finish()
    }
}
pub type BufferImageCopy2KHR = BufferImageCopy2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageResolve2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
}
unsafe impl Send for ImageResolve2 {}
unsafe impl Sync for ImageResolve2 {}
impl Default for ImageResolve2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_RESOLVE_2,
            p_next: ptr::null(),
            src_subresource: Default::default(),
            src_offset: Default::default(),
            dst_subresource: Default::default(),
            dst_offset: Default::default(),
            extent: Default::default(),
        }
    }
}
impl fmt::Debug for ImageResolve2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageResolve2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_subresource", &self.src_subresource)
            .field("src_offset", &self.src_offset)
            .field("dst_subresource", &self.dst_subresource)
            .field("dst_offset", &self.dst_offset)
            .field("extent", &self.extent)
            .finish()
    }
}
pub type ImageResolve2KHR = ImageResolve2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyBufferInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_buffer: Option<Buffer>,
    pub dst_buffer: Option<Buffer>,
    pub region_count: u32,
    pub p_regions: *const BufferCopy2,
}
unsafe impl Send for CopyBufferInfo2 {}
unsafe impl Sync for CopyBufferInfo2 {}
impl Default for CopyBufferInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_BUFFER_INFO_2,
            p_next: ptr::null(),
            src_buffer: Default::default(),
            dst_buffer: Default::default(),
            region_count: Default::default(),
            p_regions: ptr::null(),
        }
    }
}
impl fmt::Debug for CopyBufferInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyBufferInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_buffer", &self.src_buffer)
            .field("dst_buffer", &self.dst_buffer)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
pub type CopyBufferInfo2KHR = CopyBufferInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyImageInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Option<Image>,
    pub src_image_layout: ImageLayout,
    pub dst_image: Option<Image>,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const ImageCopy2,
}
unsafe impl Send for CopyImageInfo2 {}
unsafe impl Sync for CopyImageInfo2 {}
impl Default for CopyImageInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_IMAGE_INFO_2,
            p_next: ptr::null(),
            src_image: Default::default(),
            src_image_layout: Default::default(),
            dst_image: Default::default(),
            dst_image_layout: Default::default(),
            region_count: Default::default(),
            p_regions: ptr::null(),
        }
    }
}
impl fmt::Debug for CopyImageInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyImageInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_image", &self.src_image)
            .field("src_image_layout", &self.src_image_layout)
            .field("dst_image", &self.dst_image)
            .field("dst_image_layout", &self.dst_image_layout)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
pub type CopyImageInfo2KHR = CopyImageInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BlitImageInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Option<Image>,
    pub src_image_layout: ImageLayout,
    pub dst_image: Option<Image>,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const ImageBlit2,
    pub filter: Filter,
}
unsafe impl Send for BlitImageInfo2 {}
unsafe impl Sync for BlitImageInfo2 {}
impl Default for BlitImageInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::BLIT_IMAGE_INFO_2,
            p_next: ptr::null(),
            src_image: Default::default(),
            src_image_layout: Default::default(),
            dst_image: Default::default(),
            dst_image_layout: Default::default(),
            region_count: Default::default(),
            p_regions: ptr::null(),
            filter: Default::default(),
        }
    }
}
impl fmt::Debug for BlitImageInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BlitImageInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_image", &self.src_image)
            .field("src_image_layout", &self.src_image_layout)
            .field("dst_image", &self.dst_image)
            .field("dst_image_layout", &self.dst_image_layout)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .field("filter", &self.filter)
            .finish()
    }
}
pub type BlitImageInfo2KHR = BlitImageInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyBufferToImageInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_buffer: Option<Buffer>,
    pub dst_image: Option<Image>,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const BufferImageCopy2,
}
unsafe impl Send for CopyBufferToImageInfo2 {}
unsafe impl Sync for CopyBufferToImageInfo2 {}
impl Default for CopyBufferToImageInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_BUFFER_TO_IMAGE_INFO_2,
            p_next: ptr::null(),
            src_buffer: Default::default(),
            dst_image: Default::default(),
            dst_image_layout: Default::default(),
            region_count: Default::default(),
            p_regions: ptr::null(),
        }
    }
}
impl fmt::Debug for CopyBufferToImageInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyBufferToImageInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_buffer", &self.src_buffer)
            .field("dst_image", &self.dst_image)
            .field("dst_image_layout", &self.dst_image_layout)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
pub type CopyBufferToImageInfo2KHR = CopyBufferToImageInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyImageToBufferInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Option<Image>,
    pub src_image_layout: ImageLayout,
    pub dst_buffer: Option<Buffer>,
    pub region_count: u32,
    pub p_regions: *const BufferImageCopy2,
}
unsafe impl Send for CopyImageToBufferInfo2 {}
unsafe impl Sync for CopyImageToBufferInfo2 {}
impl Default for CopyImageToBufferInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::COPY_IMAGE_TO_BUFFER_INFO_2,
            p_next: ptr::null(),
            src_image: Default::default(),
            src_image_layout: Default::default(),
            dst_buffer: Default::default(),
            region_count: Default::default(),
            p_regions: ptr::null(),
        }
    }
}
impl fmt::Debug for CopyImageToBufferInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyImageToBufferInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_image", &self.src_image)
            .field("src_image_layout", &self.src_image_layout)
            .field("dst_buffer", &self.dst_buffer)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
pub type CopyImageToBufferInfo2KHR = CopyImageToBufferInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ResolveImageInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Option<Image>,
    pub src_image_layout: ImageLayout,
    pub dst_image: Option<Image>,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const ImageResolve2,
}
unsafe impl Send for ResolveImageInfo2 {}
unsafe impl Sync for ResolveImageInfo2 {}
impl Default for ResolveImageInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::RESOLVE_IMAGE_INFO_2,
            p_next: ptr::null(),
            src_image: Default::default(),
            src_image_layout: Default::default(),
            dst_image: Default::default(),
            dst_image_layout: Default::default(),
            region_count: Default::default(),
            p_regions: ptr::null(),
        }
    }
}
impl fmt::Debug for ResolveImageInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ResolveImageInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_image", &self.src_image)
            .field("src_image_layout", &self.src_image_layout)
            .field("dst_image", &self.dst_image)
            .field("dst_image_layout", &self.dst_image_layout)
            .field("region_count", &self.region_count)
            .field("p_regions", &self.p_regions)
            .finish()
    }
}
pub type ResolveImageInfo2KHR = ResolveImageInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_image_int64_atomics: Bool32,
    pub sparse_image_int64_atomics: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {}
unsafe impl Sync for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {}
impl Default for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
            p_next: ptr::null_mut(),
            shader_image_int64_atomics: Default::default(),
            sparse_image_int64_atomics: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderImageAtomicInt64FeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_image_int64_atomics", &self.shader_image_int64_atomics)
            .field("sparse_image_int64_atomics", &self.sparse_image_int64_atomics)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FragmentShadingRateAttachmentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_fragment_shading_rate_attachment: *const AttachmentReference2,
    pub shading_rate_attachment_texel_size: Extent2D,
}
unsafe impl Send for FragmentShadingRateAttachmentInfoKHR {}
unsafe impl Sync for FragmentShadingRateAttachmentInfoKHR {}
impl Default for FragmentShadingRateAttachmentInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
            p_next: ptr::null(),
            p_fragment_shading_rate_attachment: ptr::null(),
            shading_rate_attachment_texel_size: Default::default(),
        }
    }
}
impl fmt::Debug for FragmentShadingRateAttachmentInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FragmentShadingRateAttachmentInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "p_fragment_shading_rate_attachment",
                &self.p_fragment_shading_rate_attachment,
            )
            .field(
                "shading_rate_attachment_texel_size",
                &self.shading_rate_attachment_texel_size,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineFragmentShadingRateStateCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fragment_size: Extent2D,
    pub combiner_ops: [FragmentShadingRateCombinerOpKHR; 2],
}
unsafe impl Send for PipelineFragmentShadingRateStateCreateInfoKHR {}
unsafe impl Sync for PipelineFragmentShadingRateStateCreateInfoKHR {}
impl Default for PipelineFragmentShadingRateStateCreateInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR,
            p_next: ptr::null(),
            fragment_size: Default::default(),
            combiner_ops: [Default::default(); 2],
        }
    }
}
impl fmt::Debug for PipelineFragmentShadingRateStateCreateInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineFragmentShadingRateStateCreateInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fragment_size", &self.fragment_size)
            .field("combiner_ops", &self.combiner_ops)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShadingRateFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_fragment_shading_rate: Bool32,
    pub primitive_fragment_shading_rate: Bool32,
    pub attachment_fragment_shading_rate: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentShadingRateFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceFragmentShadingRateFeaturesKHR {}
impl Default for PhysicalDeviceFragmentShadingRateFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
            p_next: ptr::null_mut(),
            pipeline_fragment_shading_rate: Default::default(),
            primitive_fragment_shading_rate: Default::default(),
            attachment_fragment_shading_rate: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShadingRateFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShadingRateFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline_fragment_shading_rate", &self.pipeline_fragment_shading_rate)
            .field("primitive_fragment_shading_rate", &self.primitive_fragment_shading_rate)
            .field(
                "attachment_fragment_shading_rate",
                &self.attachment_fragment_shading_rate,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShadingRatePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_fragment_shading_rate_attachment_texel_size: Extent2D,
    pub max_fragment_shading_rate_attachment_texel_size: Extent2D,
    pub max_fragment_shading_rate_attachment_texel_size_aspect_ratio: u32,
    pub primitive_fragment_shading_rate_with_multiple_viewports: Bool32,
    pub layered_shading_rate_attachments: Bool32,
    pub fragment_shading_rate_non_trivial_combiner_ops: Bool32,
    pub max_fragment_size: Extent2D,
    pub max_fragment_size_aspect_ratio: u32,
    pub max_fragment_shading_rate_coverage_samples: u32,
    pub max_fragment_shading_rate_rasterization_samples: SampleCountFlags,
    pub fragment_shading_rate_with_shader_depth_stencil_writes: Bool32,
    pub fragment_shading_rate_with_sample_mask: Bool32,
    pub fragment_shading_rate_with_shader_sample_mask: Bool32,
    pub fragment_shading_rate_with_conservative_rasterization: Bool32,
    pub fragment_shading_rate_with_fragment_shader_interlock: Bool32,
    pub fragment_shading_rate_with_custom_sample_locations: Bool32,
    pub fragment_shading_rate_strict_multiply_combiner: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentShadingRatePropertiesKHR {}
unsafe impl Sync for PhysicalDeviceFragmentShadingRatePropertiesKHR {}
impl Default for PhysicalDeviceFragmentShadingRatePropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            min_fragment_shading_rate_attachment_texel_size: Default::default(),
            max_fragment_shading_rate_attachment_texel_size: Default::default(),
            max_fragment_shading_rate_attachment_texel_size_aspect_ratio: Default::default(),
            primitive_fragment_shading_rate_with_multiple_viewports: Default::default(),
            layered_shading_rate_attachments: Default::default(),
            fragment_shading_rate_non_trivial_combiner_ops: Default::default(),
            max_fragment_size: Default::default(),
            max_fragment_size_aspect_ratio: Default::default(),
            max_fragment_shading_rate_coverage_samples: Default::default(),
            max_fragment_shading_rate_rasterization_samples: Default::default(),
            fragment_shading_rate_with_shader_depth_stencil_writes: Default::default(),
            fragment_shading_rate_with_sample_mask: Default::default(),
            fragment_shading_rate_with_shader_sample_mask: Default::default(),
            fragment_shading_rate_with_conservative_rasterization: Default::default(),
            fragment_shading_rate_with_fragment_shader_interlock: Default::default(),
            fragment_shading_rate_with_custom_sample_locations: Default::default(),
            fragment_shading_rate_strict_multiply_combiner: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShadingRatePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShadingRatePropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "min_fragment_shading_rate_attachment_texel_size",
                &self.min_fragment_shading_rate_attachment_texel_size,
            )
            .field(
                "max_fragment_shading_rate_attachment_texel_size",
                &self.max_fragment_shading_rate_attachment_texel_size,
            )
            .field(
                "max_fragment_shading_rate_attachment_texel_size_aspect_ratio",
                &self.max_fragment_shading_rate_attachment_texel_size_aspect_ratio,
            )
            .field(
                "primitive_fragment_shading_rate_with_multiple_viewports",
                &self.primitive_fragment_shading_rate_with_multiple_viewports,
            )
            .field(
                "layered_shading_rate_attachments",
                &self.layered_shading_rate_attachments,
            )
            .field(
                "fragment_shading_rate_non_trivial_combiner_ops",
                &self.fragment_shading_rate_non_trivial_combiner_ops,
            )
            .field("max_fragment_size", &self.max_fragment_size)
            .field("max_fragment_size_aspect_ratio", &self.max_fragment_size_aspect_ratio)
            .field(
                "max_fragment_shading_rate_coverage_samples",
                &self.max_fragment_shading_rate_coverage_samples,
            )
            .field(
                "max_fragment_shading_rate_rasterization_samples",
                &self.max_fragment_shading_rate_rasterization_samples,
            )
            .field(
                "fragment_shading_rate_with_shader_depth_stencil_writes",
                &self.fragment_shading_rate_with_shader_depth_stencil_writes,
            )
            .field(
                "fragment_shading_rate_with_sample_mask",
                &self.fragment_shading_rate_with_sample_mask,
            )
            .field(
                "fragment_shading_rate_with_shader_sample_mask",
                &self.fragment_shading_rate_with_shader_sample_mask,
            )
            .field(
                "fragment_shading_rate_with_conservative_rasterization",
                &self.fragment_shading_rate_with_conservative_rasterization,
            )
            .field(
                "fragment_shading_rate_with_fragment_shader_interlock",
                &self.fragment_shading_rate_with_fragment_shader_interlock,
            )
            .field(
                "fragment_shading_rate_with_custom_sample_locations",
                &self.fragment_shading_rate_with_custom_sample_locations,
            )
            .field(
                "fragment_shading_rate_strict_multiply_combiner",
                &self.fragment_shading_rate_strict_multiply_combiner,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShadingRateKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub sample_counts: SampleCountFlags,
    pub fragment_size: Extent2D,
}
unsafe impl Send for PhysicalDeviceFragmentShadingRateKHR {}
unsafe impl Sync for PhysicalDeviceFragmentShadingRateKHR {}
impl Default for PhysicalDeviceFragmentShadingRateKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR,
            p_next: ptr::null_mut(),
            sample_counts: Default::default(),
            fragment_size: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShadingRateKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShadingRateKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("sample_counts", &self.sample_counts)
            .field("fragment_size", &self.fragment_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderTerminateInvocationFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_terminate_invocation: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderTerminateInvocationFeatures {}
unsafe impl Sync for PhysicalDeviceShaderTerminateInvocationFeatures {}
impl Default for PhysicalDeviceShaderTerminateInvocationFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
            p_next: ptr::null_mut(),
            shader_terminate_invocation: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderTerminateInvocationFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderTerminateInvocationFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_terminate_invocation", &self.shader_terminate_invocation)
            .finish()
    }
}
pub type PhysicalDeviceShaderTerminateInvocationFeaturesKHR = PhysicalDeviceShaderTerminateInvocationFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_shading_rate_enums: Bool32,
    pub supersample_fragment_shading_rates: Bool32,
    pub no_invocation_fragment_shading_rates: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {}
unsafe impl Sync for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {}
impl Default for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV,
            p_next: ptr::null_mut(),
            fragment_shading_rate_enums: Default::default(),
            supersample_fragment_shading_rates: Default::default(),
            no_invocation_fragment_shading_rates: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShadingRateEnumsFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fragment_shading_rate_enums", &self.fragment_shading_rate_enums)
            .field(
                "supersample_fragment_shading_rates",
                &self.supersample_fragment_shading_rates,
            )
            .field(
                "no_invocation_fragment_shading_rates",
                &self.no_invocation_fragment_shading_rates,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_fragment_shading_rate_invocation_count: SampleCountFlags,
}
unsafe impl Send for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {}
unsafe impl Sync for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {}
impl Default for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV,
            p_next: ptr::null_mut(),
            max_fragment_shading_rate_invocation_count: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShadingRateEnumsPropertiesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "max_fragment_shading_rate_invocation_count",
                &self.max_fragment_shading_rate_invocation_count,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineFragmentShadingRateEnumStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub shading_rate_type: FragmentShadingRateTypeNV,
    pub shading_rate: FragmentShadingRateNV,
    pub combiner_ops: [FragmentShadingRateCombinerOpKHR; 2],
}
unsafe impl Send for PipelineFragmentShadingRateEnumStateCreateInfoNV {}
unsafe impl Sync for PipelineFragmentShadingRateEnumStateCreateInfoNV {}
impl Default for PipelineFragmentShadingRateEnumStateCreateInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV,
            p_next: ptr::null(),
            shading_rate_type: Default::default(),
            shading_rate: Default::default(),
            combiner_ops: [Default::default(); 2],
        }
    }
}
impl fmt::Debug for PipelineFragmentShadingRateEnumStateCreateInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineFragmentShadingRateEnumStateCreateInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shading_rate_type", &self.shading_rate_type)
            .field("shading_rate", &self.shading_rate)
            .field("combiner_ops", &self.combiner_ops)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureBuildSizesInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure_size: DeviceSize,
    pub update_scratch_size: DeviceSize,
    pub build_scratch_size: DeviceSize,
}
unsafe impl Send for AccelerationStructureBuildSizesInfoKHR {}
unsafe impl Sync for AccelerationStructureBuildSizesInfoKHR {}
impl Default for AccelerationStructureBuildSizesInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,
            p_next: ptr::null(),
            acceleration_structure_size: Default::default(),
            update_scratch_size: Default::default(),
            build_scratch_size: Default::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureBuildSizesInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureBuildSizesInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("acceleration_structure_size", &self.acceleration_structure_size)
            .field("update_scratch_size", &self.update_scratch_size)
            .field("build_scratch_size", &self.build_scratch_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImage2DViewOf3DFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_2d_view_of_3d: Bool32,
    pub sampler_2d_view_of_3d: Bool32,
}
unsafe impl Send for PhysicalDeviceImage2DViewOf3DFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceImage2DViewOf3DFeaturesEXT {}
impl Default for PhysicalDeviceImage2DViewOf3DFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT,
            p_next: ptr::null_mut(),
            image_2d_view_of_3d: Default::default(),
            sampler_2d_view_of_3d: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImage2DViewOf3DFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImage2DViewOf3DFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_2d_view_of_3d", &self.image_2d_view_of_3d)
            .field("sampler_2d_view_of_3d", &self.sampler_2d_view_of_3d)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub mutable_descriptor_type: Bool32,
}
unsafe impl Send for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {}
unsafe impl Sync for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {}
impl Default for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE,
            p_next: ptr::null_mut(),
            mutable_descriptor_type: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceMutableDescriptorTypeFeaturesVALVE")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("mutable_descriptor_type", &self.mutable_descriptor_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MutableDescriptorTypeListVALVE {
    pub descriptor_type_count: u32,
    pub p_descriptor_types: *const DescriptorType,
}
unsafe impl Send for MutableDescriptorTypeListVALVE {}
unsafe impl Sync for MutableDescriptorTypeListVALVE {}
impl Default for MutableDescriptorTypeListVALVE {
    fn default() -> Self {
        Self {
            descriptor_type_count: Default::default(),
            p_descriptor_types: ptr::null(),
        }
    }
}
impl fmt::Debug for MutableDescriptorTypeListVALVE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MutableDescriptorTypeListVALVE")
            .field("descriptor_type_count", &self.descriptor_type_count)
            .field("p_descriptor_types", &self.p_descriptor_types)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MutableDescriptorTypeCreateInfoVALVE {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mutable_descriptor_type_list_count: u32,
    pub p_mutable_descriptor_type_lists: *const MutableDescriptorTypeListVALVE,
}
unsafe impl Send for MutableDescriptorTypeCreateInfoVALVE {}
unsafe impl Sync for MutableDescriptorTypeCreateInfoVALVE {}
impl Default for MutableDescriptorTypeCreateInfoVALVE {
    fn default() -> Self {
        Self {
            s_type: StructureType::MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE,
            p_next: ptr::null(),
            mutable_descriptor_type_list_count: Default::default(),
            p_mutable_descriptor_type_lists: ptr::null(),
        }
    }
}
impl fmt::Debug for MutableDescriptorTypeCreateInfoVALVE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MutableDescriptorTypeCreateInfoVALVE")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "mutable_descriptor_type_list_count",
                &self.mutable_descriptor_type_list_count,
            )
            .field("p_mutable_descriptor_type_lists", &self.p_mutable_descriptor_type_lists)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDepthClipControlFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub depth_clip_control: Bool32,
}
unsafe impl Send for PhysicalDeviceDepthClipControlFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceDepthClipControlFeaturesEXT {}
impl Default for PhysicalDeviceDepthClipControlFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT,
            p_next: ptr::null_mut(),
            depth_clip_control: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDepthClipControlFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDepthClipControlFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("depth_clip_control", &self.depth_clip_control)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineViewportDepthClipControlCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub negative_one_to_one: Bool32,
}
unsafe impl Send for PipelineViewportDepthClipControlCreateInfoEXT {}
unsafe impl Sync for PipelineViewportDepthClipControlCreateInfoEXT {}
impl Default for PipelineViewportDepthClipControlCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT,
            p_next: ptr::null(),
            negative_one_to_one: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineViewportDepthClipControlCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineViewportDepthClipControlCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("negative_one_to_one", &self.negative_one_to_one)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub vertex_input_dynamic_state: Bool32,
}
unsafe impl Send for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {}
impl Default for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
            p_next: ptr::null_mut(),
            vertex_input_dynamic_state: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVertexInputDynamicStateFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vertex_input_dynamic_state", &self.vertex_input_dynamic_state)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceExternalMemoryRDMAFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_memory_rdma: Bool32,
}
unsafe impl Send for PhysicalDeviceExternalMemoryRDMAFeaturesNV {}
unsafe impl Sync for PhysicalDeviceExternalMemoryRDMAFeaturesNV {}
impl Default for PhysicalDeviceExternalMemoryRDMAFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV,
            p_next: ptr::null_mut(),
            external_memory_rdma: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceExternalMemoryRDMAFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceExternalMemoryRDMAFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("external_memory_rdma", &self.external_memory_rdma)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VertexInputBindingDescription2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub binding: u32,
    pub stride: u32,
    pub input_rate: VertexInputRate,
    pub divisor: u32,
}
unsafe impl Send for VertexInputBindingDescription2EXT {}
unsafe impl Sync for VertexInputBindingDescription2EXT {}
impl Default for VertexInputBindingDescription2EXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT,
            p_next: ptr::null_mut(),
            binding: Default::default(),
            stride: Default::default(),
            input_rate: Default::default(),
            divisor: Default::default(),
        }
    }
}
impl fmt::Debug for VertexInputBindingDescription2EXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("VertexInputBindingDescription2EXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("binding", &self.binding)
            .field("stride", &self.stride)
            .field("input_rate", &self.input_rate)
            .field("divisor", &self.divisor)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VertexInputAttributeDescription2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    /// location of the shader vertex attrib
    pub location: u32,
    /// Vertex buffer binding id
    pub binding: u32,
    /// format of source data
    pub format: Format,
    /// Offset of first element in bytes from base of vertex
    pub offset: u32,
}
unsafe impl Send for VertexInputAttributeDescription2EXT {}
unsafe impl Sync for VertexInputAttributeDescription2EXT {}
impl Default for VertexInputAttributeDescription2EXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT,
            p_next: ptr::null_mut(),
            location: Default::default(),
            binding: Default::default(),
            format: Default::default(),
            offset: Default::default(),
        }
    }
}
impl fmt::Debug for VertexInputAttributeDescription2EXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("VertexInputAttributeDescription2EXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("location", &self.location)
            .field("binding", &self.binding)
            .field("format", &self.format)
            .field("offset", &self.offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceColorWriteEnableFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub color_write_enable: Bool32,
}
unsafe impl Send for PhysicalDeviceColorWriteEnableFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceColorWriteEnableFeaturesEXT {}
impl Default for PhysicalDeviceColorWriteEnableFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
            p_next: ptr::null_mut(),
            color_write_enable: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceColorWriteEnableFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceColorWriteEnableFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("color_write_enable", &self.color_write_enable)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineColorWriteCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    /// # of pAttachments
    pub attachment_count: u32,
    pub p_color_write_enables: *const Bool32,
}
unsafe impl Send for PipelineColorWriteCreateInfoEXT {}
unsafe impl Sync for PipelineColorWriteCreateInfoEXT {}
impl Default for PipelineColorWriteCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_COLOR_WRITE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            attachment_count: Default::default(),
            p_color_write_enables: ptr::null(),
        }
    }
}
impl fmt::Debug for PipelineColorWriteCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineColorWriteCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("attachment_count", &self.attachment_count)
            .field("p_color_write_enables", &self.p_color_write_enables)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryBarrier2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_stage_mask: PipelineStageFlags2,
    pub src_access_mask: AccessFlags2,
    pub dst_stage_mask: PipelineStageFlags2,
    pub dst_access_mask: AccessFlags2,
}
unsafe impl Send for MemoryBarrier2 {}
unsafe impl Sync for MemoryBarrier2 {}
impl Default for MemoryBarrier2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_BARRIER_2,
            p_next: ptr::null(),
            src_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_stage_mask: Default::default(),
            dst_access_mask: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryBarrier2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryBarrier2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_stage_mask", &self.src_stage_mask)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_stage_mask", &self.dst_stage_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .finish()
    }
}
pub type MemoryBarrier2KHR = MemoryBarrier2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageMemoryBarrier2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_stage_mask: PipelineStageFlags2,
    pub src_access_mask: AccessFlags2,
    pub dst_stage_mask: PipelineStageFlags2,
    pub dst_access_mask: AccessFlags2,
    pub old_layout: ImageLayout,
    pub new_layout: ImageLayout,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub image: Option<Image>,
    pub subresource_range: ImageSubresourceRange,
}
unsafe impl Send for ImageMemoryBarrier2 {}
unsafe impl Sync for ImageMemoryBarrier2 {}
impl Default for ImageMemoryBarrier2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_MEMORY_BARRIER_2,
            p_next: ptr::null(),
            src_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_stage_mask: Default::default(),
            dst_access_mask: Default::default(),
            old_layout: Default::default(),
            new_layout: Default::default(),
            src_queue_family_index: Default::default(),
            dst_queue_family_index: Default::default(),
            image: Default::default(),
            subresource_range: Default::default(),
        }
    }
}
impl fmt::Debug for ImageMemoryBarrier2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageMemoryBarrier2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_stage_mask", &self.src_stage_mask)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_stage_mask", &self.dst_stage_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .field("old_layout", &self.old_layout)
            .field("new_layout", &self.new_layout)
            .field("src_queue_family_index", &self.src_queue_family_index)
            .field("dst_queue_family_index", &self.dst_queue_family_index)
            .field("image", &self.image)
            .field("subresource_range", &self.subresource_range)
            .finish()
    }
}
pub type ImageMemoryBarrier2KHR = ImageMemoryBarrier2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferMemoryBarrier2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_stage_mask: PipelineStageFlags2,
    pub src_access_mask: AccessFlags2,
    pub dst_stage_mask: PipelineStageFlags2,
    pub dst_access_mask: AccessFlags2,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub buffer: Option<Buffer>,
    pub offset: DeviceSize,
    pub size: DeviceSize,
}
unsafe impl Send for BufferMemoryBarrier2 {}
unsafe impl Sync for BufferMemoryBarrier2 {}
impl Default for BufferMemoryBarrier2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_MEMORY_BARRIER_2,
            p_next: ptr::null(),
            src_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_stage_mask: Default::default(),
            dst_access_mask: Default::default(),
            src_queue_family_index: Default::default(),
            dst_queue_family_index: Default::default(),
            buffer: Default::default(),
            offset: Default::default(),
            size: Default::default(),
        }
    }
}
impl fmt::Debug for BufferMemoryBarrier2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferMemoryBarrier2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src_stage_mask", &self.src_stage_mask)
            .field("src_access_mask", &self.src_access_mask)
            .field("dst_stage_mask", &self.dst_stage_mask)
            .field("dst_access_mask", &self.dst_access_mask)
            .field("src_queue_family_index", &self.src_queue_family_index)
            .field("dst_queue_family_index", &self.dst_queue_family_index)
            .field("buffer", &self.buffer)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .finish()
    }
}
pub type BufferMemoryBarrier2KHR = BufferMemoryBarrier2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DependencyInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub dependency_flags: DependencyFlags,
    pub memory_barrier_count: u32,
    pub p_memory_barriers: *const MemoryBarrier2,
    pub buffer_memory_barrier_count: u32,
    pub p_buffer_memory_barriers: *const BufferMemoryBarrier2,
    pub image_memory_barrier_count: u32,
    pub p_image_memory_barriers: *const ImageMemoryBarrier2,
}
unsafe impl Send for DependencyInfo {}
unsafe impl Sync for DependencyInfo {}
impl Default for DependencyInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::DEPENDENCY_INFO,
            p_next: ptr::null(),
            dependency_flags: Default::default(),
            memory_barrier_count: Default::default(),
            p_memory_barriers: ptr::null(),
            buffer_memory_barrier_count: Default::default(),
            p_buffer_memory_barriers: ptr::null(),
            image_memory_barrier_count: Default::default(),
            p_image_memory_barriers: ptr::null(),
        }
    }
}
impl fmt::Debug for DependencyInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DependencyInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("dependency_flags", &self.dependency_flags)
            .field("memory_barrier_count", &self.memory_barrier_count)
            .field("p_memory_barriers", &self.p_memory_barriers)
            .field("buffer_memory_barrier_count", &self.buffer_memory_barrier_count)
            .field("p_buffer_memory_barriers", &self.p_buffer_memory_barriers)
            .field("image_memory_barrier_count", &self.image_memory_barrier_count)
            .field("p_image_memory_barriers", &self.p_image_memory_barriers)
            .finish()
    }
}
pub type DependencyInfoKHR = DependencyInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemaphoreSubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub value: u64,
    pub stage_mask: PipelineStageFlags2,
    pub device_index: u32,
}
unsafe impl Send for SemaphoreSubmitInfo {}
unsafe impl Sync for SemaphoreSubmitInfo {}
impl Default for SemaphoreSubmitInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::SEMAPHORE_SUBMIT_INFO,
            p_next: ptr::null(),
            semaphore: Default::default(),
            value: Default::default(),
            stage_mask: Default::default(),
            device_index: Default::default(),
        }
    }
}
impl fmt::Debug for SemaphoreSubmitInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SemaphoreSubmitInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("value", &self.value)
            .field("stage_mask", &self.stage_mask)
            .field("device_index", &self.device_index)
            .finish()
    }
}
pub type SemaphoreSubmitInfoKHR = SemaphoreSubmitInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferSubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub command_buffer: Option<CommandBuffer>,
    pub device_mask: u32,
}
unsafe impl Send for CommandBufferSubmitInfo {}
unsafe impl Sync for CommandBufferSubmitInfo {}
impl Default for CommandBufferSubmitInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_SUBMIT_INFO,
            p_next: ptr::null(),
            command_buffer: Default::default(),
            device_mask: Default::default(),
        }
    }
}
impl fmt::Debug for CommandBufferSubmitInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferSubmitInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("command_buffer", &self.command_buffer)
            .field("device_mask", &self.device_mask)
            .finish()
    }
}
pub type CommandBufferSubmitInfoKHR = CommandBufferSubmitInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubmitInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SubmitFlags,
    pub wait_semaphore_info_count: u32,
    pub p_wait_semaphore_infos: *const SemaphoreSubmitInfo,
    pub command_buffer_info_count: u32,
    pub p_command_buffer_infos: *const CommandBufferSubmitInfo,
    pub signal_semaphore_info_count: u32,
    pub p_signal_semaphore_infos: *const SemaphoreSubmitInfo,
}
unsafe impl Send for SubmitInfo2 {}
unsafe impl Sync for SubmitInfo2 {}
impl Default for SubmitInfo2 {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBMIT_INFO_2,
            p_next: ptr::null(),
            flags: Default::default(),
            wait_semaphore_info_count: Default::default(),
            p_wait_semaphore_infos: ptr::null(),
            command_buffer_info_count: Default::default(),
            p_command_buffer_infos: ptr::null(),
            signal_semaphore_info_count: Default::default(),
            p_signal_semaphore_infos: ptr::null(),
        }
    }
}
impl fmt::Debug for SubmitInfo2 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubmitInfo2")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("wait_semaphore_info_count", &self.wait_semaphore_info_count)
            .field("p_wait_semaphore_infos", &self.p_wait_semaphore_infos)
            .field("command_buffer_info_count", &self.command_buffer_info_count)
            .field("p_command_buffer_infos", &self.p_command_buffer_infos)
            .field("signal_semaphore_info_count", &self.signal_semaphore_info_count)
            .field("p_signal_semaphore_infos", &self.p_signal_semaphore_infos)
            .finish()
    }
}
pub type SubmitInfo2KHR = SubmitInfo2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueueFamilyCheckpointProperties2NV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub checkpoint_execution_stage_mask: PipelineStageFlags2,
}
unsafe impl Send for QueueFamilyCheckpointProperties2NV {}
unsafe impl Sync for QueueFamilyCheckpointProperties2NV {}
impl Default for QueueFamilyCheckpointProperties2NV {
    fn default() -> Self {
        Self {
            s_type: StructureType::QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV,
            p_next: ptr::null_mut(),
            checkpoint_execution_stage_mask: Default::default(),
        }
    }
}
impl fmt::Debug for QueueFamilyCheckpointProperties2NV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("QueueFamilyCheckpointProperties2NV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("checkpoint_execution_stage_mask", &self.checkpoint_execution_stage_mask)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CheckpointData2NV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stage: PipelineStageFlags2,
    pub p_checkpoint_marker: *mut c_void,
}
unsafe impl Send for CheckpointData2NV {}
unsafe impl Sync for CheckpointData2NV {}
impl Default for CheckpointData2NV {
    fn default() -> Self {
        Self {
            s_type: StructureType::CHECKPOINT_DATA_2_NV,
            p_next: ptr::null_mut(),
            stage: Default::default(),
            p_checkpoint_marker: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for CheckpointData2NV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CheckpointData2NV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stage", &self.stage)
            .field("p_checkpoint_marker", &self.p_checkpoint_marker)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSynchronization2Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub synchronization2: Bool32,
}
unsafe impl Send for PhysicalDeviceSynchronization2Features {}
unsafe impl Sync for PhysicalDeviceSynchronization2Features {}
impl Default for PhysicalDeviceSynchronization2Features {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
            p_next: ptr::null_mut(),
            synchronization2: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSynchronization2Features {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSynchronization2Features")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("synchronization2", &self.synchronization2)
            .finish()
    }
}
pub type PhysicalDeviceSynchronization2FeaturesKHR = PhysicalDeviceSynchronization2Features;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub primitives_generated_query: Bool32,
    pub primitives_generated_query_with_rasterizer_discard: Bool32,
    pub primitives_generated_query_with_non_zero_streams: Bool32,
}
unsafe impl Send for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {}
unsafe impl Sync for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {}
impl Default for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT,
            p_next: ptr::null_mut(),
            primitives_generated_query: Default::default(),
            primitives_generated_query_with_rasterizer_discard: Default::default(),
            primitives_generated_query_with_non_zero_streams: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("primitives_generated_query", &self.primitives_generated_query)
            .field(
                "primitives_generated_query_with_rasterizer_discard",
                &self.primitives_generated_query_with_rasterizer_discard,
            )
            .field(
                "primitives_generated_query_with_non_zero_streams",
                &self.primitives_generated_query_with_non_zero_streams,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceInheritedViewportScissorFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub inherited_viewport_scissor_2d: Bool32,
}
unsafe impl Send for PhysicalDeviceInheritedViewportScissorFeaturesNV {}
unsafe impl Sync for PhysicalDeviceInheritedViewportScissorFeaturesNV {}
impl Default for PhysicalDeviceInheritedViewportScissorFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV,
            p_next: ptr::null_mut(),
            inherited_viewport_scissor_2d: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceInheritedViewportScissorFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceInheritedViewportScissorFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("inherited_viewport_scissor_2d", &self.inherited_viewport_scissor_2d)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferInheritanceViewportScissorInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub viewport_scissor_2d: Bool32,
    pub viewport_depth_count: u32,
    pub p_viewport_depths: *const Viewport,
}
unsafe impl Send for CommandBufferInheritanceViewportScissorInfoNV {}
unsafe impl Sync for CommandBufferInheritanceViewportScissorInfoNV {}
impl Default for CommandBufferInheritanceViewportScissorInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV,
            p_next: ptr::null(),
            viewport_scissor_2d: Default::default(),
            viewport_depth_count: Default::default(),
            p_viewport_depths: ptr::null(),
        }
    }
}
impl fmt::Debug for CommandBufferInheritanceViewportScissorInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferInheritanceViewportScissorInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("viewport_scissor_2d", &self.viewport_scissor_2d)
            .field("viewport_depth_count", &self.viewport_depth_count)
            .field("p_viewport_depths", &self.p_viewport_depths)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ycbcr2plane444_formats: Bool32,
}
unsafe impl Send for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {}
impl Default for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT,
            p_next: ptr::null_mut(),
            ycbcr2plane444_formats: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ycbcr2plane444_formats", &self.ycbcr2plane444_formats)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceProvokingVertexFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub provoking_vertex_last: Bool32,
    pub transform_feedback_preserves_provoking_vertex: Bool32,
}
unsafe impl Send for PhysicalDeviceProvokingVertexFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceProvokingVertexFeaturesEXT {}
impl Default for PhysicalDeviceProvokingVertexFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
            p_next: ptr::null_mut(),
            provoking_vertex_last: Default::default(),
            transform_feedback_preserves_provoking_vertex: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceProvokingVertexFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceProvokingVertexFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("provoking_vertex_last", &self.provoking_vertex_last)
            .field(
                "transform_feedback_preserves_provoking_vertex",
                &self.transform_feedback_preserves_provoking_vertex,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceProvokingVertexPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub provoking_vertex_mode_per_pipeline: Bool32,
    pub transform_feedback_preserves_triangle_fan_provoking_vertex: Bool32,
}
unsafe impl Send for PhysicalDeviceProvokingVertexPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceProvokingVertexPropertiesEXT {}
impl Default for PhysicalDeviceProvokingVertexPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            provoking_vertex_mode_per_pipeline: Default::default(),
            transform_feedback_preserves_triangle_fan_provoking_vertex: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceProvokingVertexPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceProvokingVertexPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "provoking_vertex_mode_per_pipeline",
                &self.provoking_vertex_mode_per_pipeline,
            )
            .field(
                "transform_feedback_preserves_triangle_fan_provoking_vertex",
                &self.transform_feedback_preserves_triangle_fan_provoking_vertex,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRasterizationProvokingVertexStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub provoking_vertex_mode: ProvokingVertexModeEXT,
}
unsafe impl Send for PipelineRasterizationProvokingVertexStateCreateInfoEXT {}
unsafe impl Sync for PipelineRasterizationProvokingVertexStateCreateInfoEXT {}
impl Default for PipelineRasterizationProvokingVertexStateCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT,
            p_next: ptr::null(),
            provoking_vertex_mode: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineRasterizationProvokingVertexStateCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRasterizationProvokingVertexStateCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("provoking_vertex_mode", &self.provoking_vertex_mode)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CuModuleCreateInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub data_size: usize,
    pub p_data: *const c_void,
}
unsafe impl Send for CuModuleCreateInfoNVX {}
unsafe impl Sync for CuModuleCreateInfoNVX {}
impl Default for CuModuleCreateInfoNVX {
    fn default() -> Self {
        Self {
            s_type: StructureType::CU_MODULE_CREATE_INFO_NVX,
            p_next: ptr::null(),
            data_size: Default::default(),
            p_data: ptr::null(),
        }
    }
}
impl fmt::Debug for CuModuleCreateInfoNVX {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CuModuleCreateInfoNVX")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("data_size", &self.data_size)
            .field("p_data", &self.p_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CuFunctionCreateInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub module: Option<CuModuleNVX>,
    pub p_name: *const c_char,
}
unsafe impl Send for CuFunctionCreateInfoNVX {}
unsafe impl Sync for CuFunctionCreateInfoNVX {}
impl Default for CuFunctionCreateInfoNVX {
    fn default() -> Self {
        Self {
            s_type: StructureType::CU_FUNCTION_CREATE_INFO_NVX,
            p_next: ptr::null(),
            module: Default::default(),
            p_name: ptr::null(),
        }
    }
}
impl fmt::Debug for CuFunctionCreateInfoNVX {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CuFunctionCreateInfoNVX")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("module", &self.module)
            .field("p_name", &self.p_name)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CuLaunchInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub function: Option<CuFunctionNVX>,
    pub grid_dim_x: u32,
    pub grid_dim_y: u32,
    pub grid_dim_z: u32,
    pub block_dim_x: u32,
    pub block_dim_y: u32,
    pub block_dim_z: u32,
    pub shared_mem_bytes: u32,
    pub param_count: usize,
    pub p_params: *const *const c_void,
    pub extra_count: usize,
    pub p_extras: *const *const c_void,
}
unsafe impl Send for CuLaunchInfoNVX {}
unsafe impl Sync for CuLaunchInfoNVX {}
impl Default for CuLaunchInfoNVX {
    fn default() -> Self {
        Self {
            s_type: StructureType::CU_LAUNCH_INFO_NVX,
            p_next: ptr::null(),
            function: Default::default(),
            grid_dim_x: Default::default(),
            grid_dim_y: Default::default(),
            grid_dim_z: Default::default(),
            block_dim_x: Default::default(),
            block_dim_y: Default::default(),
            block_dim_z: Default::default(),
            shared_mem_bytes: Default::default(),
            param_count: Default::default(),
            p_params: ptr::null(),
            extra_count: Default::default(),
            p_extras: ptr::null(),
        }
    }
}
impl fmt::Debug for CuLaunchInfoNVX {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CuLaunchInfoNVX")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("function", &self.function)
            .field("grid_dim_x", &self.grid_dim_x)
            .field("grid_dim_y", &self.grid_dim_y)
            .field("grid_dim_z", &self.grid_dim_z)
            .field("block_dim_x", &self.block_dim_x)
            .field("block_dim_y", &self.block_dim_y)
            .field("block_dim_z", &self.block_dim_z)
            .field("shared_mem_bytes", &self.shared_mem_bytes)
            .field("param_count", &self.param_count)
            .field("p_params", &self.p_params)
            .field("extra_count", &self.extra_count)
            .field("p_extras", &self.p_extras)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderIntegerDotProductFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_integer_dot_product: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderIntegerDotProductFeatures {}
unsafe impl Sync for PhysicalDeviceShaderIntegerDotProductFeatures {}
impl Default for PhysicalDeviceShaderIntegerDotProductFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
            p_next: ptr::null_mut(),
            shader_integer_dot_product: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderIntegerDotProductFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderIntegerDotProductFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("shader_integer_dot_product", &self.shader_integer_dot_product)
            .finish()
    }
}
pub type PhysicalDeviceShaderIntegerDotProductFeaturesKHR = PhysicalDeviceShaderIntegerDotProductFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderIntegerDotProductProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub integer_dot_product8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product8_bit_signed_accelerated: Bool32,
    pub integer_dot_product8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product16_bit_signed_accelerated: Bool32,
    pub integer_dot_product16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product32_bit_signed_accelerated: Bool32,
    pub integer_dot_product32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product64_bit_signed_accelerated: Bool32,
    pub integer_dot_product64_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderIntegerDotProductProperties {}
unsafe impl Sync for PhysicalDeviceShaderIntegerDotProductProperties {}
impl Default for PhysicalDeviceShaderIntegerDotProductProperties {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
            p_next: ptr::null_mut(),
            integer_dot_product8_bit_unsigned_accelerated: Default::default(),
            integer_dot_product8_bit_signed_accelerated: Default::default(),
            integer_dot_product8_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product4x8_bit_packed_unsigned_accelerated: Default::default(),
            integer_dot_product4x8_bit_packed_signed_accelerated: Default::default(),
            integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Default::default(),
            integer_dot_product16_bit_unsigned_accelerated: Default::default(),
            integer_dot_product16_bit_signed_accelerated: Default::default(),
            integer_dot_product16_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product32_bit_unsigned_accelerated: Default::default(),
            integer_dot_product32_bit_signed_accelerated: Default::default(),
            integer_dot_product32_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product64_bit_unsigned_accelerated: Default::default(),
            integer_dot_product64_bit_signed_accelerated: Default::default(),
            integer_dot_product64_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Default::default(),
            integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderIntegerDotProductProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderIntegerDotProductProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "integer_dot_product8_bit_unsigned_accelerated",
                &self.integer_dot_product8_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product8_bit_signed_accelerated",
                &self.integer_dot_product8_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product8_bit_mixed_signedness_accelerated",
                &self.integer_dot_product8_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product4x8_bit_packed_unsigned_accelerated",
                &self.integer_dot_product4x8_bit_packed_unsigned_accelerated,
            )
            .field(
                "integer_dot_product4x8_bit_packed_signed_accelerated",
                &self.integer_dot_product4x8_bit_packed_signed_accelerated,
            )
            .field(
                "integer_dot_product4x8_bit_packed_mixed_signedness_accelerated",
                &self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product16_bit_unsigned_accelerated",
                &self.integer_dot_product16_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product16_bit_signed_accelerated",
                &self.integer_dot_product16_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product16_bit_mixed_signedness_accelerated",
                &self.integer_dot_product16_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product32_bit_unsigned_accelerated",
                &self.integer_dot_product32_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product32_bit_signed_accelerated",
                &self.integer_dot_product32_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product32_bit_mixed_signedness_accelerated",
                &self.integer_dot_product32_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product64_bit_unsigned_accelerated",
                &self.integer_dot_product64_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product64_bit_signed_accelerated",
                &self.integer_dot_product64_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product64_bit_mixed_signedness_accelerated",
                &self.integer_dot_product64_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated",
                &self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_signed_accelerated",
                &self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated,
            )
            .field(
                "integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated",
                &self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated,
            )
            .finish()
    }
}
pub type PhysicalDeviceShaderIntegerDotProductPropertiesKHR = PhysicalDeviceShaderIntegerDotProductProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDrmPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub has_primary: Bool32,
    pub has_render: Bool32,
    pub primary_major: i64,
    pub primary_minor: i64,
    pub render_major: i64,
    pub render_minor: i64,
}
unsafe impl Send for PhysicalDeviceDrmPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceDrmPropertiesEXT {}
impl Default for PhysicalDeviceDrmPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DRM_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            has_primary: Default::default(),
            has_render: Default::default(),
            primary_major: Default::default(),
            primary_minor: Default::default(),
            render_major: Default::default(),
            render_minor: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDrmPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDrmPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("has_primary", &self.has_primary)
            .field("has_render", &self.has_render)
            .field("primary_major", &self.primary_major)
            .field("primary_minor", &self.primary_minor)
            .field("render_major", &self.render_major)
            .field("render_minor", &self.render_minor)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_shader_barycentric: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {}
unsafe impl Sync for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {}
impl Default for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
            p_next: ptr::null_mut(),
            fragment_shader_barycentric: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShaderBarycentricFeaturesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("fragment_shader_barycentric", &self.fragment_shader_barycentric)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub tri_strip_vertex_order_independent_of_provoking_vertex: Bool32,
}
unsafe impl Send for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR {}
unsafe impl Sync for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR {}
impl Default for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR,
            p_next: ptr::null_mut(),
            tri_strip_vertex_order_independent_of_provoking_vertex: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceFragmentShaderBarycentricPropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "tri_strip_vertex_order_independent_of_provoking_vertex",
                &self.tri_strip_vertex_order_independent_of_provoking_vertex,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRayTracingMotionBlurFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_tracing_motion_blur: Bool32,
    pub ray_tracing_motion_blur_pipeline_trace_rays_indirect: Bool32,
}
unsafe impl Send for PhysicalDeviceRayTracingMotionBlurFeaturesNV {}
unsafe impl Sync for PhysicalDeviceRayTracingMotionBlurFeaturesNV {}
impl Default for PhysicalDeviceRayTracingMotionBlurFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV,
            p_next: ptr::null_mut(),
            ray_tracing_motion_blur: Default::default(),
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRayTracingMotionBlurFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRayTracingMotionBlurFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ray_tracing_motion_blur", &self.ray_tracing_motion_blur)
            .field(
                "ray_tracing_motion_blur_pipeline_trace_rays_indirect",
                &self.ray_tracing_motion_blur_pipeline_trace_rays_indirect,
            )
            .finish()
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Default, PartialOrd, Ord, PartialEq, Eq, Hash)]
pub struct AccelerationStructureMotionInstanceTypeNV(i32);
impl AccelerationStructureMotionInstanceTypeNV {
    pub const STATIC: Self = Self(0);
    pub const MATRIX_MOTION: Self = Self(1);
    pub const SRT_MOTION: Self = Self(2);
}
impl fmt::Display for AccelerationStructureMotionInstanceTypeNV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self.0 {
            0 => Some(&"STATIC"),
            1 => Some(&"MATRIX_MOTION"),
            2 => Some(&"SRT_MOTION"),
            _ => None,
        };
        if let Some(name) = name {
            write!(f, "{}", name)
        } else {
            write!(f, "{}", self.0)
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureGeometryMotionTrianglesDataNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_data: DeviceOrHostAddressConstKHR,
}
unsafe impl Send for AccelerationStructureGeometryMotionTrianglesDataNV {}
unsafe impl Sync for AccelerationStructureGeometryMotionTrianglesDataNV {}
impl Default for AccelerationStructureGeometryMotionTrianglesDataNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV,
            p_next: ptr::null(),
            vertex_data: Default::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureGeometryMotionTrianglesDataNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryMotionTrianglesDataNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vertex_data", &self.vertex_data)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccelerationStructureMotionInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_instances: u32,
    pub flags: AccelerationStructureMotionInfoFlagsNV,
}
unsafe impl Send for AccelerationStructureMotionInfoNV {}
unsafe impl Sync for AccelerationStructureMotionInfoNV {}
impl Default for AccelerationStructureMotionInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::ACCELERATION_STRUCTURE_MOTION_INFO_NV,
            p_next: ptr::null(),
            max_instances: Default::default(),
            flags: Default::default(),
        }
    }
}
impl fmt::Debug for AccelerationStructureMotionInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureMotionInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("max_instances", &self.max_instances)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct SRTDataNV {
    pub sx: f32,
    pub a: f32,
    pub b: f32,
    pub pvx: f32,
    pub sy: f32,
    pub c: f32,
    pub pvy: f32,
    pub sz: f32,
    pub pvz: f32,
    pub qx: f32,
    pub qy: f32,
    pub qz: f32,
    pub qw: f32,
    pub tx: f32,
    pub ty: f32,
    pub tz: f32,
}
impl fmt::Debug for SRTDataNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SRTDataNV")
            .field("sx", &self.sx)
            .field("a", &self.a)
            .field("b", &self.b)
            .field("pvx", &self.pvx)
            .field("sy", &self.sy)
            .field("c", &self.c)
            .field("pvy", &self.pvy)
            .field("sz", &self.sz)
            .field("pvz", &self.pvz)
            .field("qx", &self.qx)
            .field("qy", &self.qy)
            .field("qz", &self.qz)
            .field("qw", &self.qw)
            .field("tx", &self.tx)
            .field("ty", &self.ty)
            .field("tz", &self.tz)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct AccelerationStructureSRTMotionInstanceNV {
    pub transform_t0: SRTDataNV,
    pub transform_t1: SRTDataNV,
    pub instance_custom_index_and_mask: u32,
    pub instance_shader_binding_table_record_offset_and_flags: u32,
    pub acceleration_structure_reference: u64,
}
impl fmt::Debug for AccelerationStructureSRTMotionInstanceNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureSRTMotionInstanceNV")
            .field("transform_t0", &self.transform_t0)
            .field("transform_t1", &self.transform_t1)
            .field("instance_custom_index_and_mask", &self.instance_custom_index_and_mask)
            .field(
                "instance_shader_binding_table_record_offset_and_flags",
                &self.instance_shader_binding_table_record_offset_and_flags,
            )
            .field(
                "acceleration_structure_reference",
                &self.acceleration_structure_reference,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct AccelerationStructureMatrixMotionInstanceNV {
    pub transform_t0: TransformMatrixKHR,
    pub transform_t1: TransformMatrixKHR,
    pub instance_custom_index_and_mask: u32,
    pub instance_shader_binding_table_record_offset_and_flags: u32,
    pub acceleration_structure_reference: u64,
}
impl fmt::Debug for AccelerationStructureMatrixMotionInstanceNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureMatrixMotionInstanceNV")
            .field("transform_t0", &self.transform_t0)
            .field("transform_t1", &self.transform_t1)
            .field("instance_custom_index_and_mask", &self.instance_custom_index_and_mask)
            .field(
                "instance_shader_binding_table_record_offset_and_flags",
                &self.instance_shader_binding_table_record_offset_and_flags,
            )
            .field(
                "acceleration_structure_reference",
                &self.acceleration_structure_reference,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AccelerationStructureMotionInstanceDataNV {
    pub static_instance: AccelerationStructureInstanceKHR,
    pub matrix_motion_instance: AccelerationStructureMatrixMotionInstanceNV,
    pub srt_motion_instance: AccelerationStructureSRTMotionInstanceNV,
}
impl Default for AccelerationStructureMotionInstanceDataNV {
    fn default() -> Self {
        unsafe { mem::zeroed() }
    }
}
impl fmt::Debug for AccelerationStructureMotionInstanceDataNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureMotionInstanceDataNV")
            .field("static_instance", unsafe { &self.static_instance })
            .field("matrix_motion_instance", unsafe { &self.matrix_motion_instance })
            .field("srt_motion_instance", unsafe { &self.srt_motion_instance })
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct AccelerationStructureMotionInstanceNV {
    pub ty: AccelerationStructureMotionInstanceTypeNV,
    pub flags: AccelerationStructureMotionInstanceFlagsNV,
    pub data: AccelerationStructureMotionInstanceDataNV,
}
impl fmt::Debug for AccelerationStructureMotionInstanceNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureMotionInstanceNV")
            .field("ty", &self.ty)
            .field("flags", &self.flags)
            .field("data", &self.data)
            .finish()
    }
}
pub type RemoteAddressNV = *mut c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryGetRemoteAddressInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: Option<DeviceMemory>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for MemoryGetRemoteAddressInfoNV {}
unsafe impl Sync for MemoryGetRemoteAddressInfoNV {}
impl Default for MemoryGetRemoteAddressInfoNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::MEMORY_GET_REMOTE_ADDRESS_INFO_NV,
            p_next: ptr::null(),
            memory: Default::default(),
            handle_type: Default::default(),
        }
    }
}
impl fmt::Debug for MemoryGetRemoteAddressInfoNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MemoryGetRemoteAddressInfoNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .field("handle_type", &self.handle_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMemoryBufferCollectionFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection: Option<BufferCollectionFUCHSIA>,
    pub index: u32,
}
unsafe impl Send for ImportMemoryBufferCollectionFUCHSIA {}
unsafe impl Sync for ImportMemoryBufferCollectionFUCHSIA {}
impl Default for ImportMemoryBufferCollectionFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA,
            p_next: ptr::null(),
            collection: Default::default(),
            index: Default::default(),
        }
    }
}
impl fmt::Debug for ImportMemoryBufferCollectionFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMemoryBufferCollectionFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("collection", &self.collection)
            .field("index", &self.index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferCollectionImageCreateInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection: Option<BufferCollectionFUCHSIA>,
    pub index: u32,
}
unsafe impl Send for BufferCollectionImageCreateInfoFUCHSIA {}
unsafe impl Sync for BufferCollectionImageCreateInfoFUCHSIA {}
impl Default for BufferCollectionImageCreateInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
            p_next: ptr::null(),
            collection: Default::default(),
            index: Default::default(),
        }
    }
}
impl fmt::Debug for BufferCollectionImageCreateInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCollectionImageCreateInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("collection", &self.collection)
            .field("index", &self.index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferCollectionBufferCreateInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection: Option<BufferCollectionFUCHSIA>,
    pub index: u32,
}
unsafe impl Send for BufferCollectionBufferCreateInfoFUCHSIA {}
unsafe impl Sync for BufferCollectionBufferCreateInfoFUCHSIA {}
impl Default for BufferCollectionBufferCreateInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA,
            p_next: ptr::null(),
            collection: Default::default(),
            index: Default::default(),
        }
    }
}
impl fmt::Debug for BufferCollectionBufferCreateInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCollectionBufferCreateInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("collection", &self.collection)
            .field("index", &self.index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferCollectionCreateInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection_token: zx_handle_t,
}
unsafe impl Send for BufferCollectionCreateInfoFUCHSIA {}
unsafe impl Sync for BufferCollectionCreateInfoFUCHSIA {}
impl Default for BufferCollectionCreateInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_COLLECTION_CREATE_INFO_FUCHSIA,
            p_next: ptr::null(),
            collection_token: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for BufferCollectionCreateInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCollectionCreateInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("collection_token", &self.collection_token)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferCollectionPropertiesFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
    pub buffer_count: u32,
    pub create_info_index: u32,
    pub sysmem_pixel_format: u64,
    pub format_features: FormatFeatureFlags,
    pub sysmem_color_space_index: SysmemColorSpaceFUCHSIA,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_x_chroma_offset: ChromaLocation,
    pub suggested_y_chroma_offset: ChromaLocation,
}
unsafe impl Send for BufferCollectionPropertiesFUCHSIA {}
unsafe impl Sync for BufferCollectionPropertiesFUCHSIA {}
impl Default for BufferCollectionPropertiesFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_COLLECTION_PROPERTIES_FUCHSIA,
            p_next: ptr::null_mut(),
            memory_type_bits: Default::default(),
            buffer_count: Default::default(),
            create_info_index: Default::default(),
            sysmem_pixel_format: Default::default(),
            format_features: Default::default(),
            sysmem_color_space_index: Default::default(),
            sampler_ycbcr_conversion_components: Default::default(),
            suggested_ycbcr_model: Default::default(),
            suggested_ycbcr_range: Default::default(),
            suggested_x_chroma_offset: Default::default(),
            suggested_y_chroma_offset: Default::default(),
        }
    }
}
impl fmt::Debug for BufferCollectionPropertiesFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCollectionPropertiesFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory_type_bits", &self.memory_type_bits)
            .field("buffer_count", &self.buffer_count)
            .field("create_info_index", &self.create_info_index)
            .field("sysmem_pixel_format", &self.sysmem_pixel_format)
            .field("format_features", &self.format_features)
            .field("sysmem_color_space_index", &self.sysmem_color_space_index)
            .field(
                "sampler_ycbcr_conversion_components",
                &self.sampler_ycbcr_conversion_components,
            )
            .field("suggested_ycbcr_model", &self.suggested_ycbcr_model)
            .field("suggested_ycbcr_range", &self.suggested_ycbcr_range)
            .field("suggested_x_chroma_offset", &self.suggested_x_chroma_offset)
            .field("suggested_y_chroma_offset", &self.suggested_y_chroma_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferConstraintsInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub create_info: BufferCreateInfo,
    pub required_format_features: FormatFeatureFlags,
    pub buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA,
}
unsafe impl Send for BufferConstraintsInfoFUCHSIA {}
unsafe impl Sync for BufferConstraintsInfoFUCHSIA {}
impl Default for BufferConstraintsInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_CONSTRAINTS_INFO_FUCHSIA,
            p_next: ptr::null(),
            create_info: Default::default(),
            required_format_features: Default::default(),
            buffer_collection_constraints: Default::default(),
        }
    }
}
impl fmt::Debug for BufferConstraintsInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferConstraintsInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("create_info", &self.create_info)
            .field("required_format_features", &self.required_format_features)
            .field("buffer_collection_constraints", &self.buffer_collection_constraints)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SysmemColorSpaceFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub color_space: u32,
}
unsafe impl Send for SysmemColorSpaceFUCHSIA {}
unsafe impl Sync for SysmemColorSpaceFUCHSIA {}
impl Default for SysmemColorSpaceFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::SYSMEM_COLOR_SPACE_FUCHSIA,
            p_next: ptr::null(),
            color_space: Default::default(),
        }
    }
}
impl fmt::Debug for SysmemColorSpaceFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SysmemColorSpaceFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("color_space", &self.color_space)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageFormatConstraintsInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_create_info: ImageCreateInfo,
    pub required_format_features: FormatFeatureFlags,
    pub flags: ImageFormatConstraintsFlagsFUCHSIA,
    pub sysmem_pixel_format: u64,
    pub color_space_count: u32,
    pub p_color_spaces: *const SysmemColorSpaceFUCHSIA,
}
unsafe impl Send for ImageFormatConstraintsInfoFUCHSIA {}
unsafe impl Sync for ImageFormatConstraintsInfoFUCHSIA {}
impl Default for ImageFormatConstraintsInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA,
            p_next: ptr::null(),
            image_create_info: Default::default(),
            required_format_features: Default::default(),
            flags: Default::default(),
            sysmem_pixel_format: Default::default(),
            color_space_count: Default::default(),
            p_color_spaces: ptr::null(),
        }
    }
}
impl fmt::Debug for ImageFormatConstraintsInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageFormatConstraintsInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_create_info", &self.image_create_info)
            .field("required_format_features", &self.required_format_features)
            .field("flags", &self.flags)
            .field("sysmem_pixel_format", &self.sysmem_pixel_format)
            .field("color_space_count", &self.color_space_count)
            .field("p_color_spaces", &self.p_color_spaces)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageConstraintsInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format_constraints_count: u32,
    pub p_format_constraints: *const ImageFormatConstraintsInfoFUCHSIA,
    pub buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA,
    pub flags: ImageConstraintsInfoFlagsFUCHSIA,
}
unsafe impl Send for ImageConstraintsInfoFUCHSIA {}
unsafe impl Sync for ImageConstraintsInfoFUCHSIA {}
impl Default for ImageConstraintsInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_CONSTRAINTS_INFO_FUCHSIA,
            p_next: ptr::null(),
            format_constraints_count: Default::default(),
            p_format_constraints: ptr::null(),
            buffer_collection_constraints: Default::default(),
            flags: Default::default(),
        }
    }
}
impl fmt::Debug for ImageConstraintsInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageConstraintsInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format_constraints_count", &self.format_constraints_count)
            .field("p_format_constraints", &self.p_format_constraints)
            .field("buffer_collection_constraints", &self.buffer_collection_constraints)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferCollectionConstraintsInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub min_buffer_count: u32,
    pub max_buffer_count: u32,
    pub min_buffer_count_for_camping: u32,
    pub min_buffer_count_for_dedicated_slack: u32,
    pub min_buffer_count_for_shared_slack: u32,
}
unsafe impl Send for BufferCollectionConstraintsInfoFUCHSIA {}
unsafe impl Sync for BufferCollectionConstraintsInfoFUCHSIA {}
impl Default for BufferCollectionConstraintsInfoFUCHSIA {
    fn default() -> Self {
        Self {
            s_type: StructureType::BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA,
            p_next: ptr::null(),
            min_buffer_count: Default::default(),
            max_buffer_count: Default::default(),
            min_buffer_count_for_camping: Default::default(),
            min_buffer_count_for_dedicated_slack: Default::default(),
            min_buffer_count_for_shared_slack: Default::default(),
        }
    }
}
impl fmt::Debug for BufferCollectionConstraintsInfoFUCHSIA {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("BufferCollectionConstraintsInfoFUCHSIA")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_buffer_count", &self.min_buffer_count)
            .field("max_buffer_count", &self.max_buffer_count)
            .field("min_buffer_count_for_camping", &self.min_buffer_count_for_camping)
            .field(
                "min_buffer_count_for_dedicated_slack",
                &self.min_buffer_count_for_dedicated_slack,
            )
            .field(
                "min_buffer_count_for_shared_slack",
                &self.min_buffer_count_for_shared_slack,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format_rgba10x6_without_y_cb_cr_sampler: Bool32,
}
unsafe impl Send for PhysicalDeviceRGBA10X6FormatsFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceRGBA10X6FormatsFeaturesEXT {}
impl Default for PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT,
            p_next: ptr::null_mut(),
            format_rgba10x6_without_y_cb_cr_sampler: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRGBA10X6FormatsFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "format_rgba10x6_without_y_cb_cr_sampler",
                &self.format_rgba10x6_without_y_cb_cr_sampler,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FormatProperties3 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub linear_tiling_features: FormatFeatureFlags2,
    pub optimal_tiling_features: FormatFeatureFlags2,
    pub buffer_features: FormatFeatureFlags2,
}
unsafe impl Send for FormatProperties3 {}
unsafe impl Sync for FormatProperties3 {}
impl Default for FormatProperties3 {
    fn default() -> Self {
        Self {
            s_type: StructureType::FORMAT_PROPERTIES_3,
            p_next: ptr::null_mut(),
            linear_tiling_features: Default::default(),
            optimal_tiling_features: Default::default(),
            buffer_features: Default::default(),
        }
    }
}
impl fmt::Debug for FormatProperties3 {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FormatProperties3")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("linear_tiling_features", &self.linear_tiling_features)
            .field("optimal_tiling_features", &self.optimal_tiling_features)
            .field("buffer_features", &self.buffer_features)
            .finish()
    }
}
pub type FormatProperties3KHR = FormatProperties3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DrmFormatModifierPropertiesList2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub drm_format_modifier_count: u32,
    pub p_drm_format_modifier_properties: *mut DrmFormatModifierProperties2EXT,
}
unsafe impl Send for DrmFormatModifierPropertiesList2EXT {}
unsafe impl Sync for DrmFormatModifierPropertiesList2EXT {}
impl Default for DrmFormatModifierPropertiesList2EXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT,
            p_next: ptr::null_mut(),
            drm_format_modifier_count: Default::default(),
            p_drm_format_modifier_properties: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for DrmFormatModifierPropertiesList2EXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DrmFormatModifierPropertiesList2EXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("drm_format_modifier_count", &self.drm_format_modifier_count)
            .field(
                "p_drm_format_modifier_properties",
                &self.p_drm_format_modifier_properties,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct DrmFormatModifierProperties2EXT {
    pub drm_format_modifier: u64,
    pub drm_format_modifier_plane_count: u32,
    pub drm_format_modifier_tiling_features: FormatFeatureFlags2,
}
impl fmt::Debug for DrmFormatModifierProperties2EXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DrmFormatModifierProperties2EXT")
            .field("drm_format_modifier", &self.drm_format_modifier)
            .field("drm_format_modifier_plane_count", &self.drm_format_modifier_plane_count)
            .field(
                "drm_format_modifier_tiling_features",
                &self.drm_format_modifier_tiling_features,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AndroidHardwareBufferFormatProperties2ANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format: Format,
    pub external_format: u64,
    pub format_features: FormatFeatureFlags2,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_x_chroma_offset: ChromaLocation,
    pub suggested_y_chroma_offset: ChromaLocation,
}
unsafe impl Send for AndroidHardwareBufferFormatProperties2ANDROID {}
unsafe impl Sync for AndroidHardwareBufferFormatProperties2ANDROID {}
impl Default for AndroidHardwareBufferFormatProperties2ANDROID {
    fn default() -> Self {
        Self {
            s_type: StructureType::ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID,
            p_next: ptr::null_mut(),
            format: Default::default(),
            external_format: Default::default(),
            format_features: Default::default(),
            sampler_ycbcr_conversion_components: Default::default(),
            suggested_ycbcr_model: Default::default(),
            suggested_ycbcr_range: Default::default(),
            suggested_x_chroma_offset: Default::default(),
            suggested_y_chroma_offset: Default::default(),
        }
    }
}
impl fmt::Debug for AndroidHardwareBufferFormatProperties2ANDROID {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AndroidHardwareBufferFormatProperties2ANDROID")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("format", &self.format)
            .field("external_format", &self.external_format)
            .field("format_features", &self.format_features)
            .field(
                "sampler_ycbcr_conversion_components",
                &self.sampler_ycbcr_conversion_components,
            )
            .field("suggested_ycbcr_model", &self.suggested_ycbcr_model)
            .field("suggested_ycbcr_range", &self.suggested_ycbcr_range)
            .field("suggested_x_chroma_offset", &self.suggested_x_chroma_offset)
            .field("suggested_y_chroma_offset", &self.suggested_y_chroma_offset)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineRenderingCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachment_formats: *const Format,
    pub depth_attachment_format: Format,
    pub stencil_attachment_format: Format,
}
unsafe impl Send for PipelineRenderingCreateInfo {}
unsafe impl Sync for PipelineRenderingCreateInfo {}
impl Default for PipelineRenderingCreateInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_RENDERING_CREATE_INFO,
            p_next: ptr::null(),
            view_mask: Default::default(),
            color_attachment_count: Default::default(),
            p_color_attachment_formats: ptr::null(),
            depth_attachment_format: Default::default(),
            stencil_attachment_format: Default::default(),
        }
    }
}
impl fmt::Debug for PipelineRenderingCreateInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineRenderingCreateInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("view_mask", &self.view_mask)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachment_formats", &self.p_color_attachment_formats)
            .field("depth_attachment_format", &self.depth_attachment_format)
            .field("stencil_attachment_format", &self.stencil_attachment_format)
            .finish()
    }
}
pub type PipelineRenderingCreateInfoKHR = PipelineRenderingCreateInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderingInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderingFlags,
    pub render_area: Rect2D,
    pub layer_count: u32,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachments: *const RenderingAttachmentInfo,
    pub p_depth_attachment: *const RenderingAttachmentInfo,
    pub p_stencil_attachment: *const RenderingAttachmentInfo,
}
unsafe impl Send for RenderingInfo {}
unsafe impl Sync for RenderingInfo {}
impl Default for RenderingInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDERING_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            render_area: Default::default(),
            layer_count: Default::default(),
            view_mask: Default::default(),
            color_attachment_count: Default::default(),
            p_color_attachments: ptr::null(),
            p_depth_attachment: ptr::null(),
            p_stencil_attachment: ptr::null(),
        }
    }
}
impl fmt::Debug for RenderingInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderingInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("render_area", &self.render_area)
            .field("layer_count", &self.layer_count)
            .field("view_mask", &self.view_mask)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachments", &self.p_color_attachments)
            .field("p_depth_attachment", &self.p_depth_attachment)
            .field("p_stencil_attachment", &self.p_stencil_attachment)
            .finish()
    }
}
pub type RenderingInfoKHR = RenderingInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderingAttachmentInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: Option<ImageView>,
    pub image_layout: ImageLayout,
    pub resolve_mode: ResolveModeFlags,
    pub resolve_image_view: Option<ImageView>,
    pub resolve_image_layout: ImageLayout,
    pub load_op: AttachmentLoadOp,
    pub store_op: AttachmentStoreOp,
    pub clear_value: ClearValue,
}
unsafe impl Send for RenderingAttachmentInfo {}
unsafe impl Sync for RenderingAttachmentInfo {}
impl Default for RenderingAttachmentInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDERING_ATTACHMENT_INFO,
            p_next: ptr::null(),
            image_view: Default::default(),
            image_layout: Default::default(),
            resolve_mode: Default::default(),
            resolve_image_view: Default::default(),
            resolve_image_layout: Default::default(),
            load_op: Default::default(),
            store_op: Default::default(),
            clear_value: Default::default(),
        }
    }
}
impl fmt::Debug for RenderingAttachmentInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderingAttachmentInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_view", &self.image_view)
            .field("image_layout", &self.image_layout)
            .field("resolve_mode", &self.resolve_mode)
            .field("resolve_image_view", &self.resolve_image_view)
            .field("resolve_image_layout", &self.resolve_image_layout)
            .field("load_op", &self.load_op)
            .field("store_op", &self.store_op)
            .field("clear_value", &self.clear_value)
            .finish()
    }
}
pub type RenderingAttachmentInfoKHR = RenderingAttachmentInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderingFragmentShadingRateAttachmentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: Option<ImageView>,
    pub image_layout: ImageLayout,
    pub shading_rate_attachment_texel_size: Extent2D,
}
unsafe impl Send for RenderingFragmentShadingRateAttachmentInfoKHR {}
unsafe impl Sync for RenderingFragmentShadingRateAttachmentInfoKHR {}
impl Default for RenderingFragmentShadingRateAttachmentInfoKHR {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
            p_next: ptr::null(),
            image_view: Default::default(),
            image_layout: Default::default(),
            shading_rate_attachment_texel_size: Default::default(),
        }
    }
}
impl fmt::Debug for RenderingFragmentShadingRateAttachmentInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderingFragmentShadingRateAttachmentInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_view", &self.image_view)
            .field("image_layout", &self.image_layout)
            .field(
                "shading_rate_attachment_texel_size",
                &self.shading_rate_attachment_texel_size,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderingFragmentDensityMapAttachmentInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: Option<ImageView>,
    pub image_layout: ImageLayout,
}
unsafe impl Send for RenderingFragmentDensityMapAttachmentInfoEXT {}
unsafe impl Sync for RenderingFragmentDensityMapAttachmentInfoEXT {}
impl Default for RenderingFragmentDensityMapAttachmentInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT,
            p_next: ptr::null(),
            image_view: Default::default(),
            image_layout: Default::default(),
        }
    }
}
impl fmt::Debug for RenderingFragmentDensityMapAttachmentInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderingFragmentDensityMapAttachmentInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_view", &self.image_view)
            .field("image_layout", &self.image_layout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDynamicRenderingFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub dynamic_rendering: Bool32,
}
unsafe impl Send for PhysicalDeviceDynamicRenderingFeatures {}
unsafe impl Sync for PhysicalDeviceDynamicRenderingFeatures {}
impl Default for PhysicalDeviceDynamicRenderingFeatures {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
            p_next: ptr::null_mut(),
            dynamic_rendering: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDynamicRenderingFeatures {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDynamicRenderingFeatures")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("dynamic_rendering", &self.dynamic_rendering)
            .finish()
    }
}
pub type PhysicalDeviceDynamicRenderingFeaturesKHR = PhysicalDeviceDynamicRenderingFeatures;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandBufferInheritanceRenderingInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderingFlags,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachment_formats: *const Format,
    pub depth_attachment_format: Format,
    pub stencil_attachment_format: Format,
    pub rasterization_samples: SampleCountFlags,
}
unsafe impl Send for CommandBufferInheritanceRenderingInfo {}
unsafe impl Sync for CommandBufferInheritanceRenderingInfo {}
impl Default for CommandBufferInheritanceRenderingInfo {
    fn default() -> Self {
        Self {
            s_type: StructureType::COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
            p_next: ptr::null(),
            flags: Default::default(),
            view_mask: Default::default(),
            color_attachment_count: Default::default(),
            p_color_attachment_formats: ptr::null(),
            depth_attachment_format: Default::default(),
            stencil_attachment_format: Default::default(),
            rasterization_samples: Default::default(),
        }
    }
}
impl fmt::Debug for CommandBufferInheritanceRenderingInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CommandBufferInheritanceRenderingInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("view_mask", &self.view_mask)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachment_formats", &self.p_color_attachment_formats)
            .field("depth_attachment_format", &self.depth_attachment_format)
            .field("stencil_attachment_format", &self.stencil_attachment_format)
            .field("rasterization_samples", &self.rasterization_samples)
            .finish()
    }
}
pub type CommandBufferInheritanceRenderingInfoKHR = CommandBufferInheritanceRenderingInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AttachmentSampleCountInfoAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub color_attachment_count: u32,
    pub p_color_attachment_samples: *const SampleCountFlags,
    pub depth_stencil_attachment_samples: SampleCountFlags,
}
unsafe impl Send for AttachmentSampleCountInfoAMD {}
unsafe impl Sync for AttachmentSampleCountInfoAMD {}
impl Default for AttachmentSampleCountInfoAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
            p_next: ptr::null(),
            color_attachment_count: Default::default(),
            p_color_attachment_samples: ptr::null(),
            depth_stencil_attachment_samples: Default::default(),
        }
    }
}
impl fmt::Debug for AttachmentSampleCountInfoAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AttachmentSampleCountInfoAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("color_attachment_count", &self.color_attachment_count)
            .field("p_color_attachment_samples", &self.p_color_attachment_samples)
            .field(
                "depth_stencil_attachment_samples",
                &self.depth_stencil_attachment_samples,
            )
            .finish()
    }
}
pub type AttachmentSampleCountInfoNV = AttachmentSampleCountInfoAMD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MultiviewPerViewAttributesInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub per_view_attributes: Bool32,
    pub per_view_attributes_position_x_only: Bool32,
}
unsafe impl Send for MultiviewPerViewAttributesInfoNVX {}
unsafe impl Sync for MultiviewPerViewAttributesInfoNVX {}
impl Default for MultiviewPerViewAttributesInfoNVX {
    fn default() -> Self {
        Self {
            s_type: StructureType::MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX,
            p_next: ptr::null(),
            per_view_attributes: Default::default(),
            per_view_attributes_position_x_only: Default::default(),
        }
    }
}
impl fmt::Debug for MultiviewPerViewAttributesInfoNVX {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MultiviewPerViewAttributesInfoNVX")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("per_view_attributes", &self.per_view_attributes)
            .field(
                "per_view_attributes_position_x_only",
                &self.per_view_attributes_position_x_only,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImageViewMinLodFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_lod: Bool32,
}
unsafe impl Send for PhysicalDeviceImageViewMinLodFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceImageViewMinLodFeaturesEXT {}
impl Default for PhysicalDeviceImageViewMinLodFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT,
            p_next: ptr::null_mut(),
            min_lod: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImageViewMinLodFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImageViewMinLodFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_lod", &self.min_lod)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageViewMinLodCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub min_lod: f32,
}
unsafe impl Send for ImageViewMinLodCreateInfoEXT {}
unsafe impl Sync for ImageViewMinLodCreateInfoEXT {}
impl Default for ImageViewMinLodCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT,
            p_next: ptr::null(),
            min_lod: Default::default(),
        }
    }
}
impl fmt::Debug for ImageViewMinLodCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageViewMinLodCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("min_lod", &self.min_lod)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub rasterization_order_color_attachment_access: Bool32,
    pub rasterization_order_depth_attachment_access: Bool32,
    pub rasterization_order_stencil_attachment_access: Bool32,
}
unsafe impl Send for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM {}
unsafe impl Sync for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM {}
impl Default for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM,
            p_next: ptr::null_mut(),
            rasterization_order_color_attachment_access: Default::default(),
            rasterization_order_depth_attachment_access: Default::default(),
            rasterization_order_stencil_attachment_access: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "rasterization_order_color_attachment_access",
                &self.rasterization_order_color_attachment_access,
            )
            .field(
                "rasterization_order_depth_attachment_access",
                &self.rasterization_order_depth_attachment_access,
            )
            .field(
                "rasterization_order_stencil_attachment_access",
                &self.rasterization_order_stencil_attachment_access,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceLinearColorAttachmentFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub linear_color_attachment: Bool32,
}
unsafe impl Send for PhysicalDeviceLinearColorAttachmentFeaturesNV {}
unsafe impl Sync for PhysicalDeviceLinearColorAttachmentFeaturesNV {}
impl Default for PhysicalDeviceLinearColorAttachmentFeaturesNV {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV,
            p_next: ptr::null_mut(),
            linear_color_attachment: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceLinearColorAttachmentFeaturesNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceLinearColorAttachmentFeaturesNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("linear_color_attachment", &self.linear_color_attachment)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub graphics_pipeline_library: Bool32,
}
unsafe impl Send for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {}
impl Default for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT,
            p_next: ptr::null_mut(),
            graphics_pipeline_library: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("graphics_pipeline_library", &self.graphics_pipeline_library)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub graphics_pipeline_library_fast_linking: Bool32,
    pub graphics_pipeline_library_independent_interpolation_decoration: Bool32,
}
unsafe impl Send for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {}
unsafe impl Sync for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {}
impl Default for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            graphics_pipeline_library_fast_linking: Default::default(),
            graphics_pipeline_library_independent_interpolation_decoration: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "graphics_pipeline_library_fast_linking",
                &self.graphics_pipeline_library_fast_linking,
            )
            .field(
                "graphics_pipeline_library_independent_interpolation_decoration",
                &self.graphics_pipeline_library_independent_interpolation_decoration,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GraphicsPipelineLibraryCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: GraphicsPipelineLibraryFlagsEXT,
}
unsafe impl Send for GraphicsPipelineLibraryCreateInfoEXT {}
unsafe impl Sync for GraphicsPipelineLibraryCreateInfoEXT {}
impl Default for GraphicsPipelineLibraryCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT,
            p_next: ptr::null_mut(),
            flags: Default::default(),
        }
    }
}
impl fmt::Debug for GraphicsPipelineLibraryCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("GraphicsPipelineLibraryCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub descriptor_set_host_mapping: Bool32,
}
unsafe impl Send for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {}
unsafe impl Sync for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {}
impl Default for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE,
            p_next: ptr::null_mut(),
            descriptor_set_host_mapping: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("descriptor_set_host_mapping", &self.descriptor_set_host_mapping)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetBindingReferenceVALVE {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub descriptor_set_layout: Option<DescriptorSetLayout>,
    pub binding: u32,
}
unsafe impl Send for DescriptorSetBindingReferenceVALVE {}
unsafe impl Sync for DescriptorSetBindingReferenceVALVE {}
impl Default for DescriptorSetBindingReferenceVALVE {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_SET_BINDING_REFERENCE_VALVE,
            p_next: ptr::null(),
            descriptor_set_layout: Default::default(),
            binding: Default::default(),
        }
    }
}
impl fmt::Debug for DescriptorSetBindingReferenceVALVE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetBindingReferenceVALVE")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("descriptor_set_layout", &self.descriptor_set_layout)
            .field("binding", &self.binding)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorSetLayoutHostMappingInfoVALVE {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub descriptor_offset: usize,
    pub descriptor_size: u32,
}
unsafe impl Send for DescriptorSetLayoutHostMappingInfoVALVE {}
unsafe impl Sync for DescriptorSetLayoutHostMappingInfoVALVE {}
impl Default for DescriptorSetLayoutHostMappingInfoVALVE {
    fn default() -> Self {
        Self {
            s_type: StructureType::DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE,
            p_next: ptr::null_mut(),
            descriptor_offset: Default::default(),
            descriptor_size: Default::default(),
        }
    }
}
impl fmt::Debug for DescriptorSetLayoutHostMappingInfoVALVE {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorSetLayoutHostMappingInfoVALVE")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("descriptor_offset", &self.descriptor_offset)
            .field("descriptor_size", &self.descriptor_size)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageCompressionControlEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImageCompressionFlagsEXT,
    pub compression_control_plane_count: u32,
    pub p_fixed_rate_flags: *mut ImageCompressionFixedRateFlagsEXT,
}
unsafe impl Send for ImageCompressionControlEXT {}
unsafe impl Sync for ImageCompressionControlEXT {}
impl Default for ImageCompressionControlEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_COMPRESSION_CONTROL_EXT,
            p_next: ptr::null(),
            flags: Default::default(),
            compression_control_plane_count: Default::default(),
            p_fixed_rate_flags: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for ImageCompressionControlEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageCompressionControlEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("compression_control_plane_count", &self.compression_control_plane_count)
            .field("p_fixed_rate_flags", &self.p_fixed_rate_flags)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImageCompressionControlFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_compression_control: Bool32,
}
unsafe impl Send for PhysicalDeviceImageCompressionControlFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceImageCompressionControlFeaturesEXT {}
impl Default for PhysicalDeviceImageCompressionControlFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT,
            p_next: ptr::null_mut(),
            image_compression_control: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImageCompressionControlFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImageCompressionControlFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_compression_control", &self.image_compression_control)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageCompressionPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_compression_flags: ImageCompressionFlagsEXT,
    pub image_compression_fixed_rate_flags: ImageCompressionFixedRateFlagsEXT,
}
unsafe impl Send for ImageCompressionPropertiesEXT {}
unsafe impl Sync for ImageCompressionPropertiesEXT {}
impl Default for ImageCompressionPropertiesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_COMPRESSION_PROPERTIES_EXT,
            p_next: ptr::null_mut(),
            image_compression_flags: Default::default(),
            image_compression_fixed_rate_flags: Default::default(),
        }
    }
}
impl fmt::Debug for ImageCompressionPropertiesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageCompressionPropertiesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_compression_flags", &self.image_compression_flags)
            .field(
                "image_compression_fixed_rate_flags",
                &self.image_compression_fixed_rate_flags,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_compression_control_swapchain: Bool32,
}
unsafe impl Send for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {}
impl Default for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT,
            p_next: ptr::null_mut(),
            image_compression_control_swapchain: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "image_compression_control_swapchain",
                &self.image_compression_control_swapchain,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageSubresource2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_subresource: ImageSubresource,
}
unsafe impl Send for ImageSubresource2EXT {}
unsafe impl Sync for ImageSubresource2EXT {}
impl Default for ImageSubresource2EXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMAGE_SUBRESOURCE_2_EXT,
            p_next: ptr::null_mut(),
            image_subresource: Default::default(),
        }
    }
}
impl fmt::Debug for ImageSubresource2EXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImageSubresource2EXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_subresource", &self.image_subresource)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubresourceLayout2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subresource_layout: SubresourceLayout,
}
unsafe impl Send for SubresourceLayout2EXT {}
unsafe impl Sync for SubresourceLayout2EXT {}
impl Default for SubresourceLayout2EXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::SUBRESOURCE_LAYOUT_2_EXT,
            p_next: ptr::null_mut(),
            subresource_layout: Default::default(),
        }
    }
}
impl fmt::Debug for SubresourceLayout2EXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SubresourceLayout2EXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("subresource_layout", &self.subresource_layout)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassCreationControlEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub disallow_merging: Bool32,
}
unsafe impl Send for RenderPassCreationControlEXT {}
unsafe impl Sync for RenderPassCreationControlEXT {}
impl Default for RenderPassCreationControlEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_CREATION_CONTROL_EXT,
            p_next: ptr::null(),
            disallow_merging: Default::default(),
        }
    }
}
impl fmt::Debug for RenderPassCreationControlEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassCreationControlEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("disallow_merging", &self.disallow_merging)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
pub struct RenderPassCreationFeedbackInfoEXT {
    pub post_merge_subpass_count: u32,
}
impl fmt::Debug for RenderPassCreationFeedbackInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassCreationFeedbackInfoEXT")
            .field("post_merge_subpass_count", &self.post_merge_subpass_count)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassCreationFeedbackCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_render_pass_feedback: *mut RenderPassCreationFeedbackInfoEXT,
}
unsafe impl Send for RenderPassCreationFeedbackCreateInfoEXT {}
unsafe impl Sync for RenderPassCreationFeedbackCreateInfoEXT {}
impl Default for RenderPassCreationFeedbackCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT,
            p_next: ptr::null(),
            p_render_pass_feedback: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for RenderPassCreationFeedbackCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassCreationFeedbackCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_render_pass_feedback", &self.p_render_pass_feedback)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassSubpassFeedbackInfoEXT {
    pub subpass_merge_status: SubpassMergeStatusEXT,
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub post_merge_index: u32,
}
impl Default for RenderPassSubpassFeedbackInfoEXT {
    fn default() -> Self {
        Self {
            subpass_merge_status: Default::default(),
            description: [Default::default(); MAX_DESCRIPTION_SIZE],
            post_merge_index: Default::default(),
        }
    }
}
impl fmt::Debug for RenderPassSubpassFeedbackInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassSubpassFeedbackInfoEXT")
            .field("subpass_merge_status", &self.subpass_merge_status)
            .field("description", &unsafe { CStr::from_ptr(self.description.as_ptr()) })
            .field("post_merge_index", &self.post_merge_index)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassSubpassFeedbackCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_subpass_feedback: *mut RenderPassSubpassFeedbackInfoEXT,
}
unsafe impl Send for RenderPassSubpassFeedbackCreateInfoEXT {}
unsafe impl Sync for RenderPassSubpassFeedbackCreateInfoEXT {}
impl Default for RenderPassSubpassFeedbackCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT,
            p_next: ptr::null(),
            p_subpass_feedback: ptr::null_mut(),
        }
    }
}
impl fmt::Debug for RenderPassSubpassFeedbackCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassSubpassFeedbackCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("p_subpass_feedback", &self.p_subpass_feedback)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subpass_merge_feedback: Bool32,
}
unsafe impl Send for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {}
impl Default for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT,
            p_next: ptr::null_mut(),
            subpass_merge_feedback: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceSubpassMergeFeedbackFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("subpass_merge_feedback", &self.subpass_merge_feedback)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelinePropertiesIdentifierEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_identifier: [u8; UUID_SIZE],
}
unsafe impl Send for PipelinePropertiesIdentifierEXT {}
unsafe impl Sync for PipelinePropertiesIdentifierEXT {}
impl Default for PipelinePropertiesIdentifierEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PIPELINE_PROPERTIES_IDENTIFIER_EXT,
            p_next: ptr::null_mut(),
            pipeline_identifier: [Default::default(); UUID_SIZE],
        }
    }
}
impl fmt::Debug for PipelinePropertiesIdentifierEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelinePropertiesIdentifierEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline_identifier", &self.pipeline_identifier)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDevicePipelinePropertiesFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_properties_identifier: Bool32,
}
unsafe impl Send for PhysicalDevicePipelinePropertiesFeaturesEXT {}
unsafe impl Sync for PhysicalDevicePipelinePropertiesFeaturesEXT {}
impl Default for PhysicalDevicePipelinePropertiesFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT,
            p_next: ptr::null_mut(),
            pipeline_properties_identifier: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDevicePipelinePropertiesFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDevicePipelinePropertiesFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("pipeline_properties_identifier", &self.pipeline_properties_identifier)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_early_and_late_fragment_tests: Bool32,
}
unsafe impl Send for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {}
unsafe impl Sync for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {}
impl Default for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD,
            p_next: ptr::null_mut(),
            shader_early_and_late_fragment_tests: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "shader_early_and_late_fragment_tests",
                &self.shader_early_and_late_fragment_tests,
            )
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMetalObjectCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub export_object_type: ExportMetalObjectTypeFlagsEXT,
}
unsafe impl Send for ExportMetalObjectCreateInfoEXT {}
unsafe impl Sync for ExportMetalObjectCreateInfoEXT {}
impl Default for ExportMetalObjectCreateInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            p_next: ptr::null(),
            export_object_type: Default::default(),
        }
    }
}
impl fmt::Debug for ExportMetalObjectCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMetalObjectCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("export_object_type", &self.export_object_type)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMetalObjectsInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
}
unsafe impl Send for ExportMetalObjectsInfoEXT {}
unsafe impl Sync for ExportMetalObjectsInfoEXT {}
impl Default for ExportMetalObjectsInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_METAL_OBJECTS_INFO_EXT,
            p_next: ptr::null(),
        }
    }
}
impl fmt::Debug for ExportMetalObjectsInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMetalObjectsInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMetalDeviceInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mtl_device: MTLDevice_id,
}
unsafe impl Send for ExportMetalDeviceInfoEXT {}
unsafe impl Sync for ExportMetalDeviceInfoEXT {}
impl Default for ExportMetalDeviceInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_METAL_DEVICE_INFO_EXT,
            p_next: ptr::null(),
            mtl_device: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ExportMetalDeviceInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMetalDeviceInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("mtl_device", &self.mtl_device)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMetalCommandQueueInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub queue: Option<Queue>,
    pub mtl_command_queue: MTLCommandQueue_id,
}
unsafe impl Send for ExportMetalCommandQueueInfoEXT {}
unsafe impl Sync for ExportMetalCommandQueueInfoEXT {}
impl Default for ExportMetalCommandQueueInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_METAL_COMMAND_QUEUE_INFO_EXT,
            p_next: ptr::null(),
            queue: Default::default(),
            mtl_command_queue: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ExportMetalCommandQueueInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMetalCommandQueueInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("queue", &self.queue)
            .field("mtl_command_queue", &self.mtl_command_queue)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMetalBufferInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: Option<DeviceMemory>,
    pub mtl_buffer: MTLBuffer_id,
}
unsafe impl Send for ExportMetalBufferInfoEXT {}
unsafe impl Sync for ExportMetalBufferInfoEXT {}
impl Default for ExportMetalBufferInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_METAL_BUFFER_INFO_EXT,
            p_next: ptr::null(),
            memory: Default::default(),
            mtl_buffer: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ExportMetalBufferInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMetalBufferInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("memory", &self.memory)
            .field("mtl_buffer", &self.mtl_buffer)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMetalBufferInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mtl_buffer: MTLBuffer_id,
}
unsafe impl Send for ImportMetalBufferInfoEXT {}
unsafe impl Sync for ImportMetalBufferInfoEXT {}
impl Default for ImportMetalBufferInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_METAL_BUFFER_INFO_EXT,
            p_next: ptr::null(),
            mtl_buffer: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportMetalBufferInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMetalBufferInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("mtl_buffer", &self.mtl_buffer)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMetalTextureInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Option<Image>,
    pub image_view: Option<ImageView>,
    pub buffer_view: Option<BufferView>,
    pub plane: ImageAspectFlags,
    pub mtl_texture: MTLTexture_id,
}
unsafe impl Send for ExportMetalTextureInfoEXT {}
unsafe impl Sync for ExportMetalTextureInfoEXT {}
impl Default for ExportMetalTextureInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_METAL_TEXTURE_INFO_EXT,
            p_next: ptr::null(),
            image: Default::default(),
            image_view: Default::default(),
            buffer_view: Default::default(),
            plane: Default::default(),
            mtl_texture: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ExportMetalTextureInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMetalTextureInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image", &self.image)
            .field("image_view", &self.image_view)
            .field("buffer_view", &self.buffer_view)
            .field("plane", &self.plane)
            .field("mtl_texture", &self.mtl_texture)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMetalTextureInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub plane: ImageAspectFlags,
    pub mtl_texture: MTLTexture_id,
}
unsafe impl Send for ImportMetalTextureInfoEXT {}
unsafe impl Sync for ImportMetalTextureInfoEXT {}
impl Default for ImportMetalTextureInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_METAL_TEXTURE_INFO_EXT,
            p_next: ptr::null(),
            plane: Default::default(),
            mtl_texture: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportMetalTextureInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMetalTextureInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("plane", &self.plane)
            .field("mtl_texture", &self.mtl_texture)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMetalIOSurfaceInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Option<Image>,
    pub io_surface: IOSurfaceRef,
}
unsafe impl Send for ExportMetalIOSurfaceInfoEXT {}
unsafe impl Sync for ExportMetalIOSurfaceInfoEXT {}
impl Default for ExportMetalIOSurfaceInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_METAL_IO_SURFACE_INFO_EXT,
            p_next: ptr::null(),
            image: Default::default(),
            io_surface: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ExportMetalIOSurfaceInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMetalIOSurfaceInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image", &self.image)
            .field("io_surface", &self.io_surface)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMetalIOSurfaceInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub io_surface: IOSurfaceRef,
}
unsafe impl Send for ImportMetalIOSurfaceInfoEXT {}
unsafe impl Sync for ImportMetalIOSurfaceInfoEXT {}
impl Default for ImportMetalIOSurfaceInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_METAL_IO_SURFACE_INFO_EXT,
            p_next: ptr::null(),
            io_surface: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportMetalIOSurfaceInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMetalIOSurfaceInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("io_surface", &self.io_surface)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExportMetalSharedEventInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Option<Semaphore>,
    pub event: Option<Event>,
    pub mtl_shared_event: MTLSharedEvent_id,
}
unsafe impl Send for ExportMetalSharedEventInfoEXT {}
unsafe impl Sync for ExportMetalSharedEventInfoEXT {}
impl Default for ExportMetalSharedEventInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::EXPORT_METAL_SHARED_EVENT_INFO_EXT,
            p_next: ptr::null(),
            semaphore: Default::default(),
            event: Default::default(),
            mtl_shared_event: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ExportMetalSharedEventInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExportMetalSharedEventInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("semaphore", &self.semaphore)
            .field("event", &self.event)
            .field("mtl_shared_event", &self.mtl_shared_event)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImportMetalSharedEventInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mtl_shared_event: MTLSharedEvent_id,
}
unsafe impl Send for ImportMetalSharedEventInfoEXT {}
unsafe impl Sync for ImportMetalSharedEventInfoEXT {}
impl Default for ImportMetalSharedEventInfoEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::IMPORT_METAL_SHARED_EVENT_INFO_EXT,
            p_next: ptr::null(),
            mtl_shared_event: unsafe { mem::zeroed() },
        }
    }
}
impl fmt::Debug for ImportMetalSharedEventInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ImportMetalSharedEventInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("mtl_shared_event", &self.mtl_shared_event)
            .finish()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub non_seamless_cube_map: Bool32,
}
unsafe impl Send for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {}
unsafe impl Sync for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {}
impl Default for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
    fn default() -> Self {
        Self {
            s_type: StructureType::PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT,
            p_next: ptr::null_mut(),
            non_seamless_cube_map: Default::default(),
        }
    }
}
impl fmt::Debug for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceNonSeamlessCubeMapFeaturesEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("non_seamless_cube_map", &self.non_seamless_cube_map)
            .finish()
    }
}
pub type FnCreateInstance = unsafe extern "system" fn(
    p_create_info: *const InstanceCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_instance: *mut Instance,
) -> Result;
pub type FnDestroyInstance =
    unsafe extern "system" fn(instance: Option<Instance>, p_allocator: *const AllocationCallbacks);
pub type FnEnumeratePhysicalDevices = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_physical_device_count: *mut u32,
    p_physical_devices: *mut PhysicalDevice,
) -> Result;
pub type FnGetDeviceProcAddr =
    unsafe extern "system" fn(device: Option<Device>, p_name: *const c_char) -> Option<FnVoidFunction>;
pub type FnGetInstanceProcAddr =
    unsafe extern "system" fn(instance: Option<Instance>, p_name: *const c_char) -> Option<FnVoidFunction>;
pub type FnGetPhysicalDeviceProperties =
    unsafe extern "system" fn(physical_device: Option<PhysicalDevice>, p_properties: *mut PhysicalDeviceProperties);
pub type FnGetPhysicalDeviceQueueFamilyProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_queue_family_property_count: *mut u32,
    p_queue_family_properties: *mut QueueFamilyProperties,
);
pub type FnGetPhysicalDeviceMemoryProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_memory_properties: *mut PhysicalDeviceMemoryProperties,
);
pub type FnGetPhysicalDeviceFeatures =
    unsafe extern "system" fn(physical_device: Option<PhysicalDevice>, p_features: *mut PhysicalDeviceFeatures);
pub type FnGetPhysicalDeviceFormatProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    format: Format,
    p_format_properties: *mut FormatProperties,
);
pub type FnGetPhysicalDeviceImageFormatProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    format: Format,
    ty: ImageType,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    flags: ImageCreateFlags,
    p_image_format_properties: *mut ImageFormatProperties,
) -> Result;
pub type FnCreateDevice = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_create_info: *const DeviceCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_device: *mut Device,
) -> Result;
pub type FnDestroyDevice = unsafe extern "system" fn(device: Option<Device>, p_allocator: *const AllocationCallbacks);
pub type FnEnumerateInstanceVersion = unsafe extern "system" fn(p_api_version: *mut Version) -> Result;
pub type FnEnumerateInstanceLayerProperties =
    unsafe extern "system" fn(p_property_count: *mut u32, p_properties: *mut LayerProperties) -> Result;
pub type FnEnumerateInstanceExtensionProperties = unsafe extern "system" fn(
    p_layer_name: *const c_char,
    p_property_count: *mut u32,
    p_properties: *mut ExtensionProperties,
) -> Result;
pub type FnEnumerateDeviceLayerProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_property_count: *mut u32,
    p_properties: *mut LayerProperties,
) -> Result;
pub type FnEnumerateDeviceExtensionProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_layer_name: *const c_char,
    p_property_count: *mut u32,
    p_properties: *mut ExtensionProperties,
) -> Result;
pub type FnGetDeviceQueue =
    unsafe extern "system" fn(device: Option<Device>, queue_family_index: u32, queue_index: u32, p_queue: *mut Queue);
pub type FnQueueSubmit = unsafe extern "system" fn(
    queue: Option<Queue>,
    submit_count: u32,
    p_submits: *const SubmitInfo,
    fence: Option<Fence>,
) -> Result;
pub type FnQueueWaitIdle = unsafe extern "system" fn(queue: Option<Queue>) -> Result;
pub type FnDeviceWaitIdle = unsafe extern "system" fn(device: Option<Device>) -> Result;
pub type FnAllocateMemory = unsafe extern "system" fn(
    device: Option<Device>,
    p_allocate_info: *const MemoryAllocateInfo,
    p_allocator: *const AllocationCallbacks,
    p_memory: *mut DeviceMemory,
) -> Result;
pub type FnFreeMemory = unsafe extern "system" fn(
    device: Option<Device>,
    memory: Option<DeviceMemory>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnMapMemory = unsafe extern "system" fn(
    device: Option<Device>,
    memory: Option<DeviceMemory>,
    offset: DeviceSize,
    size: DeviceSize,
    flags: MemoryMapFlags,
    pp_data: *mut *mut c_void,
) -> Result;
pub type FnUnmapMemory = unsafe extern "system" fn(device: Option<Device>, memory: Option<DeviceMemory>);
pub type FnFlushMappedMemoryRanges = unsafe extern "system" fn(
    device: Option<Device>,
    memory_range_count: u32,
    p_memory_ranges: *const MappedMemoryRange,
) -> Result;
pub type FnInvalidateMappedMemoryRanges = unsafe extern "system" fn(
    device: Option<Device>,
    memory_range_count: u32,
    p_memory_ranges: *const MappedMemoryRange,
) -> Result;
pub type FnGetDeviceMemoryCommitment = unsafe extern "system" fn(
    device: Option<Device>,
    memory: Option<DeviceMemory>,
    p_committed_memory_in_bytes: *mut DeviceSize,
);
pub type FnGetBufferMemoryRequirements = unsafe extern "system" fn(
    device: Option<Device>,
    buffer: Option<Buffer>,
    p_memory_requirements: *mut MemoryRequirements,
);
pub type FnBindBufferMemory = unsafe extern "system" fn(
    device: Option<Device>,
    buffer: Option<Buffer>,
    memory: Option<DeviceMemory>,
    memory_offset: DeviceSize,
) -> Result;
pub type FnGetImageMemoryRequirements = unsafe extern "system" fn(
    device: Option<Device>,
    image: Option<Image>,
    p_memory_requirements: *mut MemoryRequirements,
);
pub type FnBindImageMemory = unsafe extern "system" fn(
    device: Option<Device>,
    image: Option<Image>,
    memory: Option<DeviceMemory>,
    memory_offset: DeviceSize,
) -> Result;
pub type FnGetImageSparseMemoryRequirements = unsafe extern "system" fn(
    device: Option<Device>,
    image: Option<Image>,
    p_sparse_memory_requirement_count: *mut u32,
    p_sparse_memory_requirements: *mut SparseImageMemoryRequirements,
);
pub type FnGetPhysicalDeviceSparseImageFormatProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    format: Format,
    ty: ImageType,
    samples: SampleCountFlags,
    usage: ImageUsageFlags,
    tiling: ImageTiling,
    p_property_count: *mut u32,
    p_properties: *mut SparseImageFormatProperties,
);
pub type FnQueueBindSparse = unsafe extern "system" fn(
    queue: Option<Queue>,
    bind_info_count: u32,
    p_bind_info: *const BindSparseInfo,
    fence: Option<Fence>,
) -> Result;
pub type FnCreateFence = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const FenceCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_fence: *mut Fence,
) -> Result;
pub type FnDestroyFence =
    unsafe extern "system" fn(device: Option<Device>, fence: Option<Fence>, p_allocator: *const AllocationCallbacks);
pub type FnResetFences =
    unsafe extern "system" fn(device: Option<Device>, fence_count: u32, p_fences: *const Fence) -> Result;
pub type FnGetFenceStatus = unsafe extern "system" fn(device: Option<Device>, fence: Option<Fence>) -> Result;
pub type FnWaitForFences = unsafe extern "system" fn(
    device: Option<Device>,
    fence_count: u32,
    p_fences: *const Fence,
    wait_all: Bool32,
    timeout: u64,
) -> Result;
pub type FnCreateSemaphore = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const SemaphoreCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_semaphore: *mut Semaphore,
) -> Result;
pub type FnDestroySemaphore = unsafe extern "system" fn(
    device: Option<Device>,
    semaphore: Option<Semaphore>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreateEvent = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const EventCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_event: *mut Event,
) -> Result;
pub type FnDestroyEvent =
    unsafe extern "system" fn(device: Option<Device>, event: Option<Event>, p_allocator: *const AllocationCallbacks);
pub type FnGetEventStatus = unsafe extern "system" fn(device: Option<Device>, event: Option<Event>) -> Result;
pub type FnSetEvent = unsafe extern "system" fn(device: Option<Device>, event: Option<Event>) -> Result;
pub type FnResetEvent = unsafe extern "system" fn(device: Option<Device>, event: Option<Event>) -> Result;
pub type FnCreateQueryPool = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const QueryPoolCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_query_pool: *mut QueryPool,
) -> Result;
pub type FnDestroyQueryPool = unsafe extern "system" fn(
    device: Option<Device>,
    query_pool: Option<QueryPool>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetQueryPoolResults = unsafe extern "system" fn(
    device: Option<Device>,
    query_pool: Option<QueryPool>,
    first_query: u32,
    query_count: u32,
    data_size: usize,
    p_data: *mut c_void,
    stride: DeviceSize,
    flags: QueryResultFlags,
) -> Result;
pub type FnResetQueryPool = unsafe extern "system" fn(
    device: Option<Device>,
    query_pool: Option<QueryPool>,
    first_query: u32,
    query_count: u32,
);
pub type FnCreateBuffer = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const BufferCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_buffer: *mut Buffer,
) -> Result;
pub type FnDestroyBuffer =
    unsafe extern "system" fn(device: Option<Device>, buffer: Option<Buffer>, p_allocator: *const AllocationCallbacks);
pub type FnCreateBufferView = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const BufferViewCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_view: *mut BufferView,
) -> Result;
pub type FnDestroyBufferView = unsafe extern "system" fn(
    device: Option<Device>,
    buffer_view: Option<BufferView>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreateImage = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const ImageCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_image: *mut Image,
) -> Result;
pub type FnDestroyImage =
    unsafe extern "system" fn(device: Option<Device>, image: Option<Image>, p_allocator: *const AllocationCallbacks);
pub type FnGetImageSubresourceLayout = unsafe extern "system" fn(
    device: Option<Device>,
    image: Option<Image>,
    p_subresource: *const ImageSubresource,
    p_layout: *mut SubresourceLayout,
);
pub type FnCreateImageView = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const ImageViewCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_view: *mut ImageView,
) -> Result;
pub type FnDestroyImageView = unsafe extern "system" fn(
    device: Option<Device>,
    image_view: Option<ImageView>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreateShaderModule = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const ShaderModuleCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_shader_module: *mut ShaderModule,
) -> Result;
pub type FnDestroyShaderModule = unsafe extern "system" fn(
    device: Option<Device>,
    shader_module: Option<ShaderModule>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreatePipelineCache = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const PipelineCacheCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_pipeline_cache: *mut PipelineCache,
) -> Result;
pub type FnDestroyPipelineCache = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline_cache: Option<PipelineCache>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetPipelineCacheData = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline_cache: Option<PipelineCache>,
    p_data_size: *mut usize,
    p_data: *mut c_void,
) -> Result;
pub type FnMergePipelineCaches = unsafe extern "system" fn(
    device: Option<Device>,
    dst_cache: Option<PipelineCache>,
    src_cache_count: u32,
    p_src_caches: *const PipelineCache,
) -> Result;
pub type FnCreateGraphicsPipelines = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline_cache: Option<PipelineCache>,
    create_info_count: u32,
    p_create_infos: *const GraphicsPipelineCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_pipelines: *mut Pipeline,
) -> Result;
pub type FnCreateComputePipelines = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline_cache: Option<PipelineCache>,
    create_info_count: u32,
    p_create_infos: *const ComputePipelineCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_pipelines: *mut Pipeline,
) -> Result;
pub type FnGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = unsafe extern "system" fn(
    device: Option<Device>,
    renderpass: Option<RenderPass>,
    p_max_workgroup_size: *mut Extent2D,
) -> Result;
pub type FnDestroyPipeline = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline: Option<Pipeline>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreatePipelineLayout = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const PipelineLayoutCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_pipeline_layout: *mut PipelineLayout,
) -> Result;
pub type FnDestroyPipelineLayout = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline_layout: Option<PipelineLayout>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreateSampler = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const SamplerCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_sampler: *mut Sampler,
) -> Result;
pub type FnDestroySampler = unsafe extern "system" fn(
    device: Option<Device>,
    sampler: Option<Sampler>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreateDescriptorSetLayout = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const DescriptorSetLayoutCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_set_layout: *mut DescriptorSetLayout,
) -> Result;
pub type FnDestroyDescriptorSetLayout = unsafe extern "system" fn(
    device: Option<Device>,
    descriptor_set_layout: Option<DescriptorSetLayout>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreateDescriptorPool = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const DescriptorPoolCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_descriptor_pool: *mut DescriptorPool,
) -> Result;
pub type FnDestroyDescriptorPool = unsafe extern "system" fn(
    device: Option<Device>,
    descriptor_pool: Option<DescriptorPool>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnResetDescriptorPool = unsafe extern "system" fn(
    device: Option<Device>,
    descriptor_pool: Option<DescriptorPool>,
    flags: DescriptorPoolResetFlags,
) -> Result;
pub type FnAllocateDescriptorSets = unsafe extern "system" fn(
    device: Option<Device>,
    p_allocate_info: *const DescriptorSetAllocateInfo,
    p_descriptor_sets: *mut DescriptorSet,
) -> Result;
pub type FnFreeDescriptorSets = unsafe extern "system" fn(
    device: Option<Device>,
    descriptor_pool: Option<DescriptorPool>,
    descriptor_set_count: u32,
    p_descriptor_sets: *const DescriptorSet,
) -> Result;
pub type FnUpdateDescriptorSets = unsafe extern "system" fn(
    device: Option<Device>,
    descriptor_write_count: u32,
    p_descriptor_writes: *const WriteDescriptorSet,
    descriptor_copy_count: u32,
    p_descriptor_copies: *const CopyDescriptorSet,
);
pub type FnCreateFramebuffer = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const FramebufferCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_framebuffer: *mut Framebuffer,
) -> Result;
pub type FnDestroyFramebuffer = unsafe extern "system" fn(
    device: Option<Device>,
    framebuffer: Option<Framebuffer>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCreateRenderPass = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const RenderPassCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_render_pass: *mut RenderPass,
) -> Result;
pub type FnDestroyRenderPass = unsafe extern "system" fn(
    device: Option<Device>,
    render_pass: Option<RenderPass>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetRenderAreaGranularity =
    unsafe extern "system" fn(device: Option<Device>, render_pass: Option<RenderPass>, p_granularity: *mut Extent2D);
pub type FnCreateCommandPool = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const CommandPoolCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_command_pool: *mut CommandPool,
) -> Result;
pub type FnDestroyCommandPool = unsafe extern "system" fn(
    device: Option<Device>,
    command_pool: Option<CommandPool>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnResetCommandPool = unsafe extern "system" fn(
    device: Option<Device>,
    command_pool: Option<CommandPool>,
    flags: CommandPoolResetFlags,
) -> Result;
pub type FnAllocateCommandBuffers = unsafe extern "system" fn(
    device: Option<Device>,
    p_allocate_info: *const CommandBufferAllocateInfo,
    p_command_buffers: *mut CommandBuffer,
) -> Result;
pub type FnFreeCommandBuffers = unsafe extern "system" fn(
    device: Option<Device>,
    command_pool: Option<CommandPool>,
    command_buffer_count: u32,
    p_command_buffers: *const CommandBuffer,
);
pub type FnBeginCommandBuffer = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_begin_info: *const CommandBufferBeginInfo,
) -> Result;
pub type FnEndCommandBuffer = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>) -> Result;
pub type FnResetCommandBuffer =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, flags: CommandBufferResetFlags) -> Result;
pub type FnCmdBindPipeline = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    pipeline_bind_point: PipelineBindPoint,
    pipeline: Option<Pipeline>,
);
pub type FnCmdSetViewport = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_viewport: u32,
    viewport_count: u32,
    p_viewports: *const Viewport,
);
pub type FnCmdSetScissor = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_scissor: u32,
    scissor_count: u32,
    p_scissors: *const Rect2D,
);
pub type FnCmdSetLineWidth = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, line_width: f32);
pub type FnCmdSetDepthBias = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    depth_bias_constant_factor: f32,
    depth_bias_clamp: f32,
    depth_bias_slope_factor: f32,
);
pub type FnCmdSetBlendConstants =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, blend_constants: *const f32);
pub type FnCmdSetDepthBounds =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, min_depth_bounds: f32, max_depth_bounds: f32);
pub type FnCmdSetStencilCompareMask =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, face_mask: StencilFaceFlags, compare_mask: u32);
pub type FnCmdSetStencilWriteMask =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, face_mask: StencilFaceFlags, write_mask: u32);
pub type FnCmdSetStencilReference =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, face_mask: StencilFaceFlags, reference: u32);
pub type FnCmdBindDescriptorSets = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    pipeline_bind_point: PipelineBindPoint,
    layout: Option<PipelineLayout>,
    first_set: u32,
    descriptor_set_count: u32,
    p_descriptor_sets: *const DescriptorSet,
    dynamic_offset_count: u32,
    p_dynamic_offsets: *const u32,
);
pub type FnCmdBindIndexBuffer = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    buffer: Option<Buffer>,
    offset: DeviceSize,
    index_type: IndexType,
);
pub type FnCmdBindVertexBuffers = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_binding: u32,
    binding_count: u32,
    p_buffers: *const Buffer,
    p_offsets: *const DeviceSize,
);
pub type FnCmdDraw = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    vertex_count: u32,
    instance_count: u32,
    first_vertex: u32,
    first_instance: u32,
);
pub type FnCmdDrawIndexed = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    index_count: u32,
    instance_count: u32,
    first_index: u32,
    vertex_offset: i32,
    first_instance: u32,
);
pub type FnCmdDrawMultiEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    draw_count: u32,
    p_vertex_info: *const MultiDrawInfoEXT,
    instance_count: u32,
    first_instance: u32,
    stride: u32,
);
pub type FnCmdDrawMultiIndexedEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    draw_count: u32,
    p_index_info: *const MultiDrawIndexedInfoEXT,
    instance_count: u32,
    first_instance: u32,
    stride: u32,
    p_vertex_offset: *const i32,
);
pub type FnCmdDrawIndirect = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    buffer: Option<Buffer>,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
);
pub type FnCmdDrawIndexedIndirect = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    buffer: Option<Buffer>,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
);
pub type FnCmdDispatch = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
);
pub type FnCmdDispatchIndirect =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, buffer: Option<Buffer>, offset: DeviceSize);
pub type FnCmdSubpassShadingHUAWEI = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>);
pub type FnCmdCopyBuffer = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    src_buffer: Option<Buffer>,
    dst_buffer: Option<Buffer>,
    region_count: u32,
    p_regions: *const BufferCopy,
);
pub type FnCmdCopyImage = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    src_image: Option<Image>,
    src_image_layout: ImageLayout,
    dst_image: Option<Image>,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: *const ImageCopy,
);
pub type FnCmdBlitImage = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    src_image: Option<Image>,
    src_image_layout: ImageLayout,
    dst_image: Option<Image>,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: *const ImageBlit,
    filter: Filter,
);
pub type FnCmdCopyBufferToImage = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    src_buffer: Option<Buffer>,
    dst_image: Option<Image>,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: *const BufferImageCopy,
);
pub type FnCmdCopyImageToBuffer = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    src_image: Option<Image>,
    src_image_layout: ImageLayout,
    dst_buffer: Option<Buffer>,
    region_count: u32,
    p_regions: *const BufferImageCopy,
);
pub type FnCmdUpdateBuffer = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    dst_buffer: Option<Buffer>,
    dst_offset: DeviceSize,
    data_size: DeviceSize,
    p_data: *const c_void,
);
pub type FnCmdFillBuffer = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    dst_buffer: Option<Buffer>,
    dst_offset: DeviceSize,
    size: DeviceSize,
    data: u32,
);
pub type FnCmdClearColorImage = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    image: Option<Image>,
    image_layout: ImageLayout,
    p_color: *const ClearColorValue,
    range_count: u32,
    p_ranges: *const ImageSubresourceRange,
);
pub type FnCmdClearDepthStencilImage = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    image: Option<Image>,
    image_layout: ImageLayout,
    p_depth_stencil: *const ClearDepthStencilValue,
    range_count: u32,
    p_ranges: *const ImageSubresourceRange,
);
pub type FnCmdClearAttachments = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    attachment_count: u32,
    p_attachments: *const ClearAttachment,
    rect_count: u32,
    p_rects: *const ClearRect,
);
pub type FnCmdResolveImage = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    src_image: Option<Image>,
    src_image_layout: ImageLayout,
    dst_image: Option<Image>,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: *const ImageResolve,
);
pub type FnCmdSetEvent = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    event: Option<Event>,
    stage_mask: PipelineStageFlags,
);
pub type FnCmdResetEvent = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    event: Option<Event>,
    stage_mask: PipelineStageFlags,
);
pub type FnCmdWaitEvents = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    event_count: u32,
    p_events: *const Event,
    src_stage_mask: PipelineStageFlags,
    dst_stage_mask: PipelineStageFlags,
    memory_barrier_count: u32,
    p_memory_barriers: *const MemoryBarrier,
    buffer_memory_barrier_count: u32,
    p_buffer_memory_barriers: *const BufferMemoryBarrier,
    image_memory_barrier_count: u32,
    p_image_memory_barriers: *const ImageMemoryBarrier,
);
pub type FnCmdPipelineBarrier = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    src_stage_mask: PipelineStageFlags,
    dst_stage_mask: PipelineStageFlags,
    dependency_flags: DependencyFlags,
    memory_barrier_count: u32,
    p_memory_barriers: *const MemoryBarrier,
    buffer_memory_barrier_count: u32,
    p_buffer_memory_barriers: *const BufferMemoryBarrier,
    image_memory_barrier_count: u32,
    p_image_memory_barriers: *const ImageMemoryBarrier,
);
pub type FnCmdBeginQuery = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    query_pool: Option<QueryPool>,
    query: u32,
    flags: QueryControlFlags,
);
pub type FnCmdEndQuery =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, query_pool: Option<QueryPool>, query: u32);
pub type FnCmdBeginConditionalRenderingEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_conditional_rendering_begin: *const ConditionalRenderingBeginInfoEXT,
);
pub type FnCmdEndConditionalRenderingEXT = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>);
pub type FnCmdResetQueryPool = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    query_pool: Option<QueryPool>,
    first_query: u32,
    query_count: u32,
);
pub type FnCmdWriteTimestamp = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    pipeline_stage: PipelineStageFlags,
    query_pool: Option<QueryPool>,
    query: u32,
);
pub type FnCmdCopyQueryPoolResults = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    query_pool: Option<QueryPool>,
    first_query: u32,
    query_count: u32,
    dst_buffer: Option<Buffer>,
    dst_offset: DeviceSize,
    stride: DeviceSize,
    flags: QueryResultFlags,
);
pub type FnCmdPushConstants = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    layout: Option<PipelineLayout>,
    stage_flags: ShaderStageFlags,
    offset: u32,
    size: u32,
    p_values: *const c_void,
);
pub type FnCmdBeginRenderPass = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_render_pass_begin: *const RenderPassBeginInfo,
    contents: SubpassContents,
);
pub type FnCmdNextSubpass = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, contents: SubpassContents);
pub type FnCmdEndRenderPass = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>);
pub type FnCmdExecuteCommands = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    command_buffer_count: u32,
    p_command_buffers: *const CommandBuffer,
);
pub type FnCreateAndroidSurfaceKHR = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const AndroidSurfaceCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnGetPhysicalDeviceDisplayPropertiesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_property_count: *mut u32,
    p_properties: *mut DisplayPropertiesKHR,
) -> Result;
pub type FnGetPhysicalDeviceDisplayPlanePropertiesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_property_count: *mut u32,
    p_properties: *mut DisplayPlanePropertiesKHR,
) -> Result;
pub type FnGetDisplayPlaneSupportedDisplaysKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    plane_index: u32,
    p_display_count: *mut u32,
    p_displays: *mut DisplayKHR,
) -> Result;
pub type FnGetDisplayModePropertiesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    display: Option<DisplayKHR>,
    p_property_count: *mut u32,
    p_properties: *mut DisplayModePropertiesKHR,
) -> Result;
pub type FnCreateDisplayModeKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    display: Option<DisplayKHR>,
    p_create_info: *const DisplayModeCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_mode: *mut DisplayModeKHR,
) -> Result;
pub type FnGetDisplayPlaneCapabilitiesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    mode: Option<DisplayModeKHR>,
    plane_index: u32,
    p_capabilities: *mut DisplayPlaneCapabilitiesKHR,
) -> Result;
pub type FnCreateDisplayPlaneSurfaceKHR = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const DisplaySurfaceCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnCreateSharedSwapchainsKHR = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain_count: u32,
    p_create_infos: *const SwapchainCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_swapchains: *mut SwapchainKHR,
) -> Result;
pub type FnDestroySurfaceKHR = unsafe extern "system" fn(
    instance: Option<Instance>,
    surface: Option<SurfaceKHR>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetPhysicalDeviceSurfaceSupportKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    queue_family_index: u32,
    surface: Option<SurfaceKHR>,
    p_supported: *mut Bool32,
) -> Result;
pub type FnGetPhysicalDeviceSurfaceCapabilitiesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    surface: Option<SurfaceKHR>,
    p_surface_capabilities: *mut SurfaceCapabilitiesKHR,
) -> Result;
pub type FnGetPhysicalDeviceSurfaceFormatsKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    surface: Option<SurfaceKHR>,
    p_surface_format_count: *mut u32,
    p_surface_formats: *mut SurfaceFormatKHR,
) -> Result;
pub type FnGetPhysicalDeviceSurfacePresentModesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    surface: Option<SurfaceKHR>,
    p_present_mode_count: *mut u32,
    p_present_modes: *mut PresentModeKHR,
) -> Result;
pub type FnCreateSwapchainKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const SwapchainCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_swapchain: *mut SwapchainKHR,
) -> Result;
pub type FnDestroySwapchainKHR = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain: Option<SwapchainKHR>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetSwapchainImagesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain: Option<SwapchainKHR>,
    p_swapchain_image_count: *mut u32,
    p_swapchain_images: *mut Image,
) -> Result;
pub type FnAcquireNextImageKHR = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain: Option<SwapchainKHR>,
    timeout: u64,
    semaphore: Option<Semaphore>,
    fence: Option<Fence>,
    p_image_index: *mut u32,
) -> Result;
pub type FnQueuePresentKHR =
    unsafe extern "system" fn(queue: Option<Queue>, p_present_info: *const PresentInfoKHR) -> Result;
pub type FnCreateViSurfaceNN = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const ViSurfaceCreateInfoNN,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnCreateWaylandSurfaceKHR = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const WaylandSurfaceCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnGetPhysicalDeviceWaylandPresentationSupportKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    queue_family_index: u32,
    display: *mut wl_display,
) -> Bool32;
pub type FnCreateWin32SurfaceKHR = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const Win32SurfaceCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnGetPhysicalDeviceWin32PresentationSupportKHR =
    unsafe extern "system" fn(physical_device: Option<PhysicalDevice>, queue_family_index: u32) -> Bool32;
pub type FnCreateXlibSurfaceKHR = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const XlibSurfaceCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnGetPhysicalDeviceXlibPresentationSupportKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    queue_family_index: u32,
    dpy: *mut Display,
    visual_id: VisualID,
) -> Bool32;
pub type FnCreateXcbSurfaceKHR = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const XcbSurfaceCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnGetPhysicalDeviceXcbPresentationSupportKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    queue_family_index: u32,
    connection: *mut xcb_connection_t,
    visual_id: xcb_visualid_t,
) -> Bool32;
pub type FnCreateDirectFBSurfaceEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const DirectFBSurfaceCreateInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnGetPhysicalDeviceDirectFBPresentationSupportEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    queue_family_index: u32,
    dfb: *mut IDirectFB,
) -> Bool32;
pub type FnCreateImagePipeSurfaceFUCHSIA = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const ImagePipeSurfaceCreateInfoFUCHSIA,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnCreateDebugReportCallbackEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const DebugReportCallbackCreateInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_callback: *mut DebugReportCallbackEXT,
) -> Result;
pub type FnDestroyDebugReportCallbackEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    callback: Option<DebugReportCallbackEXT>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnDebugReportMessageEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    flags: DebugReportFlagsEXT,
    object_type: DebugReportObjectTypeEXT,
    object: u64,
    location: usize,
    message_code: i32,
    p_layer_prefix: *const c_char,
    p_message: *const c_char,
);
pub type FnDebugMarkerSetObjectNameEXT =
    unsafe extern "system" fn(device: Option<Device>, p_name_info: *const DebugMarkerObjectNameInfoEXT) -> Result;
pub type FnDebugMarkerSetObjectTagEXT =
    unsafe extern "system" fn(device: Option<Device>, p_tag_info: *const DebugMarkerObjectTagInfoEXT) -> Result;
pub type FnCmdDebugMarkerBeginEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_marker_info: *const DebugMarkerMarkerInfoEXT);
pub type FnCmdDebugMarkerEndEXT = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>);
pub type FnCmdDebugMarkerInsertEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_marker_info: *const DebugMarkerMarkerInfoEXT);
pub type FnGetPhysicalDeviceExternalImageFormatPropertiesNV = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    format: Format,
    ty: ImageType,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    flags: ImageCreateFlags,
    external_handle_type: ExternalMemoryHandleTypeFlagsNV,
    p_external_image_format_properties: *mut ExternalImageFormatPropertiesNV,
) -> Result;
pub type FnGetMemoryWin32HandleNV = unsafe extern "system" fn(
    device: Option<Device>,
    memory: Option<DeviceMemory>,
    handle_type: ExternalMemoryHandleTypeFlagsNV,
    p_handle: *mut HANDLE,
) -> Result;
pub type FnCmdExecuteGeneratedCommandsNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    is_preprocessed: Bool32,
    p_generated_commands_info: *const GeneratedCommandsInfoNV,
);
pub type FnCmdPreprocessGeneratedCommandsNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_generated_commands_info: *const GeneratedCommandsInfoNV,
);
pub type FnCmdBindPipelineShaderGroupNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    pipeline_bind_point: PipelineBindPoint,
    pipeline: Option<Pipeline>,
    group_index: u32,
);
pub type FnGetGeneratedCommandsMemoryRequirementsNV = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const GeneratedCommandsMemoryRequirementsInfoNV,
    p_memory_requirements: *mut MemoryRequirements2,
);
pub type FnCreateIndirectCommandsLayoutNV = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const IndirectCommandsLayoutCreateInfoNV,
    p_allocator: *const AllocationCallbacks,
    p_indirect_commands_layout: *mut IndirectCommandsLayoutNV,
) -> Result;
pub type FnDestroyIndirectCommandsLayoutNV = unsafe extern "system" fn(
    device: Option<Device>,
    indirect_commands_layout: Option<IndirectCommandsLayoutNV>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetPhysicalDeviceFeatures2 =
    unsafe extern "system" fn(physical_device: Option<PhysicalDevice>, p_features: *mut PhysicalDeviceFeatures2);
pub type FnGetPhysicalDeviceProperties2 =
    unsafe extern "system" fn(physical_device: Option<PhysicalDevice>, p_properties: *mut PhysicalDeviceProperties2);
pub type FnGetPhysicalDeviceFormatProperties2 = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    format: Format,
    p_format_properties: *mut FormatProperties2,
);
pub type FnGetPhysicalDeviceImageFormatProperties2 = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_image_format_info: *const PhysicalDeviceImageFormatInfo2,
    p_image_format_properties: *mut ImageFormatProperties2,
) -> Result;
pub type FnGetPhysicalDeviceQueueFamilyProperties2 = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_queue_family_property_count: *mut u32,
    p_queue_family_properties: *mut QueueFamilyProperties2,
);
pub type FnGetPhysicalDeviceMemoryProperties2 = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_memory_properties: *mut PhysicalDeviceMemoryProperties2,
);
pub type FnGetPhysicalDeviceSparseImageFormatProperties2 = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_format_info: *const PhysicalDeviceSparseImageFormatInfo2,
    p_property_count: *mut u32,
    p_properties: *mut SparseImageFormatProperties2,
);
pub type FnCmdPushDescriptorSetKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    pipeline_bind_point: PipelineBindPoint,
    layout: Option<PipelineLayout>,
    set: u32,
    descriptor_write_count: u32,
    p_descriptor_writes: *const WriteDescriptorSet,
);
pub type FnTrimCommandPool =
    unsafe extern "system" fn(device: Option<Device>, command_pool: Option<CommandPool>, flags: CommandPoolTrimFlags);
pub type FnGetPhysicalDeviceExternalBufferProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_external_buffer_info: *const PhysicalDeviceExternalBufferInfo,
    p_external_buffer_properties: *mut ExternalBufferProperties,
);
pub type FnGetMemoryWin32HandleKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_win32_handle_info: *const MemoryGetWin32HandleInfoKHR,
    p_handle: *mut HANDLE,
) -> Result;
pub type FnGetMemoryWin32HandlePropertiesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    handle_type: ExternalMemoryHandleTypeFlags,
    handle: HANDLE,
    p_memory_win32_handle_properties: *mut MemoryWin32HandlePropertiesKHR,
) -> Result;
pub type FnGetMemoryFdKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_fd_info: *const MemoryGetFdInfoKHR,
    p_fd: *mut c_int,
) -> Result;
pub type FnGetMemoryFdPropertiesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    handle_type: ExternalMemoryHandleTypeFlags,
    fd: c_int,
    p_memory_fd_properties: *mut MemoryFdPropertiesKHR,
) -> Result;
pub type FnGetMemoryZirconHandleFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_zircon_handle_info: *const MemoryGetZirconHandleInfoFUCHSIA,
    p_zircon_handle: *mut zx_handle_t,
) -> Result;
pub type FnGetMemoryZirconHandlePropertiesFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    handle_type: ExternalMemoryHandleTypeFlags,
    zircon_handle: zx_handle_t,
    p_memory_zircon_handle_properties: *mut MemoryZirconHandlePropertiesFUCHSIA,
) -> Result;
pub type FnGetMemoryRemoteAddressNV = unsafe extern "system" fn(
    device: Option<Device>,
    p_memory_get_remote_address_info: *const MemoryGetRemoteAddressInfoNV,
    p_address: *mut RemoteAddressNV,
) -> Result;
pub type FnGetPhysicalDeviceExternalSemaphoreProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_external_semaphore_info: *const PhysicalDeviceExternalSemaphoreInfo,
    p_external_semaphore_properties: *mut ExternalSemaphoreProperties,
);
pub type FnGetSemaphoreWin32HandleKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_win32_handle_info: *const SemaphoreGetWin32HandleInfoKHR,
    p_handle: *mut HANDLE,
) -> Result;
pub type FnImportSemaphoreWin32HandleKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_import_semaphore_win32_handle_info: *const ImportSemaphoreWin32HandleInfoKHR,
) -> Result;
pub type FnGetSemaphoreFdKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_fd_info: *const SemaphoreGetFdInfoKHR,
    p_fd: *mut c_int,
) -> Result;
pub type FnImportSemaphoreFdKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_import_semaphore_fd_info: *const ImportSemaphoreFdInfoKHR,
) -> Result;
pub type FnGetSemaphoreZirconHandleFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_zircon_handle_info: *const SemaphoreGetZirconHandleInfoFUCHSIA,
    p_zircon_handle: *mut zx_handle_t,
) -> Result;
pub type FnImportSemaphoreZirconHandleFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    p_import_semaphore_zircon_handle_info: *const ImportSemaphoreZirconHandleInfoFUCHSIA,
) -> Result;
pub type FnGetPhysicalDeviceExternalFenceProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_external_fence_info: *const PhysicalDeviceExternalFenceInfo,
    p_external_fence_properties: *mut ExternalFenceProperties,
);
pub type FnGetFenceWin32HandleKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_win32_handle_info: *const FenceGetWin32HandleInfoKHR,
    p_handle: *mut HANDLE,
) -> Result;
pub type FnImportFenceWin32HandleKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_import_fence_win32_handle_info: *const ImportFenceWin32HandleInfoKHR,
) -> Result;
pub type FnGetFenceFdKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_get_fd_info: *const FenceGetFdInfoKHR,
    p_fd: *mut c_int,
) -> Result;
pub type FnImportFenceFdKHR =
    unsafe extern "system" fn(device: Option<Device>, p_import_fence_fd_info: *const ImportFenceFdInfoKHR) -> Result;
pub type FnReleaseDisplayEXT =
    unsafe extern "system" fn(physical_device: Option<PhysicalDevice>, display: Option<DisplayKHR>) -> Result;
pub type FnAcquireXlibDisplayEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    dpy: *mut Display,
    display: Option<DisplayKHR>,
) -> Result;
pub type FnGetRandROutputDisplayEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    dpy: *mut Display,
    rr_output: RROutput,
    p_display: *mut DisplayKHR,
) -> Result;
pub type FnAcquireWinrtDisplayNV =
    unsafe extern "system" fn(physical_device: Option<PhysicalDevice>, display: Option<DisplayKHR>) -> Result;
pub type FnGetWinrtDisplayNV = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    device_relative_id: u32,
    p_display: *mut DisplayKHR,
) -> Result;
pub type FnDisplayPowerControlEXT = unsafe extern "system" fn(
    device: Option<Device>,
    display: Option<DisplayKHR>,
    p_display_power_info: *const DisplayPowerInfoEXT,
) -> Result;
pub type FnRegisterDeviceEventEXT = unsafe extern "system" fn(
    device: Option<Device>,
    p_device_event_info: *const DeviceEventInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_fence: *mut Fence,
) -> Result;
pub type FnRegisterDisplayEventEXT = unsafe extern "system" fn(
    device: Option<Device>,
    display: Option<DisplayKHR>,
    p_display_event_info: *const DisplayEventInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_fence: *mut Fence,
) -> Result;
pub type FnGetSwapchainCounterEXT = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain: Option<SwapchainKHR>,
    counter: SurfaceCounterFlagsEXT,
    p_counter_value: *mut u64,
) -> Result;
pub type FnGetPhysicalDeviceSurfaceCapabilities2EXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    surface: Option<SurfaceKHR>,
    p_surface_capabilities: *mut SurfaceCapabilities2EXT,
) -> Result;
pub type FnEnumeratePhysicalDeviceGroups = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_physical_device_group_count: *mut u32,
    p_physical_device_group_properties: *mut PhysicalDeviceGroupProperties,
) -> Result;
pub type FnGetDeviceGroupPeerMemoryFeatures = unsafe extern "system" fn(
    device: Option<Device>,
    heap_index: u32,
    local_device_index: u32,
    remote_device_index: u32,
    p_peer_memory_features: *mut PeerMemoryFeatureFlags,
);
pub type FnBindBufferMemory2 = unsafe extern "system" fn(
    device: Option<Device>,
    bind_info_count: u32,
    p_bind_infos: *const BindBufferMemoryInfo,
) -> Result;
pub type FnBindImageMemory2 = unsafe extern "system" fn(
    device: Option<Device>,
    bind_info_count: u32,
    p_bind_infos: *const BindImageMemoryInfo,
) -> Result;
pub type FnCmdSetDeviceMask = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, device_mask: u32);
pub type FnGetDeviceGroupPresentCapabilitiesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_device_group_present_capabilities: *mut DeviceGroupPresentCapabilitiesKHR,
) -> Result;
pub type FnGetDeviceGroupSurfacePresentModesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    surface: Option<SurfaceKHR>,
    p_modes: *mut DeviceGroupPresentModeFlagsKHR,
) -> Result;
pub type FnAcquireNextImage2KHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_acquire_info: *const AcquireNextImageInfoKHR,
    p_image_index: *mut u32,
) -> Result;
pub type FnCmdDispatchBase = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    base_group_x: u32,
    base_group_y: u32,
    base_group_z: u32,
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
);
pub type FnGetPhysicalDevicePresentRectanglesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    surface: Option<SurfaceKHR>,
    p_rect_count: *mut u32,
    p_rects: *mut Rect2D,
) -> Result;
pub type FnCreateDescriptorUpdateTemplate = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const DescriptorUpdateTemplateCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_descriptor_update_template: *mut DescriptorUpdateTemplate,
) -> Result;
pub type FnDestroyDescriptorUpdateTemplate = unsafe extern "system" fn(
    device: Option<Device>,
    descriptor_update_template: Option<DescriptorUpdateTemplate>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnUpdateDescriptorSetWithTemplate = unsafe extern "system" fn(
    device: Option<Device>,
    descriptor_set: Option<DescriptorSet>,
    descriptor_update_template: Option<DescriptorUpdateTemplate>,
    p_data: *const c_void,
);
pub type FnCmdPushDescriptorSetWithTemplateKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    descriptor_update_template: Option<DescriptorUpdateTemplate>,
    layout: Option<PipelineLayout>,
    set: u32,
    p_data: *const c_void,
);
pub type FnSetHdrMetadataEXT = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain_count: u32,
    p_swapchains: *const SwapchainKHR,
    p_metadata: *const HdrMetadataEXT,
);
pub type FnGetSwapchainStatusKHR =
    unsafe extern "system" fn(device: Option<Device>, swapchain: Option<SwapchainKHR>) -> Result;
pub type FnGetRefreshCycleDurationGOOGLE = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain: Option<SwapchainKHR>,
    p_display_timing_properties: *mut RefreshCycleDurationGOOGLE,
) -> Result;
pub type FnGetPastPresentationTimingGOOGLE = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain: Option<SwapchainKHR>,
    p_presentation_timing_count: *mut u32,
    p_presentation_timings: *mut PastPresentationTimingGOOGLE,
) -> Result;
pub type FnCreateIOSSurfaceMVK = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const IOSSurfaceCreateInfoMVK,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnCreateMacOSSurfaceMVK = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const MacOSSurfaceCreateInfoMVK,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnCreateMetalSurfaceEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const MetalSurfaceCreateInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnCmdSetViewportWScalingNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_viewport: u32,
    viewport_count: u32,
    p_viewport_w_scalings: *const ViewportWScalingNV,
);
pub type FnCmdSetDiscardRectangleEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_discard_rectangle: u32,
    discard_rectangle_count: u32,
    p_discard_rectangles: *const Rect2D,
);
pub type FnCmdSetSampleLocationsEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_sample_locations_info: *const SampleLocationsInfoEXT,
);
pub type FnGetPhysicalDeviceMultisamplePropertiesEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    samples: SampleCountFlags,
    p_multisample_properties: *mut MultisamplePropertiesEXT,
);
pub type FnGetPhysicalDeviceSurfaceCapabilities2KHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_surface_capabilities: *mut SurfaceCapabilities2KHR,
) -> Result;
pub type FnGetPhysicalDeviceSurfaceFormats2KHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_surface_format_count: *mut u32,
    p_surface_formats: *mut SurfaceFormat2KHR,
) -> Result;
pub type FnGetPhysicalDeviceDisplayProperties2KHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_property_count: *mut u32,
    p_properties: *mut DisplayProperties2KHR,
) -> Result;
pub type FnGetPhysicalDeviceDisplayPlaneProperties2KHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_property_count: *mut u32,
    p_properties: *mut DisplayPlaneProperties2KHR,
) -> Result;
pub type FnGetDisplayModeProperties2KHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    display: Option<DisplayKHR>,
    p_property_count: *mut u32,
    p_properties: *mut DisplayModeProperties2KHR,
) -> Result;
pub type FnGetDisplayPlaneCapabilities2KHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_display_plane_info: *const DisplayPlaneInfo2KHR,
    p_capabilities: *mut DisplayPlaneCapabilities2KHR,
) -> Result;
pub type FnGetBufferMemoryRequirements2 = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const BufferMemoryRequirementsInfo2,
    p_memory_requirements: *mut MemoryRequirements2,
);
pub type FnGetImageMemoryRequirements2 = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const ImageMemoryRequirementsInfo2,
    p_memory_requirements: *mut MemoryRequirements2,
);
pub type FnGetImageSparseMemoryRequirements2 = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const ImageSparseMemoryRequirementsInfo2,
    p_sparse_memory_requirement_count: *mut u32,
    p_sparse_memory_requirements: *mut SparseImageMemoryRequirements2,
);
pub type FnGetDeviceBufferMemoryRequirements = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const DeviceBufferMemoryRequirements,
    p_memory_requirements: *mut MemoryRequirements2,
);
pub type FnGetDeviceImageMemoryRequirements = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const DeviceImageMemoryRequirements,
    p_memory_requirements: *mut MemoryRequirements2,
);
pub type FnGetDeviceImageSparseMemoryRequirements = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const DeviceImageMemoryRequirements,
    p_sparse_memory_requirement_count: *mut u32,
    p_sparse_memory_requirements: *mut SparseImageMemoryRequirements2,
);
pub type FnCreateSamplerYcbcrConversion = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const SamplerYcbcrConversionCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_ycbcr_conversion: *mut SamplerYcbcrConversion,
) -> Result;
pub type FnDestroySamplerYcbcrConversion = unsafe extern "system" fn(
    device: Option<Device>,
    ycbcr_conversion: Option<SamplerYcbcrConversion>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetDeviceQueue2 =
    unsafe extern "system" fn(device: Option<Device>, p_queue_info: *const DeviceQueueInfo2, p_queue: *mut Queue);
pub type FnCreateValidationCacheEXT = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const ValidationCacheCreateInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_validation_cache: *mut ValidationCacheEXT,
) -> Result;
pub type FnDestroyValidationCacheEXT = unsafe extern "system" fn(
    device: Option<Device>,
    validation_cache: Option<ValidationCacheEXT>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetValidationCacheDataEXT = unsafe extern "system" fn(
    device: Option<Device>,
    validation_cache: Option<ValidationCacheEXT>,
    p_data_size: *mut usize,
    p_data: *mut c_void,
) -> Result;
pub type FnMergeValidationCachesEXT = unsafe extern "system" fn(
    device: Option<Device>,
    dst_cache: Option<ValidationCacheEXT>,
    src_cache_count: u32,
    p_src_caches: *const ValidationCacheEXT,
) -> Result;
pub type FnGetDescriptorSetLayoutSupport = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const DescriptorSetLayoutCreateInfo,
    p_support: *mut DescriptorSetLayoutSupport,
);
pub type FnGetShaderInfoAMD = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline: Option<Pipeline>,
    shader_stage: ShaderStageFlags,
    info_type: ShaderInfoTypeAMD,
    p_info_size: *mut usize,
    p_info: *mut c_void,
) -> Result;
pub type FnSetLocalDimmingAMD =
    unsafe extern "system" fn(device: Option<Device>, swap_chain: Option<SwapchainKHR>, local_dimming_enable: Bool32);
pub type FnGetPhysicalDeviceCalibrateableTimeDomainsEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_time_domain_count: *mut u32,
    p_time_domains: *mut TimeDomainEXT,
) -> Result;
pub type FnGetCalibratedTimestampsEXT = unsafe extern "system" fn(
    device: Option<Device>,
    timestamp_count: u32,
    p_timestamp_infos: *const CalibratedTimestampInfoEXT,
    p_timestamps: *mut u64,
    p_max_deviation: *mut u64,
) -> Result;
pub type FnSetDebugUtilsObjectNameEXT =
    unsafe extern "system" fn(device: Option<Device>, p_name_info: *const DebugUtilsObjectNameInfoEXT) -> Result;
pub type FnSetDebugUtilsObjectTagEXT =
    unsafe extern "system" fn(device: Option<Device>, p_tag_info: *const DebugUtilsObjectTagInfoEXT) -> Result;
pub type FnQueueBeginDebugUtilsLabelEXT =
    unsafe extern "system" fn(queue: Option<Queue>, p_label_info: *const DebugUtilsLabelEXT);
pub type FnQueueEndDebugUtilsLabelEXT = unsafe extern "system" fn(queue: Option<Queue>);
pub type FnQueueInsertDebugUtilsLabelEXT =
    unsafe extern "system" fn(queue: Option<Queue>, p_label_info: *const DebugUtilsLabelEXT);
pub type FnCmdBeginDebugUtilsLabelEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_label_info: *const DebugUtilsLabelEXT);
pub type FnCmdEndDebugUtilsLabelEXT = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>);
pub type FnCmdInsertDebugUtilsLabelEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_label_info: *const DebugUtilsLabelEXT);
pub type FnCreateDebugUtilsMessengerEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const DebugUtilsMessengerCreateInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_messenger: *mut DebugUtilsMessengerEXT,
) -> Result;
pub type FnDestroyDebugUtilsMessengerEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    messenger: Option<DebugUtilsMessengerEXT>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnSubmitDebugUtilsMessageEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    message_severity: DebugUtilsMessageSeverityFlagsEXT,
    message_types: DebugUtilsMessageTypeFlagsEXT,
    p_callback_data: *const DebugUtilsMessengerCallbackDataEXT,
);
pub type FnGetMemoryHostPointerPropertiesEXT = unsafe extern "system" fn(
    device: Option<Device>,
    handle_type: ExternalMemoryHandleTypeFlags,
    p_host_pointer: *const c_void,
    p_memory_host_pointer_properties: *mut MemoryHostPointerPropertiesEXT,
) -> Result;
pub type FnCmdWriteBufferMarkerAMD = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    pipeline_stage: PipelineStageFlags,
    dst_buffer: Option<Buffer>,
    dst_offset: DeviceSize,
    marker: u32,
);
pub type FnCreateRenderPass2 = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const RenderPassCreateInfo2,
    p_allocator: *const AllocationCallbacks,
    p_render_pass: *mut RenderPass,
) -> Result;
pub type FnCmdBeginRenderPass2 = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_render_pass_begin: *const RenderPassBeginInfo,
    p_subpass_begin_info: *const SubpassBeginInfo,
);
pub type FnCmdNextSubpass2 = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_subpass_begin_info: *const SubpassBeginInfo,
    p_subpass_end_info: *const SubpassEndInfo,
);
pub type FnCmdEndRenderPass2 =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_subpass_end_info: *const SubpassEndInfo);
pub type FnGetSemaphoreCounterValue =
    unsafe extern "system" fn(device: Option<Device>, semaphore: Option<Semaphore>, p_value: *mut u64) -> Result;
pub type FnWaitSemaphores =
    unsafe extern "system" fn(device: Option<Device>, p_wait_info: *const SemaphoreWaitInfo, timeout: u64) -> Result;
pub type FnSignalSemaphore =
    unsafe extern "system" fn(device: Option<Device>, p_signal_info: *const SemaphoreSignalInfo) -> Result;
pub type FnGetAndroidHardwareBufferPropertiesANDROID = unsafe extern "system" fn(
    device: Option<Device>,
    buffer: *const AHardwareBuffer,
    p_properties: *mut AndroidHardwareBufferPropertiesANDROID,
) -> Result;
pub type FnGetMemoryAndroidHardwareBufferANDROID = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const MemoryGetAndroidHardwareBufferInfoANDROID,
    p_buffer: *mut *mut AHardwareBuffer,
) -> Result;
pub type FnCmdDrawIndirectCount = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    buffer: Option<Buffer>,
    offset: DeviceSize,
    count_buffer: Option<Buffer>,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
);
pub type FnCmdDrawIndexedIndirectCount = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    buffer: Option<Buffer>,
    offset: DeviceSize,
    count_buffer: Option<Buffer>,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
);
pub type FnCmdSetCheckpointNV =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_checkpoint_marker: *const c_void);
pub type FnGetQueueCheckpointDataNV = unsafe extern "system" fn(
    queue: Option<Queue>,
    p_checkpoint_data_count: *mut u32,
    p_checkpoint_data: *mut CheckpointDataNV,
);
pub type FnCmdBindTransformFeedbackBuffersEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_binding: u32,
    binding_count: u32,
    p_buffers: *const Buffer,
    p_offsets: *const DeviceSize,
    p_sizes: *const DeviceSize,
);
pub type FnCmdBeginTransformFeedbackEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_counter_buffer: u32,
    counter_buffer_count: u32,
    p_counter_buffers: *const Buffer,
    p_counter_buffer_offsets: *const DeviceSize,
);
pub type FnCmdEndTransformFeedbackEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_counter_buffer: u32,
    counter_buffer_count: u32,
    p_counter_buffers: *const Buffer,
    p_counter_buffer_offsets: *const DeviceSize,
);
pub type FnCmdBeginQueryIndexedEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    query_pool: Option<QueryPool>,
    query: u32,
    flags: QueryControlFlags,
    index: u32,
);
pub type FnCmdEndQueryIndexedEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    query_pool: Option<QueryPool>,
    query: u32,
    index: u32,
);
pub type FnCmdDrawIndirectByteCountEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    instance_count: u32,
    first_instance: u32,
    counter_buffer: Option<Buffer>,
    counter_buffer_offset: DeviceSize,
    counter_offset: u32,
    vertex_stride: u32,
);
pub type FnCmdSetExclusiveScissorNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_exclusive_scissor: u32,
    exclusive_scissor_count: u32,
    p_exclusive_scissors: *const Rect2D,
);
pub type FnCmdBindShadingRateImageNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    image_view: Option<ImageView>,
    image_layout: ImageLayout,
);
pub type FnCmdSetViewportShadingRatePaletteNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_viewport: u32,
    viewport_count: u32,
    p_shading_rate_palettes: *const ShadingRatePaletteNV,
);
pub type FnCmdSetCoarseSampleOrderNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    sample_order_type: CoarseSampleOrderTypeNV,
    custom_sample_order_count: u32,
    p_custom_sample_orders: *const CoarseSampleOrderCustomNV,
);
pub type FnCmdDrawMeshTasksNV =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, task_count: u32, first_task: u32);
pub type FnCmdDrawMeshTasksIndirectNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    buffer: Option<Buffer>,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
);
pub type FnCmdDrawMeshTasksIndirectCountNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    buffer: Option<Buffer>,
    offset: DeviceSize,
    count_buffer: Option<Buffer>,
    count_buffer_offset: DeviceSize,
    max_draw_count: u32,
    stride: u32,
);
pub type FnCompileDeferredNV =
    unsafe extern "system" fn(device: Option<Device>, pipeline: Option<Pipeline>, shader: u32) -> Result;
pub type FnCreateAccelerationStructureNV = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const AccelerationStructureCreateInfoNV,
    p_allocator: *const AllocationCallbacks,
    p_acceleration_structure: *mut AccelerationStructureNV,
) -> Result;
pub type FnCmdBindInvocationMaskHUAWEI = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    image_view: Option<ImageView>,
    image_layout: ImageLayout,
);
pub type FnDestroyAccelerationStructureKHR = unsafe extern "system" fn(
    device: Option<Device>,
    acceleration_structure: Option<AccelerationStructureKHR>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnDestroyAccelerationStructureNV = unsafe extern "system" fn(
    device: Option<Device>,
    acceleration_structure: Option<AccelerationStructureNV>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetAccelerationStructureMemoryRequirementsNV = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const AccelerationStructureMemoryRequirementsInfoNV,
    p_memory_requirements: *mut MemoryRequirements2KHR,
);
pub type FnBindAccelerationStructureMemoryNV = unsafe extern "system" fn(
    device: Option<Device>,
    bind_info_count: u32,
    p_bind_infos: *const BindAccelerationStructureMemoryInfoNV,
) -> Result;
pub type FnCmdCopyAccelerationStructureNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    dst: Option<AccelerationStructureNV>,
    src: Option<AccelerationStructureNV>,
    mode: CopyAccelerationStructureModeKHR,
);
pub type FnCmdCopyAccelerationStructureKHR =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_info: *const CopyAccelerationStructureInfoKHR);
pub type FnCopyAccelerationStructureKHR = unsafe extern "system" fn(
    device: Option<Device>,
    deferred_operation: Option<DeferredOperationKHR>,
    p_info: *const CopyAccelerationStructureInfoKHR,
) -> Result;
pub type FnCmdCopyAccelerationStructureToMemoryKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_info: *const CopyAccelerationStructureToMemoryInfoKHR,
);
pub type FnCopyAccelerationStructureToMemoryKHR = unsafe extern "system" fn(
    device: Option<Device>,
    deferred_operation: Option<DeferredOperationKHR>,
    p_info: *const CopyAccelerationStructureToMemoryInfoKHR,
) -> Result;
pub type FnCmdCopyMemoryToAccelerationStructureKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_info: *const CopyMemoryToAccelerationStructureInfoKHR,
);
pub type FnCopyMemoryToAccelerationStructureKHR = unsafe extern "system" fn(
    device: Option<Device>,
    deferred_operation: Option<DeferredOperationKHR>,
    p_info: *const CopyMemoryToAccelerationStructureInfoKHR,
) -> Result;
pub type FnCmdWriteAccelerationStructuresPropertiesKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    acceleration_structure_count: u32,
    p_acceleration_structures: *const AccelerationStructureKHR,
    query_type: QueryType,
    query_pool: Option<QueryPool>,
    first_query: u32,
);
pub type FnCmdWriteAccelerationStructuresPropertiesNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    acceleration_structure_count: u32,
    p_acceleration_structures: *const AccelerationStructureNV,
    query_type: QueryType,
    query_pool: Option<QueryPool>,
    first_query: u32,
);
pub type FnCmdBuildAccelerationStructureNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_info: *const AccelerationStructureInfoNV,
    instance_data: Option<Buffer>,
    instance_offset: DeviceSize,
    update: Bool32,
    dst: Option<AccelerationStructureNV>,
    src: Option<AccelerationStructureNV>,
    scratch: Option<Buffer>,
    scratch_offset: DeviceSize,
);
pub type FnWriteAccelerationStructuresPropertiesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    acceleration_structure_count: u32,
    p_acceleration_structures: *const AccelerationStructureKHR,
    query_type: QueryType,
    data_size: usize,
    p_data: *mut c_void,
    stride: usize,
) -> Result;
pub type FnCmdTraceRaysKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_raygen_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_miss_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_hit_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_callable_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    width: u32,
    height: u32,
    depth: u32,
);
pub type FnCmdTraceRaysNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    raygen_shader_binding_table_buffer: Option<Buffer>,
    raygen_shader_binding_offset: DeviceSize,
    miss_shader_binding_table_buffer: Option<Buffer>,
    miss_shader_binding_offset: DeviceSize,
    miss_shader_binding_stride: DeviceSize,
    hit_shader_binding_table_buffer: Option<Buffer>,
    hit_shader_binding_offset: DeviceSize,
    hit_shader_binding_stride: DeviceSize,
    callable_shader_binding_table_buffer: Option<Buffer>,
    callable_shader_binding_offset: DeviceSize,
    callable_shader_binding_stride: DeviceSize,
    width: u32,
    height: u32,
    depth: u32,
);
pub type FnGetRayTracingShaderGroupHandlesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline: Option<Pipeline>,
    first_group: u32,
    group_count: u32,
    data_size: usize,
    p_data: *mut c_void,
) -> Result;
pub type FnGetRayTracingCaptureReplayShaderGroupHandlesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline: Option<Pipeline>,
    first_group: u32,
    group_count: u32,
    data_size: usize,
    p_data: *mut c_void,
) -> Result;
pub type FnGetAccelerationStructureHandleNV = unsafe extern "system" fn(
    device: Option<Device>,
    acceleration_structure: Option<AccelerationStructureNV>,
    data_size: usize,
    p_data: *mut c_void,
) -> Result;
pub type FnCreateRayTracingPipelinesNV = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline_cache: Option<PipelineCache>,
    create_info_count: u32,
    p_create_infos: *const RayTracingPipelineCreateInfoNV,
    p_allocator: *const AllocationCallbacks,
    p_pipelines: *mut Pipeline,
) -> Result;
pub type FnCreateRayTracingPipelinesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    deferred_operation: Option<DeferredOperationKHR>,
    pipeline_cache: Option<PipelineCache>,
    create_info_count: u32,
    p_create_infos: *const RayTracingPipelineCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_pipelines: *mut Pipeline,
) -> Result;
pub type FnGetPhysicalDeviceCooperativeMatrixPropertiesNV = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_property_count: *mut u32,
    p_properties: *mut CooperativeMatrixPropertiesNV,
) -> Result;
pub type FnCmdTraceRaysIndirectKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_raygen_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_miss_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_hit_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    p_callable_shader_binding_table: *const StridedDeviceAddressRegionKHR,
    indirect_device_address: DeviceAddress,
);
pub type FnCmdTraceRaysIndirect2KHR =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, indirect_device_address: DeviceAddress);
pub type FnGetDeviceAccelerationStructureCompatibilityKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_version_info: *const AccelerationStructureVersionInfoKHR,
    p_compatibility: *mut AccelerationStructureCompatibilityKHR,
);
pub type FnGetRayTracingShaderGroupStackSizeKHR = unsafe extern "system" fn(
    device: Option<Device>,
    pipeline: Option<Pipeline>,
    group: u32,
    group_shader: ShaderGroupShaderKHR,
) -> DeviceSize;
pub type FnCmdSetRayTracingPipelineStackSizeKHR =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, pipeline_stack_size: u32);
pub type FnGetImageViewHandleNVX =
    unsafe extern "system" fn(device: Option<Device>, p_info: *const ImageViewHandleInfoNVX) -> u32;
pub type FnGetImageViewAddressNVX = unsafe extern "system" fn(
    device: Option<Device>,
    image_view: Option<ImageView>,
    p_properties: *mut ImageViewAddressPropertiesNVX,
) -> Result;
pub type FnGetPhysicalDeviceSurfacePresentModes2EXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_present_mode_count: *mut u32,
    p_present_modes: *mut PresentModeKHR,
) -> Result;
pub type FnGetDeviceGroupSurfacePresentModes2EXT = unsafe extern "system" fn(
    device: Option<Device>,
    p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    p_modes: *mut DeviceGroupPresentModeFlagsKHR,
) -> Result;
pub type FnAcquireFullScreenExclusiveModeEXT =
    unsafe extern "system" fn(device: Option<Device>, swapchain: Option<SwapchainKHR>) -> Result;
pub type FnReleaseFullScreenExclusiveModeEXT =
    unsafe extern "system" fn(device: Option<Device>, swapchain: Option<SwapchainKHR>) -> Result;
pub type FnEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    queue_family_index: u32,
    p_counter_count: *mut u32,
    p_counters: *mut PerformanceCounterKHR,
    p_counter_descriptions: *mut PerformanceCounterDescriptionKHR,
) -> Result;
pub type FnGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_performance_query_create_info: *const QueryPoolPerformanceCreateInfoKHR,
    p_num_passes: *mut u32,
);
pub type FnAcquireProfilingLockKHR =
    unsafe extern "system" fn(device: Option<Device>, p_info: *const AcquireProfilingLockInfoKHR) -> Result;
pub type FnReleaseProfilingLockKHR = unsafe extern "system" fn(device: Option<Device>);
pub type FnGetImageDrmFormatModifierPropertiesEXT = unsafe extern "system" fn(
    device: Option<Device>,
    image: Option<Image>,
    p_properties: *mut ImageDrmFormatModifierPropertiesEXT,
) -> Result;
pub type FnGetBufferOpaqueCaptureAddress =
    unsafe extern "system" fn(device: Option<Device>, p_info: *const BufferDeviceAddressInfo) -> u64;
pub type FnGetBufferDeviceAddress =
    unsafe extern "system" fn(device: Option<Device>, p_info: *const BufferDeviceAddressInfo) -> DeviceAddress;
pub type FnCreateHeadlessSurfaceEXT = unsafe extern "system" fn(
    instance: Option<Instance>,
    p_create_info: *const HeadlessSurfaceCreateInfoEXT,
    p_allocator: *const AllocationCallbacks,
    p_surface: *mut SurfaceKHR,
) -> Result;
pub type FnGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_combination_count: *mut u32,
    p_combinations: *mut FramebufferMixedSamplesCombinationNV,
) -> Result;
pub type FnInitializePerformanceApiINTEL = unsafe extern "system" fn(
    device: Option<Device>,
    p_initialize_info: *const InitializePerformanceApiInfoINTEL,
) -> Result;
pub type FnUninitializePerformanceApiINTEL = unsafe extern "system" fn(device: Option<Device>);
pub type FnCmdSetPerformanceMarkerINTEL = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_marker_info: *const PerformanceMarkerInfoINTEL,
) -> Result;
pub type FnCmdSetPerformanceStreamMarkerINTEL = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_marker_info: *const PerformanceStreamMarkerInfoINTEL,
) -> Result;
pub type FnCmdSetPerformanceOverrideINTEL = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_override_info: *const PerformanceOverrideInfoINTEL,
) -> Result;
pub type FnAcquirePerformanceConfigurationINTEL = unsafe extern "system" fn(
    device: Option<Device>,
    p_acquire_info: *const PerformanceConfigurationAcquireInfoINTEL,
    p_configuration: *mut PerformanceConfigurationINTEL,
) -> Result;
pub type FnReleasePerformanceConfigurationINTEL =
    unsafe extern "system" fn(device: Option<Device>, configuration: Option<PerformanceConfigurationINTEL>) -> Result;
pub type FnQueueSetPerformanceConfigurationINTEL =
    unsafe extern "system" fn(queue: Option<Queue>, configuration: Option<PerformanceConfigurationINTEL>) -> Result;
pub type FnGetPerformanceParameterINTEL = unsafe extern "system" fn(
    device: Option<Device>,
    parameter: PerformanceParameterTypeINTEL,
    p_value: *mut PerformanceValueINTEL,
) -> Result;
pub type FnGetDeviceMemoryOpaqueCaptureAddress =
    unsafe extern "system" fn(device: Option<Device>, p_info: *const DeviceMemoryOpaqueCaptureAddressInfo) -> u64;
pub type FnGetPipelineExecutablePropertiesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_pipeline_info: *const PipelineInfoKHR,
    p_executable_count: *mut u32,
    p_properties: *mut PipelineExecutablePropertiesKHR,
) -> Result;
pub type FnGetPipelineExecutableStatisticsKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_executable_info: *const PipelineExecutableInfoKHR,
    p_statistic_count: *mut u32,
    p_statistics: *mut PipelineExecutableStatisticKHR,
) -> Result;
pub type FnGetPipelineExecutableInternalRepresentationsKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_executable_info: *const PipelineExecutableInfoKHR,
    p_internal_representation_count: *mut u32,
    p_internal_representations: *mut PipelineExecutableInternalRepresentationKHR,
) -> Result;
pub type FnCmdSetLineStippleEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    line_stipple_factor: u32,
    line_stipple_pattern: u16,
);
pub type FnGetPhysicalDeviceToolProperties = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_tool_count: *mut u32,
    p_tool_properties: *mut PhysicalDeviceToolProperties,
) -> Result;
pub type FnCreateAccelerationStructureKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const AccelerationStructureCreateInfoKHR,
    p_allocator: *const AllocationCallbacks,
    p_acceleration_structure: *mut AccelerationStructureKHR,
) -> Result;
pub type FnCmdBuildAccelerationStructuresKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    info_count: u32,
    p_infos: *const AccelerationStructureBuildGeometryInfoKHR,
    pp_build_range_infos: *const *const AccelerationStructureBuildRangeInfoKHR,
);
pub type FnCmdBuildAccelerationStructuresIndirectKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    info_count: u32,
    p_infos: *const AccelerationStructureBuildGeometryInfoKHR,
    p_indirect_device_addresses: *const DeviceAddress,
    p_indirect_strides: *const u32,
    pp_max_primitive_counts: *const *const u32,
);
pub type FnBuildAccelerationStructuresKHR = unsafe extern "system" fn(
    device: Option<Device>,
    deferred_operation: Option<DeferredOperationKHR>,
    info_count: u32,
    p_infos: *const AccelerationStructureBuildGeometryInfoKHR,
    pp_build_range_infos: *const *const AccelerationStructureBuildRangeInfoKHR,
) -> Result;
pub type FnGetAccelerationStructureDeviceAddressKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_info: *const AccelerationStructureDeviceAddressInfoKHR,
) -> DeviceAddress;
pub type FnCreateDeferredOperationKHR = unsafe extern "system" fn(
    device: Option<Device>,
    p_allocator: *const AllocationCallbacks,
    p_deferred_operation: *mut DeferredOperationKHR,
) -> Result;
pub type FnDestroyDeferredOperationKHR = unsafe extern "system" fn(
    device: Option<Device>,
    operation: Option<DeferredOperationKHR>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetDeferredOperationMaxConcurrencyKHR =
    unsafe extern "system" fn(device: Option<Device>, operation: Option<DeferredOperationKHR>) -> u32;
pub type FnGetDeferredOperationResultKHR =
    unsafe extern "system" fn(device: Option<Device>, operation: Option<DeferredOperationKHR>) -> Result;
pub type FnDeferredOperationJoinKHR =
    unsafe extern "system" fn(device: Option<Device>, operation: Option<DeferredOperationKHR>) -> Result;
pub type FnCmdSetCullMode = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, cull_mode: CullModeFlags);
pub type FnCmdSetFrontFace = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, front_face: FrontFace);
pub type FnCmdSetPrimitiveTopology =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, primitive_topology: PrimitiveTopology);
pub type FnCmdSetViewportWithCount =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, viewport_count: u32, p_viewports: *const Viewport);
pub type FnCmdSetScissorWithCount =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, scissor_count: u32, p_scissors: *const Rect2D);
pub type FnCmdBindVertexBuffers2 = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    first_binding: u32,
    binding_count: u32,
    p_buffers: *const Buffer,
    p_offsets: *const DeviceSize,
    p_sizes: *const DeviceSize,
    p_strides: *const DeviceSize,
);
pub type FnCmdSetDepthTestEnable =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, depth_test_enable: Bool32);
pub type FnCmdSetDepthWriteEnable =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, depth_write_enable: Bool32);
pub type FnCmdSetDepthCompareOp =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, depth_compare_op: CompareOp);
pub type FnCmdSetDepthBoundsTestEnable =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, depth_bounds_test_enable: Bool32);
pub type FnCmdSetStencilTestEnable =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, stencil_test_enable: Bool32);
pub type FnCmdSetStencilOp = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    face_mask: StencilFaceFlags,
    fail_op: StencilOp,
    pass_op: StencilOp,
    depth_fail_op: StencilOp,
    compare_op: CompareOp,
);
pub type FnCmdSetPatchControlPointsEXT =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, patch_control_points: u32);
pub type FnCmdSetRasterizerDiscardEnable =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, rasterizer_discard_enable: Bool32);
pub type FnCmdSetDepthBiasEnable =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, depth_bias_enable: Bool32);
pub type FnCmdSetLogicOpEXT = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, logic_op: LogicOp);
pub type FnCmdSetPrimitiveRestartEnable =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, primitive_restart_enable: Bool32);
pub type FnCreatePrivateDataSlot = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const PrivateDataSlotCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_private_data_slot: *mut PrivateDataSlot,
) -> Result;
pub type FnDestroyPrivateDataSlot = unsafe extern "system" fn(
    device: Option<Device>,
    private_data_slot: Option<PrivateDataSlot>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnSetPrivateData = unsafe extern "system" fn(
    device: Option<Device>,
    object_type: ObjectType,
    object_handle: u64,
    private_data_slot: Option<PrivateDataSlot>,
    data: u64,
) -> Result;
pub type FnGetPrivateData = unsafe extern "system" fn(
    device: Option<Device>,
    object_type: ObjectType,
    object_handle: u64,
    private_data_slot: Option<PrivateDataSlot>,
    p_data: *mut u64,
);
pub type FnCmdCopyBuffer2 =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_copy_buffer_info: *const CopyBufferInfo2);
pub type FnCmdCopyImage2 =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_copy_image_info: *const CopyImageInfo2);
pub type FnCmdBlitImage2 =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_blit_image_info: *const BlitImageInfo2);
pub type FnCmdCopyBufferToImage2 = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_copy_buffer_to_image_info: *const CopyBufferToImageInfo2,
);
pub type FnCmdCopyImageToBuffer2 = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_copy_image_to_buffer_info: *const CopyImageToBufferInfo2,
);
pub type FnCmdResolveImage2 =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_resolve_image_info: *const ResolveImageInfo2);
pub type FnCmdSetFragmentShadingRateKHR = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    p_fragment_size: *const Extent2D,
    combiner_ops: *const FragmentShadingRateCombinerOpKHR,
);
pub type FnGetPhysicalDeviceFragmentShadingRatesKHR = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    p_fragment_shading_rate_count: *mut u32,
    p_fragment_shading_rates: *mut PhysicalDeviceFragmentShadingRateKHR,
) -> Result;
pub type FnCmdSetFragmentShadingRateEnumNV = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    shading_rate: FragmentShadingRateNV,
    combiner_ops: *const FragmentShadingRateCombinerOpKHR,
);
pub type FnGetAccelerationStructureBuildSizesKHR = unsafe extern "system" fn(
    device: Option<Device>,
    build_type: AccelerationStructureBuildTypeKHR,
    p_build_info: *const AccelerationStructureBuildGeometryInfoKHR,
    p_max_primitive_counts: *const u32,
    p_size_info: *mut AccelerationStructureBuildSizesInfoKHR,
);
pub type FnCmdSetVertexInputEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    vertex_binding_description_count: u32,
    p_vertex_binding_descriptions: *const VertexInputBindingDescription2EXT,
    vertex_attribute_description_count: u32,
    p_vertex_attribute_descriptions: *const VertexInputAttributeDescription2EXT,
);
pub type FnCmdSetColorWriteEnableEXT = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    attachment_count: u32,
    p_color_write_enables: *const Bool32,
);
pub type FnCmdSetEvent2 = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    event: Option<Event>,
    p_dependency_info: *const DependencyInfo,
);
pub type FnCmdResetEvent2 = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    event: Option<Event>,
    stage_mask: PipelineStageFlags2,
);
pub type FnCmdWaitEvents2 = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    event_count: u32,
    p_events: *const Event,
    p_dependency_infos: *const DependencyInfo,
);
pub type FnCmdPipelineBarrier2 =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_dependency_info: *const DependencyInfo);
pub type FnQueueSubmit2 = unsafe extern "system" fn(
    queue: Option<Queue>,
    submit_count: u32,
    p_submits: *const SubmitInfo2,
    fence: Option<Fence>,
) -> Result;
pub type FnCmdWriteTimestamp2 = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    stage: PipelineStageFlags2,
    query_pool: Option<QueryPool>,
    query: u32,
);
pub type FnCmdWriteBufferMarker2AMD = unsafe extern "system" fn(
    command_buffer: Option<CommandBuffer>,
    stage: PipelineStageFlags2,
    dst_buffer: Option<Buffer>,
    dst_offset: DeviceSize,
    marker: u32,
);
pub type FnGetQueueCheckpointData2NV = unsafe extern "system" fn(
    queue: Option<Queue>,
    p_checkpoint_data_count: *mut u32,
    p_checkpoint_data: *mut CheckpointData2NV,
);
pub type FnCreateCuModuleNVX = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const CuModuleCreateInfoNVX,
    p_allocator: *const AllocationCallbacks,
    p_module: *mut CuModuleNVX,
) -> Result;
pub type FnCreateCuFunctionNVX = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const CuFunctionCreateInfoNVX,
    p_allocator: *const AllocationCallbacks,
    p_function: *mut CuFunctionNVX,
) -> Result;
pub type FnDestroyCuModuleNVX = unsafe extern "system" fn(
    device: Option<Device>,
    module: Option<CuModuleNVX>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnDestroyCuFunctionNVX = unsafe extern "system" fn(
    device: Option<Device>,
    function: Option<CuFunctionNVX>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnCmdCuLaunchKernelNVX =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_launch_info: *const CuLaunchInfoNVX);
pub type FnSetDeviceMemoryPriorityEXT =
    unsafe extern "system" fn(device: Option<Device>, memory: Option<DeviceMemory>, priority: f32);
pub type FnAcquireDrmDisplayEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    drm_fd: i32,
    display: Option<DisplayKHR>,
) -> Result;
pub type FnGetDrmDisplayEXT = unsafe extern "system" fn(
    physical_device: Option<PhysicalDevice>,
    drm_fd: i32,
    connector_id: u32,
    display: *mut DisplayKHR,
) -> Result;
pub type FnWaitForPresentKHR = unsafe extern "system" fn(
    device: Option<Device>,
    swapchain: Option<SwapchainKHR>,
    present_id: u64,
    timeout: u64,
) -> Result;
pub type FnCreateBufferCollectionFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    p_create_info: *const BufferCollectionCreateInfoFUCHSIA,
    p_allocator: *const AllocationCallbacks,
    p_collection: *mut BufferCollectionFUCHSIA,
) -> Result;
pub type FnSetBufferCollectionBufferConstraintsFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    collection: Option<BufferCollectionFUCHSIA>,
    p_buffer_constraints_info: *const BufferConstraintsInfoFUCHSIA,
) -> Result;
pub type FnSetBufferCollectionImageConstraintsFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    collection: Option<BufferCollectionFUCHSIA>,
    p_image_constraints_info: *const ImageConstraintsInfoFUCHSIA,
) -> Result;
pub type FnDestroyBufferCollectionFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    collection: Option<BufferCollectionFUCHSIA>,
    p_allocator: *const AllocationCallbacks,
);
pub type FnGetBufferCollectionPropertiesFUCHSIA = unsafe extern "system" fn(
    device: Option<Device>,
    collection: Option<BufferCollectionFUCHSIA>,
    p_properties: *mut BufferCollectionPropertiesFUCHSIA,
) -> Result;
pub type FnCmdBeginRendering =
    unsafe extern "system" fn(command_buffer: Option<CommandBuffer>, p_rendering_info: *const RenderingInfo);
pub type FnCmdEndRendering = unsafe extern "system" fn(command_buffer: Option<CommandBuffer>);
pub type FnGetDescriptorSetLayoutHostMappingInfoVALVE = unsafe extern "system" fn(
    device: Option<Device>,
    p_binding_reference: *const DescriptorSetBindingReferenceVALVE,
    p_host_mapping: *mut DescriptorSetLayoutHostMappingInfoVALVE,
);
pub type FnGetDescriptorSetHostMappingVALVE =
    unsafe extern "system" fn(device: Option<Device>, descriptor_set: Option<DescriptorSet>, pp_data: *mut *mut c_void);
pub type FnGetImageSubresourceLayout2EXT = unsafe extern "system" fn(
    device: Option<Device>,
    image: Option<Image>,
    p_subresource: *const ImageSubresource2EXT,
    p_layout: *mut SubresourceLayout2EXT,
);
pub type FnGetPipelinePropertiesEXT = unsafe extern "system" fn(
    device: Option<Device>,
    p_pipeline_info: *const PipelineInfoEXT,
    p_pipeline_properties: *mut BaseOutStructure,
) -> Result;
pub type FnExportMetalObjectsEXT =
    unsafe extern "system" fn(device: Option<Device>, p_metal_objects_info: *mut ExportMetalObjectsInfoEXT);
