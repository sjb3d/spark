// Generated from vk.xml version 1.4.327

pub fn make_version(major: u32, minor: u32, patch: u32) Version {
    return Version{
        .major = @truncate(major),
        .minor = @truncate(minor),
        .patch = @truncate(patch),
    };
}

pub const Bool32 = enum(u32) {
    false = 0,
    true = 1,
    _,

    pub fn from_bool(b: bool) Bool32 {
        return if (b) .true else .false;
    }
    pub fn to_bool(self: Bool32) bool {
        return self != .false;
    }
};

pub const Version = packed struct(u32) {
    patch: u12 = 0,
    minor: u10 = 0,
    major: u7 = 0,
    variant: u3 = 0,

    pub fn to_int(self: Version) u32 {
        return @bitCast(self);
    }
    pub fn from_int(i: u32) Version {
        return @bitCast(i);
    }

    pub fn format(self: Version, writer: *std.io.Writer) std.io.Writer.Error!void {
        return writer.print("{}.{}.{}", .{ self.major, self.minor, self.patch });
    }
};

pub const MissingFunctionError = error{
    MissingFunction,
};

pub const Loader = struct {
    lib: std.DynLib,
    fp_get_instance_proc_addr: FpGetInstanceProcAddr,

    pub fn init() !Loader {
        var lib = try std.DynLib.open("vulkan-1.dll");
        const fp_get_instance_proc_addr = lib.lookup(FpGetInstanceProcAddr, "vkGetInstanceProcAddr") orelse return error.MissingFunction;

        return Loader{
            .lib = lib,
            .fp_get_instance_proc_addr = fp_get_instance_proc_addr,
        };
    }

    pub fn get_instance_proc_addr(self: Loader, p_name: [*:0]const u8) MissingFunctionError!FpVoidFunction {
        return self.fp_get_instance_proc_addr(.null_handle, p_name) orelse return error.MissingFunction;
    }
};

fn BitField(comptime Fields: type) type {
    const bit_count = 1 << @bitSizeOf(@typeInfo(Fields).@"enum".tag_type);
    const BitsInt = std.meta.Int(.unsigned, bit_count);

    return packed struct(BitsInt) {
        bits: BitsInt,

        const Self = @This();

        pub const none: Self = .{ .bits = 0 };

        pub fn init(init_values: std.enums.EnumFieldStruct(Fields, bool, false)) Self {
            var result: Self = .none;
            inline for (std.meta.fields(Fields)) |field| {
                if (@field(init_values, field.name)) {
                    result.set(@field(Fields, field.name));
                }
            }
            return result;
        }
        pub fn init_one(field: Fields) Self {
            return Self{ .bits = bit_from_field(field) };
        }

        fn bit_from_field(field: Fields) BitsInt {
            return @as(BitsInt, 1) << @intFromEnum(field);
        }

        pub fn set(self: *Self, field: Fields) void {
            self.bits |= bit_from_field(field);
        }
        pub fn unset(self: *Self, field: Fields) void {
            self.bits &= ~bit_from_field(field);
        }

        pub fn intersect_with(self: *Self, other: Self) void {
            self.bits &= other.bits;
        }
        pub fn union_with(self: *Self, other: Self) void {
            self.bits |= other.bits;
        }

        pub fn intersected_with(self: Self, other: Self) Self {
            return Self{ .bits = self.bits & other.bits };
        }
        pub fn unioned_with(self: Self, other: Self) Self {
            return Self{ .bits = self.bits | other.bits };
        }

        pub fn eql(self: Self, other: Self) bool {
            return self.bits == other.bits;
        }

        pub fn is_set(self: Self, field: Fields) bool {
            return (self.bits & bit_from_field(field)) != 0;
        }
        pub fn is_none(self: Self) bool {
            return self.bits == 0;
        }
        pub fn is_superset_of(self: Self, other: Self) bool {
            return self.intersected_with(other).eql(other);
        }
        pub fn is_subset_of(self: Self, other: Self) bool {
            return self.intersected_with(other).eql(self);
        }
    };
}

pub const EnumerateResult = enum {
    success,
    incomplete,
};

fn enumerate_generic_to_array(
    comptime ErrorSet: type,
    comptime Element: type,
    enumerator: anytype,
    allocator: Allocator,
) ErrorSet![]Element {
    while (true) {
        var len: u32 = undefined;
        const len_result = try enumerator.enumerate(&len, null);
        switch (len_result) {
            .success => {},
            .incomplete => return error.Unexpected,
        }
        var items = try allocator.alloc(Element, len);
        errdefer allocator.free(items);
        const items_result = try enumerator.enumerate(&len, items.ptr);
        switch (items_result) {
            .success => return items[0..len],
            .incomplete => allocator.free(items),
        }
    }
}

fn enumerate_generic_unchecked_to_array(
    comptime Element: type,
    enumerator: anytype,
    allocator: Allocator,
) Allocator.Error![]Element {
    var len: u32 = undefined;
    enumerator.enumerate(&len, null);
    var items = try allocator.alloc(Element, len);
    enumerator.enumerate(&len, items.ptr);
    return items[0..len];
}
pub const max_physical_device_name_size = 256;
pub const uuid_size = 16;
pub const luid_size = 8;
pub const max_extension_name_size = 256;
pub const max_description_size = 256;
pub const max_memory_types = 32;
pub const max_memory_heaps = 16;
pub const lod_clamp_none: f32 = 1000;
pub const remaining_mip_levels: u32 = 0xffffffff;
pub const remaining_array_layers: u32 = 0xffffffff;
pub const remaining_3d_slices_ext: u32 = 0xffffffff;
pub const whole_size: u64 = 0xffffffffffffffff;
pub const attachment_unused: u32 = 0xffffffff;
pub const queue_family_ignored: u32 = 0xffffffff;
pub const queue_family_external: u32 = 0xfffffffe;
pub const queue_family_foreign_ext: u32 = 0xfffffffd;
pub const subpass_external: u32 = 0xffffffff;
pub const max_device_group_size = 32;
pub const max_driver_name_size = 256;
pub const max_driver_info_size = 256;
pub const shader_unused_khr: u32 = 0xffffffff;
pub const max_global_priority_size = 16;
pub const max_shader_module_identifier_size_ext = 32;
pub const max_pipeline_binary_key_size_khr = 32;
pub const shader_index_unused_amdx: u32 = 0xffffffff;
pub const partitioned_acceleration_structure_partition_index_global_nv: u32 = 0xffffffff;
pub const compressed_triangle_format_dgf1_byte_alignment_amdx = 128;
pub const compressed_triangle_format_dgf1_byte_stride_amdx = 128;
pub const max_physical_device_data_graph_operation_set_name_size_arm = 128;
pub const wl_display = opaque {};
pub const Display = opaque {};
pub const VisualID = c_ulong;
pub const xcb_connection_t = opaque {};
pub const xcb_visualid_t = u32;
pub const IDirectFB = opaque {};
pub const HANDLE = ?*anyopaque;
pub const zx_handle_t = u32;
pub const RROutput = c_ulong;
pub const AHardwareBuffer = opaque {};
pub const OHNativeWindow = ?*anyopaque;
pub const MTLSharedEvent_id = ?*anyopaque;
pub const IOSurfaceRef = ?*anyopaque;
pub const MTLTexture_id = ?*anyopaque;
pub const MTLBuffer_id = ?*anyopaque;
pub const MTLCommandQueue_id = ?*anyopaque;
pub const MTLDevice_id = ?*anyopaque;
pub const HMONITOR = ?*anyopaque;
pub const CAMetalLayer = opaque {};
pub const SECURITY_ATTRIBUTES = opaque {};
pub const DWORD = c_ulong;
pub const LPCWSTR = ?*const u16;
pub const IDirectFBSurface = opaque {};
pub const xcb_window_t = u32;
pub const Window = c_ulong;
pub const HINSTANCE = ?*anyopaque;
pub const HWND = ?*anyopaque;
pub const wl_surface = opaque {};
pub const ANativeWindow = opaque {};
pub const SampleMask = u32;
pub const Flags = u32;
pub const Flags64 = u64;
pub const DeviceSize = u64;
pub const DeviceAddress = u64;
pub const FramebufferCreateFlagBits = enum(u5) {
    imageless = 0,
    _,
};
pub const FramebufferCreateFlags = BitField(FramebufferCreateFlagBits);
pub const QueryPoolCreateFlagBits = enum(u5) {
    reset_khr = 0,
    _,
};
pub const QueryPoolCreateFlags = BitField(QueryPoolCreateFlagBits);
pub const RenderPassCreateFlagBits = enum(u5) {
    transform_qcom = 1,
    per_layer_fragment_density_valve = 2,
    _,
};
pub const RenderPassCreateFlags = BitField(RenderPassCreateFlagBits);
pub const SamplerCreateFlagBits = enum(u5) {
    subsampled_ext = 0,
    subsampled_coarse_reconstruction_ext = 1,
    descriptor_buffer_capture_replay_ext = 3,
    non_seamless_cube_map_ext = 2,
    image_processing_qcom = 4,
    _,
};
pub const SamplerCreateFlags = BitField(SamplerCreateFlagBits);
pub const PipelineLayoutCreateFlagBits = enum(u5) {
    independent_sets_ext = 1,
    _,
};
pub const PipelineLayoutCreateFlags = BitField(PipelineLayoutCreateFlagBits);
pub const PipelineCacheCreateFlagBits = enum(u5) {
    externally_synchronized = 0,
    internally_synchronized_merge_khr = 3,
    _,
};
pub const PipelineCacheCreateFlags = BitField(PipelineCacheCreateFlagBits);
pub const PipelineDepthStencilStateCreateFlagBits = enum(u5) {
    rasterization_order_attachment_depth_access_ext = 0,
    rasterization_order_attachment_stencil_access_ext = 1,
    _,
};
pub const PipelineDepthStencilStateCreateFlags = BitField(PipelineDepthStencilStateCreateFlagBits);
pub const PipelineDynamicStateCreateFlagBits = enum(u5) {
    _,
};
pub const PipelineDynamicStateCreateFlags = BitField(PipelineDynamicStateCreateFlagBits);
pub const PipelineColorBlendStateCreateFlagBits = enum(u5) {
    rasterization_order_attachment_access_ext = 0,
    _,
};
pub const PipelineColorBlendStateCreateFlags = BitField(PipelineColorBlendStateCreateFlagBits);
pub const PipelineMultisampleStateCreateFlagBits = enum(u5) {
    _,
};
pub const PipelineMultisampleStateCreateFlags = BitField(PipelineMultisampleStateCreateFlagBits);
pub const PipelineRasterizationStateCreateFlagBits = enum(u5) {
    _,
};
pub const PipelineRasterizationStateCreateFlags = BitField(PipelineRasterizationStateCreateFlagBits);
pub const PipelineViewportStateCreateFlagBits = enum(u5) {
    _,
};
pub const PipelineViewportStateCreateFlags = BitField(PipelineViewportStateCreateFlagBits);
pub const PipelineTessellationStateCreateFlagBits = enum(u5) {
    _,
};
pub const PipelineTessellationStateCreateFlags = BitField(PipelineTessellationStateCreateFlagBits);
pub const PipelineInputAssemblyStateCreateFlagBits = enum(u5) {
    _,
};
pub const PipelineInputAssemblyStateCreateFlags = BitField(PipelineInputAssemblyStateCreateFlagBits);
pub const PipelineVertexInputStateCreateFlagBits = enum(u5) {
    _,
};
pub const PipelineVertexInputStateCreateFlags = BitField(PipelineVertexInputStateCreateFlagBits);
pub const PipelineShaderStageCreateFlagBits = enum(u5) {
    allow_varying_subgroup_size = 0,
    require_full_subgroups = 1,
    _,
};
pub const PipelineShaderStageCreateFlags = BitField(PipelineShaderStageCreateFlagBits);
pub const DescriptorSetLayoutCreateFlagBits = enum(u5) {
    update_after_bind_pool = 1,
    push_descriptor = 0,
    descriptor_buffer_ext = 4,
    embedded_immutable_samplers_ext = 5,
    indirect_bindable_nv = 7,
    host_only_pool_ext = 2,
    per_stage_nv = 6,
    _,
};
pub const DescriptorSetLayoutCreateFlags = BitField(DescriptorSetLayoutCreateFlagBits);
pub const BufferViewCreateFlagBits = enum(u5) {
    _,
};
pub const BufferViewCreateFlags = BitField(BufferViewCreateFlagBits);
pub const InstanceCreateFlagBits = enum(u5) {
    enumerate_portability_khr = 0,
    _,
};
pub const InstanceCreateFlags = BitField(InstanceCreateFlagBits);
pub const DeviceCreateFlagBits = enum(u5) {
    _,
};
pub const DeviceCreateFlags = BitField(DeviceCreateFlagBits);
pub const DeviceQueueCreateFlagBits = enum(u5) {
    protected = 0,
    _,
};
pub const DeviceQueueCreateFlags = BitField(DeviceQueueCreateFlagBits);
pub const QueueFlagBits = enum(u5) {
    graphics = 0,
    compute = 1,
    transfer = 2,
    sparse_binding = 3,
    protected = 4,
    optical_flow_nv = 8,
    data_graph_arm = 10,
    _,
};
pub const QueueFlags = BitField(QueueFlagBits);
pub const MemoryPropertyFlagBits = enum(u5) {
    device_local = 0,
    host_visible = 1,
    host_coherent = 2,
    host_cached = 3,
    lazily_allocated = 4,
    protected = 5,
    device_coherent_amd = 6,
    device_uncached_amd = 7,
    rdma_capable_nv = 8,
    _,
};
pub const MemoryPropertyFlags = BitField(MemoryPropertyFlagBits);
pub const MemoryHeapFlagBits = enum(u5) {
    device_local = 0,
    multi_instance = 1,
    tile_memory_qcom = 3,
    _,
};
pub const MemoryHeapFlags = BitField(MemoryHeapFlagBits);
pub const AccessFlagBits = enum(u5) {
    indirect_command_read = 0,
    index_read = 1,
    vertex_attribute_read = 2,
    uniform_read = 3,
    input_attachment_read = 4,
    shader_read = 5,
    shader_write = 6,
    color_attachment_read = 7,
    color_attachment_write = 8,
    depth_stencil_attachment_read = 9,
    depth_stencil_attachment_write = 10,
    transfer_read = 11,
    transfer_write = 12,
    host_read = 13,
    host_write = 14,
    memory_read = 15,
    memory_write = 16,
    transform_feedback_write_ext = 25,
    transform_feedback_counter_read_ext = 26,
    transform_feedback_counter_write_ext = 27,
    conditional_rendering_read_ext = 20,
    color_attachment_read_noncoherent_ext = 19,
    acceleration_structure_read_khr = 21,
    acceleration_structure_write_khr = 22,
    fragment_density_map_read_ext = 24,
    fragment_shading_rate_attachment_read_khr = 23,
    command_preprocess_read_ext = 17,
    command_preprocess_write_ext = 18,
    _,
};
pub const AccessFlags = BitField(AccessFlagBits);
pub const AccessFlagMasks = struct {
    pub const none = AccessFlags{ .bits = 0x0 };
};
pub const BufferUsageFlagBits = enum(u5) {
    transfer_src = 0,
    transfer_dst = 1,
    uniform_texel_buffer = 2,
    storage_texel_buffer = 3,
    uniform_buffer = 4,
    storage_buffer = 5,
    index_buffer = 6,
    vertex_buffer = 7,
    indirect_buffer = 8,
    shader_device_address = 17,
    transform_feedback_buffer_ext = 11,
    transform_feedback_counter_buffer_ext = 12,
    conditional_rendering_ext = 9,
    execution_graph_scratch_amdx = 25,
    acceleration_structure_build_input_read_only_khr = 19,
    acceleration_structure_storage_khr = 20,
    shader_binding_table_khr = 10,
    sampler_descriptor_buffer_ext = 21,
    resource_descriptor_buffer_ext = 22,
    push_descriptors_descriptor_buffer_ext = 26,
    micromap_build_input_read_only_ext = 23,
    micromap_storage_ext = 24,
    tile_memory_qcom = 27,
    _,
};
pub const BufferUsageFlags = BitField(BufferUsageFlagBits);
pub const BufferCreateFlagBits = enum(u5) {
    sparse_binding = 0,
    sparse_residency = 1,
    sparse_aliased = 2,
    protected = 3,
    device_address_capture_replay = 4,
    descriptor_buffer_capture_replay_ext = 5,
    _,
};
pub const BufferCreateFlags = BitField(BufferCreateFlagBits);
pub const ShaderStageFlagBits = enum(u5) {
    vertex = 0,
    tessellation_control = 1,
    tessellation_evaluation = 2,
    geometry = 3,
    fragment = 4,
    compute = 5,
    raygen_khr = 8,
    any_hit_khr = 9,
    closest_hit_khr = 10,
    miss_khr = 11,
    intersection_khr = 12,
    callable_khr = 13,
    task_ext = 6,
    mesh_ext = 7,
    subpass_shading_huawei = 14,
    cluster_culling_huawei = 19,
    _,
};
pub const ShaderStageFlags = BitField(ShaderStageFlagBits);
pub const ShaderStageFlagMasks = struct {
    pub const all_graphics = ShaderStageFlags{ .bits = 0x1f };
    pub const all = ShaderStageFlags{ .bits = 0x7fffffff };
};
pub const ImageUsageFlagBits = enum(u5) {
    transfer_src = 0,
    transfer_dst = 1,
    sampled = 2,
    storage = 3,
    color_attachment = 4,
    depth_stencil_attachment = 5,
    transient_attachment = 6,
    input_attachment = 7,
    host_transfer = 22,
    fragment_density_map_ext = 9,
    fragment_shading_rate_attachment_khr = 8,
    attachment_feedback_loop_ext = 19,
    invocation_mask_huawei = 18,
    sample_weight_qcom = 20,
    sample_block_match_qcom = 21,
    tensor_aliasing_arm = 23,
    tile_memory_qcom = 27,
    _,
};
pub const ImageUsageFlags = BitField(ImageUsageFlagBits);
pub const ImageCreateFlagBits = enum(u5) {
    sparse_binding = 0,
    sparse_residency = 1,
    sparse_aliased = 2,
    mutable_format = 3,
    cube_compatible = 4,
    alias = 10,
    split_instance_bind_regions = 6,
    @"2d_array_compatible" = 5,
    block_texel_view_compatible = 7,
    extended_usage = 8,
    protected = 11,
    disjoint = 9,
    corner_sampled_nv = 13,
    sample_locations_compatible_depth_ext = 12,
    subsampled_ext = 14,
    descriptor_buffer_capture_replay_ext = 16,
    multisampled_render_to_single_sampled_ext = 18,
    @"2d_view_compatible_ext" = 17,
    fragment_density_map_offset_ext = 15,
    _,
};
pub const ImageCreateFlags = BitField(ImageCreateFlagBits);
pub const ImageViewCreateFlagBits = enum(u5) {
    fragment_density_map_dynamic_ext = 0,
    descriptor_buffer_capture_replay_ext = 2,
    fragment_density_map_deferred_ext = 1,
    _,
};
pub const ImageViewCreateFlags = BitField(ImageViewCreateFlagBits);
pub const PipelineCreateFlagBits = enum(u5) {
    disable_optimization = 0,
    allow_derivatives = 1,
    derivative = 2,
    view_index_from_device_index = 3,
    dispatch_base = 4,
    fail_on_pipeline_compile_required = 8,
    early_return_on_failure = 9,
    no_protected_access = 27,
    protected_access_only = 30,
    ray_tracing_no_null_any_hit_shaders_khr = 14,
    ray_tracing_no_null_closest_hit_shaders_khr = 15,
    ray_tracing_no_null_miss_shaders_khr = 16,
    ray_tracing_no_null_intersection_shaders_khr = 17,
    ray_tracing_skip_triangles_khr = 12,
    ray_tracing_skip_aabbs_khr = 13,
    ray_tracing_shader_group_handle_capture_replay_khr = 19,
    defer_compile_nv = 5,
    rendering_fragment_density_map_attachment_ext = 22,
    rendering_fragment_shading_rate_attachment_khr = 21,
    capture_statistics_khr = 6,
    capture_internal_representations_khr = 7,
    indirect_bindable_nv = 18,
    library_khr = 11,
    descriptor_buffer_ext = 29,
    retain_link_time_optimization_info_ext = 23,
    link_time_optimization_ext = 10,
    ray_tracing_allow_motion_nv = 20,
    color_attachment_feedback_loop_ext = 25,
    depth_stencil_attachment_feedback_loop_ext = 26,
    ray_tracing_opacity_micromap_ext = 24,
    ray_tracing_displacement_micromap_nv = 28,
    _,
};
pub const PipelineCreateFlags = BitField(PipelineCreateFlagBits);
pub const ColorComponentFlagBits = enum(u5) {
    r = 0,
    g = 1,
    b = 2,
    a = 3,
    _,
};
pub const ColorComponentFlags = BitField(ColorComponentFlagBits);
pub const FenceCreateFlagBits = enum(u5) {
    signaled = 0,
    _,
};
pub const FenceCreateFlags = BitField(FenceCreateFlagBits);
pub const SemaphoreCreateFlagBits = enum(u5) {
    _,
};
pub const SemaphoreCreateFlags = BitField(SemaphoreCreateFlagBits);
pub const FormatFeatureFlagBits = enum(u5) {
    sampled_image = 0,
    storage_image = 1,
    storage_image_atomic = 2,
    uniform_texel_buffer = 3,
    storage_texel_buffer = 4,
    storage_texel_buffer_atomic = 5,
    vertex_buffer = 6,
    color_attachment = 7,
    color_attachment_blend = 8,
    depth_stencil_attachment = 9,
    blit_src = 10,
    blit_dst = 11,
    sampled_image_filter_linear = 12,
    transfer_src = 14,
    transfer_dst = 15,
    midpoint_chroma_samples = 17,
    sampled_image_ycbcr_conversion_linear_filter = 18,
    sampled_image_ycbcr_conversion_separate_reconstruction_filter = 19,
    sampled_image_ycbcr_conversion_chroma_reconstruction_explicit = 20,
    sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_forceable = 21,
    disjoint = 22,
    cosited_chroma_samples = 23,
    sampled_image_filter_minmax = 16,
    acceleration_structure_vertex_buffer_khr = 29,
    sampled_image_filter_cubic_ext = 13,
    fragment_density_map_ext = 24,
    fragment_shading_rate_attachment_khr = 30,
    _,
};
pub const FormatFeatureFlags = BitField(FormatFeatureFlagBits);
pub const QueryControlFlagBits = enum(u5) {
    precise = 0,
    _,
};
pub const QueryControlFlags = BitField(QueryControlFlagBits);
pub const QueryResultFlagBits = enum(u5) {
    @"64" = 0,
    wait = 1,
    with_availability = 2,
    partial = 3,
    _,
};
pub const QueryResultFlags = BitField(QueryResultFlagBits);
pub const ShaderModuleCreateFlagBits = enum(u5) {
    _,
};
pub const ShaderModuleCreateFlags = BitField(ShaderModuleCreateFlagBits);
pub const EventCreateFlagBits = enum(u5) {
    device_only = 0,
    _,
};
pub const EventCreateFlags = BitField(EventCreateFlagBits);
pub const CommandPoolCreateFlagBits = enum(u5) {
    transient = 0,
    reset_command_buffer = 1,
    protected = 2,
    _,
};
pub const CommandPoolCreateFlags = BitField(CommandPoolCreateFlagBits);
pub const CommandPoolResetFlagBits = enum(u5) {
    release_resources = 0,
    _,
};
pub const CommandPoolResetFlags = BitField(CommandPoolResetFlagBits);
pub const CommandBufferResetFlagBits = enum(u5) {
    release_resources = 0,
    _,
};
pub const CommandBufferResetFlags = BitField(CommandBufferResetFlagBits);
pub const CommandBufferUsageFlagBits = enum(u5) {
    one_time_submit = 0,
    render_pass_continue = 1,
    simultaneous_use = 2,
    _,
};
pub const CommandBufferUsageFlags = BitField(CommandBufferUsageFlagBits);
pub const QueryPipelineStatisticFlagBits = enum(u5) {
    input_assembly_vertices = 0,
    input_assembly_primitives = 1,
    vertex_shader_invocations = 2,
    geometry_shader_invocations = 3,
    geometry_shader_primitives = 4,
    clipping_invocations = 5,
    clipping_primitives = 6,
    fragment_shader_invocations = 7,
    tessellation_control_shader_patches = 8,
    tessellation_evaluation_shader_invocations = 9,
    compute_shader_invocations = 10,
    task_shader_invocations_ext = 11,
    mesh_shader_invocations_ext = 12,
    cluster_culling_shader_invocations_huawei = 13,
    _,
};
pub const QueryPipelineStatisticFlags = BitField(QueryPipelineStatisticFlagBits);
pub const MemoryMapFlagBits = enum(u5) {
    placed_ext = 0,
    _,
};
pub const MemoryMapFlags = BitField(MemoryMapFlagBits);
pub const MemoryUnmapFlagBits = enum(u5) {
    reserve_ext = 0,
    _,
};
pub const MemoryUnmapFlags = BitField(MemoryUnmapFlagBits);
pub const MemoryUnmapFlagsKHR = MemoryUnmapFlags;
pub const ImageAspectFlagBits = enum(u5) {
    color = 0,
    depth = 1,
    stencil = 2,
    metadata = 3,
    plane_0 = 4,
    plane_1 = 5,
    plane_2 = 6,
    memory_plane_0_ext = 7,
    memory_plane_1_ext = 8,
    memory_plane_2_ext = 9,
    memory_plane_3_ext = 10,
    _,
};
pub const ImageAspectFlags = BitField(ImageAspectFlagBits);
pub const ImageAspectFlagMasks = struct {
    pub const none = ImageAspectFlags{ .bits = 0x0 };
};
pub const SparseMemoryBindFlagBits = enum(u5) {
    metadata = 0,
    _,
};
pub const SparseMemoryBindFlags = BitField(SparseMemoryBindFlagBits);
pub const SparseImageFormatFlagBits = enum(u5) {
    single_miptail = 0,
    aligned_mip_size = 1,
    nonstandard_block_size = 2,
    _,
};
pub const SparseImageFormatFlags = BitField(SparseImageFormatFlagBits);
pub const SubpassDescriptionFlagBits = enum(u5) {
    per_view_attributes_nvx = 0,
    per_view_position_x_only_nvx = 1,
    fragment_region_qcom = 2,
    shader_resolve_qcom = 3,
    tile_shading_apron_qcom = 8,
    rasterization_order_attachment_color_access_ext = 4,
    rasterization_order_attachment_depth_access_ext = 5,
    rasterization_order_attachment_stencil_access_ext = 6,
    enable_legacy_dithering_ext = 7,
    _,
};
pub const SubpassDescriptionFlags = BitField(SubpassDescriptionFlagBits);
pub const PipelineStageFlagBits = enum(u5) {
    top_of_pipe = 0,
    draw_indirect = 1,
    vertex_input = 2,
    vertex_shader = 3,
    tessellation_control_shader = 4,
    tessellation_evaluation_shader = 5,
    geometry_shader = 6,
    fragment_shader = 7,
    early_fragment_tests = 8,
    late_fragment_tests = 9,
    color_attachment_output = 10,
    compute_shader = 11,
    transfer = 12,
    bottom_of_pipe = 13,
    host = 14,
    all_graphics = 15,
    all_commands = 16,
    transform_feedback_ext = 24,
    conditional_rendering_ext = 18,
    acceleration_structure_build_khr = 25,
    ray_tracing_shader_khr = 21,
    fragment_density_process_ext = 23,
    fragment_shading_rate_attachment_khr = 22,
    task_shader_ext = 19,
    mesh_shader_ext = 20,
    command_preprocess_ext = 17,
    _,
};
pub const PipelineStageFlags = BitField(PipelineStageFlagBits);
pub const PipelineStageFlagMasks = struct {
    pub const none = PipelineStageFlags{ .bits = 0x0 };
};
pub const SampleCountFlagBits = enum(u5) {
    @"1" = 0,
    @"2" = 1,
    @"4" = 2,
    @"8" = 3,
    @"16" = 4,
    @"32" = 5,
    @"64" = 6,
    _,
};
pub const SampleCountFlags = BitField(SampleCountFlagBits);
pub const AttachmentDescriptionFlagBits = enum(u5) {
    may_alias = 0,
    _,
};
pub const AttachmentDescriptionFlags = BitField(AttachmentDescriptionFlagBits);
pub const StencilFaceFlagBits = enum(u5) {
    front = 0,
    back = 1,
    _,
};
pub const StencilFaceFlags = BitField(StencilFaceFlagBits);
pub const StencilFaceFlagMasks = struct {
    pub const front_and_back = StencilFaceFlags{ .bits = 0x3 };
};
pub const CullModeFlagBits = enum(u5) {
    front = 0,
    back = 1,
    _,
};
pub const CullModeFlags = BitField(CullModeFlagBits);
pub const CullModeFlagMasks = struct {
    pub const none = CullModeFlags{ .bits = 0x0 };
    pub const front_and_back = CullModeFlags{ .bits = 0x3 };
};
pub const DescriptorPoolCreateFlagBits = enum(u5) {
    free_descriptor_set = 0,
    update_after_bind = 1,
    host_only_ext = 2,
    allow_overallocation_sets_nv = 3,
    allow_overallocation_pools_nv = 4,
    _,
};
pub const DescriptorPoolCreateFlags = BitField(DescriptorPoolCreateFlagBits);
pub const DescriptorPoolResetFlagBits = enum(u5) {
    _,
};
pub const DescriptorPoolResetFlags = BitField(DescriptorPoolResetFlagBits);
pub const DependencyFlagBits = enum(u5) {
    by_region = 0,
    device_group = 2,
    view_local = 1,
    feedback_loop_ext = 3,
    queue_family_ownership_transfer_use_all_stages_khr = 5,
    asymmetric_event_khr = 6,
    _,
};
pub const DependencyFlags = BitField(DependencyFlagBits);
pub const SubgroupFeatureFlagBits = enum(u5) {
    basic = 0,
    vote = 1,
    arithmetic = 2,
    ballot = 3,
    shuffle = 4,
    shuffle_relative = 5,
    clustered = 6,
    quad = 7,
    rotate = 9,
    rotate_clustered = 10,
    partitioned_nv = 8,
    _,
};
pub const SubgroupFeatureFlags = BitField(SubgroupFeatureFlagBits);
pub const IndirectCommandsLayoutUsageFlagBitsNV = enum(u5) {
    explicit_preprocess = 0,
    indexed_sequences = 1,
    unordered_sequences = 2,
    _,
};
pub const IndirectCommandsLayoutUsageFlagsNV = BitField(IndirectCommandsLayoutUsageFlagBitsNV);
pub const IndirectStateFlagBitsNV = enum(u5) {
    frontface = 0,
    _,
};
pub const IndirectStateFlagsNV = BitField(IndirectStateFlagBitsNV);
pub const GeometryFlagBitsKHR = enum(u5) {
    @"opaque" = 0,
    no_duplicate_any_hit_invocation = 1,
    _,
};
pub const GeometryFlagsKHR = BitField(GeometryFlagBitsKHR);
pub const GeometryFlagsNV = GeometryFlagsKHR;
pub const GeometryInstanceFlagBitsKHR = enum(u5) {
    triangle_facing_cull_disable = 0,
    triangle_flip_facing = 1,
    force_opaque = 2,
    force_no_opaque = 3,
    force_opacity_micromap_2_state_ext = 4,
    disable_opacity_micromaps_ext = 5,
    _,
};
pub const GeometryInstanceFlagsKHR = BitField(GeometryInstanceFlagBitsKHR);
pub const GeometryInstanceFlagsNV = GeometryInstanceFlagsKHR;
pub const ClusterAccelerationStructureGeometryFlagBitsNV = enum(u5) {
    cull_disable = 0,
    no_duplicate_anyhit_invocation = 1,
    @"opaque" = 2,
    _,
};
pub const ClusterAccelerationStructureGeometryFlagsNV = BitField(ClusterAccelerationStructureGeometryFlagBitsNV);
pub const ClusterAccelerationStructureClusterFlagBitsNV = enum(u5) {
    allow_disable_opacity_micromaps = 0,
    _,
};
pub const ClusterAccelerationStructureClusterFlagsNV = BitField(ClusterAccelerationStructureClusterFlagBitsNV);
pub const ClusterAccelerationStructureAddressResolutionFlagBitsNV = enum(u5) {
    indirected_dst_implicit_data = 0,
    indirected_scratch_data = 1,
    indirected_dst_address_array = 2,
    indirected_dst_sizes_array = 3,
    indirected_src_infos_array = 4,
    indirected_src_infos_count = 5,
    _,
};
pub const ClusterAccelerationStructureAddressResolutionFlagsNV = BitField(ClusterAccelerationStructureAddressResolutionFlagBitsNV);
pub const ClusterAccelerationStructureAddressResolutionFlagMasksNV = struct {
    pub const none = ClusterAccelerationStructureAddressResolutionFlagsNV{ .bits = 0x0 };
};
pub const BuildAccelerationStructureFlagBitsKHR = enum(u5) {
    allow_update = 0,
    allow_compaction = 1,
    prefer_fast_trace = 2,
    prefer_fast_build = 3,
    low_memory = 4,
    motion_nv = 5,
    allow_opacity_micromap_update_ext = 6,
    allow_disable_opacity_micromaps_ext = 7,
    allow_opacity_micromap_data_update_ext = 8,
    allow_displacement_micromap_update_nv = 9,
    allow_data_access = 11,
    allow_cluster_opacity_micromaps_nv = 12,
    _,
};
pub const BuildAccelerationStructureFlagsKHR = BitField(BuildAccelerationStructureFlagBitsKHR);
pub const BuildAccelerationStructureFlagsNV = BuildAccelerationStructureFlagsKHR;
pub const PrivateDataSlotCreateFlagBits = enum(u5) {
    _,
};
pub const PrivateDataSlotCreateFlags = BitField(PrivateDataSlotCreateFlagBits);
pub const PrivateDataSlotCreateFlagsEXT = PrivateDataSlotCreateFlags;
pub const AccelerationStructureCreateFlagBitsKHR = enum(u5) {
    device_address_capture_replay = 0,
    descriptor_buffer_capture_replay_ext = 3,
    motion_nv = 2,
    _,
};
pub const AccelerationStructureCreateFlagsKHR = BitField(AccelerationStructureCreateFlagBitsKHR);
pub const DescriptorUpdateTemplateCreateFlagBits = enum(u5) {
    _,
};
pub const DescriptorUpdateTemplateCreateFlags = BitField(DescriptorUpdateTemplateCreateFlagBits);
pub const DescriptorUpdateTemplateCreateFlagsKHR = DescriptorUpdateTemplateCreateFlags;
pub const PipelineCreationFeedbackFlagBits = enum(u5) {
    valid = 0,
    application_pipeline_cache_hit = 1,
    base_pipeline_acceleration = 2,
    _,
};
pub const PipelineCreationFeedbackFlags = BitField(PipelineCreationFeedbackFlagBits);
pub const PipelineCreationFeedbackFlagsEXT = PipelineCreationFeedbackFlags;
pub const PerformanceCounterDescriptionFlagBitsKHR = enum(u5) {
    performance_impacting = 0,
    concurrently_impacted = 1,
    _,
};
pub const PerformanceCounterDescriptionFlagsKHR = BitField(PerformanceCounterDescriptionFlagBitsKHR);
pub const AcquireProfilingLockFlagBitsKHR = enum(u5) {
    _,
};
pub const AcquireProfilingLockFlagsKHR = BitField(AcquireProfilingLockFlagBitsKHR);
pub const SemaphoreWaitFlagBits = enum(u5) {
    any = 0,
    _,
};
pub const SemaphoreWaitFlags = BitField(SemaphoreWaitFlagBits);
pub const SemaphoreWaitFlagsKHR = SemaphoreWaitFlags;
pub const PipelineCompilerControlFlagBitsAMD = enum(u5) {
    _,
};
pub const PipelineCompilerControlFlagsAMD = BitField(PipelineCompilerControlFlagBitsAMD);
pub const ShaderCorePropertiesFlagBitsAMD = enum(u5) {
    _,
};
pub const ShaderCorePropertiesFlagsAMD = BitField(ShaderCorePropertiesFlagBitsAMD);
pub const DeviceDiagnosticsConfigFlagBitsNV = enum(u5) {
    enable_shader_debug_info = 0,
    enable_resource_tracking = 1,
    enable_automatic_checkpoints = 2,
    enable_shader_error_reporting = 3,
    _,
};
pub const DeviceDiagnosticsConfigFlagsNV = BitField(DeviceDiagnosticsConfigFlagBitsNV);
pub const AccessFlagBits2 = enum(u6) {
    indirect_command_read = 0,
    index_read = 1,
    vertex_attribute_read = 2,
    uniform_read = 3,
    input_attachment_read = 4,
    shader_read = 5,
    shader_write = 6,
    color_attachment_read = 7,
    color_attachment_write = 8,
    depth_stencil_attachment_read = 9,
    depth_stencil_attachment_write = 10,
    transfer_read = 11,
    transfer_write = 12,
    host_read = 13,
    host_write = 14,
    memory_read = 15,
    memory_write = 16,
    shader_sampled_read = 32,
    shader_storage_read = 33,
    shader_storage_write = 34,
    shader_tile_attachment_read_qcom = 51,
    shader_tile_attachment_write_qcom = 52,
    transform_feedback_write_ext = 25,
    transform_feedback_counter_read_ext = 26,
    transform_feedback_counter_write_ext = 27,
    conditional_rendering_read_ext = 20,
    command_preprocess_read_ext = 17,
    command_preprocess_write_ext = 18,
    fragment_shading_rate_attachment_read_khr = 23,
    acceleration_structure_read_khr = 21,
    acceleration_structure_write_khr = 22,
    fragment_density_map_read_ext = 24,
    color_attachment_read_noncoherent_ext = 19,
    descriptor_buffer_read_ext = 41,
    invocation_mask_read_huawei = 39,
    shader_binding_table_read_khr = 40,
    micromap_read_ext = 44,
    micromap_write_ext = 45,
    optical_flow_read_nv = 42,
    optical_flow_write_nv = 43,
    data_graph_read_arm = 47,
    data_graph_write_arm = 48,
    _,
};
pub const AccessFlags2 = BitField(AccessFlagBits2);
pub const AccessFlagMasks2 = struct {
    pub const none = AccessFlags2{ .bits = 0x0 };
};
pub const AccessFlags2KHR = AccessFlags2;
pub const PipelineStageFlagBits2 = enum(u6) {
    top_of_pipe = 0,
    draw_indirect = 1,
    vertex_input = 2,
    vertex_shader = 3,
    tessellation_control_shader = 4,
    tessellation_evaluation_shader = 5,
    geometry_shader = 6,
    fragment_shader = 7,
    early_fragment_tests = 8,
    late_fragment_tests = 9,
    color_attachment_output = 10,
    compute_shader = 11,
    all_transfer = 12,
    bottom_of_pipe = 13,
    host = 14,
    all_graphics = 15,
    all_commands = 16,
    copy = 32,
    resolve = 33,
    blit = 34,
    clear = 35,
    index_input = 36,
    vertex_attribute_input = 37,
    pre_rasterization_shaders = 38,
    transform_feedback_ext = 24,
    conditional_rendering_ext = 18,
    command_preprocess_ext = 17,
    fragment_shading_rate_attachment_khr = 22,
    acceleration_structure_build_khr = 25,
    ray_tracing_shader_khr = 21,
    fragment_density_process_ext = 23,
    task_shader_ext = 19,
    mesh_shader_ext = 20,
    subpass_shader_huawei = 39,
    invocation_mask_huawei = 40,
    acceleration_structure_copy_khr = 28,
    micromap_build_ext = 30,
    cluster_culling_shader_huawei = 41,
    optical_flow_nv = 29,
    convert_cooperative_vector_matrix_nv = 44,
    data_graph_arm = 42,
    _,
};
pub const PipelineStageFlags2 = BitField(PipelineStageFlagBits2);
pub const PipelineStageFlagMasks2 = struct {
    pub const none = PipelineStageFlags2{ .bits = 0x0 };
};
pub const PipelineStageFlags2KHR = PipelineStageFlags2;
pub const AccelerationStructureMotionInfoFlagBitsNV = enum(u5) {
    _,
};
pub const AccelerationStructureMotionInfoFlagsNV = BitField(AccelerationStructureMotionInfoFlagBitsNV);
pub const AccelerationStructureMotionInstanceFlagBitsNV = enum(u5) {
    _,
};
pub const AccelerationStructureMotionInstanceFlagsNV = BitField(AccelerationStructureMotionInstanceFlagBitsNV);
pub const FormatFeatureFlagBits2 = enum(u6) {
    sampled_image = 0,
    storage_image = 1,
    storage_image_atomic = 2,
    uniform_texel_buffer = 3,
    storage_texel_buffer = 4,
    storage_texel_buffer_atomic = 5,
    vertex_buffer = 6,
    color_attachment = 7,
    color_attachment_blend = 8,
    depth_stencil_attachment = 9,
    blit_src = 10,
    blit_dst = 11,
    sampled_image_filter_linear = 12,
    transfer_src = 14,
    transfer_dst = 15,
    sampled_image_filter_minmax = 16,
    midpoint_chroma_samples = 17,
    sampled_image_ycbcr_conversion_linear_filter = 18,
    sampled_image_ycbcr_conversion_separate_reconstruction_filter = 19,
    sampled_image_ycbcr_conversion_chroma_reconstruction_explicit = 20,
    sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_forceable = 21,
    disjoint = 22,
    cosited_chroma_samples = 23,
    storage_read_without_format = 31,
    storage_write_without_format = 32,
    sampled_image_depth_comparison = 33,
    sampled_image_filter_cubic = 13,
    host_image_transfer = 46,
    acceleration_structure_vertex_buffer_khr = 29,
    fragment_density_map_ext = 24,
    fragment_shading_rate_attachment_khr = 30,
    acceleration_structure_radius_buffer_nv = 51,
    linear_color_attachment_nv = 38,
    weight_image_qcom = 34,
    weight_sampled_image_qcom = 35,
    block_matching_qcom = 36,
    box_filter_sampled_qcom = 37,
    tensor_shader_arm = 39,
    tensor_image_aliasing_arm = 43,
    optical_flow_image_nv = 40,
    optical_flow_vector_nv = 41,
    optical_flow_cost_nv = 42,
    tensor_data_graph_arm = 48,
    _,
};
pub const FormatFeatureFlags2 = BitField(FormatFeatureFlagBits2);
pub const FormatFeatureFlags2KHR = FormatFeatureFlags2;
pub const RenderingFlagBits = enum(u5) {
    contents_secondary_command_buffers = 0,
    suspending = 1,
    resuming = 2,
    enable_legacy_dithering_ext = 3,
    contents_inline_khr = 4,
    per_layer_fragment_density_valve = 5,
    _,
};
pub const RenderingFlags = BitField(RenderingFlagBits);
pub const MemoryDecompressionMethodFlagBitsNV = enum(u6) {
    gdeflate_1_0 = 0,
    _,
};
pub const MemoryDecompressionMethodFlagsNV = BitField(MemoryDecompressionMethodFlagBitsNV);
pub const RenderingFlagsKHR = RenderingFlags;
pub const BuildMicromapFlagBitsEXT = enum(u5) {
    prefer_fast_trace = 0,
    prefer_fast_build = 1,
    allow_compaction = 2,
    _,
};
pub const BuildMicromapFlagsEXT = BitField(BuildMicromapFlagBitsEXT);
pub const MicromapCreateFlagBitsEXT = enum(u5) {
    device_address_capture_replay = 0,
    _,
};
pub const MicromapCreateFlagsEXT = BitField(MicromapCreateFlagBitsEXT);
pub const IndirectCommandsLayoutUsageFlagBitsEXT = enum(u5) {
    explicit_preprocess = 0,
    unordered_sequences = 1,
    _,
};
pub const IndirectCommandsLayoutUsageFlagsEXT = BitField(IndirectCommandsLayoutUsageFlagBitsEXT);
pub const IndirectCommandsInputModeFlagBitsEXT = enum(u5) {
    vulkan_index_buffer = 0,
    dxgi_index_buffer = 1,
    _,
};
pub const IndirectCommandsInputModeFlagsEXT = BitField(IndirectCommandsInputModeFlagBitsEXT);
pub const DirectDriverLoadingFlagBitsLUNARG = enum(u5) {
    _,
};
pub const DirectDriverLoadingFlagsLUNARG = BitField(DirectDriverLoadingFlagBitsLUNARG);
pub const PipelineCreateFlagBits2 = enum(u6) {
    disable_optimization = 0,
    allow_derivatives = 1,
    derivative = 2,
    view_index_from_device_index = 3,
    dispatch_base = 4,
    fail_on_pipeline_compile_required = 8,
    early_return_on_failure = 9,
    no_protected_access = 27,
    protected_access_only = 30,
    execution_graph_amdx = 32,
    ray_tracing_allow_spheres_and_linear_swept_spheres_nv = 33,
    enable_legacy_dithering_ext = 34,
    defer_compile_nv = 5,
    capture_statistics_khr = 6,
    capture_internal_representations_khr = 7,
    link_time_optimization_ext = 10,
    retain_link_time_optimization_info_ext = 23,
    library_khr = 11,
    ray_tracing_skip_triangles_khr = 12,
    ray_tracing_skip_aabbs_khr = 13,
    ray_tracing_no_null_any_hit_shaders_khr = 14,
    ray_tracing_no_null_closest_hit_shaders_khr = 15,
    ray_tracing_no_null_miss_shaders_khr = 16,
    ray_tracing_no_null_intersection_shaders_khr = 17,
    ray_tracing_shader_group_handle_capture_replay_khr = 19,
    indirect_bindable_nv = 18,
    ray_tracing_allow_motion_nv = 20,
    rendering_fragment_shading_rate_attachment_khr = 21,
    rendering_fragment_density_map_attachment_ext = 22,
    ray_tracing_opacity_micromap_ext = 24,
    color_attachment_feedback_loop_ext = 25,
    depth_stencil_attachment_feedback_loop_ext = 26,
    ray_tracing_displacement_micromap_nv = 28,
    descriptor_buffer_ext = 29,
    disallow_opacity_micromap_arm = 37,
    capture_data_khr = 31,
    indirect_bindable_ext = 38,
    per_layer_fragment_density_valve = 40,
    _,
};
pub const PipelineCreateFlags2 = BitField(PipelineCreateFlagBits2);
pub const PipelineCreateFlags2KHR = PipelineCreateFlags2;
pub const BufferUsageFlagBits2 = enum(u6) {
    transfer_src = 0,
    transfer_dst = 1,
    uniform_texel_buffer = 2,
    storage_texel_buffer = 3,
    uniform_buffer = 4,
    storage_buffer = 5,
    index_buffer = 6,
    vertex_buffer = 7,
    indirect_buffer = 8,
    shader_device_address = 17,
    execution_graph_scratch_amdx = 25,
    conditional_rendering_ext = 9,
    shader_binding_table_khr = 10,
    transform_feedback_buffer_ext = 11,
    transform_feedback_counter_buffer_ext = 12,
    acceleration_structure_build_input_read_only_khr = 19,
    acceleration_structure_storage_khr = 20,
    sampler_descriptor_buffer_ext = 21,
    resource_descriptor_buffer_ext = 22,
    push_descriptors_descriptor_buffer_ext = 26,
    micromap_build_input_read_only_ext = 23,
    micromap_storage_ext = 24,
    compressed_data_dgf1_amdx = 33,
    data_graph_foreign_descriptor_arm = 29,
    tile_memory_qcom = 27,
    preprocess_buffer_ext = 31,
    _,
};
pub const BufferUsageFlags2 = BitField(BufferUsageFlagBits2);
pub const BufferUsageFlags2KHR = BufferUsageFlags2;
pub const TensorCreateFlagBitsARM = enum(u6) {
    mutable_format = 0,
    protected = 1,
    descriptor_buffer_capture_replay = 2,
    _,
};
pub const TensorCreateFlagsARM = BitField(TensorCreateFlagBitsARM);
pub const TensorUsageFlagBitsARM = enum(u6) {
    shader = 1,
    transfer_src = 2,
    transfer_dst = 3,
    image_aliasing = 4,
    data_graph = 5,
    _,
};
pub const TensorUsageFlagsARM = BitField(TensorUsageFlagBitsARM);
pub const TensorViewCreateFlagBitsARM = enum(u6) {
    descriptor_buffer_capture_replay = 0,
    _,
};
pub const TensorViewCreateFlagsARM = BitField(TensorViewCreateFlagBitsARM);
pub const DataGraphPipelineSessionCreateFlagBitsARM = enum(u6) {
    protected = 0,
    _,
};
pub const DataGraphPipelineSessionCreateFlagsARM = BitField(DataGraphPipelineSessionCreateFlagBitsARM);
pub const DataGraphPipelineDispatchFlagBitsARM = enum(u6) {
    _,
};
pub const DataGraphPipelineDispatchFlagsARM = BitField(DataGraphPipelineDispatchFlagBitsARM);
pub const CompositeAlphaFlagBitsKHR = enum(u5) {
    @"opaque" = 0,
    pre_multiplied = 1,
    post_multiplied = 2,
    inherit = 3,
    _,
};
pub const CompositeAlphaFlagsKHR = BitField(CompositeAlphaFlagBitsKHR);
pub const DisplayPlaneAlphaFlagBitsKHR = enum(u5) {
    @"opaque" = 0,
    global = 1,
    per_pixel = 2,
    per_pixel_premultiplied = 3,
    _,
};
pub const DisplayPlaneAlphaFlagsKHR = BitField(DisplayPlaneAlphaFlagBitsKHR);
pub const SurfaceTransformFlagBitsKHR = enum(u5) {
    identity = 0,
    rotate_90 = 1,
    rotate_180 = 2,
    rotate_270 = 3,
    horizontal_mirror = 4,
    horizontal_mirror_rotate_90 = 5,
    horizontal_mirror_rotate_180 = 6,
    horizontal_mirror_rotate_270 = 7,
    inherit = 8,
    _,
};
pub const SurfaceTransformFlagsKHR = BitField(SurfaceTransformFlagBitsKHR);
pub const SwapchainCreateFlagBitsKHR = enum(u5) {
    split_instance_bind_regions = 0,
    protected = 1,
    mutable_format = 2,
    present_id_2 = 6,
    present_wait_2 = 7,
    deferred_memory_allocation = 3,
    _,
};
pub const SwapchainCreateFlagsKHR = BitField(SwapchainCreateFlagBitsKHR);
pub const DisplayModeCreateFlagBitsKHR = enum(u5) {
    _,
};
pub const DisplayModeCreateFlagsKHR = BitField(DisplayModeCreateFlagBitsKHR);
pub const DisplaySurfaceCreateFlagBitsKHR = enum(u5) {
    _,
};
pub const DisplaySurfaceCreateFlagsKHR = BitField(DisplaySurfaceCreateFlagBitsKHR);
pub const AndroidSurfaceCreateFlagBitsKHR = enum(u5) {
    _,
};
pub const AndroidSurfaceCreateFlagsKHR = BitField(AndroidSurfaceCreateFlagBitsKHR);
pub const ViSurfaceCreateFlagBitsNN = enum(u5) {
    _,
};
pub const ViSurfaceCreateFlagsNN = BitField(ViSurfaceCreateFlagBitsNN);
pub const WaylandSurfaceCreateFlagBitsKHR = enum(u5) {
    _,
};
pub const WaylandSurfaceCreateFlagsKHR = BitField(WaylandSurfaceCreateFlagBitsKHR);
pub const Win32SurfaceCreateFlagBitsKHR = enum(u5) {
    _,
};
pub const Win32SurfaceCreateFlagsKHR = BitField(Win32SurfaceCreateFlagBitsKHR);
pub const XlibSurfaceCreateFlagBitsKHR = enum(u5) {
    _,
};
pub const XlibSurfaceCreateFlagsKHR = BitField(XlibSurfaceCreateFlagBitsKHR);
pub const XcbSurfaceCreateFlagBitsKHR = enum(u5) {
    _,
};
pub const XcbSurfaceCreateFlagsKHR = BitField(XcbSurfaceCreateFlagBitsKHR);
pub const DirectFBSurfaceCreateFlagBitsEXT = enum(u5) {
    _,
};
pub const DirectFBSurfaceCreateFlagsEXT = BitField(DirectFBSurfaceCreateFlagBitsEXT);
pub const IOSSurfaceCreateFlagBitsMVK = enum(u5) {
    _,
};
pub const IOSSurfaceCreateFlagsMVK = BitField(IOSSurfaceCreateFlagBitsMVK);
pub const MacOSSurfaceCreateFlagBitsMVK = enum(u5) {
    _,
};
pub const MacOSSurfaceCreateFlagsMVK = BitField(MacOSSurfaceCreateFlagBitsMVK);
pub const MetalSurfaceCreateFlagBitsEXT = enum(u5) {
    _,
};
pub const MetalSurfaceCreateFlagsEXT = BitField(MetalSurfaceCreateFlagBitsEXT);
pub const ImagePipeSurfaceCreateFlagBitsFUCHSIA = enum(u5) {
    _,
};
pub const ImagePipeSurfaceCreateFlagsFUCHSIA = BitField(ImagePipeSurfaceCreateFlagBitsFUCHSIA);
pub const HeadlessSurfaceCreateFlagBitsEXT = enum(u5) {
    _,
};
pub const HeadlessSurfaceCreateFlagsEXT = BitField(HeadlessSurfaceCreateFlagBitsEXT);
pub const PeerMemoryFeatureFlagBits = enum(u5) {
    copy_src = 0,
    copy_dst = 1,
    generic_src = 2,
    generic_dst = 3,
    _,
};
pub const PeerMemoryFeatureFlags = BitField(PeerMemoryFeatureFlagBits);
pub const PeerMemoryFeatureFlagsKHR = PeerMemoryFeatureFlags;
pub const MemoryAllocateFlagBits = enum(u5) {
    device_mask = 0,
    device_address = 1,
    device_address_capture_replay = 2,
    zero_initialize_ext = 3,
    _,
};
pub const MemoryAllocateFlags = BitField(MemoryAllocateFlagBits);
pub const MemoryAllocateFlagsKHR = MemoryAllocateFlags;
pub const DeviceGroupPresentModeFlagBitsKHR = enum(u5) {
    local = 0,
    remote = 1,
    sum = 2,
    local_multi_device = 3,
    _,
};
pub const DeviceGroupPresentModeFlagsKHR = BitField(DeviceGroupPresentModeFlagBitsKHR);
pub const DebugReportFlagBitsEXT = enum(u5) {
    information = 0,
    warning = 1,
    performance_warning = 2,
    @"error" = 3,
    debug = 4,
    _,
};
pub const DebugReportFlagsEXT = BitField(DebugReportFlagBitsEXT);
pub const CommandPoolTrimFlagBits = enum(u5) {
    _,
};
pub const CommandPoolTrimFlags = BitField(CommandPoolTrimFlagBits);
pub const CommandPoolTrimFlagsKHR = CommandPoolTrimFlags;
pub const ExternalMemoryHandleTypeFlagBitsNV = enum(u5) {
    opaque_win32 = 0,
    opaque_win32_kmt = 1,
    d3d11_image = 2,
    d3d11_image_kmt = 3,
    _,
};
pub const ExternalMemoryHandleTypeFlagsNV = BitField(ExternalMemoryHandleTypeFlagBitsNV);
pub const ClusterAccelerationStructureIndexFormatFlagBitsNV = enum(u5) {
    @"8bit" = 0,
    @"16bit" = 1,
    @"32bit" = 2,
    _,
};
pub const ClusterAccelerationStructureIndexFormatFlagsNV = BitField(ClusterAccelerationStructureIndexFormatFlagBitsNV);
pub const ExternalMemoryFeatureFlagBitsNV = enum(u5) {
    dedicated_only = 0,
    exportable = 1,
    importable = 2,
    _,
};
pub const ExternalMemoryFeatureFlagsNV = BitField(ExternalMemoryFeatureFlagBitsNV);
pub const ExternalMemoryHandleTypeFlagBits = enum(u5) {
    opaque_fd = 0,
    opaque_win32 = 1,
    opaque_win32_kmt = 2,
    d3d11_texture = 3,
    d3d11_texture_kmt = 4,
    d3d12_heap = 5,
    d3d12_resource = 6,
    dma_buf_ext = 9,
    android_hardware_buffer_android = 10,
    host_allocation_ext = 7,
    host_mapped_foreign_memory_ext = 8,
    zircon_vmo_fuchsia = 11,
    rdma_address_nv = 12,
    mtlbuffer_ext = 16,
    mtltexture_ext = 17,
    mtlheap_ext = 18,
    _,
};
pub const ExternalMemoryHandleTypeFlags = BitField(ExternalMemoryHandleTypeFlagBits);
pub const ExternalMemoryHandleTypeFlagsKHR = ExternalMemoryHandleTypeFlags;
pub const ExternalMemoryFeatureFlagBits = enum(u5) {
    dedicated_only = 0,
    exportable = 1,
    importable = 2,
    _,
};
pub const ExternalMemoryFeatureFlags = BitField(ExternalMemoryFeatureFlagBits);
pub const ExternalMemoryFeatureFlagsKHR = ExternalMemoryFeatureFlags;
pub const ExternalSemaphoreHandleTypeFlagBits = enum(u5) {
    opaque_fd = 0,
    opaque_win32 = 1,
    opaque_win32_kmt = 2,
    d3d12_fence = 3,
    sync_fd = 4,
    zircon_event_fuchsia = 7,
    _,
};
pub const ExternalSemaphoreHandleTypeFlags = BitField(ExternalSemaphoreHandleTypeFlagBits);
pub const ExternalSemaphoreHandleTypeFlagsKHR = ExternalSemaphoreHandleTypeFlags;
pub const ExternalSemaphoreFeatureFlagBits = enum(u5) {
    exportable = 0,
    importable = 1,
    _,
};
pub const ExternalSemaphoreFeatureFlags = BitField(ExternalSemaphoreFeatureFlagBits);
pub const ExternalSemaphoreFeatureFlagsKHR = ExternalSemaphoreFeatureFlags;
pub const SemaphoreImportFlagBits = enum(u5) {
    temporary = 0,
    _,
};
pub const SemaphoreImportFlags = BitField(SemaphoreImportFlagBits);
pub const SemaphoreImportFlagsKHR = SemaphoreImportFlags;
pub const ExternalFenceHandleTypeFlagBits = enum(u5) {
    opaque_fd = 0,
    opaque_win32 = 1,
    opaque_win32_kmt = 2,
    sync_fd = 3,
    _,
};
pub const ExternalFenceHandleTypeFlags = BitField(ExternalFenceHandleTypeFlagBits);
pub const ExternalFenceHandleTypeFlagsKHR = ExternalFenceHandleTypeFlags;
pub const ExternalFenceFeatureFlagBits = enum(u5) {
    exportable = 0,
    importable = 1,
    _,
};
pub const ExternalFenceFeatureFlags = BitField(ExternalFenceFeatureFlagBits);
pub const ExternalFenceFeatureFlagsKHR = ExternalFenceFeatureFlags;
pub const FenceImportFlagBits = enum(u5) {
    temporary = 0,
    _,
};
pub const FenceImportFlags = BitField(FenceImportFlagBits);
pub const FenceImportFlagsKHR = FenceImportFlags;
pub const SurfaceCounterFlagBitsEXT = enum(u5) {
    vblank = 0,
    _,
};
pub const SurfaceCounterFlagsEXT = BitField(SurfaceCounterFlagBitsEXT);
pub const PipelineViewportSwizzleStateCreateFlagBitsNV = enum(u5) {
    _,
};
pub const PipelineViewportSwizzleStateCreateFlagsNV = BitField(PipelineViewportSwizzleStateCreateFlagBitsNV);
pub const PipelineDiscardRectangleStateCreateFlagBitsEXT = enum(u5) {
    _,
};
pub const PipelineDiscardRectangleStateCreateFlagsEXT = BitField(PipelineDiscardRectangleStateCreateFlagBitsEXT);
pub const PipelineCoverageToColorStateCreateFlagBitsNV = enum(u5) {
    _,
};
pub const PipelineCoverageToColorStateCreateFlagsNV = BitField(PipelineCoverageToColorStateCreateFlagBitsNV);
pub const PipelineCoverageModulationStateCreateFlagBitsNV = enum(u5) {
    _,
};
pub const PipelineCoverageModulationStateCreateFlagsNV = BitField(PipelineCoverageModulationStateCreateFlagBitsNV);
pub const PipelineCoverageReductionStateCreateFlagBitsNV = enum(u5) {
    _,
};
pub const PipelineCoverageReductionStateCreateFlagsNV = BitField(PipelineCoverageReductionStateCreateFlagBitsNV);
pub const ValidationCacheCreateFlagBitsEXT = enum(u5) {
    _,
};
pub const ValidationCacheCreateFlagsEXT = BitField(ValidationCacheCreateFlagBitsEXT);
pub const DebugUtilsMessageSeverityFlagBitsEXT = enum(u5) {
    verbose = 0,
    info = 4,
    warning = 8,
    @"error" = 12,
    _,
};
pub const DebugUtilsMessageSeverityFlagsEXT = BitField(DebugUtilsMessageSeverityFlagBitsEXT);
pub const DebugUtilsMessageTypeFlagBitsEXT = enum(u5) {
    general = 0,
    validation = 1,
    performance = 2,
    device_address_binding = 3,
    _,
};
pub const DebugUtilsMessageTypeFlagsEXT = BitField(DebugUtilsMessageTypeFlagBitsEXT);
pub const DebugUtilsMessengerCreateFlagBitsEXT = enum(u5) {
    _,
};
pub const DebugUtilsMessengerCreateFlagsEXT = BitField(DebugUtilsMessengerCreateFlagBitsEXT);
pub const DebugUtilsMessengerCallbackDataFlagBitsEXT = enum(u5) {
    _,
};
pub const DebugUtilsMessengerCallbackDataFlagsEXT = BitField(DebugUtilsMessengerCallbackDataFlagBitsEXT);
pub const DeviceMemoryReportFlagBitsEXT = enum(u5) {
    _,
};
pub const DeviceMemoryReportFlagsEXT = BitField(DeviceMemoryReportFlagBitsEXT);
pub const PipelineRasterizationConservativeStateCreateFlagBitsEXT = enum(u5) {
    _,
};
pub const PipelineRasterizationConservativeStateCreateFlagsEXT = BitField(PipelineRasterizationConservativeStateCreateFlagBitsEXT);
pub const DescriptorBindingFlagBits = enum(u5) {
    update_after_bind = 0,
    update_unused_while_pending = 1,
    partially_bound = 2,
    variable_descriptor_count = 3,
    _,
};
pub const DescriptorBindingFlags = BitField(DescriptorBindingFlagBits);
pub const DescriptorBindingFlagsEXT = DescriptorBindingFlags;
pub const ConditionalRenderingFlagBitsEXT = enum(u5) {
    inverted = 0,
    _,
};
pub const ConditionalRenderingFlagsEXT = BitField(ConditionalRenderingFlagBitsEXT);
pub const ResolveModeFlagBits = enum(u5) {
    sample_zero = 0,
    average = 1,
    min = 2,
    max = 3,
    external_format_downsample_android = 4,
    _,
};
pub const ResolveModeFlags = BitField(ResolveModeFlagBits);
pub const ResolveModeFlagMasks = struct {
    pub const none = ResolveModeFlags{ .bits = 0x0 };
};
pub const ResolveModeFlagsKHR = ResolveModeFlags;
pub const PipelineRasterizationStateStreamCreateFlagBitsEXT = enum(u5) {
    _,
};
pub const PipelineRasterizationStateStreamCreateFlagsEXT = BitField(PipelineRasterizationStateStreamCreateFlagBitsEXT);
pub const PipelineRasterizationDepthClipStateCreateFlagBitsEXT = enum(u5) {
    _,
};
pub const PipelineRasterizationDepthClipStateCreateFlagsEXT = BitField(PipelineRasterizationDepthClipStateCreateFlagBitsEXT);
pub const ToolPurposeFlagBits = enum(u5) {
    validation = 0,
    profiling = 1,
    tracing = 2,
    additional_features = 3,
    modifying_features = 4,
    debug_reporting_ext = 5,
    debug_markers_ext = 6,
    _,
};
pub const ToolPurposeFlags = BitField(ToolPurposeFlagBits);
pub const ToolPurposeFlagsEXT = ToolPurposeFlags;
pub const SubmitFlagBits = enum(u5) {
    protected = 0,
    _,
};
pub const SubmitFlags = BitField(SubmitFlagBits);
pub const SubmitFlagsKHR = SubmitFlags;
pub const ImageFormatConstraintsFlagBitsFUCHSIA = enum(u5) {
    _,
};
pub const ImageFormatConstraintsFlagsFUCHSIA = BitField(ImageFormatConstraintsFlagBitsFUCHSIA);
pub const HostImageCopyFlagBits = enum(u5) {
    memcpy = 0,
    _,
};
pub const HostImageCopyFlags = BitField(HostImageCopyFlagBits);
pub const HostImageCopyFlagsEXT = HostImageCopyFlags;
pub const PartitionedAccelerationStructureInstanceFlagBitsNV = enum(u5) {
    triangle_facing_cull_disable = 0,
    triangle_flip_facing = 1,
    force_opaque = 2,
    force_no_opaque = 3,
    enable_explicit_bounding_box = 4,
    _,
};
pub const PartitionedAccelerationStructureInstanceFlagsNV = BitField(PartitionedAccelerationStructureInstanceFlagBitsNV);
pub const ImageConstraintsInfoFlagBitsFUCHSIA = enum(u5) {
    cpu_read_rarely = 0,
    cpu_read_often = 1,
    cpu_write_rarely = 2,
    cpu_write_often = 3,
    protected_optional = 4,
    _,
};
pub const ImageConstraintsInfoFlagsFUCHSIA = BitField(ImageConstraintsInfoFlagBitsFUCHSIA);
pub const GraphicsPipelineLibraryFlagBitsEXT = enum(u5) {
    vertex_input_interface = 0,
    pre_rasterization_shaders = 1,
    fragment_shader = 2,
    fragment_output_interface = 3,
    _,
};
pub const GraphicsPipelineLibraryFlagsEXT = BitField(GraphicsPipelineLibraryFlagBitsEXT);
pub const ImageCompressionFlagBitsEXT = enum(u5) {
    fixed_rate_default = 0,
    fixed_rate_explicit = 1,
    disabled = 2,
    _,
};
pub const ImageCompressionFlagsEXT = BitField(ImageCompressionFlagBitsEXT);
pub const ImageCompressionFlagMasksEXT = struct {
    pub const default = ImageCompressionFlagsEXT{ .bits = 0x0 };
};
pub const ImageCompressionFixedRateFlagBitsEXT = enum(u5) {
    @"1bpc" = 0,
    @"2bpc" = 1,
    @"3bpc" = 2,
    @"4bpc" = 3,
    @"5bpc" = 4,
    @"6bpc" = 5,
    @"7bpc" = 6,
    @"8bpc" = 7,
    @"9bpc" = 8,
    @"10bpc" = 9,
    @"11bpc" = 10,
    @"12bpc" = 11,
    @"13bpc" = 12,
    @"14bpc" = 13,
    @"15bpc" = 14,
    @"16bpc" = 15,
    @"17bpc" = 16,
    @"18bpc" = 17,
    @"19bpc" = 18,
    @"20bpc" = 19,
    @"21bpc" = 20,
    @"22bpc" = 21,
    @"23bpc" = 22,
    @"24bpc" = 23,
    _,
};
pub const ImageCompressionFixedRateFlagsEXT = BitField(ImageCompressionFixedRateFlagBitsEXT);
pub const ImageCompressionFixedRateFlagMasksEXT = struct {
    pub const none = ImageCompressionFixedRateFlagsEXT{ .bits = 0x0 };
};
pub const ExportMetalObjectTypeFlagBitsEXT = enum(u5) {
    metal_device = 0,
    metal_command_queue = 1,
    metal_buffer = 2,
    metal_texture = 3,
    metal_iosurface = 4,
    metal_shared_event = 5,
    _,
};
pub const ExportMetalObjectTypeFlagsEXT = BitField(ExportMetalObjectTypeFlagBitsEXT);
pub const DeviceAddressBindingFlagBitsEXT = enum(u5) {
    internal_object = 0,
    _,
};
pub const DeviceAddressBindingFlagsEXT = BitField(DeviceAddressBindingFlagBitsEXT);
pub const OpticalFlowGridSizeFlagBitsNV = enum(u5) {
    @"1x1" = 0,
    @"2x2" = 1,
    @"4x4" = 2,
    @"8x8" = 3,
    _,
};
pub const OpticalFlowGridSizeFlagsNV = BitField(OpticalFlowGridSizeFlagBitsNV);
pub const OpticalFlowGridSizeFlagMasksNV = struct {
    pub const unknown = OpticalFlowGridSizeFlagsNV{ .bits = 0x0 };
};
pub const OpticalFlowUsageFlagBitsNV = enum(u5) {
    input = 0,
    output = 1,
    hint = 2,
    cost = 3,
    global_flow = 4,
    _,
};
pub const OpticalFlowUsageFlagsNV = BitField(OpticalFlowUsageFlagBitsNV);
pub const OpticalFlowUsageFlagMasksNV = struct {
    pub const unknown = OpticalFlowUsageFlagsNV{ .bits = 0x0 };
};
pub const OpticalFlowSessionCreateFlagBitsNV = enum(u5) {
    enable_hint = 0,
    enable_cost = 1,
    enable_global_flow = 2,
    allow_regions = 3,
    both_directions = 4,
    _,
};
pub const OpticalFlowSessionCreateFlagsNV = BitField(OpticalFlowSessionCreateFlagBitsNV);
pub const OpticalFlowExecuteFlagBitsNV = enum(u5) {
    disable_temporal_hints = 0,
    _,
};
pub const OpticalFlowExecuteFlagsNV = BitField(OpticalFlowExecuteFlagBitsNV);
pub const FrameBoundaryFlagBitsEXT = enum(u5) {
    frame_end = 0,
    _,
};
pub const FrameBoundaryFlagsEXT = BitField(FrameBoundaryFlagBitsEXT);
pub const PresentScalingFlagBitsKHR = enum(u5) {
    one_to_one = 0,
    aspect_ratio_stretch = 1,
    stretch = 2,
    _,
};
pub const PresentScalingFlagsKHR = BitField(PresentScalingFlagBitsKHR);
pub const PresentScalingFlagsEXT = PresentScalingFlagsKHR;
pub const PresentGravityFlagBitsKHR = enum(u5) {
    min = 0,
    max = 1,
    centered = 2,
    _,
};
pub const PresentGravityFlagsKHR = BitField(PresentGravityFlagBitsKHR);
pub const PresentGravityFlagsEXT = PresentGravityFlagsKHR;
pub const ShaderCreateFlagBitsEXT = enum(u5) {
    link_stage = 0,
    allow_varying_subgroup_size = 1,
    require_full_subgroups = 2,
    no_task_shader = 3,
    dispatch_base = 4,
    fragment_shading_rate_attachment = 5,
    fragment_density_map_attachment = 6,
    indirect_bindable = 7,
    _,
};
pub const ShaderCreateFlagsEXT = BitField(ShaderCreateFlagBitsEXT);
pub const TileShadingRenderPassFlagBitsQCOM = enum(u5) {
    enable = 0,
    per_tile_execution = 1,
    _,
};
pub const TileShadingRenderPassFlagsQCOM = BitField(TileShadingRenderPassFlagBitsQCOM);
pub const PhysicalDeviceSchedulingControlsFlagBitsARM = enum(u6) {
    shader_core_count = 0,
    _,
};
pub const PhysicalDeviceSchedulingControlsFlagsARM = BitField(PhysicalDeviceSchedulingControlsFlagBitsARM);
pub const SurfaceCreateFlagBitsOHOS = enum(u5) {
    _,
};
pub const SurfaceCreateFlagsOHOS = BitField(SurfaceCreateFlagBitsOHOS);
pub const AccessFlagBits3KHR = enum(u6) {
    _,
};
pub const AccessFlags3KHR = BitField(AccessFlagBits3KHR);
pub const AccessFlagMasks3KHR = struct {
    pub const @"3_none" = AccessFlags3KHR{ .bits = 0x0 };
};
pub const Instance = enum(usize) { null_handle = 0, _ };
pub const PhysicalDevice = enum(usize) { null_handle = 0, _ };
pub const Device = enum(usize) { null_handle = 0, _ };
pub const Queue = enum(usize) { null_handle = 0, _ };
pub const CommandBuffer = enum(usize) { null_handle = 0, _ };
pub const DeviceMemory = enum(u64) { null_handle = 0, _ };
pub const CommandPool = enum(u64) { null_handle = 0, _ };
pub const Buffer = enum(u64) { null_handle = 0, _ };
pub const BufferView = enum(u64) { null_handle = 0, _ };
pub const Image = enum(u64) { null_handle = 0, _ };
pub const ImageView = enum(u64) { null_handle = 0, _ };
pub const ShaderModule = enum(u64) { null_handle = 0, _ };
pub const Pipeline = enum(u64) { null_handle = 0, _ };
pub const PipelineLayout = enum(u64) { null_handle = 0, _ };
pub const Sampler = enum(u64) { null_handle = 0, _ };
pub const DescriptorSet = enum(u64) { null_handle = 0, _ };
pub const DescriptorSetLayout = enum(u64) { null_handle = 0, _ };
pub const DescriptorPool = enum(u64) { null_handle = 0, _ };
pub const Fence = enum(u64) { null_handle = 0, _ };
pub const Semaphore = enum(u64) { null_handle = 0, _ };
pub const Event = enum(u64) { null_handle = 0, _ };
pub const QueryPool = enum(u64) { null_handle = 0, _ };
pub const Framebuffer = enum(u64) { null_handle = 0, _ };
pub const RenderPass = enum(u64) { null_handle = 0, _ };
pub const PipelineCache = enum(u64) { null_handle = 0, _ };
pub const PipelineBinaryKHR = enum(u64) { null_handle = 0, _ };
pub const IndirectCommandsLayoutNV = enum(u64) { null_handle = 0, _ };
pub const IndirectCommandsLayoutEXT = enum(u64) { null_handle = 0, _ };
pub const IndirectExecutionSetEXT = enum(u64) { null_handle = 0, _ };
pub const DescriptorUpdateTemplate = enum(u64) { null_handle = 0, _ };
pub const DescriptorUpdateTemplateKHR = DescriptorUpdateTemplate;
pub const SamplerYcbcrConversion = enum(u64) { null_handle = 0, _ };
pub const SamplerYcbcrConversionKHR = SamplerYcbcrConversion;
pub const ValidationCacheEXT = enum(u64) { null_handle = 0, _ };
pub const AccelerationStructureKHR = enum(u64) { null_handle = 0, _ };
pub const AccelerationStructureNV = enum(u64) { null_handle = 0, _ };
pub const PerformanceConfigurationINTEL = enum(u64) { null_handle = 0, _ };
pub const BufferCollectionFUCHSIA = enum(u64) { null_handle = 0, _ };
pub const DeferredOperationKHR = enum(u64) { null_handle = 0, _ };
pub const PrivateDataSlot = enum(u64) { null_handle = 0, _ };
pub const PrivateDataSlotEXT = PrivateDataSlot;
pub const CuModuleNVX = enum(u64) { null_handle = 0, _ };
pub const CuFunctionNVX = enum(u64) { null_handle = 0, _ };
pub const OpticalFlowSessionNV = enum(u64) { null_handle = 0, _ };
pub const MicromapEXT = enum(u64) { null_handle = 0, _ };
pub const ShaderEXT = enum(u64) { null_handle = 0, _ };
pub const TensorARM = enum(u64) { null_handle = 0, _ };
pub const TensorViewARM = enum(u64) { null_handle = 0, _ };
pub const DataGraphPipelineSessionARM = enum(u64) { null_handle = 0, _ };
pub const DisplayKHR = enum(u64) { null_handle = 0, _ };
pub const DisplayModeKHR = enum(u64) { null_handle = 0, _ };
pub const SurfaceKHR = enum(u64) { null_handle = 0, _ };
pub const SwapchainKHR = enum(u64) { null_handle = 0, _ };
pub const DebugReportCallbackEXT = enum(u64) { null_handle = 0, _ };
pub const DebugUtilsMessengerEXT = enum(u64) { null_handle = 0, _ };
pub const AttachmentLoadOp = enum(i32) {
    load = 0,
    clear = 1,
    dont_care = 2,
    none = 1000400000,
    _,
};
pub const AttachmentStoreOp = enum(i32) {
    store = 0,
    dont_care = 1,
    none = 1000301000,
    _,
};
pub const BlendFactor = enum(i32) {
    zero = 0,
    one = 1,
    src_color = 2,
    one_minus_src_color = 3,
    dst_color = 4,
    one_minus_dst_color = 5,
    src_alpha = 6,
    one_minus_src_alpha = 7,
    dst_alpha = 8,
    one_minus_dst_alpha = 9,
    constant_color = 10,
    one_minus_constant_color = 11,
    constant_alpha = 12,
    one_minus_constant_alpha = 13,
    src_alpha_saturate = 14,
    src1_color = 15,
    one_minus_src1_color = 16,
    src1_alpha = 17,
    one_minus_src1_alpha = 18,
    _,
};
pub const BlendOp = enum(i32) {
    add = 0,
    subtract = 1,
    reverse_subtract = 2,
    min = 3,
    max = 4,
    zero_ext = 1000148000,
    src_ext = 1000148001,
    dst_ext = 1000148002,
    src_over_ext = 1000148003,
    dst_over_ext = 1000148004,
    src_in_ext = 1000148005,
    dst_in_ext = 1000148006,
    src_out_ext = 1000148007,
    dst_out_ext = 1000148008,
    src_atop_ext = 1000148009,
    dst_atop_ext = 1000148010,
    xor_ext = 1000148011,
    multiply_ext = 1000148012,
    screen_ext = 1000148013,
    overlay_ext = 1000148014,
    darken_ext = 1000148015,
    lighten_ext = 1000148016,
    colordodge_ext = 1000148017,
    colorburn_ext = 1000148018,
    hardlight_ext = 1000148019,
    softlight_ext = 1000148020,
    difference_ext = 1000148021,
    exclusion_ext = 1000148022,
    invert_ext = 1000148023,
    invert_rgb_ext = 1000148024,
    lineardodge_ext = 1000148025,
    linearburn_ext = 1000148026,
    vividlight_ext = 1000148027,
    linearlight_ext = 1000148028,
    pinlight_ext = 1000148029,
    hardmix_ext = 1000148030,
    hsl_hue_ext = 1000148031,
    hsl_saturation_ext = 1000148032,
    hsl_color_ext = 1000148033,
    hsl_luminosity_ext = 1000148034,
    plus_ext = 1000148035,
    plus_clamped_ext = 1000148036,
    plus_clamped_alpha_ext = 1000148037,
    plus_darker_ext = 1000148038,
    minus_ext = 1000148039,
    minus_clamped_ext = 1000148040,
    contrast_ext = 1000148041,
    invert_ovg_ext = 1000148042,
    red_ext = 1000148043,
    green_ext = 1000148044,
    blue_ext = 1000148045,
    _,
};
pub const BorderColor = enum(i32) {
    float_transparent_black = 0,
    int_transparent_black = 1,
    float_opaque_black = 2,
    int_opaque_black = 3,
    float_opaque_white = 4,
    int_opaque_white = 5,
    float_custom_ext = 1000287003,
    int_custom_ext = 1000287004,
    _,
};
pub const PipelineCacheHeaderVersion = enum(i32) {
    one = 1,
    _,
};
pub const ComponentSwizzle = enum(i32) {
    identity = 0,
    zero = 1,
    one = 2,
    r = 3,
    g = 4,
    b = 5,
    a = 6,
    _,
};
pub const CommandBufferLevel = enum(i32) {
    primary = 0,
    secondary = 1,
    _,
};
pub const CompareOp = enum(i32) {
    never = 0,
    less = 1,
    equal = 2,
    less_or_equal = 3,
    greater = 4,
    not_equal = 5,
    greater_or_equal = 6,
    always = 7,
    _,
};
pub const DescriptorType = enum(i32) {
    sampler = 0,
    combined_image_sampler = 1,
    sampled_image = 2,
    storage_image = 3,
    uniform_texel_buffer = 4,
    storage_texel_buffer = 5,
    uniform_buffer = 6,
    storage_buffer = 7,
    uniform_buffer_dynamic = 8,
    storage_buffer_dynamic = 9,
    input_attachment = 10,
    inline_uniform_block = 1000138000,
    acceleration_structure_khr = 1000150000,
    acceleration_structure_nv = 1000165000,
    sample_weight_image_qcom = 1000440000,
    block_match_image_qcom = 1000440001,
    tensor_arm = 1000460000,
    mutable_ext = 1000351000,
    partitioned_acceleration_structure_nv = 1000570000,
    _,
};
pub const DynamicState = enum(i32) {
    viewport = 0,
    scissor = 1,
    line_width = 2,
    depth_bias = 3,
    blend_constants = 4,
    depth_bounds = 5,
    stencil_compare_mask = 6,
    stencil_write_mask = 7,
    stencil_reference = 8,
    cull_mode = 1000267000,
    front_face = 1000267001,
    primitive_topology = 1000267002,
    viewport_with_count = 1000267003,
    scissor_with_count = 1000267004,
    vertex_input_binding_stride = 1000267005,
    depth_test_enable = 1000267006,
    depth_write_enable = 1000267007,
    depth_compare_op = 1000267008,
    depth_bounds_test_enable = 1000267009,
    stencil_test_enable = 1000267010,
    stencil_op = 1000267011,
    rasterizer_discard_enable = 1000377001,
    depth_bias_enable = 1000377002,
    primitive_restart_enable = 1000377004,
    line_stipple = 1000259000,
    viewport_w_scaling_nv = 1000087000,
    discard_rectangle_ext = 1000099000,
    discard_rectangle_enable_ext = 1000099001,
    discard_rectangle_mode_ext = 1000099002,
    sample_locations_ext = 1000143000,
    ray_tracing_pipeline_stack_size_khr = 1000347000,
    viewport_shading_rate_palette_nv = 1000164004,
    viewport_coarse_sample_order_nv = 1000164006,
    exclusive_scissor_enable_nv = 1000205000,
    exclusive_scissor_nv = 1000205001,
    fragment_shading_rate_khr = 1000226000,
    vertex_input_ext = 1000352000,
    patch_control_points_ext = 1000377000,
    logic_op_ext = 1000377003,
    color_write_enable_ext = 1000381000,
    depth_clamp_enable_ext = 1000455003,
    polygon_mode_ext = 1000455004,
    rasterization_samples_ext = 1000455005,
    sample_mask_ext = 1000455006,
    alpha_to_coverage_enable_ext = 1000455007,
    alpha_to_one_enable_ext = 1000455008,
    logic_op_enable_ext = 1000455009,
    color_blend_enable_ext = 1000455010,
    color_blend_equation_ext = 1000455011,
    color_write_mask_ext = 1000455012,
    tessellation_domain_origin_ext = 1000455002,
    rasterization_stream_ext = 1000455013,
    conservative_rasterization_mode_ext = 1000455014,
    extra_primitive_overestimation_size_ext = 1000455015,
    depth_clip_enable_ext = 1000455016,
    sample_locations_enable_ext = 1000455017,
    color_blend_advanced_ext = 1000455018,
    provoking_vertex_mode_ext = 1000455019,
    line_rasterization_mode_ext = 1000455020,
    line_stipple_enable_ext = 1000455021,
    depth_clip_negative_one_to_one_ext = 1000455022,
    viewport_w_scaling_enable_nv = 1000455023,
    viewport_swizzle_nv = 1000455024,
    coverage_to_color_enable_nv = 1000455025,
    coverage_to_color_location_nv = 1000455026,
    coverage_modulation_mode_nv = 1000455027,
    coverage_modulation_table_enable_nv = 1000455028,
    coverage_modulation_table_nv = 1000455029,
    shading_rate_image_enable_nv = 1000455030,
    representative_fragment_test_enable_nv = 1000455031,
    coverage_reduction_mode_nv = 1000455032,
    attachment_feedback_loop_enable_ext = 1000524000,
    depth_clamp_range_ext = 1000582000,
    _,
};
pub const PolygonMode = enum(i32) {
    fill = 0,
    line = 1,
    point = 2,
    fill_rectangle_nv = 1000153000,
    _,
};
pub const Format = enum(i32) {
    undefined = 0,
    r4g4_unorm_pack8 = 1,
    r4g4b4a4_unorm_pack16 = 2,
    b4g4r4a4_unorm_pack16 = 3,
    r5g6b5_unorm_pack16 = 4,
    b5g6r5_unorm_pack16 = 5,
    r5g5b5a1_unorm_pack16 = 6,
    b5g5r5a1_unorm_pack16 = 7,
    a1r5g5b5_unorm_pack16 = 8,
    r8_unorm = 9,
    r8_snorm = 10,
    r8_uscaled = 11,
    r8_sscaled = 12,
    r8_uint = 13,
    r8_sint = 14,
    r8_srgb = 15,
    r8g8_unorm = 16,
    r8g8_snorm = 17,
    r8g8_uscaled = 18,
    r8g8_sscaled = 19,
    r8g8_uint = 20,
    r8g8_sint = 21,
    r8g8_srgb = 22,
    r8g8b8_unorm = 23,
    r8g8b8_snorm = 24,
    r8g8b8_uscaled = 25,
    r8g8b8_sscaled = 26,
    r8g8b8_uint = 27,
    r8g8b8_sint = 28,
    r8g8b8_srgb = 29,
    b8g8r8_unorm = 30,
    b8g8r8_snorm = 31,
    b8g8r8_uscaled = 32,
    b8g8r8_sscaled = 33,
    b8g8r8_uint = 34,
    b8g8r8_sint = 35,
    b8g8r8_srgb = 36,
    r8g8b8a8_unorm = 37,
    r8g8b8a8_snorm = 38,
    r8g8b8a8_uscaled = 39,
    r8g8b8a8_sscaled = 40,
    r8g8b8a8_uint = 41,
    r8g8b8a8_sint = 42,
    r8g8b8a8_srgb = 43,
    b8g8r8a8_unorm = 44,
    b8g8r8a8_snorm = 45,
    b8g8r8a8_uscaled = 46,
    b8g8r8a8_sscaled = 47,
    b8g8r8a8_uint = 48,
    b8g8r8a8_sint = 49,
    b8g8r8a8_srgb = 50,
    a8b8g8r8_unorm_pack32 = 51,
    a8b8g8r8_snorm_pack32 = 52,
    a8b8g8r8_uscaled_pack32 = 53,
    a8b8g8r8_sscaled_pack32 = 54,
    a8b8g8r8_uint_pack32 = 55,
    a8b8g8r8_sint_pack32 = 56,
    a8b8g8r8_srgb_pack32 = 57,
    a2r10g10b10_unorm_pack32 = 58,
    a2r10g10b10_snorm_pack32 = 59,
    a2r10g10b10_uscaled_pack32 = 60,
    a2r10g10b10_sscaled_pack32 = 61,
    a2r10g10b10_uint_pack32 = 62,
    a2r10g10b10_sint_pack32 = 63,
    a2b10g10r10_unorm_pack32 = 64,
    a2b10g10r10_snorm_pack32 = 65,
    a2b10g10r10_uscaled_pack32 = 66,
    a2b10g10r10_sscaled_pack32 = 67,
    a2b10g10r10_uint_pack32 = 68,
    a2b10g10r10_sint_pack32 = 69,
    r16_unorm = 70,
    r16_snorm = 71,
    r16_uscaled = 72,
    r16_sscaled = 73,
    r16_uint = 74,
    r16_sint = 75,
    r16_sfloat = 76,
    r16g16_unorm = 77,
    r16g16_snorm = 78,
    r16g16_uscaled = 79,
    r16g16_sscaled = 80,
    r16g16_uint = 81,
    r16g16_sint = 82,
    r16g16_sfloat = 83,
    r16g16b16_unorm = 84,
    r16g16b16_snorm = 85,
    r16g16b16_uscaled = 86,
    r16g16b16_sscaled = 87,
    r16g16b16_uint = 88,
    r16g16b16_sint = 89,
    r16g16b16_sfloat = 90,
    r16g16b16a16_unorm = 91,
    r16g16b16a16_snorm = 92,
    r16g16b16a16_uscaled = 93,
    r16g16b16a16_sscaled = 94,
    r16g16b16a16_uint = 95,
    r16g16b16a16_sint = 96,
    r16g16b16a16_sfloat = 97,
    r32_uint = 98,
    r32_sint = 99,
    r32_sfloat = 100,
    r32g32_uint = 101,
    r32g32_sint = 102,
    r32g32_sfloat = 103,
    r32g32b32_uint = 104,
    r32g32b32_sint = 105,
    r32g32b32_sfloat = 106,
    r32g32b32a32_uint = 107,
    r32g32b32a32_sint = 108,
    r32g32b32a32_sfloat = 109,
    r64_uint = 110,
    r64_sint = 111,
    r64_sfloat = 112,
    r64g64_uint = 113,
    r64g64_sint = 114,
    r64g64_sfloat = 115,
    r64g64b64_uint = 116,
    r64g64b64_sint = 117,
    r64g64b64_sfloat = 118,
    r64g64b64a64_uint = 119,
    r64g64b64a64_sint = 120,
    r64g64b64a64_sfloat = 121,
    b10g11r11_ufloat_pack32 = 122,
    e5b9g9r9_ufloat_pack32 = 123,
    d16_unorm = 124,
    x8_d24_unorm_pack32 = 125,
    d32_sfloat = 126,
    s8_uint = 127,
    d16_unorm_s8_uint = 128,
    d24_unorm_s8_uint = 129,
    d32_sfloat_s8_uint = 130,
    bc1_rgb_unorm_block = 131,
    bc1_rgb_srgb_block = 132,
    bc1_rgba_unorm_block = 133,
    bc1_rgba_srgb_block = 134,
    bc2_unorm_block = 135,
    bc2_srgb_block = 136,
    bc3_unorm_block = 137,
    bc3_srgb_block = 138,
    bc4_unorm_block = 139,
    bc4_snorm_block = 140,
    bc5_unorm_block = 141,
    bc5_snorm_block = 142,
    bc6h_ufloat_block = 143,
    bc6h_sfloat_block = 144,
    bc7_unorm_block = 145,
    bc7_srgb_block = 146,
    etc2_r8g8b8_unorm_block = 147,
    etc2_r8g8b8_srgb_block = 148,
    etc2_r8g8b8a1_unorm_block = 149,
    etc2_r8g8b8a1_srgb_block = 150,
    etc2_r8g8b8a8_unorm_block = 151,
    etc2_r8g8b8a8_srgb_block = 152,
    eac_r11_unorm_block = 153,
    eac_r11_snorm_block = 154,
    eac_r11g11_unorm_block = 155,
    eac_r11g11_snorm_block = 156,
    astc_4x4_unorm_block = 157,
    astc_4x4_srgb_block = 158,
    astc_5x4_unorm_block = 159,
    astc_5x4_srgb_block = 160,
    astc_5x5_unorm_block = 161,
    astc_5x5_srgb_block = 162,
    astc_6x5_unorm_block = 163,
    astc_6x5_srgb_block = 164,
    astc_6x6_unorm_block = 165,
    astc_6x6_srgb_block = 166,
    astc_8x5_unorm_block = 167,
    astc_8x5_srgb_block = 168,
    astc_8x6_unorm_block = 169,
    astc_8x6_srgb_block = 170,
    astc_8x8_unorm_block = 171,
    astc_8x8_srgb_block = 172,
    astc_10x5_unorm_block = 173,
    astc_10x5_srgb_block = 174,
    astc_10x6_unorm_block = 175,
    astc_10x6_srgb_block = 176,
    astc_10x8_unorm_block = 177,
    astc_10x8_srgb_block = 178,
    astc_10x10_unorm_block = 179,
    astc_10x10_srgb_block = 180,
    astc_12x10_unorm_block = 181,
    astc_12x10_srgb_block = 182,
    astc_12x12_unorm_block = 183,
    astc_12x12_srgb_block = 184,
    g8b8g8r8_422_unorm = 1000156000,
    b8g8r8g8_422_unorm = 1000156001,
    g8_b8_r8_3plane_420_unorm = 1000156002,
    g8_b8r8_2plane_420_unorm = 1000156003,
    g8_b8_r8_3plane_422_unorm = 1000156004,
    g8_b8r8_2plane_422_unorm = 1000156005,
    g8_b8_r8_3plane_444_unorm = 1000156006,
    r10x6_unorm_pack16 = 1000156007,
    r10x6g10x6_unorm_2pack16 = 1000156008,
    r10x6g10x6b10x6a10x6_unorm_4pack16 = 1000156009,
    g10x6b10x6g10x6r10x6_422_unorm_4pack16 = 1000156010,
    b10x6g10x6r10x6g10x6_422_unorm_4pack16 = 1000156011,
    g10x6_b10x6_r10x6_3plane_420_unorm_3pack16 = 1000156012,
    g10x6_b10x6r10x6_2plane_420_unorm_3pack16 = 1000156013,
    g10x6_b10x6_r10x6_3plane_422_unorm_3pack16 = 1000156014,
    g10x6_b10x6r10x6_2plane_422_unorm_3pack16 = 1000156015,
    g10x6_b10x6_r10x6_3plane_444_unorm_3pack16 = 1000156016,
    r12x4_unorm_pack16 = 1000156017,
    r12x4g12x4_unorm_2pack16 = 1000156018,
    r12x4g12x4b12x4a12x4_unorm_4pack16 = 1000156019,
    g12x4b12x4g12x4r12x4_422_unorm_4pack16 = 1000156020,
    b12x4g12x4r12x4g12x4_422_unorm_4pack16 = 1000156021,
    g12x4_b12x4_r12x4_3plane_420_unorm_3pack16 = 1000156022,
    g12x4_b12x4r12x4_2plane_420_unorm_3pack16 = 1000156023,
    g12x4_b12x4_r12x4_3plane_422_unorm_3pack16 = 1000156024,
    g12x4_b12x4r12x4_2plane_422_unorm_3pack16 = 1000156025,
    g12x4_b12x4_r12x4_3plane_444_unorm_3pack16 = 1000156026,
    g16b16g16r16_422_unorm = 1000156027,
    b16g16r16g16_422_unorm = 1000156028,
    g16_b16_r16_3plane_420_unorm = 1000156029,
    g16_b16r16_2plane_420_unorm = 1000156030,
    g16_b16_r16_3plane_422_unorm = 1000156031,
    g16_b16r16_2plane_422_unorm = 1000156032,
    g16_b16_r16_3plane_444_unorm = 1000156033,
    g8_b8r8_2plane_444_unorm = 1000330000,
    g10x6_b10x6r10x6_2plane_444_unorm_3pack16 = 1000330001,
    g12x4_b12x4r12x4_2plane_444_unorm_3pack16 = 1000330002,
    g16_b16r16_2plane_444_unorm = 1000330003,
    a4r4g4b4_unorm_pack16 = 1000340000,
    a4b4g4r4_unorm_pack16 = 1000340001,
    astc_4x4_sfloat_block = 1000066000,
    astc_5x4_sfloat_block = 1000066001,
    astc_5x5_sfloat_block = 1000066002,
    astc_6x5_sfloat_block = 1000066003,
    astc_6x6_sfloat_block = 1000066004,
    astc_8x5_sfloat_block = 1000066005,
    astc_8x6_sfloat_block = 1000066006,
    astc_8x8_sfloat_block = 1000066007,
    astc_10x5_sfloat_block = 1000066008,
    astc_10x6_sfloat_block = 1000066009,
    astc_10x8_sfloat_block = 1000066010,
    astc_10x10_sfloat_block = 1000066011,
    astc_12x10_sfloat_block = 1000066012,
    astc_12x12_sfloat_block = 1000066013,
    a1b5g5r5_unorm_pack16 = 1000470000,
    a8_unorm = 1000470001,
    pvrtc1_2bpp_unorm_block_img = 1000054000,
    pvrtc1_4bpp_unorm_block_img = 1000054001,
    pvrtc2_2bpp_unorm_block_img = 1000054002,
    pvrtc2_4bpp_unorm_block_img = 1000054003,
    pvrtc1_2bpp_srgb_block_img = 1000054004,
    pvrtc1_4bpp_srgb_block_img = 1000054005,
    pvrtc2_2bpp_srgb_block_img = 1000054006,
    pvrtc2_4bpp_srgb_block_img = 1000054007,
    r8_bool_arm = 1000460000,
    r16g16_sfixed5_nv = 1000464000,
    r10x6_uint_pack16_arm = 1000609000,
    r10x6g10x6_uint_2pack16_arm = 1000609001,
    r10x6g10x6b10x6a10x6_uint_4pack16_arm = 1000609002,
    r12x4_uint_pack16_arm = 1000609003,
    r12x4g12x4_uint_2pack16_arm = 1000609004,
    r12x4g12x4b12x4a12x4_uint_4pack16_arm = 1000609005,
    r14x2_uint_pack16_arm = 1000609006,
    r14x2g14x2_uint_2pack16_arm = 1000609007,
    r14x2g14x2b14x2a14x2_uint_4pack16_arm = 1000609008,
    r14x2_unorm_pack16_arm = 1000609009,
    r14x2g14x2_unorm_2pack16_arm = 1000609010,
    r14x2g14x2b14x2a14x2_unorm_4pack16_arm = 1000609011,
    g14x2_b14x2r14x2_2plane_420_unorm_3pack16_arm = 1000609012,
    g14x2_b14x2r14x2_2plane_422_unorm_3pack16_arm = 1000609013,
    _,
};
pub const FrontFace = enum(i32) {
    counter_clockwise = 0,
    clockwise = 1,
    _,
};
pub const ImageLayout = enum(i32) {
    undefined = 0,
    general = 1,
    color_attachment_optimal = 2,
    depth_stencil_attachment_optimal = 3,
    depth_stencil_read_only_optimal = 4,
    shader_read_only_optimal = 5,
    transfer_src_optimal = 6,
    transfer_dst_optimal = 7,
    preinitialized = 8,
    depth_read_only_stencil_attachment_optimal = 1000117000,
    depth_attachment_stencil_read_only_optimal = 1000117001,
    depth_attachment_optimal = 1000241000,
    depth_read_only_optimal = 1000241001,
    stencil_attachment_optimal = 1000241002,
    stencil_read_only_optimal = 1000241003,
    read_only_optimal = 1000314000,
    attachment_optimal = 1000314001,
    rendering_local_read = 1000232000,
    present_src_khr = 1000001002,
    shared_present_khr = 1000111000,
    fragment_density_map_optimal_ext = 1000218000,
    fragment_shading_rate_attachment_optimal_khr = 1000164003,
    attachment_feedback_loop_optimal_ext = 1000339000,
    tensor_aliasing_arm = 1000460000,
    zero_initialized_ext = 1000620000,
    _,
};
pub const ImageTiling = enum(i32) {
    optimal = 0,
    linear = 1,
    drm_format_modifier_ext = 1000158000,
    _,
};
pub const ImageType = enum(i32) {
    @"1d" = 0,
    @"2d" = 1,
    @"3d" = 2,
    _,
};
pub const ImageViewType = enum(i32) {
    @"1d" = 0,
    @"2d" = 1,
    @"3d" = 2,
    cube = 3,
    @"1d_array" = 4,
    @"2d_array" = 5,
    cube_array = 6,
    _,
};
pub const IndirectCommandsTokenTypeEXT = enum(i32) {
    execution_set = 0,
    push_constant = 1,
    sequence_index = 2,
    index_buffer = 3,
    vertex_buffer = 4,
    draw_indexed = 5,
    draw = 6,
    draw_indexed_count = 7,
    draw_count = 8,
    dispatch = 9,
    draw_mesh_tasks_nv = 1000202002,
    draw_mesh_tasks_count_nv = 1000202003,
    draw_mesh_tasks = 1000328000,
    draw_mesh_tasks_count = 1000328001,
    trace_rays2 = 1000386004,
    _,
};
pub const SharingMode = enum(i32) {
    exclusive = 0,
    concurrent = 1,
    _,
};
pub const IndexType = enum(i32) {
    uint16 = 0,
    uint32 = 1,
    uint8 = 1000265000,
    none_khr = 1000165000,
    _,
};
pub const LogicOp = enum(i32) {
    clear = 0,
    @"and" = 1,
    and_reverse = 2,
    copy = 3,
    and_inverted = 4,
    no_op = 5,
    xor = 6,
    @"or" = 7,
    nor = 8,
    equivalent = 9,
    invert = 10,
    or_reverse = 11,
    copy_inverted = 12,
    or_inverted = 13,
    nand = 14,
    set = 15,
    _,
};
pub const PhysicalDeviceType = enum(i32) {
    other = 0,
    integrated_gpu = 1,
    discrete_gpu = 2,
    virtual_gpu = 3,
    cpu = 4,
    _,
};
pub const PipelineBindPoint = enum(i32) {
    graphics = 0,
    compute = 1,
    execution_graph_amdx = 1000134000,
    ray_tracing_khr = 1000165000,
    subpass_shading_huawei = 1000369003,
    data_graph_arm = 1000507000,
    _,
};
pub const PrimitiveTopology = enum(i32) {
    point_list = 0,
    line_list = 1,
    line_strip = 2,
    triangle_list = 3,
    triangle_strip = 4,
    triangle_fan = 5,
    line_list_with_adjacency = 6,
    line_strip_with_adjacency = 7,
    triangle_list_with_adjacency = 8,
    triangle_strip_with_adjacency = 9,
    patch_list = 10,
    _,
};
pub const QueryType = enum(i32) {
    occlusion = 0,
    pipeline_statistics = 1,
    timestamp = 2,
    transform_feedback_stream_ext = 1000028004,
    performance_query_khr = 1000116000,
    acceleration_structure_compacted_size_khr = 1000150000,
    acceleration_structure_serialization_size_khr = 1000150001,
    acceleration_structure_compacted_size_nv = 1000165000,
    performance_query_intel = 1000210000,
    mesh_primitives_generated_ext = 1000328000,
    primitives_generated_ext = 1000382000,
    acceleration_structure_serialization_bottom_level_pointers_khr = 1000386000,
    acceleration_structure_size_khr = 1000386001,
    micromap_serialization_size_ext = 1000396000,
    micromap_compacted_size_ext = 1000396001,
    _,
};
pub const SubpassContents = enum(i32) {
    @"inline" = 0,
    secondary_command_buffers = 1,
    inline_and_secondary_command_buffers_khr = 1000451000,
    _,
};
pub const Result = enum(i32) {
    success = 0,
    not_ready = 1,
    timeout = 2,
    event_set = 3,
    event_reset = 4,
    incomplete = 5,
    error_out_of_host_memory = -1,
    error_out_of_device_memory = -2,
    error_initialization_failed = -3,
    error_device_lost = -4,
    error_memory_map_failed = -5,
    error_layer_not_present = -6,
    error_extension_not_present = -7,
    error_feature_not_present = -8,
    error_incompatible_driver = -9,
    error_too_many_objects = -10,
    error_format_not_supported = -11,
    error_fragmented_pool = -12,
    error_unknown = -13,
    error_validation_failed = -1000011001,
    error_out_of_pool_memory = -1000069000,
    error_invalid_external_handle = -1000072003,
    error_fragmentation = -1000161000,
    error_invalid_opaque_capture_address = -1000257000,
    pipeline_compile_required = 1000297000,
    error_not_permitted = -1000174001,
    error_surface_lost_khr = -1000000000,
    error_native_window_in_use_khr = -1000000001,
    suboptimal_khr = 1000001003,
    error_out_of_date_khr = -1000001004,
    error_incompatible_display_khr = -1000003001,
    error_invalid_shader_nv = -1000012000,
    error_invalid_drm_format_modifier_plane_layout_ext = -1000158000,
    error_full_screen_exclusive_mode_lost_ext = -1000255000,
    thread_idle_khr = 1000268000,
    thread_done_khr = 1000268001,
    operation_deferred_khr = 1000268002,
    operation_not_deferred_khr = 1000268003,
    error_compression_exhausted_ext = -1000338000,
    incompatible_shader_binary_ext = 1000482000,
    pipeline_binary_missing_khr = 1000483000,
    error_not_enough_space_khr = -1000483000,
    _,
};
pub const StencilOp = enum(i32) {
    keep = 0,
    zero = 1,
    replace = 2,
    increment_and_clamp = 3,
    decrement_and_clamp = 4,
    invert = 5,
    increment_and_wrap = 6,
    decrement_and_wrap = 7,
    _,
};
pub const StructureType = enum(i32) {
    application_info = 0,
    instance_create_info = 1,
    device_queue_create_info = 2,
    device_create_info = 3,
    submit_info = 4,
    memory_allocate_info = 5,
    mapped_memory_range = 6,
    bind_sparse_info = 7,
    fence_create_info = 8,
    semaphore_create_info = 9,
    event_create_info = 10,
    query_pool_create_info = 11,
    buffer_create_info = 12,
    buffer_view_create_info = 13,
    image_create_info = 14,
    image_view_create_info = 15,
    shader_module_create_info = 16,
    pipeline_cache_create_info = 17,
    pipeline_shader_stage_create_info = 18,
    pipeline_vertex_input_state_create_info = 19,
    pipeline_input_assembly_state_create_info = 20,
    pipeline_tessellation_state_create_info = 21,
    pipeline_viewport_state_create_info = 22,
    pipeline_rasterization_state_create_info = 23,
    pipeline_multisample_state_create_info = 24,
    pipeline_depth_stencil_state_create_info = 25,
    pipeline_color_blend_state_create_info = 26,
    pipeline_dynamic_state_create_info = 27,
    graphics_pipeline_create_info = 28,
    compute_pipeline_create_info = 29,
    pipeline_layout_create_info = 30,
    sampler_create_info = 31,
    descriptor_set_layout_create_info = 32,
    descriptor_pool_create_info = 33,
    descriptor_set_allocate_info = 34,
    write_descriptor_set = 35,
    copy_descriptor_set = 36,
    framebuffer_create_info = 37,
    render_pass_create_info = 38,
    command_pool_create_info = 39,
    command_buffer_allocate_info = 40,
    command_buffer_inheritance_info = 41,
    command_buffer_begin_info = 42,
    render_pass_begin_info = 43,
    buffer_memory_barrier = 44,
    image_memory_barrier = 45,
    memory_barrier = 46,
    loader_instance_create_info = 47,
    loader_device_create_info = 48,
    physical_device_subgroup_properties = 1000094000,
    bind_buffer_memory_info = 1000157000,
    bind_image_memory_info = 1000157001,
    physical_device_16bit_storage_features = 1000083000,
    memory_dedicated_requirements = 1000127000,
    memory_dedicated_allocate_info = 1000127001,
    memory_allocate_flags_info = 1000060000,
    device_group_render_pass_begin_info = 1000060003,
    device_group_command_buffer_begin_info = 1000060004,
    device_group_submit_info = 1000060005,
    device_group_bind_sparse_info = 1000060006,
    bind_buffer_memory_device_group_info = 1000060013,
    bind_image_memory_device_group_info = 1000060014,
    physical_device_group_properties = 1000070000,
    device_group_device_create_info = 1000070001,
    buffer_memory_requirements_info_2 = 1000146000,
    image_memory_requirements_info_2 = 1000146001,
    image_sparse_memory_requirements_info_2 = 1000146002,
    memory_requirements_2 = 1000146003,
    sparse_image_memory_requirements_2 = 1000146004,
    physical_device_features_2 = 1000059000,
    physical_device_properties_2 = 1000059001,
    format_properties_2 = 1000059002,
    image_format_properties_2 = 1000059003,
    physical_device_image_format_info_2 = 1000059004,
    queue_family_properties_2 = 1000059005,
    physical_device_memory_properties_2 = 1000059006,
    sparse_image_format_properties_2 = 1000059007,
    physical_device_sparse_image_format_info_2 = 1000059008,
    physical_device_point_clipping_properties = 1000117000,
    render_pass_input_attachment_aspect_create_info = 1000117001,
    image_view_usage_create_info = 1000117002,
    pipeline_tessellation_domain_origin_state_create_info = 1000117003,
    render_pass_multiview_create_info = 1000053000,
    physical_device_multiview_features = 1000053001,
    physical_device_multiview_properties = 1000053002,
    physical_device_variable_pointers_features = 1000120000,
    protected_submit_info = 1000145000,
    physical_device_protected_memory_features = 1000145001,
    physical_device_protected_memory_properties = 1000145002,
    device_queue_info_2 = 1000145003,
    sampler_ycbcr_conversion_create_info = 1000156000,
    sampler_ycbcr_conversion_info = 1000156001,
    bind_image_plane_memory_info = 1000156002,
    image_plane_memory_requirements_info = 1000156003,
    physical_device_sampler_ycbcr_conversion_features = 1000156004,
    sampler_ycbcr_conversion_image_format_properties = 1000156005,
    descriptor_update_template_create_info = 1000085000,
    physical_device_external_image_format_info = 1000071000,
    external_image_format_properties = 1000071001,
    physical_device_external_buffer_info = 1000071002,
    external_buffer_properties = 1000071003,
    physical_device_id_properties = 1000071004,
    external_memory_buffer_create_info = 1000072000,
    external_memory_image_create_info = 1000072001,
    export_memory_allocate_info = 1000072002,
    physical_device_external_fence_info = 1000112000,
    external_fence_properties = 1000112001,
    export_fence_create_info = 1000113000,
    export_semaphore_create_info = 1000077000,
    physical_device_external_semaphore_info = 1000076000,
    external_semaphore_properties = 1000076001,
    physical_device_maintenance_3_properties = 1000168000,
    descriptor_set_layout_support = 1000168001,
    physical_device_shader_draw_parameters_features = 1000063000,
    physical_device_vulkan_1_1_features = 49,
    physical_device_vulkan_1_1_properties = 50,
    physical_device_vulkan_1_2_features = 51,
    physical_device_vulkan_1_2_properties = 52,
    image_format_list_create_info = 1000147000,
    attachment_description_2 = 1000109000,
    attachment_reference_2 = 1000109001,
    subpass_description_2 = 1000109002,
    subpass_dependency_2 = 1000109003,
    render_pass_create_info_2 = 1000109004,
    subpass_begin_info = 1000109005,
    subpass_end_info = 1000109006,
    physical_device_8bit_storage_features = 1000177000,
    physical_device_driver_properties = 1000196000,
    physical_device_shader_atomic_int64_features = 1000180000,
    physical_device_shader_float16_int8_features = 1000082000,
    physical_device_float_controls_properties = 1000197000,
    descriptor_set_layout_binding_flags_create_info = 1000161000,
    physical_device_descriptor_indexing_features = 1000161001,
    physical_device_descriptor_indexing_properties = 1000161002,
    descriptor_set_variable_descriptor_count_allocate_info = 1000161003,
    descriptor_set_variable_descriptor_count_layout_support = 1000161004,
    physical_device_depth_stencil_resolve_properties = 1000199000,
    subpass_description_depth_stencil_resolve = 1000199001,
    physical_device_scalar_block_layout_features = 1000221000,
    image_stencil_usage_create_info = 1000246000,
    physical_device_sampler_filter_minmax_properties = 1000130000,
    sampler_reduction_mode_create_info = 1000130001,
    physical_device_vulkan_memory_model_features = 1000211000,
    physical_device_imageless_framebuffer_features = 1000108000,
    framebuffer_attachments_create_info = 1000108001,
    framebuffer_attachment_image_info = 1000108002,
    render_pass_attachment_begin_info = 1000108003,
    physical_device_uniform_buffer_standard_layout_features = 1000253000,
    physical_device_shader_subgroup_extended_types_features = 1000175000,
    physical_device_separate_depth_stencil_layouts_features = 1000241000,
    attachment_reference_stencil_layout = 1000241001,
    attachment_description_stencil_layout = 1000241002,
    physical_device_host_query_reset_features = 1000261000,
    physical_device_timeline_semaphore_features = 1000207000,
    physical_device_timeline_semaphore_properties = 1000207001,
    semaphore_type_create_info = 1000207002,
    timeline_semaphore_submit_info = 1000207003,
    semaphore_wait_info = 1000207004,
    semaphore_signal_info = 1000207005,
    physical_device_buffer_device_address_features = 1000257000,
    buffer_device_address_info = 1000244001,
    buffer_opaque_capture_address_create_info = 1000257002,
    memory_opaque_capture_address_allocate_info = 1000257003,
    device_memory_opaque_capture_address_info = 1000257004,
    physical_device_vulkan_1_3_features = 53,
    physical_device_vulkan_1_3_properties = 54,
    pipeline_creation_feedback_create_info = 1000192000,
    physical_device_shader_terminate_invocation_features = 1000215000,
    physical_device_tool_properties = 1000245000,
    physical_device_shader_demote_to_helper_invocation_features = 1000276000,
    physical_device_private_data_features = 1000295000,
    device_private_data_create_info = 1000295001,
    private_data_slot_create_info = 1000295002,
    physical_device_pipeline_creation_cache_control_features = 1000297000,
    memory_barrier_2 = 1000314000,
    buffer_memory_barrier_2 = 1000314001,
    image_memory_barrier_2 = 1000314002,
    dependency_info = 1000314003,
    submit_info_2 = 1000314004,
    semaphore_submit_info = 1000314005,
    command_buffer_submit_info = 1000314006,
    physical_device_synchronization_2_features = 1000314007,
    physical_device_zero_initialize_workgroup_memory_features = 1000325000,
    physical_device_image_robustness_features = 1000335000,
    copy_buffer_info_2 = 1000337000,
    copy_image_info_2 = 1000337001,
    copy_buffer_to_image_info_2 = 1000337002,
    copy_image_to_buffer_info_2 = 1000337003,
    blit_image_info_2 = 1000337004,
    resolve_image_info_2 = 1000337005,
    buffer_copy_2 = 1000337006,
    image_copy_2 = 1000337007,
    image_blit_2 = 1000337008,
    buffer_image_copy_2 = 1000337009,
    image_resolve_2 = 1000337010,
    physical_device_subgroup_size_control_properties = 1000225000,
    pipeline_shader_stage_required_subgroup_size_create_info = 1000225001,
    physical_device_subgroup_size_control_features = 1000225002,
    physical_device_inline_uniform_block_features = 1000138000,
    physical_device_inline_uniform_block_properties = 1000138001,
    write_descriptor_set_inline_uniform_block = 1000138002,
    descriptor_pool_inline_uniform_block_create_info = 1000138003,
    physical_device_texture_compression_astc_hdr_features = 1000066000,
    rendering_info = 1000044000,
    rendering_attachment_info = 1000044001,
    pipeline_rendering_create_info = 1000044002,
    physical_device_dynamic_rendering_features = 1000044003,
    command_buffer_inheritance_rendering_info = 1000044004,
    physical_device_shader_integer_dot_product_features = 1000280000,
    physical_device_shader_integer_dot_product_properties = 1000280001,
    physical_device_texel_buffer_alignment_properties = 1000281001,
    format_properties_3 = 1000360000,
    physical_device_maintenance_4_features = 1000413000,
    physical_device_maintenance_4_properties = 1000413001,
    device_buffer_memory_requirements = 1000413002,
    device_image_memory_requirements = 1000413003,
    physical_device_vulkan_1_4_features = 55,
    physical_device_vulkan_1_4_properties = 56,
    device_queue_global_priority_create_info = 1000174000,
    physical_device_global_priority_query_features = 1000388000,
    queue_family_global_priority_properties = 1000388001,
    physical_device_shader_subgroup_rotate_features = 1000416000,
    physical_device_shader_float_controls_2_features = 1000528000,
    physical_device_shader_expect_assume_features = 1000544000,
    physical_device_line_rasterization_features = 1000259000,
    pipeline_rasterization_line_state_create_info = 1000259001,
    physical_device_line_rasterization_properties = 1000259002,
    physical_device_vertex_attribute_divisor_properties = 1000525000,
    pipeline_vertex_input_divisor_state_create_info = 1000190001,
    physical_device_vertex_attribute_divisor_features = 1000190002,
    physical_device_index_type_uint8_features = 1000265000,
    memory_map_info = 1000271000,
    memory_unmap_info = 1000271001,
    physical_device_maintenance_5_features = 1000470000,
    physical_device_maintenance_5_properties = 1000470001,
    rendering_area_info = 1000470003,
    device_image_subresource_info = 1000470004,
    subresource_layout_2 = 1000338002,
    image_subresource_2 = 1000338003,
    pipeline_create_flags_2_create_info = 1000470005,
    buffer_usage_flags_2_create_info = 1000470006,
    physical_device_push_descriptor_properties = 1000080000,
    physical_device_dynamic_rendering_local_read_features = 1000232000,
    rendering_attachment_location_info = 1000232001,
    rendering_input_attachment_index_info = 1000232002,
    physical_device_maintenance_6_features = 1000545000,
    physical_device_maintenance_6_properties = 1000545001,
    bind_memory_status = 1000545002,
    bind_descriptor_sets_info = 1000545003,
    push_constants_info = 1000545004,
    push_descriptor_set_info = 1000545005,
    push_descriptor_set_with_template_info = 1000545006,
    physical_device_pipeline_protected_access_features = 1000466000,
    pipeline_robustness_create_info = 1000068000,
    physical_device_pipeline_robustness_features = 1000068001,
    physical_device_pipeline_robustness_properties = 1000068002,
    physical_device_host_image_copy_features = 1000270000,
    physical_device_host_image_copy_properties = 1000270001,
    memory_to_image_copy = 1000270002,
    image_to_memory_copy = 1000270003,
    copy_image_to_memory_info = 1000270004,
    copy_memory_to_image_info = 1000270005,
    host_image_layout_transition_info = 1000270006,
    copy_image_to_image_info = 1000270007,
    subresource_host_memcpy_size = 1000270008,
    host_image_copy_device_performance_query = 1000270009,
    swapchain_create_info_khr = 1000001000,
    present_info_khr = 1000001001,
    device_group_present_capabilities_khr = 1000060007,
    image_swapchain_create_info_khr = 1000060008,
    bind_image_memory_swapchain_info_khr = 1000060009,
    acquire_next_image_info_khr = 1000060010,
    device_group_present_info_khr = 1000060011,
    device_group_swapchain_create_info_khr = 1000060012,
    display_mode_create_info_khr = 1000002000,
    display_surface_create_info_khr = 1000002001,
    display_present_info_khr = 1000003000,
    xlib_surface_create_info_khr = 1000004000,
    xcb_surface_create_info_khr = 1000005000,
    wayland_surface_create_info_khr = 1000006000,
    android_surface_create_info_khr = 1000008000,
    win32_surface_create_info_khr = 1000009000,
    debug_report_callback_create_info_ext = 1000011000,
    pipeline_rasterization_state_rasterization_order_amd = 1000018000,
    debug_marker_object_name_info_ext = 1000022000,
    debug_marker_object_tag_info_ext = 1000022001,
    debug_marker_marker_info_ext = 1000022002,
    dedicated_allocation_image_create_info_nv = 1000026000,
    dedicated_allocation_buffer_create_info_nv = 1000026001,
    dedicated_allocation_memory_allocate_info_nv = 1000026002,
    physical_device_transform_feedback_features_ext = 1000028000,
    physical_device_transform_feedback_properties_ext = 1000028001,
    pipeline_rasterization_state_stream_create_info_ext = 1000028002,
    cu_module_create_info_nvx = 1000029000,
    cu_function_create_info_nvx = 1000029001,
    cu_launch_info_nvx = 1000029002,
    cu_module_texturing_mode_create_info_nvx = 1000029004,
    image_view_handle_info_nvx = 1000030000,
    image_view_address_properties_nvx = 1000030001,
    texture_lod_gather_format_properties_amd = 1000041000,
    physical_device_corner_sampled_image_features_nv = 1000050000,
    external_memory_image_create_info_nv = 1000056000,
    export_memory_allocate_info_nv = 1000056001,
    import_memory_win32_handle_info_nv = 1000057000,
    export_memory_win32_handle_info_nv = 1000057001,
    win32_keyed_mutex_acquire_release_info_nv = 1000058000,
    validation_flags_ext = 1000061000,
    vi_surface_create_info_nn = 1000062000,
    image_view_astc_decode_mode_ext = 1000067000,
    physical_device_astc_decode_features_ext = 1000067001,
    import_memory_win32_handle_info_khr = 1000073000,
    export_memory_win32_handle_info_khr = 1000073001,
    memory_win32_handle_properties_khr = 1000073002,
    memory_get_win32_handle_info_khr = 1000073003,
    import_memory_fd_info_khr = 1000074000,
    memory_fd_properties_khr = 1000074001,
    memory_get_fd_info_khr = 1000074002,
    win32_keyed_mutex_acquire_release_info_khr = 1000075000,
    import_semaphore_win32_handle_info_khr = 1000078000,
    export_semaphore_win32_handle_info_khr = 1000078001,
    d3d12_fence_submit_info_khr = 1000078002,
    semaphore_get_win32_handle_info_khr = 1000078003,
    import_semaphore_fd_info_khr = 1000079000,
    semaphore_get_fd_info_khr = 1000079001,
    command_buffer_inheritance_conditional_rendering_info_ext = 1000081000,
    physical_device_conditional_rendering_features_ext = 1000081001,
    conditional_rendering_begin_info_ext = 1000081002,
    present_regions_khr = 1000084000,
    pipeline_viewport_w_scaling_state_create_info_nv = 1000087000,
    surface_capabilities_2_ext = 1000090000,
    display_power_info_ext = 1000091000,
    device_event_info_ext = 1000091001,
    display_event_info_ext = 1000091002,
    swapchain_counter_create_info_ext = 1000091003,
    present_times_info_google = 1000092000,
    physical_device_multiview_per_view_attributes_properties_nvx = 1000097000,
    multiview_per_view_attributes_info_nvx = 1000044009,
    pipeline_viewport_swizzle_state_create_info_nv = 1000098000,
    physical_device_discard_rectangle_properties_ext = 1000099000,
    pipeline_discard_rectangle_state_create_info_ext = 1000099001,
    physical_device_conservative_rasterization_properties_ext = 1000101000,
    pipeline_rasterization_conservative_state_create_info_ext = 1000101001,
    physical_device_depth_clip_enable_features_ext = 1000102000,
    pipeline_rasterization_depth_clip_state_create_info_ext = 1000102001,
    hdr_metadata_ext = 1000105000,
    physical_device_relaxed_line_rasterization_features_img = 1000110000,
    shared_present_surface_capabilities_khr = 1000111000,
    import_fence_win32_handle_info_khr = 1000114000,
    export_fence_win32_handle_info_khr = 1000114001,
    fence_get_win32_handle_info_khr = 1000114002,
    import_fence_fd_info_khr = 1000115000,
    fence_get_fd_info_khr = 1000115001,
    physical_device_performance_query_features_khr = 1000116000,
    physical_device_performance_query_properties_khr = 1000116001,
    query_pool_performance_create_info_khr = 1000116002,
    performance_query_submit_info_khr = 1000116003,
    acquire_profiling_lock_info_khr = 1000116004,
    performance_counter_khr = 1000116005,
    performance_counter_description_khr = 1000116006,
    physical_device_surface_info_2_khr = 1000119000,
    surface_capabilities_2_khr = 1000119001,
    surface_format_2_khr = 1000119002,
    display_properties_2_khr = 1000121000,
    display_plane_properties_2_khr = 1000121001,
    display_mode_properties_2_khr = 1000121002,
    display_plane_info_2_khr = 1000121003,
    display_plane_capabilities_2_khr = 1000121004,
    ios_surface_create_info_mvk = 1000122000,
    macos_surface_create_info_mvk = 1000123000,
    debug_utils_object_name_info_ext = 1000128000,
    debug_utils_object_tag_info_ext = 1000128001,
    debug_utils_label_ext = 1000128002,
    debug_utils_messenger_callback_data_ext = 1000128003,
    debug_utils_messenger_create_info_ext = 1000128004,
    android_hardware_buffer_usage_android = 1000129000,
    android_hardware_buffer_properties_android = 1000129001,
    android_hardware_buffer_format_properties_android = 1000129002,
    import_android_hardware_buffer_info_android = 1000129003,
    memory_get_android_hardware_buffer_info_android = 1000129004,
    external_format_android = 1000129005,
    android_hardware_buffer_format_properties_2_android = 1000129006,
    physical_device_shader_enqueue_features_amdx = 1000134000,
    physical_device_shader_enqueue_properties_amdx = 1000134001,
    execution_graph_pipeline_scratch_size_amdx = 1000134002,
    execution_graph_pipeline_create_info_amdx = 1000134003,
    pipeline_shader_stage_node_create_info_amdx = 1000134004,
    attachment_sample_count_info_amd = 1000044008,
    physical_device_shader_bfloat16_features_khr = 1000141000,
    sample_locations_info_ext = 1000143000,
    render_pass_sample_locations_begin_info_ext = 1000143001,
    pipeline_sample_locations_state_create_info_ext = 1000143002,
    physical_device_sample_locations_properties_ext = 1000143003,
    multisample_properties_ext = 1000143004,
    physical_device_blend_operation_advanced_features_ext = 1000148000,
    physical_device_blend_operation_advanced_properties_ext = 1000148001,
    pipeline_color_blend_advanced_state_create_info_ext = 1000148002,
    pipeline_coverage_to_color_state_create_info_nv = 1000149000,
    write_descriptor_set_acceleration_structure_khr = 1000150007,
    acceleration_structure_build_geometry_info_khr = 1000150000,
    acceleration_structure_device_address_info_khr = 1000150002,
    acceleration_structure_geometry_aabbs_data_khr = 1000150003,
    acceleration_structure_geometry_instances_data_khr = 1000150004,
    acceleration_structure_geometry_triangles_data_khr = 1000150005,
    acceleration_structure_geometry_khr = 1000150006,
    acceleration_structure_version_info_khr = 1000150009,
    copy_acceleration_structure_info_khr = 1000150010,
    copy_acceleration_structure_to_memory_info_khr = 1000150011,
    copy_memory_to_acceleration_structure_info_khr = 1000150012,
    physical_device_acceleration_structure_features_khr = 1000150013,
    physical_device_acceleration_structure_properties_khr = 1000150014,
    acceleration_structure_create_info_khr = 1000150017,
    acceleration_structure_build_sizes_info_khr = 1000150020,
    physical_device_ray_tracing_pipeline_features_khr = 1000347000,
    physical_device_ray_tracing_pipeline_properties_khr = 1000347001,
    ray_tracing_pipeline_create_info_khr = 1000150015,
    ray_tracing_shader_group_create_info_khr = 1000150016,
    ray_tracing_pipeline_interface_create_info_khr = 1000150018,
    physical_device_ray_query_features_khr = 1000348013,
    pipeline_coverage_modulation_state_create_info_nv = 1000152000,
    physical_device_shader_sm_builtins_features_nv = 1000154000,
    physical_device_shader_sm_builtins_properties_nv = 1000154001,
    drm_format_modifier_properties_list_ext = 1000158000,
    physical_device_image_drm_format_modifier_info_ext = 1000158002,
    image_drm_format_modifier_list_create_info_ext = 1000158003,
    image_drm_format_modifier_explicit_create_info_ext = 1000158004,
    image_drm_format_modifier_properties_ext = 1000158005,
    drm_format_modifier_properties_list_2_ext = 1000158006,
    validation_cache_create_info_ext = 1000160000,
    shader_module_validation_cache_create_info_ext = 1000160001,
    physical_device_portability_subset_features_khr = 1000163000,
    physical_device_portability_subset_properties_khr = 1000163001,
    pipeline_viewport_shading_rate_image_state_create_info_nv = 1000164000,
    physical_device_shading_rate_image_features_nv = 1000164001,
    physical_device_shading_rate_image_properties_nv = 1000164002,
    pipeline_viewport_coarse_sample_order_state_create_info_nv = 1000164005,
    ray_tracing_pipeline_create_info_nv = 1000165000,
    acceleration_structure_create_info_nv = 1000165001,
    geometry_nv = 1000165003,
    geometry_triangles_nv = 1000165004,
    geometry_aabb_nv = 1000165005,
    bind_acceleration_structure_memory_info_nv = 1000165006,
    write_descriptor_set_acceleration_structure_nv = 1000165007,
    acceleration_structure_memory_requirements_info_nv = 1000165008,
    physical_device_ray_tracing_properties_nv = 1000165009,
    ray_tracing_shader_group_create_info_nv = 1000165011,
    acceleration_structure_info_nv = 1000165012,
    physical_device_representative_fragment_test_features_nv = 1000166000,
    pipeline_representative_fragment_test_state_create_info_nv = 1000166001,
    physical_device_image_view_image_format_info_ext = 1000170000,
    filter_cubic_image_view_image_format_properties_ext = 1000170001,
    import_memory_host_pointer_info_ext = 1000178000,
    memory_host_pointer_properties_ext = 1000178001,
    physical_device_external_memory_host_properties_ext = 1000178002,
    physical_device_shader_clock_features_khr = 1000181000,
    pipeline_compiler_control_create_info_amd = 1000183000,
    physical_device_shader_core_properties_amd = 1000185000,
    device_memory_overallocation_create_info_amd = 1000189000,
    physical_device_vertex_attribute_divisor_properties_ext = 1000190000,
    physical_device_mesh_shader_features_nv = 1000202000,
    physical_device_mesh_shader_properties_nv = 1000202001,
    physical_device_shader_image_footprint_features_nv = 1000204000,
    pipeline_viewport_exclusive_scissor_state_create_info_nv = 1000205000,
    physical_device_exclusive_scissor_features_nv = 1000205002,
    checkpoint_data_nv = 1000206000,
    queue_family_checkpoint_properties_nv = 1000206001,
    queue_family_checkpoint_properties_2_nv = 1000314008,
    checkpoint_data_2_nv = 1000314009,
    physical_device_shader_integer_functions_2_features_intel = 1000209000,
    query_pool_performance_query_create_info_intel = 1000210000,
    initialize_performance_api_info_intel = 1000210001,
    performance_marker_info_intel = 1000210002,
    performance_stream_marker_info_intel = 1000210003,
    performance_override_info_intel = 1000210004,
    performance_configuration_acquire_info_intel = 1000210005,
    physical_device_pci_bus_info_properties_ext = 1000212000,
    display_native_hdr_surface_capabilities_amd = 1000213000,
    swapchain_display_native_hdr_create_info_amd = 1000213001,
    imagepipe_surface_create_info_fuchsia = 1000214000,
    metal_surface_create_info_ext = 1000217000,
    physical_device_fragment_density_map_features_ext = 1000218000,
    physical_device_fragment_density_map_properties_ext = 1000218001,
    render_pass_fragment_density_map_create_info_ext = 1000218002,
    rendering_fragment_density_map_attachment_info_ext = 1000044007,
    fragment_shading_rate_attachment_info_khr = 1000226000,
    pipeline_fragment_shading_rate_state_create_info_khr = 1000226001,
    physical_device_fragment_shading_rate_properties_khr = 1000226002,
    physical_device_fragment_shading_rate_features_khr = 1000226003,
    physical_device_fragment_shading_rate_khr = 1000226004,
    rendering_fragment_shading_rate_attachment_info_khr = 1000044006,
    physical_device_shader_core_properties_2_amd = 1000227000,
    physical_device_coherent_memory_features_amd = 1000229000,
    physical_device_shader_image_atomic_int64_features_ext = 1000234000,
    physical_device_shader_quad_control_features_khr = 1000235000,
    physical_device_memory_budget_properties_ext = 1000237000,
    physical_device_memory_priority_features_ext = 1000238000,
    memory_priority_allocate_info_ext = 1000238001,
    surface_protected_capabilities_khr = 1000239000,
    physical_device_dedicated_allocation_image_aliasing_features_nv = 1000240000,
    physical_device_buffer_device_address_features_ext = 1000244000,
    buffer_device_address_create_info_ext = 1000244002,
    validation_features_ext = 1000247000,
    physical_device_present_wait_features_khr = 1000248000,
    physical_device_cooperative_matrix_features_nv = 1000249000,
    cooperative_matrix_properties_nv = 1000249001,
    physical_device_cooperative_matrix_properties_nv = 1000249002,
    physical_device_coverage_reduction_mode_features_nv = 1000250000,
    pipeline_coverage_reduction_state_create_info_nv = 1000250001,
    framebuffer_mixed_samples_combination_nv = 1000250002,
    physical_device_fragment_shader_interlock_features_ext = 1000251000,
    physical_device_ycbcr_image_arrays_features_ext = 1000252000,
    physical_device_provoking_vertex_features_ext = 1000254000,
    pipeline_rasterization_provoking_vertex_state_create_info_ext = 1000254001,
    physical_device_provoking_vertex_properties_ext = 1000254002,
    surface_full_screen_exclusive_info_ext = 1000255000,
    surface_capabilities_full_screen_exclusive_ext = 1000255002,
    surface_full_screen_exclusive_win32_info_ext = 1000255001,
    headless_surface_create_info_ext = 1000256000,
    physical_device_shader_atomic_float_features_ext = 1000260000,
    physical_device_extended_dynamic_state_features_ext = 1000267000,
    physical_device_pipeline_executable_properties_features_khr = 1000269000,
    pipeline_info_khr = 1000269001,
    pipeline_executable_properties_khr = 1000269002,
    pipeline_executable_info_khr = 1000269003,
    pipeline_executable_statistic_khr = 1000269004,
    pipeline_executable_internal_representation_khr = 1000269005,
    physical_device_map_memory_placed_features_ext = 1000272000,
    physical_device_map_memory_placed_properties_ext = 1000272001,
    memory_map_placed_info_ext = 1000272002,
    physical_device_shader_atomic_float_2_features_ext = 1000273000,
    physical_device_device_generated_commands_properties_nv = 1000277000,
    graphics_shader_group_create_info_nv = 1000277001,
    graphics_pipeline_shader_groups_create_info_nv = 1000277002,
    indirect_commands_layout_token_nv = 1000277003,
    indirect_commands_layout_create_info_nv = 1000277004,
    generated_commands_info_nv = 1000277005,
    generated_commands_memory_requirements_info_nv = 1000277006,
    physical_device_device_generated_commands_features_nv = 1000277007,
    physical_device_inherited_viewport_scissor_features_nv = 1000278000,
    command_buffer_inheritance_viewport_scissor_info_nv = 1000278001,
    physical_device_texel_buffer_alignment_features_ext = 1000281000,
    command_buffer_inheritance_render_pass_transform_info_qcom = 1000282000,
    render_pass_transform_begin_info_qcom = 1000282001,
    physical_device_depth_bias_control_features_ext = 1000283000,
    depth_bias_info_ext = 1000283001,
    depth_bias_representation_info_ext = 1000283002,
    physical_device_device_memory_report_features_ext = 1000284000,
    device_device_memory_report_create_info_ext = 1000284001,
    device_memory_report_callback_data_ext = 1000284002,
    sampler_custom_border_color_create_info_ext = 1000287000,
    physical_device_custom_border_color_properties_ext = 1000287001,
    physical_device_custom_border_color_features_ext = 1000287002,
    pipeline_library_create_info_khr = 1000290000,
    physical_device_present_barrier_features_nv = 1000292000,
    surface_capabilities_present_barrier_nv = 1000292001,
    swapchain_present_barrier_create_info_nv = 1000292002,
    present_id_khr = 1000294000,
    physical_device_present_id_features_khr = 1000294001,
    physical_device_diagnostics_config_features_nv = 1000300000,
    device_diagnostics_config_create_info_nv = 1000300001,
    cuda_module_create_info_nv = 1000307000,
    cuda_function_create_info_nv = 1000307001,
    cuda_launch_info_nv = 1000307002,
    physical_device_cuda_kernel_launch_features_nv = 1000307003,
    physical_device_cuda_kernel_launch_properties_nv = 1000307004,
    physical_device_tile_shading_features_qcom = 1000309000,
    physical_device_tile_shading_properties_qcom = 1000309001,
    render_pass_tile_shading_create_info_qcom = 1000309002,
    per_tile_begin_info_qcom = 1000309003,
    per_tile_end_info_qcom = 1000309004,
    dispatch_tile_info_qcom = 1000309005,
    query_low_latency_support_nv = 1000310000,
    export_metal_object_create_info_ext = 1000311000,
    export_metal_objects_info_ext = 1000311001,
    export_metal_device_info_ext = 1000311002,
    export_metal_command_queue_info_ext = 1000311003,
    export_metal_buffer_info_ext = 1000311004,
    import_metal_buffer_info_ext = 1000311005,
    export_metal_texture_info_ext = 1000311006,
    import_metal_texture_info_ext = 1000311007,
    export_metal_io_surface_info_ext = 1000311008,
    import_metal_io_surface_info_ext = 1000311009,
    export_metal_shared_event_info_ext = 1000311010,
    import_metal_shared_event_info_ext = 1000311011,
    physical_device_descriptor_buffer_properties_ext = 1000316000,
    physical_device_descriptor_buffer_density_map_properties_ext = 1000316001,
    physical_device_descriptor_buffer_features_ext = 1000316002,
    descriptor_address_info_ext = 1000316003,
    descriptor_get_info_ext = 1000316004,
    buffer_capture_descriptor_data_info_ext = 1000316005,
    image_capture_descriptor_data_info_ext = 1000316006,
    image_view_capture_descriptor_data_info_ext = 1000316007,
    sampler_capture_descriptor_data_info_ext = 1000316008,
    opaque_capture_descriptor_data_create_info_ext = 1000316010,
    descriptor_buffer_binding_info_ext = 1000316011,
    descriptor_buffer_binding_push_descriptor_buffer_handle_ext = 1000316012,
    acceleration_structure_capture_descriptor_data_info_ext = 1000316009,
    physical_device_graphics_pipeline_library_features_ext = 1000320000,
    physical_device_graphics_pipeline_library_properties_ext = 1000320001,
    graphics_pipeline_library_create_info_ext = 1000320002,
    physical_device_shader_early_and_late_fragment_tests_features_amd = 1000321000,
    physical_device_fragment_shader_barycentric_features_khr = 1000203000,
    physical_device_fragment_shader_barycentric_properties_khr = 1000322000,
    physical_device_shader_subgroup_uniform_control_flow_features_khr = 1000323000,
    physical_device_fragment_shading_rate_enums_properties_nv = 1000326000,
    physical_device_fragment_shading_rate_enums_features_nv = 1000326001,
    pipeline_fragment_shading_rate_enum_state_create_info_nv = 1000326002,
    acceleration_structure_geometry_motion_triangles_data_nv = 1000327000,
    physical_device_ray_tracing_motion_blur_features_nv = 1000327001,
    acceleration_structure_motion_info_nv = 1000327002,
    physical_device_mesh_shader_features_ext = 1000328000,
    physical_device_mesh_shader_properties_ext = 1000328001,
    physical_device_ycbcr_2_plane_444_formats_features_ext = 1000330000,
    physical_device_fragment_density_map_2_features_ext = 1000332000,
    physical_device_fragment_density_map_2_properties_ext = 1000332001,
    copy_command_transform_info_qcom = 1000333000,
    physical_device_workgroup_memory_explicit_layout_features_khr = 1000336000,
    physical_device_image_compression_control_features_ext = 1000338000,
    image_compression_control_ext = 1000338001,
    image_compression_properties_ext = 1000338004,
    physical_device_attachment_feedback_loop_layout_features_ext = 1000339000,
    physical_device_4444_formats_features_ext = 1000340000,
    physical_device_fault_features_ext = 1000341000,
    device_fault_counts_ext = 1000341001,
    device_fault_info_ext = 1000341002,
    physical_device_rgba10x6_formats_features_ext = 1000344000,
    directfb_surface_create_info_ext = 1000346000,
    physical_device_vertex_input_dynamic_state_features_ext = 1000352000,
    vertex_input_binding_description_2_ext = 1000352001,
    vertex_input_attribute_description_2_ext = 1000352002,
    physical_device_drm_properties_ext = 1000353000,
    physical_device_address_binding_report_features_ext = 1000354000,
    device_address_binding_callback_data_ext = 1000354001,
    physical_device_depth_clip_control_features_ext = 1000355000,
    pipeline_viewport_depth_clip_control_create_info_ext = 1000355001,
    physical_device_primitive_topology_list_restart_features_ext = 1000356000,
    import_memory_zircon_handle_info_fuchsia = 1000364000,
    memory_zircon_handle_properties_fuchsia = 1000364001,
    memory_get_zircon_handle_info_fuchsia = 1000364002,
    import_semaphore_zircon_handle_info_fuchsia = 1000365000,
    semaphore_get_zircon_handle_info_fuchsia = 1000365001,
    buffer_collection_create_info_fuchsia = 1000366000,
    import_memory_buffer_collection_fuchsia = 1000366001,
    buffer_collection_image_create_info_fuchsia = 1000366002,
    buffer_collection_properties_fuchsia = 1000366003,
    buffer_constraints_info_fuchsia = 1000366004,
    buffer_collection_buffer_create_info_fuchsia = 1000366005,
    image_constraints_info_fuchsia = 1000366006,
    image_format_constraints_info_fuchsia = 1000366007,
    sysmem_color_space_fuchsia = 1000366008,
    buffer_collection_constraints_info_fuchsia = 1000366009,
    subpass_shading_pipeline_create_info_huawei = 1000369000,
    physical_device_subpass_shading_features_huawei = 1000369001,
    physical_device_subpass_shading_properties_huawei = 1000369002,
    physical_device_invocation_mask_features_huawei = 1000370000,
    memory_get_remote_address_info_nv = 1000371000,
    physical_device_external_memory_rdma_features_nv = 1000371001,
    pipeline_properties_identifier_ext = 1000372000,
    physical_device_pipeline_properties_features_ext = 1000372001,
    physical_device_frame_boundary_features_ext = 1000375000,
    frame_boundary_ext = 1000375001,
    physical_device_multisampled_render_to_single_sampled_features_ext = 1000376000,
    subpass_resolve_performance_query_ext = 1000376001,
    multisampled_render_to_single_sampled_info_ext = 1000376002,
    physical_device_extended_dynamic_state_2_features_ext = 1000377000,
    physical_device_color_write_enable_features_ext = 1000381000,
    pipeline_color_write_create_info_ext = 1000381001,
    physical_device_primitives_generated_query_features_ext = 1000382000,
    physical_device_ray_tracing_maintenance_1_features_khr = 1000386000,
    physical_device_shader_untyped_pointers_features_khr = 1000387000,
    physical_device_image_view_min_lod_features_ext = 1000391000,
    image_view_min_lod_create_info_ext = 1000391001,
    physical_device_multi_draw_features_ext = 1000392000,
    physical_device_multi_draw_properties_ext = 1000392001,
    physical_device_image_2d_view_of_3d_features_ext = 1000393000,
    physical_device_shader_tile_image_features_ext = 1000395000,
    physical_device_shader_tile_image_properties_ext = 1000395001,
    micromap_build_info_ext = 1000396000,
    micromap_version_info_ext = 1000396001,
    copy_micromap_info_ext = 1000396002,
    copy_micromap_to_memory_info_ext = 1000396003,
    copy_memory_to_micromap_info_ext = 1000396004,
    physical_device_opacity_micromap_features_ext = 1000396005,
    physical_device_opacity_micromap_properties_ext = 1000396006,
    micromap_create_info_ext = 1000396007,
    micromap_build_sizes_info_ext = 1000396008,
    acceleration_structure_triangles_opacity_micromap_ext = 1000396009,
    physical_device_displacement_micromap_features_nv = 1000397000,
    physical_device_displacement_micromap_properties_nv = 1000397001,
    acceleration_structure_triangles_displacement_micromap_nv = 1000397002,
    physical_device_cluster_culling_shader_features_huawei = 1000404000,
    physical_device_cluster_culling_shader_properties_huawei = 1000404001,
    physical_device_cluster_culling_shader_vrs_features_huawei = 1000404002,
    physical_device_border_color_swizzle_features_ext = 1000411000,
    sampler_border_color_component_mapping_create_info_ext = 1000411001,
    physical_device_pageable_device_local_memory_features_ext = 1000412000,
    physical_device_shader_core_properties_arm = 1000415000,
    device_queue_shader_core_control_create_info_arm = 1000417000,
    physical_device_scheduling_controls_features_arm = 1000417001,
    physical_device_scheduling_controls_properties_arm = 1000417002,
    physical_device_image_sliced_view_of_3d_features_ext = 1000418000,
    image_view_sliced_create_info_ext = 1000418001,
    physical_device_descriptor_set_host_mapping_features_valve = 1000420000,
    descriptor_set_binding_reference_valve = 1000420001,
    descriptor_set_layout_host_mapping_info_valve = 1000420002,
    physical_device_non_seamless_cube_map_features_ext = 1000422000,
    physical_device_render_pass_striped_features_arm = 1000424000,
    physical_device_render_pass_striped_properties_arm = 1000424001,
    render_pass_stripe_begin_info_arm = 1000424002,
    render_pass_stripe_info_arm = 1000424003,
    render_pass_stripe_submit_info_arm = 1000424004,
    physical_device_copy_memory_indirect_features_nv = 1000426000,
    physical_device_copy_memory_indirect_properties_nv = 1000426001,
    physical_device_memory_decompression_features_nv = 1000427000,
    physical_device_memory_decompression_properties_nv = 1000427001,
    physical_device_device_generated_commands_compute_features_nv = 1000428000,
    compute_pipeline_indirect_buffer_info_nv = 1000428001,
    pipeline_indirect_device_address_info_nv = 1000428002,
    physical_device_ray_tracing_linear_swept_spheres_features_nv = 1000429008,
    acceleration_structure_geometry_linear_swept_spheres_data_nv = 1000429009,
    acceleration_structure_geometry_spheres_data_nv = 1000429010,
    physical_device_linear_color_attachment_features_nv = 1000430000,
    physical_device_shader_maximal_reconvergence_features_khr = 1000434000,
    physical_device_image_compression_control_swapchain_features_ext = 1000437000,
    physical_device_image_processing_features_qcom = 1000440000,
    physical_device_image_processing_properties_qcom = 1000440001,
    image_view_sample_weight_create_info_qcom = 1000440002,
    physical_device_nested_command_buffer_features_ext = 1000451000,
    physical_device_nested_command_buffer_properties_ext = 1000451001,
    external_memory_acquire_unmodified_ext = 1000453000,
    physical_device_extended_dynamic_state_3_features_ext = 1000455000,
    physical_device_extended_dynamic_state_3_properties_ext = 1000455001,
    physical_device_subpass_merge_feedback_features_ext = 1000458000,
    render_pass_creation_control_ext = 1000458001,
    render_pass_creation_feedback_create_info_ext = 1000458002,
    render_pass_subpass_feedback_create_info_ext = 1000458003,
    direct_driver_loading_info_lunarg = 1000459000,
    direct_driver_loading_list_lunarg = 1000459001,
    tensor_create_info_arm = 1000460000,
    tensor_view_create_info_arm = 1000460001,
    bind_tensor_memory_info_arm = 1000460002,
    write_descriptor_set_tensor_arm = 1000460003,
    physical_device_tensor_properties_arm = 1000460004,
    tensor_format_properties_arm = 1000460005,
    tensor_description_arm = 1000460006,
    tensor_memory_requirements_info_arm = 1000460007,
    tensor_memory_barrier_arm = 1000460008,
    physical_device_tensor_features_arm = 1000460009,
    device_tensor_memory_requirements_arm = 1000460010,
    copy_tensor_info_arm = 1000460011,
    tensor_copy_arm = 1000460012,
    tensor_dependency_info_arm = 1000460013,
    memory_dedicated_allocate_info_tensor_arm = 1000460014,
    physical_device_external_tensor_info_arm = 1000460015,
    external_tensor_properties_arm = 1000460016,
    external_memory_tensor_create_info_arm = 1000460017,
    physical_device_descriptor_buffer_tensor_features_arm = 1000460018,
    physical_device_descriptor_buffer_tensor_properties_arm = 1000460019,
    descriptor_get_tensor_info_arm = 1000460020,
    tensor_capture_descriptor_data_info_arm = 1000460021,
    tensor_view_capture_descriptor_data_info_arm = 1000460022,
    frame_boundary_tensors_arm = 1000460023,
    physical_device_shader_module_identifier_features_ext = 1000462000,
    physical_device_shader_module_identifier_properties_ext = 1000462001,
    pipeline_shader_stage_module_identifier_create_info_ext = 1000462002,
    shader_module_identifier_ext = 1000462003,
    physical_device_rasterization_order_attachment_access_features_ext = 1000342000,
    physical_device_optical_flow_features_nv = 1000464000,
    physical_device_optical_flow_properties_nv = 1000464001,
    optical_flow_image_format_info_nv = 1000464002,
    optical_flow_image_format_properties_nv = 1000464003,
    optical_flow_session_create_info_nv = 1000464004,
    optical_flow_execute_info_nv = 1000464005,
    optical_flow_session_create_private_data_info_nv = 1000464010,
    physical_device_legacy_dithering_features_ext = 1000465000,
    physical_device_external_format_resolve_features_android = 1000468000,
    physical_device_external_format_resolve_properties_android = 1000468001,
    android_hardware_buffer_format_resolve_properties_android = 1000468002,
    physical_device_anti_lag_features_amd = 1000476000,
    anti_lag_data_amd = 1000476001,
    anti_lag_presentation_info_amd = 1000476002,
    physical_device_dense_geometry_format_features_amdx = 1000478000,
    acceleration_structure_dense_geometry_format_triangles_data_amdx = 1000478001,
    surface_capabilities_present_id_2_khr = 1000479000,
    present_id_2_khr = 1000479001,
    physical_device_present_id_2_features_khr = 1000479002,
    surface_capabilities_present_wait_2_khr = 1000480000,
    physical_device_present_wait_2_features_khr = 1000480001,
    present_wait_2_info_khr = 1000480002,
    physical_device_ray_tracing_position_fetch_features_khr = 1000481000,
    physical_device_shader_object_features_ext = 1000482000,
    physical_device_shader_object_properties_ext = 1000482001,
    shader_create_info_ext = 1000482002,
    physical_device_pipeline_binary_features_khr = 1000483000,
    pipeline_binary_create_info_khr = 1000483001,
    pipeline_binary_info_khr = 1000483002,
    pipeline_binary_key_khr = 1000483003,
    physical_device_pipeline_binary_properties_khr = 1000483004,
    release_captured_pipeline_data_info_khr = 1000483005,
    pipeline_binary_data_info_khr = 1000483006,
    pipeline_create_info_khr = 1000483007,
    device_pipeline_binary_internal_cache_control_khr = 1000483008,
    pipeline_binary_handles_info_khr = 1000483009,
    physical_device_tile_properties_features_qcom = 1000484000,
    tile_properties_qcom = 1000484001,
    physical_device_amigo_profiling_features_sec = 1000485000,
    amigo_profiling_submit_info_sec = 1000485001,
    surface_present_mode_khr = 1000274000,
    surface_present_scaling_capabilities_khr = 1000274001,
    surface_present_mode_compatibility_khr = 1000274002,
    physical_device_swapchain_maintenance_1_features_khr = 1000275000,
    swapchain_present_fence_info_khr = 1000275001,
    swapchain_present_modes_create_info_khr = 1000275002,
    swapchain_present_mode_info_khr = 1000275003,
    swapchain_present_scaling_create_info_khr = 1000275004,
    release_swapchain_images_info_khr = 1000275005,
    physical_device_multiview_per_view_viewports_features_qcom = 1000488000,
    physical_device_ray_tracing_invocation_reorder_features_nv = 1000490000,
    physical_device_ray_tracing_invocation_reorder_properties_nv = 1000490001,
    physical_device_cooperative_vector_features_nv = 1000491000,
    physical_device_cooperative_vector_properties_nv = 1000491001,
    cooperative_vector_properties_nv = 1000491002,
    convert_cooperative_vector_matrix_info_nv = 1000491004,
    physical_device_extended_sparse_address_space_features_nv = 1000492000,
    physical_device_extended_sparse_address_space_properties_nv = 1000492001,
    physical_device_mutable_descriptor_type_features_ext = 1000351000,
    mutable_descriptor_type_create_info_ext = 1000351002,
    physical_device_legacy_vertex_attributes_features_ext = 1000495000,
    physical_device_legacy_vertex_attributes_properties_ext = 1000495001,
    layer_settings_create_info_ext = 1000496000,
    physical_device_shader_core_builtins_features_arm = 1000497000,
    physical_device_shader_core_builtins_properties_arm = 1000497001,
    physical_device_pipeline_library_group_handles_features_ext = 1000498000,
    physical_device_dynamic_rendering_unused_attachments_features_ext = 1000499000,
    latency_sleep_mode_info_nv = 1000505000,
    latency_sleep_info_nv = 1000505001,
    set_latency_marker_info_nv = 1000505002,
    get_latency_marker_info_nv = 1000505003,
    latency_timings_frame_report_nv = 1000505004,
    latency_submission_present_id_nv = 1000505005,
    out_of_band_queue_type_info_nv = 1000505006,
    swapchain_latency_create_info_nv = 1000505007,
    latency_surface_capabilities_nv = 1000505008,
    physical_device_cooperative_matrix_features_khr = 1000506000,
    cooperative_matrix_properties_khr = 1000506001,
    physical_device_cooperative_matrix_properties_khr = 1000506002,
    data_graph_pipeline_create_info_arm = 1000507000,
    data_graph_pipeline_session_create_info_arm = 1000507001,
    data_graph_pipeline_resource_info_arm = 1000507002,
    data_graph_pipeline_constant_arm = 1000507003,
    data_graph_pipeline_session_memory_requirements_info_arm = 1000507004,
    bind_data_graph_pipeline_session_memory_info_arm = 1000507005,
    physical_device_data_graph_features_arm = 1000507006,
    data_graph_pipeline_shader_module_create_info_arm = 1000507007,
    data_graph_pipeline_property_query_result_arm = 1000507008,
    data_graph_pipeline_info_arm = 1000507009,
    data_graph_pipeline_compiler_control_create_info_arm = 1000507010,
    data_graph_pipeline_session_bind_point_requirements_info_arm = 1000507011,
    data_graph_pipeline_session_bind_point_requirement_arm = 1000507012,
    data_graph_pipeline_identifier_create_info_arm = 1000507013,
    data_graph_pipeline_dispatch_info_arm = 1000507014,
    data_graph_processing_engine_create_info_arm = 1000507016,
    queue_family_data_graph_processing_engine_properties_arm = 1000507017,
    queue_family_data_graph_properties_arm = 1000507018,
    physical_device_queue_family_data_graph_processing_engine_info_arm = 1000507019,
    data_graph_pipeline_constant_tensor_semi_structured_sparsity_info_arm = 1000507015,
    physical_device_multiview_per_view_render_areas_features_qcom = 1000510000,
    multiview_per_view_render_areas_render_pass_begin_info_qcom = 1000510001,
    physical_device_compute_shader_derivatives_features_khr = 1000201000,
    physical_device_compute_shader_derivatives_properties_khr = 1000511000,
    physical_device_per_stage_descriptor_set_features_nv = 1000516000,
    physical_device_image_processing_2_features_qcom = 1000518000,
    physical_device_image_processing_2_properties_qcom = 1000518001,
    sampler_block_match_window_create_info_qcom = 1000518002,
    sampler_cubic_weights_create_info_qcom = 1000519000,
    physical_device_cubic_weights_features_qcom = 1000519001,
    blit_image_cubic_weights_info_qcom = 1000519002,
    physical_device_ycbcr_degamma_features_qcom = 1000520000,
    sampler_ycbcr_conversion_ycbcr_degamma_create_info_qcom = 1000520001,
    physical_device_cubic_clamp_features_qcom = 1000521000,
    physical_device_attachment_feedback_loop_dynamic_state_features_ext = 1000524000,
    physical_device_unified_image_layouts_features_khr = 1000527000,
    attachment_feedback_loop_info_ext = 1000527001,
    physical_device_layered_driver_properties_msft = 1000530000,
    calibrated_timestamp_info_khr = 1000184000,
    set_descriptor_buffer_offsets_info_ext = 1000545007,
    bind_descriptor_buffer_embedded_samplers_info_ext = 1000545008,
    physical_device_descriptor_pool_overallocation_features_nv = 1000546000,
    physical_device_tile_memory_heap_features_qcom = 1000547000,
    physical_device_tile_memory_heap_properties_qcom = 1000547001,
    tile_memory_requirements_qcom = 1000547002,
    tile_memory_bind_info_qcom = 1000547003,
    tile_memory_size_info_qcom = 1000547004,
    display_surface_stereo_create_info_nv = 1000551000,
    display_mode_stereo_properties_nv = 1000551001,
    physical_device_raw_access_chains_features_nv = 1000555000,
    external_compute_queue_device_create_info_nv = 1000556000,
    external_compute_queue_create_info_nv = 1000556001,
    external_compute_queue_data_params_nv = 1000556002,
    physical_device_external_compute_queue_properties_nv = 1000556003,
    physical_device_shader_relaxed_extended_instruction_features_khr = 1000558000,
    physical_device_command_buffer_inheritance_features_nv = 1000559000,
    physical_device_maintenance_7_features_khr = 1000562000,
    physical_device_maintenance_7_properties_khr = 1000562001,
    physical_device_layered_api_properties_list_khr = 1000562002,
    physical_device_layered_api_properties_khr = 1000562003,
    physical_device_layered_api_vulkan_properties_khr = 1000562004,
    physical_device_shader_atomic_float16_vector_features_nv = 1000563000,
    physical_device_shader_replicated_composites_features_ext = 1000564000,
    physical_device_shader_float8_features_ext = 1000567000,
    physical_device_ray_tracing_validation_features_nv = 1000568000,
    physical_device_cluster_acceleration_structure_features_nv = 1000569000,
    physical_device_cluster_acceleration_structure_properties_nv = 1000569001,
    cluster_acceleration_structure_clusters_bottom_level_input_nv = 1000569002,
    cluster_acceleration_structure_triangle_cluster_input_nv = 1000569003,
    cluster_acceleration_structure_move_objects_input_nv = 1000569004,
    cluster_acceleration_structure_input_info_nv = 1000569005,
    cluster_acceleration_structure_commands_info_nv = 1000569006,
    ray_tracing_pipeline_cluster_acceleration_structure_create_info_nv = 1000569007,
    physical_device_partitioned_acceleration_structure_features_nv = 1000570000,
    physical_device_partitioned_acceleration_structure_properties_nv = 1000570001,
    write_descriptor_set_partitioned_acceleration_structure_nv = 1000570002,
    partitioned_acceleration_structure_instances_input_nv = 1000570003,
    build_partitioned_acceleration_structure_info_nv = 1000570004,
    partitioned_acceleration_structure_flags_nv = 1000570005,
    physical_device_device_generated_commands_features_ext = 1000572000,
    physical_device_device_generated_commands_properties_ext = 1000572001,
    generated_commands_memory_requirements_info_ext = 1000572002,
    indirect_execution_set_create_info_ext = 1000572003,
    generated_commands_info_ext = 1000572004,
    indirect_commands_layout_create_info_ext = 1000572006,
    indirect_commands_layout_token_ext = 1000572007,
    write_indirect_execution_set_pipeline_ext = 1000572008,
    write_indirect_execution_set_shader_ext = 1000572009,
    indirect_execution_set_pipeline_info_ext = 1000572010,
    indirect_execution_set_shader_info_ext = 1000572011,
    indirect_execution_set_shader_layout_info_ext = 1000572012,
    generated_commands_pipeline_info_ext = 1000572013,
    generated_commands_shader_info_ext = 1000572014,
    physical_device_maintenance_8_features_khr = 1000574000,
    memory_barrier_access_flags_3_khr = 1000574002,
    physical_device_image_alignment_control_features_mesa = 1000575000,
    physical_device_image_alignment_control_properties_mesa = 1000575001,
    image_alignment_control_create_info_mesa = 1000575002,
    physical_device_depth_clamp_control_features_ext = 1000582000,
    pipeline_viewport_depth_clamp_control_create_info_ext = 1000582001,
    physical_device_maintenance_9_features_khr = 1000584000,
    physical_device_maintenance_9_properties_khr = 1000584001,
    queue_family_ownership_transfer_properties_khr = 1000584002,
    surface_create_info_ohos = 1000685000,
    physical_device_hdr_vivid_features_huawei = 1000590000,
    hdr_vivid_dynamic_metadata_huawei = 1000590001,
    physical_device_cooperative_matrix_2_features_nv = 1000593000,
    cooperative_matrix_flexible_dimensions_properties_nv = 1000593001,
    physical_device_cooperative_matrix_2_properties_nv = 1000593002,
    physical_device_pipeline_opacity_micromap_features_arm = 1000596000,
    import_memory_metal_handle_info_ext = 1000602000,
    memory_metal_handle_properties_ext = 1000602001,
    memory_get_metal_handle_info_ext = 1000602002,
    physical_device_depth_clamp_zero_one_features_khr = 1000421000,
    physical_device_vertex_attribute_robustness_features_ext = 1000608000,
    physical_device_format_pack_features_arm = 1000609000,
    physical_device_fragment_density_map_layered_features_valve = 1000611000,
    physical_device_fragment_density_map_layered_properties_valve = 1000611001,
    pipeline_fragment_density_map_layered_create_info_valve = 1000611002,
    physical_device_robustness_2_features_khr = 1000286000,
    physical_device_robustness_2_properties_khr = 1000286001,
    set_present_config_nv = 1000613000,
    physical_device_present_metering_features_nv = 1000613001,
    physical_device_fragment_density_map_offset_features_ext = 1000425000,
    physical_device_fragment_density_map_offset_properties_ext = 1000425001,
    render_pass_fragment_density_map_offset_end_info_ext = 1000425002,
    rendering_end_info_ext = 1000619003,
    physical_device_zero_initialize_device_memory_features_ext = 1000620000,
    physical_device_present_mode_fifo_latest_ready_features_khr = 1000361000,
    physical_device_pipeline_cache_incremental_mode_features_sec = 1000637000,
    _,
};
pub const SystemAllocationScope = enum(i32) {
    command = 0,
    object = 1,
    cache = 2,
    device = 3,
    instance = 4,
    _,
};
pub const InternalAllocationType = enum(i32) {
    executable = 0,
    _,
};
pub const SamplerAddressMode = enum(i32) {
    repeat = 0,
    mirrored_repeat = 1,
    clamp_to_edge = 2,
    clamp_to_border = 3,
    mirror_clamp_to_edge = 4,
    _,
};
pub const Filter = enum(i32) {
    nearest = 0,
    linear = 1,
    cubic_ext = 1000015000,
    _,
};
pub const SamplerMipmapMode = enum(i32) {
    nearest = 0,
    linear = 1,
    _,
};
pub const VertexInputRate = enum(i32) {
    vertex = 0,
    instance = 1,
    _,
};
pub const ClusterAccelerationStructureTypeNV = enum(i32) {
    clusters_bottom_level = 0,
    triangle_cluster = 1,
    triangle_cluster_template = 2,
    _,
};
pub const ClusterAccelerationStructureOpTypeNV = enum(i32) {
    move_objects = 0,
    build_clusters_bottom_level = 1,
    build_triangle_cluster = 2,
    build_triangle_cluster_template = 3,
    instantiate_triangle_cluster = 4,
    get_cluster_template_indices = 5,
    _,
};
pub const ClusterAccelerationStructureOpModeNV = enum(i32) {
    implicit_destinations = 0,
    explicit_destinations = 1,
    compute_sizes = 2,
    _,
};
pub const ObjectType = enum(i32) {
    unknown = 0,
    instance = 1,
    physical_device = 2,
    device = 3,
    queue = 4,
    semaphore = 5,
    command_buffer = 6,
    fence = 7,
    device_memory = 8,
    buffer = 9,
    image = 10,
    event = 11,
    query_pool = 12,
    buffer_view = 13,
    image_view = 14,
    shader_module = 15,
    pipeline_cache = 16,
    pipeline_layout = 17,
    render_pass = 18,
    pipeline = 19,
    descriptor_set_layout = 20,
    sampler = 21,
    descriptor_pool = 22,
    descriptor_set = 23,
    framebuffer = 24,
    command_pool = 25,
    sampler_ycbcr_conversion = 1000156000,
    descriptor_update_template = 1000085000,
    private_data_slot = 1000295000,
    surface_khr = 1000000000,
    swapchain_khr = 1000001000,
    display_khr = 1000002000,
    display_mode_khr = 1000002001,
    debug_report_callback_ext = 1000011000,
    cu_module_nvx = 1000029000,
    cu_function_nvx = 1000029001,
    debug_utils_messenger_ext = 1000128000,
    acceleration_structure_khr = 1000150000,
    validation_cache_ext = 1000160000,
    acceleration_structure_nv = 1000165000,
    performance_configuration_intel = 1000210000,
    deferred_operation_khr = 1000268000,
    indirect_commands_layout_nv = 1000277000,
    cuda_module_nv = 1000307000,
    cuda_function_nv = 1000307001,
    buffer_collection_fuchsia = 1000366000,
    micromap_ext = 1000396000,
    tensor_arm = 1000460000,
    tensor_view_arm = 1000460001,
    optical_flow_session_nv = 1000464000,
    shader_ext = 1000482000,
    pipeline_binary_khr = 1000483000,
    data_graph_pipeline_session_arm = 1000507000,
    external_compute_queue_nv = 1000556000,
    indirect_commands_layout_ext = 1000572000,
    indirect_execution_set_ext = 1000572001,
    _,
};
pub const RayTracingInvocationReorderModeNV = enum(i32) {
    none = 0,
    reorder = 1,
    _,
};
pub const IndirectCommandsTokenTypeNV = enum(i32) {
    shader_group = 0,
    state_flags = 1,
    index_buffer = 2,
    vertex_buffer = 3,
    push_constant = 4,
    draw_indexed = 5,
    draw = 6,
    draw_tasks = 7,
    draw_mesh_tasks = 1000328000,
    pipeline = 1000428003,
    dispatch = 1000428004,
    _,
};
pub const DescriptorUpdateTemplateType = enum(i32) {
    descriptor_set = 0,
    push_descriptors = 1,
    _,
};
pub const DescriptorUpdateTemplateTypeKHR = DescriptorUpdateTemplateType;
pub const ViewportCoordinateSwizzleNV = enum(i32) {
    positive_x = 0,
    negative_x = 1,
    positive_y = 2,
    negative_y = 3,
    positive_z = 4,
    negative_z = 5,
    positive_w = 6,
    negative_w = 7,
    _,
};
pub const DiscardRectangleModeEXT = enum(i32) {
    inclusive = 0,
    exclusive = 1,
    _,
};
pub const PointClippingBehavior = enum(i32) {
    all_clip_planes = 0,
    user_clip_planes_only = 1,
    _,
};
pub const PointClippingBehaviorKHR = PointClippingBehavior;
pub const CoverageModulationModeNV = enum(i32) {
    none = 0,
    rgb = 1,
    alpha = 2,
    rgba = 3,
    _,
};
pub const CoverageReductionModeNV = enum(i32) {
    merge = 0,
    truncate = 1,
    _,
};
pub const ValidationCacheHeaderVersionEXT = enum(i32) {
    one = 1,
    _,
};
pub const ShaderInfoTypeAMD = enum(i32) {
    statistics = 0,
    binary = 1,
    disassembly = 2,
    _,
};
pub const QueueGlobalPriority = enum(i32) {
    low = 128,
    medium = 256,
    high = 512,
    realtime = 1024,
    _,
};
pub const QueueGlobalPriorityKHR = QueueGlobalPriority;
pub const QueueGlobalPriorityEXT = QueueGlobalPriority;
pub const TimeDomainKHR = enum(i32) {
    device = 0,
    clock_monotonic = 1,
    clock_monotonic_raw = 2,
    query_performance_counter = 3,
    _,
};
pub const TimeDomainEXT = TimeDomainKHR;
pub const ConservativeRasterizationModeEXT = enum(i32) {
    disabled = 0,
    overestimate = 1,
    underestimate = 2,
    _,
};
pub const SemaphoreType = enum(i32) {
    binary = 0,
    timeline = 1,
    _,
};
pub const SemaphoreTypeKHR = SemaphoreType;
pub const BuildAccelerationStructureModeKHR = enum(i32) {
    build = 0,
    update = 1,
    _,
};
pub const CopyAccelerationStructureModeKHR = enum(i32) {
    clone = 0,
    compact = 1,
    serialize = 2,
    deserialize = 3,
    _,
};
pub const CopyAccelerationStructureModeNV = CopyAccelerationStructureModeKHR;
pub const AccelerationStructureTypeKHR = enum(i32) {
    top_level = 0,
    bottom_level = 1,
    generic = 2,
    _,
};
pub const AccelerationStructureTypeNV = AccelerationStructureTypeKHR;
pub const GeometryTypeKHR = enum(i32) {
    triangles = 0,
    aabbs = 1,
    instances = 2,
    spheres_nv = 1000429004,
    linear_swept_spheres_nv = 1000429005,
    dense_geometry_format_triangles_amdx = 1000478000,
    _,
};
pub const GeometryTypeNV = GeometryTypeKHR;
pub const RayTracingShaderGroupTypeKHR = enum(i32) {
    general = 0,
    triangles_hit_group = 1,
    procedural_hit_group = 2,
    _,
};
pub const RayTracingShaderGroupTypeNV = RayTracingShaderGroupTypeKHR;
pub const AccelerationStructureMemoryRequirementsTypeNV = enum(i32) {
    object = 0,
    build_scratch = 1,
    update_scratch = 2,
    _,
};
pub const AccelerationStructureBuildTypeKHR = enum(i32) {
    host = 0,
    device = 1,
    host_or_device = 2,
    _,
};
pub const AccelerationStructureCompatibilityKHR = enum(i32) {
    compatible = 0,
    incompatible = 1,
    _,
};
pub const RayTracingLssIndexingModeNV = enum(i32) {
    list = 0,
    successive = 1,
    _,
};
pub const RayTracingLssPrimitiveEndCapsModeNV = enum(i32) {
    none = 0,
    chained = 1,
    _,
};
pub const ShaderGroupShaderKHR = enum(i32) {
    general = 0,
    closest_hit = 1,
    any_hit = 2,
    intersection = 3,
    _,
};
pub const MemoryOverallocationBehaviorAMD = enum(i32) {
    default = 0,
    allowed = 1,
    disallowed = 2,
    _,
};
pub const PerformanceCounterScopeKHR = enum(i32) {
    command_buffer = 0,
    render_pass = 1,
    command = 2,
    _,
};
pub const PerformanceCounterUnitKHR = enum(i32) {
    generic = 0,
    percentage = 1,
    nanoseconds = 2,
    bytes = 3,
    bytes_per_second = 4,
    kelvin = 5,
    watts = 6,
    volts = 7,
    amps = 8,
    hertz = 9,
    cycles = 10,
    _,
};
pub const PerformanceCounterStorageKHR = enum(i32) {
    int32 = 0,
    int64 = 1,
    uint32 = 2,
    uint64 = 3,
    float32 = 4,
    float64 = 5,
    _,
};
pub const PerformanceConfigurationTypeINTEL = enum(i32) {
    command_queue_metrics_discovery_activated = 0,
    _,
};
pub const QueryPoolSamplingModeINTEL = enum(i32) {
    manual = 0,
    _,
};
pub const PerformanceOverrideTypeINTEL = enum(i32) {
    null_hardware = 0,
    flush_gpu_caches = 1,
    _,
};
pub const PerformanceParameterTypeINTEL = enum(i32) {
    hw_counters_supported = 0,
    stream_marker_valid_bits = 1,
    _,
};
pub const PerformanceValueTypeINTEL = enum(i32) {
    uint32 = 0,
    uint64 = 1,
    float = 2,
    bool = 3,
    string = 4,
    _,
};
pub const LineRasterizationMode = enum(i32) {
    default = 0,
    rectangular = 1,
    bresenham = 2,
    rectangular_smooth = 3,
    _,
};
pub const LineRasterizationModeKHR = LineRasterizationMode;
pub const LineRasterizationModeEXT = LineRasterizationMode;
pub const FragmentShadingRateNV = enum(i32) {
    @"1_invocation_per_pixel" = 0,
    @"1_invocation_per_1x2_pixels" = 1,
    @"1_invocation_per_2x1_pixels" = 4,
    @"1_invocation_per_2x2_pixels" = 5,
    @"1_invocation_per_2x4_pixels" = 6,
    @"1_invocation_per_4x2_pixels" = 9,
    @"1_invocation_per_4x4_pixels" = 10,
    @"2_invocations_per_pixel" = 11,
    @"4_invocations_per_pixel" = 12,
    @"8_invocations_per_pixel" = 13,
    @"16_invocations_per_pixel" = 14,
    no_invocations = 15,
    _,
};
pub const FragmentShadingRateTypeNV = enum(i32) {
    fragment_size = 0,
    enums = 1,
    _,
};
pub const SubpassMergeStatusEXT = enum(i32) {
    merged = 0,
    disallowed = 1,
    not_merged_side_effects = 2,
    not_merged_samples_mismatch = 3,
    not_merged_views_mismatch = 4,
    not_merged_aliasing = 5,
    not_merged_dependencies = 6,
    not_merged_incompatible_input_attachment = 7,
    not_merged_too_many_attachments = 8,
    not_merged_insufficient_storage = 9,
    not_merged_depth_stencil_count = 10,
    not_merged_resolve_attachment_reuse = 11,
    not_merged_single_subpass = 12,
    not_merged_unspecified = 13,
    _,
};
pub const ProvokingVertexModeEXT = enum(i32) {
    first_vertex = 0,
    last_vertex = 1,
    _,
};
pub const PipelineRobustnessBufferBehavior = enum(i32) {
    device_default = 0,
    disabled = 1,
    robust_buffer_access = 2,
    robust_buffer_access_2 = 3,
    _,
};
pub const PipelineRobustnessBufferBehaviorEXT = PipelineRobustnessBufferBehavior;
pub const PipelineRobustnessImageBehavior = enum(i32) {
    device_default = 0,
    disabled = 1,
    robust_image_access = 2,
    robust_image_access_2 = 3,
    _,
};
pub const PipelineRobustnessImageBehaviorEXT = PipelineRobustnessImageBehavior;
pub const DeviceAddressBindingTypeEXT = enum(i32) {
    bind = 0,
    unbind = 1,
    _,
};
pub const MicromapTypeEXT = enum(i32) {
    opacity_micromap = 0,
    displacement_micromap_nv = 1000397000,
    _,
};
pub const BuildMicromapModeEXT = enum(i32) {
    build = 0,
    _,
};
pub const CopyMicromapModeEXT = enum(i32) {
    clone = 0,
    serialize = 1,
    deserialize = 2,
    compact = 3,
    _,
};
pub const OpacityMicromapFormatEXT = enum(i32) {
    @"2_state" = 1,
    @"4_state" = 2,
    _,
};
pub const OpacityMicromapSpecialIndexEXT = enum(i32) {
    fully_transparent = -1,
    fully_opaque = -2,
    fully_unknown_transparent = -3,
    fully_unknown_opaque = -4,
    cluster_geometry_disable_opacity_micromap_nv = -5,
    _,
};
pub const DeviceFaultVendorBinaryHeaderVersionEXT = enum(i32) {
    one = 1,
    _,
};
pub const IndirectExecutionSetInfoTypeEXT = enum(i32) {
    pipelines = 0,
    shader_objects = 1,
    _,
};
pub const DepthBiasRepresentationEXT = enum(i32) {
    least_representable_value_format = 0,
    least_representable_value_force_unorm = 1,
    float = 2,
    _,
};
pub const DirectDriverLoadingModeLUNARG = enum(i32) {
    exclusive = 0,
    inclusive = 1,
    _,
};
pub const PartitionedAccelerationStructureOpTypeNV = enum(i32) {
    write_instance = 0,
    update_instance = 1,
    write_partition_translation = 2,
    _,
};
pub const AntiLagModeAMD = enum(i32) {
    driver_control = 0,
    on = 1,
    off = 2,
    _,
};
pub const AntiLagStageAMD = enum(i32) {
    input = 0,
    present = 1,
    _,
};
pub const DisplacementMicromapFormatNV = enum(i32) {
    @"64_triangles_64_bytes" = 1,
    @"256_triangles_128_bytes" = 2,
    @"1024_triangles_128_bytes" = 3,
    _,
};
pub const ShaderCodeTypeEXT = enum(i32) {
    binary = 0,
    spirv = 1,
    _,
};
pub const ScopeKHR = enum(i32) {
    device = 1,
    workgroup = 2,
    subgroup = 3,
    queue_family = 5,
    _,
};
pub const ComponentTypeKHR = enum(i32) {
    float16 = 0,
    float32 = 1,
    float64 = 2,
    sint8 = 3,
    sint16 = 4,
    sint32 = 5,
    sint64 = 6,
    uint8 = 7,
    uint16 = 8,
    uint32 = 9,
    uint64 = 10,
    bfloat16 = 1000141000,
    sint8_packed_nv = 1000491000,
    uint8_packed_nv = 1000491001,
    float8_e4m3_ext = 1000491002,
    float8_e5m2_ext = 1000491003,
    _,
};
pub const ScopeNV = ScopeKHR;
pub const ComponentTypeNV = ComponentTypeKHR;
pub const CubicFilterWeightsQCOM = enum(i32) {
    catmull_rom = 0,
    zero_tangent_cardinal = 1,
    b_spline = 2,
    mitchell_netravali = 3,
    _,
};
pub const BlockMatchWindowCompareModeQCOM = enum(i32) {
    min = 0,
    max = 1,
    _,
};
pub const LayeredDriverUnderlyingApiMSFT = enum(i32) {
    none = 0,
    d3d12 = 1,
    _,
};
pub const PhysicalDeviceLayeredApiKHR = enum(i32) {
    vulkan = 0,
    d3d12 = 1,
    metal = 2,
    opengl = 3,
    opengles = 4,
    _,
};
pub const CompressedTriangleFormatAMDX = enum(i32) {
    dgf1 = 0,
    _,
};
pub const DepthClampModeEXT = enum(i32) {
    viewport_range = 0,
    user_defined_range = 1,
    _,
};
pub const CooperativeVectorMatrixLayoutNV = enum(i32) {
    row_major = 0,
    column_major = 1,
    inferencing_optimal = 2,
    training_optimal = 3,
    _,
};
pub const TensorTilingARM = enum(i32) {
    optimal = 0,
    linear = 1,
    _,
};
pub const DataGraphPipelinePropertyARM = enum(i32) {
    creation_log = 0,
    identifier = 1,
    _,
};
pub const DataGraphPipelineSessionBindPointARM = enum(i32) {
    transient = 0,
    _,
};
pub const DataGraphPipelineSessionBindPointTypeARM = enum(i32) {
    memory = 0,
    _,
};
pub const PhysicalDeviceDataGraphProcessingEngineTypeARM = enum(i32) {
    default = 0,
    _,
};
pub const PhysicalDeviceDataGraphOperationTypeARM = enum(i32) {
    spirv_extended_instruction_set = 0,
    _,
};
pub const ColorSpaceKHR = enum(i32) {
    srgb_nonlinear = 0,
    display_p3_nonlinear_ext = 1000104001,
    extended_srgb_linear_ext = 1000104002,
    display_p3_linear_ext = 1000104003,
    dci_p3_nonlinear_ext = 1000104004,
    bt709_linear_ext = 1000104005,
    bt709_nonlinear_ext = 1000104006,
    bt2020_linear_ext = 1000104007,
    hdr10_st2084_ext = 1000104008,
    dolbyvision_ext = 1000104009,
    hdr10_hlg_ext = 1000104010,
    adobergb_linear_ext = 1000104011,
    adobergb_nonlinear_ext = 1000104012,
    pass_through_ext = 1000104013,
    extended_srgb_nonlinear_ext = 1000104014,
    display_native_amd = 1000213000,
    _,
};
pub const PresentModeKHR = enum(i32) {
    immediate = 0,
    mailbox = 1,
    fifo = 2,
    fifo_relaxed = 3,
    shared_demand_refresh = 1000111000,
    shared_continuous_refresh = 1000111001,
    fifo_latest_ready = 1000361000,
    _,
};
pub const DisplaySurfaceStereoTypeNV = enum(i32) {
    none = 0,
    onboard_din = 1,
    hdmi_3d = 2,
    inband_displayport = 3,
    _,
};
pub const DebugReportObjectTypeEXT = enum(i32) {
    unknown = 0,
    instance = 1,
    physical_device = 2,
    device = 3,
    queue = 4,
    semaphore = 5,
    command_buffer = 6,
    fence = 7,
    device_memory = 8,
    buffer = 9,
    image = 10,
    event = 11,
    query_pool = 12,
    buffer_view = 13,
    image_view = 14,
    shader_module = 15,
    pipeline_cache = 16,
    pipeline_layout = 17,
    render_pass = 18,
    pipeline = 19,
    descriptor_set_layout = 20,
    sampler = 21,
    descriptor_pool = 22,
    descriptor_set = 23,
    framebuffer = 24,
    command_pool = 25,
    surface_khr = 26,
    swapchain_khr = 27,
    debug_report_callback_ext = 28,
    display_khr = 29,
    display_mode_khr = 30,
    validation_cache_ext = 33,
    sampler_ycbcr_conversion = 1000156000,
    descriptor_update_template = 1000085000,
    cu_module_nvx = 1000029000,
    cu_function_nvx = 1000029001,
    acceleration_structure_khr = 1000150000,
    acceleration_structure_nv = 1000165000,
    cuda_module_nv = 1000307000,
    cuda_function_nv = 1000307001,
    buffer_collection_fuchsia = 1000366000,
    _,
};
pub const DeviceMemoryReportEventTypeEXT = enum(i32) {
    allocate = 0,
    free = 1,
    import = 2,
    unimport = 3,
    allocation_failed = 4,
    _,
};
pub const RasterizationOrderAMD = enum(i32) {
    strict = 0,
    relaxed = 1,
    _,
};
pub const ValidationCheckEXT = enum(i32) {
    all = 0,
    shaders = 1,
    _,
};
pub const ValidationFeatureEnableEXT = enum(i32) {
    gpu_assisted = 0,
    gpu_assisted_reserve_binding_slot = 1,
    best_practices = 2,
    debug_printf = 3,
    synchronization_validation = 4,
    _,
};
pub const ValidationFeatureDisableEXT = enum(i32) {
    all = 0,
    shaders = 1,
    thread_safety = 2,
    api_parameters = 3,
    object_lifetimes = 4,
    core_checks = 5,
    unique_handles = 6,
    shader_validation_cache = 7,
    _,
};
pub const DisplayPowerStateEXT = enum(i32) {
    off = 0,
    @"suspend" = 1,
    on = 2,
    _,
};
pub const DeviceEventTypeEXT = enum(i32) {
    display_hotplug = 0,
    _,
};
pub const DisplayEventTypeEXT = enum(i32) {
    first_pixel_out = 0,
    _,
};
pub const TessellationDomainOrigin = enum(i32) {
    upper_left = 0,
    lower_left = 1,
    _,
};
pub const TessellationDomainOriginKHR = TessellationDomainOrigin;
pub const SamplerYcbcrModelConversion = enum(i32) {
    rgb_identity = 0,
    ycbcr_identity = 1,
    ycbcr_709 = 2,
    ycbcr_601 = 3,
    ycbcr_2020 = 4,
    _,
};
pub const SamplerYcbcrModelConversionKHR = SamplerYcbcrModelConversion;
pub const SamplerYcbcrRange = enum(i32) {
    itu_full = 0,
    itu_narrow = 1,
    _,
};
pub const SamplerYcbcrRangeKHR = SamplerYcbcrRange;
pub const ChromaLocation = enum(i32) {
    cosited_even = 0,
    midpoint = 1,
    _,
};
pub const ChromaLocationKHR = ChromaLocation;
pub const SamplerReductionMode = enum(i32) {
    weighted_average = 0,
    min = 1,
    max = 2,
    weighted_average_rangeclamp_qcom = 1000521000,
    _,
};
pub const SamplerReductionModeEXT = SamplerReductionMode;
pub const BlendOverlapEXT = enum(i32) {
    uncorrelated = 0,
    disjoint = 1,
    conjoint = 2,
    _,
};
pub const FullScreenExclusiveEXT = enum(i32) {
    default = 0,
    allowed = 1,
    disallowed = 2,
    application_controlled = 3,
    _,
};
pub const ShaderFloatControlsIndependence = enum(i32) {
    @"32_bit_only" = 0,
    all = 1,
    none = 2,
    _,
};
pub const ShaderFloatControlsIndependenceKHR = ShaderFloatControlsIndependence;
pub const FragmentShadingRateCombinerOpKHR = enum(i32) {
    keep = 0,
    replace = 1,
    min = 2,
    max = 3,
    mul = 4,
    _,
};
pub const OpticalFlowPerformanceLevelNV = enum(i32) {
    unknown = 0,
    slow = 1,
    medium = 2,
    fast = 3,
    _,
};
pub const OpticalFlowSessionBindingPointNV = enum(i32) {
    unknown = 0,
    input = 1,
    reference = 2,
    hint = 3,
    flow_vector = 4,
    backward_flow_vector = 5,
    cost = 6,
    backward_cost = 7,
    global_flow = 8,
    _,
};
pub const DeviceFaultAddressTypeEXT = enum(i32) {
    none = 0,
    read_invalid = 1,
    write_invalid = 2,
    execute_invalid = 3,
    instruction_pointer_unknown = 4,
    instruction_pointer_invalid = 5,
    instruction_pointer_fault = 6,
    _,
};
pub const LayerSettingTypeEXT = enum(i32) {
    bool32 = 0,
    int32 = 1,
    int64 = 2,
    uint32 = 3,
    uint64 = 4,
    float32 = 5,
    float64 = 6,
    string = 7,
    _,
};
pub const LatencyMarkerNV = enum(i32) {
    simulation_start = 0,
    simulation_end = 1,
    rendersubmit_start = 2,
    rendersubmit_end = 3,
    present_start = 4,
    present_end = 5,
    input_sample = 6,
    trigger_flash = 7,
    out_of_band_rendersubmit_start = 8,
    out_of_band_rendersubmit_end = 9,
    out_of_band_present_start = 10,
    out_of_band_present_end = 11,
    _,
};
pub const OutOfBandQueueTypeNV = enum(i32) {
    render = 0,
    present = 1,
    _,
};
pub const VendorId = enum(i32) {
    khronos = 65536,
    viv = 65537,
    vsi = 65538,
    kazan = 65539,
    codeplay = 65540,
    mesa = 65541,
    pocl = 65542,
    mobileye = 65543,
    _,
};
pub const DriverId = enum(i32) {
    amd_proprietary = 1,
    amd_open_source = 2,
    mesa_radv = 3,
    nvidia_proprietary = 4,
    intel_proprietary_windows = 5,
    intel_open_source_mesa = 6,
    imagination_proprietary = 7,
    qualcomm_proprietary = 8,
    arm_proprietary = 9,
    google_swiftshader = 10,
    ggp_proprietary = 11,
    broadcom_proprietary = 12,
    mesa_llvmpipe = 13,
    moltenvk = 14,
    coreavi_proprietary = 15,
    juice_proprietary = 16,
    verisilicon_proprietary = 17,
    mesa_turnip = 18,
    mesa_v3dv = 19,
    mesa_panvk = 20,
    samsung_proprietary = 21,
    mesa_venus = 22,
    mesa_dozen = 23,
    mesa_nvk = 24,
    imagination_open_source_mesa = 25,
    mesa_honeykrisp = 26,
    vulkan_sc_emulation_on_vulkan = 27,
    _,
};
pub const DriverIdKHR = DriverId;
pub const ShadingRatePaletteEntryNV = enum(i32) {
    no_invocations = 0,
    @"16_invocations_per_pixel" = 1,
    @"8_invocations_per_pixel" = 2,
    @"4_invocations_per_pixel" = 3,
    @"2_invocations_per_pixel" = 4,
    @"1_invocation_per_pixel" = 5,
    @"1_invocation_per_2x1_pixels" = 6,
    @"1_invocation_per_1x2_pixels" = 7,
    @"1_invocation_per_2x2_pixels" = 8,
    @"1_invocation_per_4x2_pixels" = 9,
    @"1_invocation_per_2x4_pixels" = 10,
    @"1_invocation_per_4x4_pixels" = 11,
    _,
};
pub const CoarseSampleOrderTypeNV = enum(i32) {
    default = 0,
    custom = 1,
    pixel_major = 2,
    sample_major = 3,
    _,
};
pub const PipelineExecutableStatisticFormatKHR = enum(i32) {
    bool32 = 0,
    int64 = 1,
    uint64 = 2,
    float64 = 3,
    _,
};
pub const DefaultVertexAttributeValueKHR = enum(i32) {
    zero_zero_zero_zero = 0,
    zero_zero_zero_one = 1,
    _,
};
pub const FpInternalAllocationNotification = *const fn (?*anyopaque, usize, InternalAllocationType, SystemAllocationScope) callconv(.c) void;
pub const FpInternalFreeNotification = *const fn (?*anyopaque, usize, InternalAllocationType, SystemAllocationScope) callconv(.c) void;
pub const FpReallocationFunction = *const fn (?*anyopaque, ?*anyopaque, usize, usize, SystemAllocationScope) callconv(.c) ?*anyopaque;
pub const FpAllocationFunction = *const fn (?*anyopaque, usize, usize, SystemAllocationScope) callconv(.c) ?*anyopaque;
pub const FpFreeFunction = *const fn (?*anyopaque, ?*anyopaque) callconv(.c) void;
pub const FpVoidFunction = *const fn () callconv(.c) void;
pub const FpDebugReportCallbackEXT = *const fn (DebugReportFlagsEXT, DebugReportObjectTypeEXT, u64, usize, i32, [*c]const u8, [*c]const u8, ?*anyopaque) callconv(.c) Bool32;
pub const FpDebugUtilsMessengerCallbackEXT = *const fn (DebugUtilsMessageSeverityFlagsEXT, DebugUtilsMessageTypeFlagsEXT, [*c]const DebugUtilsMessengerCallbackDataEXT, ?*anyopaque) callconv(.c) Bool32;
pub const FpDeviceMemoryReportCallbackEXT = *const fn ([*c]const DeviceMemoryReportCallbackDataEXT, ?*anyopaque) callconv(.c) void;
pub const FpGetInstanceProcAddrLUNARG = *const fn (Instance, [*c]const u8) callconv(.c) ?FpVoidFunction;
pub const BaseOutStructure = extern struct {
    s_type: StructureType = @enumFromInt(0),
    p_next: ?*BaseOutStructure = null,
};
pub const BaseInStructure = extern struct {
    s_type: StructureType = @enumFromInt(0),
    p_next: ?*const BaseInStructure = null,
};
pub const Offset2D = extern struct {
    x: i32 = 0,
    y: i32 = 0,
};
pub const Offset3D = extern struct {
    x: i32 = 0,
    y: i32 = 0,
    z: i32 = 0,
};
pub const Extent2D = extern struct {
    width: u32 = 0,
    height: u32 = 0,
};
pub const Extent3D = extern struct {
    width: u32 = 0,
    height: u32 = 0,
    depth: u32 = 0,
};
pub const Viewport = extern struct {
    x: f32 = 0,
    y: f32 = 0,
    width: f32 = 0,
    height: f32 = 0,
    min_depth: f32 = 0,
    max_depth: f32 = 0,
};
pub const Rect2D = extern struct {
    offset: Offset2D = .{},
    extent: Extent2D = .{},
};
pub const ClearRect = extern struct {
    rect: Rect2D = .{},
    base_array_layer: u32 = 0,
    layer_count: u32 = 0,
};
pub const ComponentMapping = extern struct {
    r: ComponentSwizzle = @enumFromInt(0),
    g: ComponentSwizzle = @enumFromInt(0),
    b: ComponentSwizzle = @enumFromInt(0),
    a: ComponentSwizzle = @enumFromInt(0),
};
pub const PhysicalDeviceProperties = extern struct {
    api_version: Version = Version.from_int(0),
    driver_version: u32 = 0,
    vendor_id: u32 = 0,
    device_id: u32 = 0,
    device_type: PhysicalDeviceType = @enumFromInt(0),
    device_name: [max_physical_device_name_size - 1:0]u8 = [_:0]u8{0} ** (max_physical_device_name_size - 1),
    pipeline_cache_uuid: [uuid_size]u8 = [_]u8{0} ** uuid_size,
    limits: PhysicalDeviceLimits = .{},
    sparse_properties: PhysicalDeviceSparseProperties = .{},
};
pub const ExtensionProperties = extern struct {
    extension_name: [max_extension_name_size - 1:0]u8 = [_:0]u8{0} ** (max_extension_name_size - 1),
    spec_version: u32 = 0,
};
pub const LayerProperties = extern struct {
    layer_name: [max_extension_name_size - 1:0]u8 = [_:0]u8{0} ** (max_extension_name_size - 1),
    spec_version: u32 = 0,
    implementation_version: u32 = 0,
    description: [max_description_size - 1:0]u8 = [_:0]u8{0} ** (max_description_size - 1),
};
pub const ApplicationInfo = extern struct {
    s_type: StructureType = .application_info,
    p_next: ?*const anyopaque = null,
    p_application_name: ?[*:0]const u8 = null,
    application_version: u32 = 0,
    p_engine_name: ?[*:0]const u8 = null,
    engine_version: u32 = 0,
    api_version: Version = Version.from_int(0),
};
pub const AllocationCallbacks = extern struct {
    p_user_data: ?*anyopaque = null,
    pfn_allocation: ?FpAllocationFunction = null,
    pfn_reallocation: ?FpReallocationFunction = null,
    pfn_free: ?FpFreeFunction = null,
    pfn_internal_allocation: ?FpInternalAllocationNotification = null,
    pfn_internal_free: ?FpInternalFreeNotification = null,
};
pub const DeviceQueueCreateInfo = extern struct {
    s_type: StructureType = .device_queue_create_info,
    p_next: ?*const anyopaque = null,
    flags: DeviceQueueCreateFlags = .none,
    queue_family_index: u32 = 0,
    queue_count: u32 = 0,
    p_queue_priorities: ?[*]const f32 = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DeviceQueueGlobalPriorityCreateInfo,
            *DeviceQueueShaderCoreControlCreateInfoARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DeviceCreateInfo = extern struct {
    s_type: StructureType = .device_create_info,
    p_next: ?*const anyopaque = null,
    flags: DeviceCreateFlags = .none,
    queue_create_info_count: u32 = 0,
    p_queue_create_infos: ?[*]const DeviceQueueCreateInfo = null,
    enabled_layer_count: u32 = 0,
    pp_enabled_layer_names: ?[*]const ?[*:0]const u8 = null,
    enabled_extension_count: u32 = 0,
    pp_enabled_extension_names: ?[*]const ?[*:0]const u8 = null,
    p_enabled_features: ?*const PhysicalDeviceFeatures = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PhysicalDeviceDeviceGeneratedCommandsFeaturesNV,
            *PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV,
            *DevicePrivateDataCreateInfo,
            *PhysicalDevicePrivateDataFeatures,
            *PhysicalDeviceClusterAccelerationStructureFeaturesNV,
            *PhysicalDeviceFeatures2,
            *PhysicalDeviceVariablePointersFeatures,
            *PhysicalDeviceMultiviewFeatures,
            *DeviceGroupDeviceCreateInfo,
            *PhysicalDevicePresentIdFeaturesKHR,
            *PhysicalDevicePresentId2FeaturesKHR,
            *PhysicalDevicePresentWaitFeaturesKHR,
            *PhysicalDevicePresentWait2FeaturesKHR,
            *PhysicalDevice16BitStorageFeatures,
            *PhysicalDeviceShaderSubgroupExtendedTypesFeatures,
            *PhysicalDeviceSamplerYcbcrConversionFeatures,
            *PhysicalDeviceProtectedMemoryFeatures,
            *PhysicalDeviceBlendOperationAdvancedFeaturesEXT,
            *PhysicalDeviceMultiDrawFeaturesEXT,
            *PhysicalDeviceInlineUniformBlockFeatures,
            *PhysicalDeviceMaintenance4Features,
            *PhysicalDeviceMaintenance5Features,
            *PhysicalDeviceMaintenance6Features,
            *PhysicalDeviceMaintenance7FeaturesKHR,
            *PhysicalDeviceMaintenance8FeaturesKHR,
            *PhysicalDeviceMaintenance9FeaturesKHR,
            *PhysicalDeviceShaderDrawParametersFeatures,
            *PhysicalDeviceShaderFloat16Int8Features,
            *PhysicalDeviceHostQueryResetFeatures,
            *PhysicalDeviceGlobalPriorityQueryFeatures,
            *PhysicalDeviceDeviceMemoryReportFeaturesEXT,
            *DeviceDeviceMemoryReportCreateInfoEXT,
            *PhysicalDeviceDescriptorIndexingFeatures,
            *PhysicalDeviceTimelineSemaphoreFeatures,
            *PhysicalDevice8BitStorageFeatures,
            *PhysicalDeviceConditionalRenderingFeaturesEXT,
            *PhysicalDeviceVulkanMemoryModelFeatures,
            *PhysicalDeviceShaderAtomicInt64Features,
            *PhysicalDeviceShaderAtomicFloatFeaturesEXT,
            *PhysicalDeviceShaderAtomicFloat2FeaturesEXT,
            *PhysicalDeviceVertexAttributeDivisorFeatures,
            *PhysicalDeviceASTCDecodeFeaturesEXT,
            *PhysicalDeviceTransformFeedbackFeaturesEXT,
            *PhysicalDeviceRepresentativeFragmentTestFeaturesNV,
            *PhysicalDeviceExclusiveScissorFeaturesNV,
            *PhysicalDeviceCornerSampledImageFeaturesNV,
            *PhysicalDeviceComputeShaderDerivativesFeaturesKHR,
            *PhysicalDeviceShaderImageFootprintFeaturesNV,
            *PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,
            *PhysicalDeviceCopyMemoryIndirectFeaturesNV,
            *PhysicalDeviceMemoryDecompressionFeaturesNV,
            *PhysicalDeviceShadingRateImageFeaturesNV,
            *PhysicalDeviceInvocationMaskFeaturesHUAWEI,
            *PhysicalDeviceMeshShaderFeaturesNV,
            *PhysicalDeviceMeshShaderFeaturesEXT,
            *PhysicalDeviceAccelerationStructureFeaturesKHR,
            *PhysicalDeviceRayTracingPipelineFeaturesKHR,
            *PhysicalDeviceRayQueryFeaturesKHR,
            *PhysicalDeviceRayTracingMaintenance1FeaturesKHR,
            *DeviceMemoryOverallocationCreateInfoAMD,
            *PhysicalDeviceFragmentDensityMapFeaturesEXT,
            *PhysicalDeviceFragmentDensityMap2FeaturesEXT,
            *PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT,
            *PhysicalDeviceScalarBlockLayoutFeatures,
            *PhysicalDeviceUniformBufferStandardLayoutFeatures,
            *PhysicalDeviceDepthClipEnableFeaturesEXT,
            *PhysicalDeviceMemoryPriorityFeaturesEXT,
            *PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT,
            *PhysicalDeviceBufferDeviceAddressFeatures,
            *PhysicalDeviceBufferDeviceAddressFeaturesEXT,
            *PhysicalDeviceImagelessFramebufferFeatures,
            *PhysicalDeviceTextureCompressionASTCHDRFeatures,
            *PhysicalDeviceCooperativeMatrixFeaturesNV,
            *PhysicalDeviceYcbcrImageArraysFeaturesEXT,
            *PhysicalDevicePresentBarrierFeaturesNV,
            *PhysicalDevicePerformanceQueryFeaturesKHR,
            *PhysicalDeviceCoverageReductionModeFeaturesNV,
            *PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,
            *PhysicalDeviceShaderClockFeaturesKHR,
            *PhysicalDeviceIndexTypeUint8Features,
            *PhysicalDeviceShaderSMBuiltinsFeaturesNV,
            *PhysicalDeviceFragmentShaderInterlockFeaturesEXT,
            *PhysicalDeviceSeparateDepthStencilLayoutsFeatures,
            *PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT,
            *PhysicalDevicePipelineExecutablePropertiesFeaturesKHR,
            *PhysicalDeviceShaderDemoteToHelperInvocationFeatures,
            *PhysicalDeviceTexelBufferAlignmentFeaturesEXT,
            *PhysicalDeviceSubgroupSizeControlFeatures,
            *PhysicalDeviceLineRasterizationFeatures,
            *PhysicalDevicePipelineCreationCacheControlFeatures,
            *PhysicalDeviceVulkan11Features,
            *PhysicalDeviceVulkan12Features,
            *PhysicalDeviceVulkan13Features,
            *PhysicalDeviceVulkan14Features,
            *PhysicalDeviceCoherentMemoryFeaturesAMD,
            *PhysicalDeviceCustomBorderColorFeaturesEXT,
            *PhysicalDeviceBorderColorSwizzleFeaturesEXT,
            *PhysicalDeviceExtendedDynamicStateFeaturesEXT,
            *PhysicalDeviceExtendedDynamicState2FeaturesEXT,
            *PhysicalDeviceExtendedDynamicState3FeaturesEXT,
            *PhysicalDevicePartitionedAccelerationStructureFeaturesNV,
            *PhysicalDeviceDiagnosticsConfigFeaturesNV,
            *DeviceDiagnosticsConfigCreateInfoNV,
            *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures,
            *PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR,
            *PhysicalDeviceRobustness2FeaturesKHR,
            *PhysicalDeviceImageRobustnessFeatures,
            *PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR,
            *PhysicalDevicePortabilitySubsetFeaturesKHR,
            *PhysicalDevice4444FormatsFeaturesEXT,
            *PhysicalDeviceSubpassShadingFeaturesHUAWEI,
            *PhysicalDeviceClusterCullingShaderFeaturesHUAWEI,
            *PhysicalDeviceShaderImageAtomicInt64FeaturesEXT,
            *PhysicalDeviceFragmentShadingRateFeaturesKHR,
            *PhysicalDeviceShaderTerminateInvocationFeatures,
            *PhysicalDeviceFragmentShadingRateEnumsFeaturesNV,
            *PhysicalDeviceImage2DViewOf3DFeaturesEXT,
            *PhysicalDeviceImageSlicedViewOf3DFeaturesEXT,
            *PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT,
            *PhysicalDeviceLegacyVertexAttributesFeaturesEXT,
            *PhysicalDeviceMutableDescriptorTypeFeaturesEXT,
            *PhysicalDeviceDepthClipControlFeaturesEXT,
            *PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT,
            *PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT,
            *PhysicalDeviceDepthClampControlFeaturesEXT,
            *PhysicalDeviceVertexInputDynamicStateFeaturesEXT,
            *PhysicalDeviceExternalMemoryRDMAFeaturesNV,
            *PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR,
            *PhysicalDeviceColorWriteEnableFeaturesEXT,
            *PhysicalDeviceSynchronization2Features,
            *PhysicalDeviceUnifiedImageLayoutsFeaturesKHR,
            *PhysicalDeviceHostImageCopyFeatures,
            *PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT,
            *PhysicalDeviceLegacyDitheringFeaturesEXT,
            *PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT,
            *PhysicalDevicePipelineProtectedAccessFeatures,
            *PhysicalDeviceInheritedViewportScissorFeaturesNV,
            *PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT,
            *PhysicalDeviceProvokingVertexFeaturesEXT,
            *PhysicalDeviceDescriptorBufferFeaturesEXT,
            *PhysicalDeviceShaderIntegerDotProductFeatures,
            *PhysicalDeviceFragmentShaderBarycentricFeaturesKHR,
            *PhysicalDeviceRayTracingMotionBlurFeaturesNV,
            *PhysicalDeviceRayTracingValidationFeaturesNV,
            *PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV,
            *PhysicalDeviceRGBA10X6FormatsFeaturesEXT,
            *PhysicalDeviceDynamicRenderingFeatures,
            *PhysicalDeviceImageViewMinLodFeaturesEXT,
            *PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT,
            *PhysicalDeviceLinearColorAttachmentFeaturesNV,
            *PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT,
            *PhysicalDevicePipelineBinaryFeaturesKHR,
            *DevicePipelineBinaryInternalCacheControlKHR,
            *PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE,
            *PhysicalDeviceNestedCommandBufferFeaturesEXT,
            *PhysicalDeviceShaderModuleIdentifierFeaturesEXT,
            *PhysicalDeviceImageCompressionControlFeaturesEXT,
            *PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT,
            *PhysicalDeviceSubpassMergeFeedbackFeaturesEXT,
            *PhysicalDeviceOpacityMicromapFeaturesEXT,
            *PhysicalDeviceDisplacementMicromapFeaturesNV,
            *PhysicalDevicePipelinePropertiesFeaturesEXT,
            *PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD,
            *PhysicalDeviceNonSeamlessCubeMapFeaturesEXT,
            *PhysicalDevicePipelineRobustnessFeatures,
            *PhysicalDeviceImageProcessingFeaturesQCOM,
            *PhysicalDeviceTilePropertiesFeaturesQCOM,
            *PhysicalDeviceAmigoProfilingFeaturesSEC,
            *PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT,
            *PhysicalDeviceAddressBindingReportFeaturesEXT,
            *PhysicalDeviceOpticalFlowFeaturesNV,
            *PhysicalDeviceFaultFeaturesEXT,
            *PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT,
            *PhysicalDeviceShaderCoreBuiltinsFeaturesARM,
            *PhysicalDeviceFrameBoundaryFeaturesEXT,
            *PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT,
            *PhysicalDeviceSwapchainMaintenance1FeaturesKHR,
            *PhysicalDeviceDepthBiasControlFeaturesEXT,
            *PhysicalDeviceRayTracingInvocationReorderFeaturesNV,
            *PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV,
            *PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM,
            *PhysicalDeviceRayTracingPositionFetchFeaturesKHR,
            *PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM,
            *PhysicalDeviceShaderObjectFeaturesEXT,
            *PhysicalDeviceShaderTileImageFeaturesEXT,
            *PhysicalDeviceCooperativeMatrixFeaturesKHR,
            *PhysicalDeviceShaderEnqueueFeaturesAMDX,
            *PhysicalDeviceAntiLagFeaturesAMD,
            *PhysicalDeviceTileMemoryHeapFeaturesQCOM,
            *PhysicalDeviceCubicClampFeaturesQCOM,
            *PhysicalDeviceYcbcrDegammaFeaturesQCOM,
            *PhysicalDeviceCubicWeightsFeaturesQCOM,
            *PhysicalDeviceImageProcessing2FeaturesQCOM,
            *PhysicalDeviceDescriptorPoolOverallocationFeaturesNV,
            *PhysicalDevicePerStageDescriptorSetFeaturesNV,
            *PhysicalDeviceExternalFormatResolveFeaturesANDROID,
            *PhysicalDeviceCudaKernelLaunchFeaturesNV,
            *DeviceQueueShaderCoreControlCreateInfoARM,
            *PhysicalDeviceSchedulingControlsFeaturesARM,
            *PhysicalDeviceRelaxedLineRasterizationFeaturesIMG,
            *PhysicalDeviceRenderPassStripedFeaturesARM,
            *PhysicalDevicePipelineOpacityMicromapFeaturesARM,
            *PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR,
            *PhysicalDeviceShaderSubgroupRotateFeatures,
            *PhysicalDeviceShaderExpectAssumeFeatures,
            *PhysicalDeviceShaderFloatControls2Features,
            *PhysicalDeviceDynamicRenderingLocalReadFeatures,
            *PhysicalDeviceShaderQuadControlFeaturesKHR,
            *PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV,
            *PhysicalDeviceMapMemoryPlacedFeaturesEXT,
            *PhysicalDeviceShaderBfloat16FeaturesKHR,
            *PhysicalDeviceRawAccessChainsFeaturesNV,
            *PhysicalDeviceCommandBufferInheritanceFeaturesNV,
            *PhysicalDeviceImageAlignmentControlFeaturesMESA,
            *PhysicalDeviceShaderReplicatedCompositesFeaturesEXT,
            *PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR,
            *PhysicalDeviceCooperativeMatrix2FeaturesNV,
            *PhysicalDeviceHdrVividFeaturesHUAWEI,
            *PhysicalDeviceVertexAttributeRobustnessFeaturesEXT,
            *PhysicalDeviceDenseGeometryFormatFeaturesAMDX,
            *PhysicalDeviceDepthClampZeroOneFeaturesKHR,
            *PhysicalDeviceCooperativeVectorFeaturesNV,
            *PhysicalDeviceTileShadingFeaturesQCOM,
            *PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE,
            *PhysicalDevicePresentMeteringFeaturesNV,
            *ExternalComputeQueueDeviceCreateInfoNV,
            *PhysicalDeviceFormatPackFeaturesARM,
            *PhysicalDeviceTensorFeaturesARM,
            *PhysicalDeviceDescriptorBufferTensorFeaturesARM,
            *PhysicalDeviceShaderFloat8FeaturesEXT,
            *PhysicalDeviceDataGraphFeaturesARM,
            *PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC,
            *PhysicalDeviceShaderUntypedPointersFeaturesKHR,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const InstanceCreateInfo = extern struct {
    s_type: StructureType = .instance_create_info,
    p_next: ?*const anyopaque = null,
    flags: InstanceCreateFlags = .none,
    p_application_info: ?*const ApplicationInfo = null,
    enabled_layer_count: u32 = 0,
    pp_enabled_layer_names: ?[*]const ?[*:0]const u8 = null,
    enabled_extension_count: u32 = 0,
    pp_enabled_extension_names: ?[*]const ?[*:0]const u8 = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DebugReportCallbackCreateInfoEXT,
            *ValidationFlagsEXT,
            *ValidationFeaturesEXT,
            *LayerSettingsCreateInfoEXT,
            *DebugUtilsMessengerCreateInfoEXT,
            *ExportMetalObjectCreateInfoEXT,
            *DirectDriverLoadingListLUNARG,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const QueueFamilyProperties = extern struct {
    queue_flags: QueueFlags = .none,
    queue_count: u32 = 0,
    timestamp_valid_bits: u32 = 0,
    min_image_transfer_granularity: Extent3D = .{},
};
pub const PhysicalDeviceMemoryProperties = extern struct {
    memory_type_count: u32 = 0,
    memory_types: [max_memory_types]MemoryType = [_]MemoryType{.{}} ** max_memory_types,
    memory_heap_count: u32 = 0,
    memory_heaps: [max_memory_heaps]MemoryHeap = [_]MemoryHeap{.{}} ** max_memory_heaps,
};
pub const MemoryAllocateInfo = extern struct {
    s_type: StructureType = .memory_allocate_info,
    p_next: ?*const anyopaque = null,
    allocation_size: DeviceSize = 0,
    memory_type_index: u32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DedicatedAllocationMemoryAllocateInfoNV,
            *ExportMemoryAllocateInfoNV,
            *ImportMemoryWin32HandleInfoNV,
            *ExportMemoryWin32HandleInfoNV,
            *ExportMemoryAllocateInfo,
            *ImportMemoryWin32HandleInfoKHR,
            *ExportMemoryWin32HandleInfoKHR,
            *ImportMemoryZirconHandleInfoFUCHSIA,
            *ImportMemoryFdInfoKHR,
            *ImportMemoryMetalHandleInfoEXT,
            *MemoryAllocateFlagsInfo,
            *MemoryDedicatedAllocateInfo,
            *ImportMemoryHostPointerInfoEXT,
            *ImportAndroidHardwareBufferInfoANDROID,
            *MemoryPriorityAllocateInfoEXT,
            *MemoryOpaqueCaptureAddressAllocateInfo,
            *ImportMemoryBufferCollectionFUCHSIA,
            *ExportMetalObjectCreateInfoEXT,
            *ImportMetalBufferInfoEXT,
            *MemoryDedicatedAllocateInfoTensorARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const MemoryRequirements = extern struct {
    size: DeviceSize = 0,
    alignment: DeviceSize = 0,
    memory_type_bits: u32 = 0,
};
pub const SparseImageFormatProperties = extern struct {
    aspect_mask: ImageAspectFlags = .none,
    image_granularity: Extent3D = .{},
    flags: SparseImageFormatFlags = .none,
};
pub const SparseImageMemoryRequirements = extern struct {
    format_properties: SparseImageFormatProperties = .{},
    image_mip_tail_first_lod: u32 = 0,
    image_mip_tail_size: DeviceSize = 0,
    image_mip_tail_offset: DeviceSize = 0,
    image_mip_tail_stride: DeviceSize = 0,
};
pub const MemoryType = extern struct {
    property_flags: MemoryPropertyFlags = .none,
    heap_index: u32 = 0,
};
pub const MemoryHeap = extern struct {
    size: DeviceSize = 0,
    flags: MemoryHeapFlags = .none,
};
pub const MappedMemoryRange = extern struct {
    s_type: StructureType = .mapped_memory_range,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory = .null_handle,
    offset: DeviceSize = 0,
    size: DeviceSize = 0,
};
pub const FormatProperties = extern struct {
    linear_tiling_features: FormatFeatureFlags = .none,
    optimal_tiling_features: FormatFeatureFlags = .none,
    buffer_features: FormatFeatureFlags = .none,
};
pub const ImageFormatProperties = extern struct {
    max_extent: Extent3D = .{},
    max_mip_levels: u32 = 0,
    max_array_layers: u32 = 0,
    sample_counts: SampleCountFlags = .none,
    max_resource_size: DeviceSize = 0,
};
pub const DescriptorBufferInfo = extern struct {
    buffer: Buffer = .null_handle,
    offset: DeviceSize = 0,
    range: DeviceSize = 0,
};
pub const DescriptorImageInfo = extern struct {
    sampler: Sampler = .null_handle,
    image_view: ImageView = .null_handle,
    image_layout: ImageLayout = @enumFromInt(0),
};
pub const WriteDescriptorSet = extern struct {
    s_type: StructureType = .write_descriptor_set,
    p_next: ?*const anyopaque = null,
    dst_set: DescriptorSet = .null_handle,
    dst_binding: u32 = 0,
    dst_array_element: u32 = 0,
    descriptor_count: u32 = 0,
    descriptor_type: DescriptorType = @enumFromInt(0),
    p_image_info: ?[*]const DescriptorImageInfo = null,
    p_buffer_info: ?[*]const DescriptorBufferInfo = null,
    p_texel_buffer_view: ?[*]const BufferView = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *WriteDescriptorSetInlineUniformBlock,
            *WriteDescriptorSetAccelerationStructureKHR,
            *WriteDescriptorSetAccelerationStructureNV,
            *WriteDescriptorSetPartitionedAccelerationStructureNV,
            *WriteDescriptorSetTensorARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const CopyDescriptorSet = extern struct {
    s_type: StructureType = .copy_descriptor_set,
    p_next: ?*const anyopaque = null,
    src_set: DescriptorSet = .null_handle,
    src_binding: u32 = 0,
    src_array_element: u32 = 0,
    dst_set: DescriptorSet = .null_handle,
    dst_binding: u32 = 0,
    dst_array_element: u32 = 0,
    descriptor_count: u32 = 0,
};
pub const BufferUsageFlags2CreateInfo = extern struct {
    s_type: StructureType = .buffer_usage_flags_2_create_info,
    p_next: ?*const anyopaque = null,
    usage: BufferUsageFlags2 = .none,
};
pub const BufferUsageFlags2CreateInfoKHR = BufferUsageFlags2CreateInfo;
pub const BufferCreateInfo = extern struct {
    s_type: StructureType = .buffer_create_info,
    p_next: ?*const anyopaque = null,
    flags: BufferCreateFlags = .none,
    size: DeviceSize = 0,
    usage: BufferUsageFlags = .none,
    sharing_mode: SharingMode = @enumFromInt(0),
    queue_family_index_count: u32 = 0,
    p_queue_family_indices: ?[*]const u32 = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *BufferUsageFlags2CreateInfo,
            *DedicatedAllocationBufferCreateInfoNV,
            *ExternalMemoryBufferCreateInfo,
            *BufferOpaqueCaptureAddressCreateInfo,
            *BufferDeviceAddressCreateInfoEXT,
            *OpaqueCaptureDescriptorDataCreateInfoEXT,
            *BufferCollectionBufferCreateInfoFUCHSIA,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const BufferViewCreateInfo = extern struct {
    s_type: StructureType = .buffer_view_create_info,
    p_next: ?*const anyopaque = null,
    flags: BufferViewCreateFlags = .none,
    buffer: Buffer = .null_handle,
    format: Format = @enumFromInt(0),
    offset: DeviceSize = 0,
    range: DeviceSize = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *BufferUsageFlags2CreateInfo,
            *ExportMetalObjectCreateInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const ImageSubresource = extern struct {
    aspect_mask: ImageAspectFlags = .none,
    mip_level: u32 = 0,
    array_layer: u32 = 0,
};
pub const ImageSubresourceLayers = extern struct {
    aspect_mask: ImageAspectFlags = .none,
    mip_level: u32 = 0,
    base_array_layer: u32 = 0,
    layer_count: u32 = 0,
};
pub const ImageSubresourceRange = extern struct {
    aspect_mask: ImageAspectFlags = .none,
    base_mip_level: u32 = 0,
    level_count: u32 = 0,
    base_array_layer: u32 = 0,
    layer_count: u32 = 0,
};
pub const MemoryBarrier = extern struct {
    s_type: StructureType = .memory_barrier,
    p_next: ?*const anyopaque = null,
    src_access_mask: AccessFlags = .none,
    dst_access_mask: AccessFlags = .none,
};
pub const BufferMemoryBarrier = extern struct {
    s_type: StructureType = .buffer_memory_barrier,
    p_next: ?*const anyopaque = null,
    src_access_mask: AccessFlags = .none,
    dst_access_mask: AccessFlags = .none,
    src_queue_family_index: u32 = 0,
    dst_queue_family_index: u32 = 0,
    buffer: Buffer = .null_handle,
    offset: DeviceSize = 0,
    size: DeviceSize = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ExternalMemoryAcquireUnmodifiedEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const ImageMemoryBarrier = extern struct {
    s_type: StructureType = .image_memory_barrier,
    p_next: ?*const anyopaque = null,
    src_access_mask: AccessFlags = .none,
    dst_access_mask: AccessFlags = .none,
    old_layout: ImageLayout = @enumFromInt(0),
    new_layout: ImageLayout = @enumFromInt(0),
    src_queue_family_index: u32 = 0,
    dst_queue_family_index: u32 = 0,
    image: Image = .null_handle,
    subresource_range: ImageSubresourceRange = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *SampleLocationsInfoEXT,
            *ExternalMemoryAcquireUnmodifiedEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const ImageCreateInfo = extern struct {
    s_type: StructureType = .image_create_info,
    p_next: ?*const anyopaque = null,
    flags: ImageCreateFlags = .none,
    image_type: ImageType = @enumFromInt(0),
    format: Format = @enumFromInt(0),
    extent: Extent3D = .{},
    mip_levels: u32 = 0,
    array_layers: u32 = 0,
    samples: SampleCountFlags = .none,
    tiling: ImageTiling = @enumFromInt(0),
    usage: ImageUsageFlags = .none,
    sharing_mode: SharingMode = @enumFromInt(0),
    queue_family_index_count: u32 = 0,
    p_queue_family_indices: ?[*]const u32 = null,
    initial_layout: ImageLayout = @enumFromInt(0),
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DedicatedAllocationImageCreateInfoNV,
            *ExternalMemoryImageCreateInfoNV,
            *ExternalMemoryImageCreateInfo,
            *ImageSwapchainCreateInfoKHR,
            *ImageFormatListCreateInfo,
            *ExternalFormatANDROID,
            *ImageDrmFormatModifierListCreateInfoEXT,
            *ImageDrmFormatModifierExplicitCreateInfoEXT,
            *ImageStencilUsageCreateInfo,
            *OpaqueCaptureDescriptorDataCreateInfoEXT,
            *BufferCollectionImageCreateInfoFUCHSIA,
            *ImageCompressionControlEXT,
            *ExportMetalObjectCreateInfoEXT,
            *ImportMetalTextureInfoEXT,
            *ImportMetalIOSurfaceInfoEXT,
            *OpticalFlowImageFormatInfoNV,
            *ImageAlignmentControlCreateInfoMESA,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const SubresourceLayout = extern struct {
    offset: DeviceSize = 0,
    size: DeviceSize = 0,
    row_pitch: DeviceSize = 0,
    array_pitch: DeviceSize = 0,
    depth_pitch: DeviceSize = 0,
};
pub const ImageViewCreateInfo = extern struct {
    s_type: StructureType = .image_view_create_info,
    p_next: ?*const anyopaque = null,
    flags: ImageViewCreateFlags = .none,
    image: Image = .null_handle,
    view_type: ImageViewType = @enumFromInt(0),
    format: Format = @enumFromInt(0),
    components: ComponentMapping = .{},
    subresource_range: ImageSubresourceRange = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ImageViewUsageCreateInfo,
            *ImageViewSlicedCreateInfoEXT,
            *SamplerYcbcrConversionInfo,
            *ImageViewASTCDecodeModeEXT,
            *OpaqueCaptureDescriptorDataCreateInfoEXT,
            *ImageViewMinLodCreateInfoEXT,
            *ExportMetalObjectCreateInfoEXT,
            *ImageViewSampleWeightCreateInfoQCOM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const BufferCopy = extern struct {
    src_offset: DeviceSize = 0,
    dst_offset: DeviceSize = 0,
    size: DeviceSize = 0,
};
pub const SparseMemoryBind = extern struct {
    resource_offset: DeviceSize = 0,
    size: DeviceSize = 0,
    memory: DeviceMemory = .null_handle,
    memory_offset: DeviceSize = 0,
    flags: SparseMemoryBindFlags = .none,
};
pub const SparseImageMemoryBind = extern struct {
    subresource: ImageSubresource = .{},
    offset: Offset3D = .{},
    extent: Extent3D = .{},
    memory: DeviceMemory = .null_handle,
    memory_offset: DeviceSize = 0,
    flags: SparseMemoryBindFlags = .none,
};
pub const SparseBufferMemoryBindInfo = extern struct {
    buffer: Buffer = .null_handle,
    bind_count: u32 = 0,
    p_binds: ?[*]const SparseMemoryBind = null,
};
pub const SparseImageOpaqueMemoryBindInfo = extern struct {
    image: Image = .null_handle,
    bind_count: u32 = 0,
    p_binds: ?[*]const SparseMemoryBind = null,
};
pub const SparseImageMemoryBindInfo = extern struct {
    image: Image = .null_handle,
    bind_count: u32 = 0,
    p_binds: ?[*]const SparseImageMemoryBind = null,
};
pub const BindSparseInfo = extern struct {
    s_type: StructureType = .bind_sparse_info,
    p_next: ?*const anyopaque = null,
    wait_semaphore_count: u32 = 0,
    p_wait_semaphores: ?[*]const Semaphore = null,
    buffer_bind_count: u32 = 0,
    p_buffer_binds: ?[*]const SparseBufferMemoryBindInfo = null,
    image_opaque_bind_count: u32 = 0,
    p_image_opaque_binds: ?[*]const SparseImageOpaqueMemoryBindInfo = null,
    image_bind_count: u32 = 0,
    p_image_binds: ?[*]const SparseImageMemoryBindInfo = null,
    signal_semaphore_count: u32 = 0,
    p_signal_semaphores: ?[*]const Semaphore = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DeviceGroupBindSparseInfo,
            *TimelineSemaphoreSubmitInfo,
            *FrameBoundaryEXT,
            *FrameBoundaryTensorsARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const ImageCopy = extern struct {
    src_subresource: ImageSubresourceLayers = .{},
    src_offset: Offset3D = .{},
    dst_subresource: ImageSubresourceLayers = .{},
    dst_offset: Offset3D = .{},
    extent: Extent3D = .{},
};
pub const ImageBlit = extern struct {
    src_subresource: ImageSubresourceLayers = .{},
    src_offsets: [2]Offset3D = [_]Offset3D{.{}} ** 2,
    dst_subresource: ImageSubresourceLayers = .{},
    dst_offsets: [2]Offset3D = [_]Offset3D{.{}} ** 2,
};
pub const BufferImageCopy = extern struct {
    buffer_offset: DeviceSize = 0,
    buffer_row_length: u32 = 0,
    buffer_image_height: u32 = 0,
    image_subresource: ImageSubresourceLayers = .{},
    image_offset: Offset3D = .{},
    image_extent: Extent3D = .{},
};
pub const CopyMemoryIndirectCommandNV = extern struct {
    src_address: DeviceAddress = 0,
    dst_address: DeviceAddress = 0,
    size: DeviceSize = 0,
};
pub const CopyMemoryToImageIndirectCommandNV = extern struct {
    src_address: DeviceAddress = 0,
    buffer_row_length: u32 = 0,
    buffer_image_height: u32 = 0,
    image_subresource: ImageSubresourceLayers = .{},
    image_offset: Offset3D = .{},
    image_extent: Extent3D = .{},
};
pub const ImageResolve = extern struct {
    src_subresource: ImageSubresourceLayers = .{},
    src_offset: Offset3D = .{},
    dst_subresource: ImageSubresourceLayers = .{},
    dst_offset: Offset3D = .{},
    extent: Extent3D = .{},
};
pub const ShaderModuleCreateInfo = extern struct {
    s_type: StructureType = .shader_module_create_info,
    p_next: ?*const anyopaque = null,
    flags: ShaderModuleCreateFlags = .none,
    code_size: usize = 0,
    p_code: ?[*]const u32 = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ValidationFeaturesEXT,
            *ShaderModuleValidationCacheCreateInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DescriptorSetLayoutBinding = extern struct {
    binding: u32 = 0,
    descriptor_type: DescriptorType = @enumFromInt(0),
    descriptor_count: u32 = 0,
    stage_flags: ShaderStageFlags = .none,
    p_immutable_samplers: ?[*]const Sampler = null,
};
pub const DescriptorSetLayoutCreateInfo = extern struct {
    s_type: StructureType = .descriptor_set_layout_create_info,
    p_next: ?*const anyopaque = null,
    flags: DescriptorSetLayoutCreateFlags = .none,
    binding_count: u32 = 0,
    p_bindings: ?[*]const DescriptorSetLayoutBinding = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DescriptorSetLayoutBindingFlagsCreateInfo,
            *MutableDescriptorTypeCreateInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DescriptorPoolSize = extern struct {
    type: DescriptorType = @enumFromInt(0),
    descriptor_count: u32 = 0,
};
pub const DescriptorPoolCreateInfo = extern struct {
    s_type: StructureType = .descriptor_pool_create_info,
    p_next: ?*const anyopaque = null,
    flags: DescriptorPoolCreateFlags = .none,
    max_sets: u32 = 0,
    pool_size_count: u32 = 0,
    p_pool_sizes: ?[*]const DescriptorPoolSize = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DescriptorPoolInlineUniformBlockCreateInfo,
            *MutableDescriptorTypeCreateInfoEXT,
            *DataGraphProcessingEngineCreateInfoARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DescriptorSetAllocateInfo = extern struct {
    s_type: StructureType = .descriptor_set_allocate_info,
    p_next: ?*const anyopaque = null,
    descriptor_pool: DescriptorPool = .null_handle,
    descriptor_set_count: u32 = 0,
    p_set_layouts: ?[*]const DescriptorSetLayout = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DescriptorSetVariableDescriptorCountAllocateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const SpecializationMapEntry = extern struct {
    constant_id: u32 = 0,
    offset: u32 = 0,
    size: usize = 0,
};
pub const SpecializationInfo = extern struct {
    map_entry_count: u32 = 0,
    p_map_entries: ?[*]const SpecializationMapEntry = null,
    data_size: usize = 0,
    p_data: ?*const anyopaque = null,
};
pub const PipelineShaderStageCreateInfo = extern struct {
    s_type: StructureType = .pipeline_shader_stage_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineShaderStageCreateFlags = .none,
    stage: ShaderStageFlags = .none,
    module: ShaderModule = .null_handle,
    p_name: ?[*:0]const u8 = null,
    p_specialization_info: ?*const SpecializationInfo = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ShaderModuleCreateInfo,
            *ShaderModuleValidationCacheCreateInfoEXT,
            *DebugUtilsObjectNameInfoEXT,
            *PipelineShaderStageRequiredSubgroupSizeCreateInfo,
            *PipelineShaderStageModuleIdentifierCreateInfoEXT,
            *PipelineRobustnessCreateInfo,
            *PipelineShaderStageNodeCreateInfoAMDX,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const ComputePipelineCreateInfo = extern struct {
    s_type: StructureType = .compute_pipeline_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineCreateFlags = .none,
    stage: PipelineShaderStageCreateInfo = .{},
    layout: PipelineLayout = .null_handle,
    base_pipeline_handle: Pipeline = .null_handle,
    base_pipeline_index: i32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ComputePipelineIndirectBufferInfoNV,
            *PipelineCreateFlags2CreateInfo,
            *PipelineBinaryInfoKHR,
            *PipelineCreationFeedbackCreateInfo,
            *SubpassShadingPipelineCreateInfoHUAWEI,
            *PipelineCompilerControlCreateInfoAMD,
            *PipelineRobustnessCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const ComputePipelineIndirectBufferInfoNV = extern struct {
    s_type: StructureType = .compute_pipeline_indirect_buffer_info_nv,
    p_next: ?*const anyopaque = null,
    device_address: DeviceAddress = 0,
    size: DeviceSize = 0,
    pipeline_device_address_capture_replay: DeviceAddress = 0,
};
pub const PipelineCreateFlags2CreateInfo = extern struct {
    s_type: StructureType = .pipeline_create_flags_2_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineCreateFlags2 = .none,
};
pub const PipelineCreateFlags2CreateInfoKHR = PipelineCreateFlags2CreateInfo;
pub const VertexInputBindingDescription = extern struct {
    binding: u32 = 0,
    stride: u32 = 0,
    input_rate: VertexInputRate = @enumFromInt(0),
};
pub const VertexInputAttributeDescription = extern struct {
    location: u32 = 0,
    binding: u32 = 0,
    format: Format = @enumFromInt(0),
    offset: u32 = 0,
};
pub const PipelineVertexInputStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_vertex_input_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineVertexInputStateCreateFlags = .none,
    vertex_binding_description_count: u32 = 0,
    p_vertex_binding_descriptions: ?[*]const VertexInputBindingDescription = null,
    vertex_attribute_description_count: u32 = 0,
    p_vertex_attribute_descriptions: ?[*]const VertexInputAttributeDescription = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineVertexInputDivisorStateCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PipelineInputAssemblyStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_input_assembly_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineInputAssemblyStateCreateFlags = .none,
    topology: PrimitiveTopology = @enumFromInt(0),
    primitive_restart_enable: Bool32 = .false,
};
pub const PipelineTessellationStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_tessellation_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineTessellationStateCreateFlags = .none,
    patch_control_points: u32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineTessellationDomainOriginStateCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PipelineViewportStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_viewport_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineViewportStateCreateFlags = .none,
    viewport_count: u32 = 0,
    p_viewports: ?[*]const Viewport = null,
    scissor_count: u32 = 0,
    p_scissors: ?[*]const Rect2D = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineViewportWScalingStateCreateInfoNV,
            *PipelineViewportSwizzleStateCreateInfoNV,
            *PipelineViewportExclusiveScissorStateCreateInfoNV,
            *PipelineViewportShadingRateImageStateCreateInfoNV,
            *PipelineViewportCoarseSampleOrderStateCreateInfoNV,
            *PipelineViewportDepthClipControlCreateInfoEXT,
            *PipelineViewportDepthClampControlCreateInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PipelineRasterizationStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_rasterization_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineRasterizationStateCreateFlags = .none,
    depth_clamp_enable: Bool32 = .false,
    rasterizer_discard_enable: Bool32 = .false,
    polygon_mode: PolygonMode = @enumFromInt(0),
    cull_mode: CullModeFlags = .none,
    front_face: FrontFace = @enumFromInt(0),
    depth_bias_enable: Bool32 = .false,
    depth_bias_constant_factor: f32 = 0,
    depth_bias_clamp: f32 = 0,
    depth_bias_slope_factor: f32 = 0,
    line_width: f32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineRasterizationStateRasterizationOrderAMD,
            *PipelineRasterizationConservativeStateCreateInfoEXT,
            *PipelineRasterizationStateStreamCreateInfoEXT,
            *PipelineRasterizationDepthClipStateCreateInfoEXT,
            *PipelineRasterizationLineStateCreateInfo,
            *PipelineRasterizationProvokingVertexStateCreateInfoEXT,
            *DepthBiasRepresentationInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PipelineMultisampleStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_multisample_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineMultisampleStateCreateFlags = .none,
    rasterization_samples: SampleCountFlags = .none,
    sample_shading_enable: Bool32 = .false,
    min_sample_shading: f32 = 0,
    p_sample_mask: ?[*]const SampleMask = null,
    alpha_to_coverage_enable: Bool32 = .false,
    alpha_to_one_enable: Bool32 = .false,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineCoverageToColorStateCreateInfoNV,
            *PipelineSampleLocationsStateCreateInfoEXT,
            *PipelineCoverageModulationStateCreateInfoNV,
            *PipelineCoverageReductionStateCreateInfoNV,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PipelineColorBlendAttachmentState = extern struct {
    blend_enable: Bool32 = .false,
    src_color_blend_factor: BlendFactor = @enumFromInt(0),
    dst_color_blend_factor: BlendFactor = @enumFromInt(0),
    color_blend_op: BlendOp = @enumFromInt(0),
    src_alpha_blend_factor: BlendFactor = @enumFromInt(0),
    dst_alpha_blend_factor: BlendFactor = @enumFromInt(0),
    alpha_blend_op: BlendOp = @enumFromInt(0),
    color_write_mask: ColorComponentFlags = .none,
};
pub const PipelineColorBlendStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_color_blend_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineColorBlendStateCreateFlags = .none,
    logic_op_enable: Bool32 = .false,
    logic_op: LogicOp = @enumFromInt(0),
    attachment_count: u32 = 0,
    p_attachments: ?[*]const PipelineColorBlendAttachmentState = null,
    blend_constants: [4]f32 = [_]f32{0} ** 4,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineColorBlendAdvancedStateCreateInfoEXT,
            *PipelineColorWriteCreateInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PipelineDynamicStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_dynamic_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineDynamicStateCreateFlags = .none,
    dynamic_state_count: u32 = 0,
    p_dynamic_states: ?[*]const DynamicState = null,
};
pub const StencilOpState = extern struct {
    fail_op: StencilOp = @enumFromInt(0),
    pass_op: StencilOp = @enumFromInt(0),
    depth_fail_op: StencilOp = @enumFromInt(0),
    compare_op: CompareOp = @enumFromInt(0),
    compare_mask: u32 = 0,
    write_mask: u32 = 0,
    reference: u32 = 0,
};
pub const PipelineDepthStencilStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_depth_stencil_state_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineDepthStencilStateCreateFlags = .none,
    depth_test_enable: Bool32 = .false,
    depth_write_enable: Bool32 = .false,
    depth_compare_op: CompareOp = @enumFromInt(0),
    depth_bounds_test_enable: Bool32 = .false,
    stencil_test_enable: Bool32 = .false,
    front: StencilOpState = .{},
    back: StencilOpState = .{},
    min_depth_bounds: f32 = 0,
    max_depth_bounds: f32 = 0,
};
pub const GraphicsPipelineCreateInfo = extern struct {
    s_type: StructureType = .graphics_pipeline_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineCreateFlags = .none,
    stage_count: u32 = 0,
    p_stages: ?[*]const PipelineShaderStageCreateInfo = null,
    p_vertex_input_state: ?*const PipelineVertexInputStateCreateInfo = null,
    p_input_assembly_state: ?*const PipelineInputAssemblyStateCreateInfo = null,
    p_tessellation_state: ?*const PipelineTessellationStateCreateInfo = null,
    p_viewport_state: ?*const PipelineViewportStateCreateInfo = null,
    p_rasterization_state: ?*const PipelineRasterizationStateCreateInfo = null,
    p_multisample_state: ?*const PipelineMultisampleStateCreateInfo = null,
    p_depth_stencil_state: ?*const PipelineDepthStencilStateCreateInfo = null,
    p_color_blend_state: ?*const PipelineColorBlendStateCreateInfo = null,
    p_dynamic_state: ?*const PipelineDynamicStateCreateInfo = null,
    layout: PipelineLayout = .null_handle,
    render_pass: RenderPass = .null_handle,
    subpass: u32 = 0,
    base_pipeline_handle: Pipeline = .null_handle,
    base_pipeline_index: i32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineCreateFlags2CreateInfo,
            *PipelineBinaryInfoKHR,
            *GraphicsPipelineShaderGroupsCreateInfoNV,
            *PipelineDiscardRectangleStateCreateInfoEXT,
            *ExternalFormatANDROID,
            *PipelineRepresentativeFragmentTestStateCreateInfoNV,
            *PipelineCreationFeedbackCreateInfo,
            *PipelineCompilerControlCreateInfoAMD,
            *PipelineLibraryCreateInfoKHR,
            *PipelineFragmentShadingRateStateCreateInfoKHR,
            *PipelineFragmentShadingRateEnumStateCreateInfoNV,
            *PipelineRenderingCreateInfo,
            *AttachmentSampleCountInfoAMD,
            *MultiviewPerViewAttributesInfoNVX,
            *GraphicsPipelineLibraryCreateInfoEXT,
            *PipelineRobustnessCreateInfo,
            *RenderingAttachmentLocationInfo,
            *RenderingInputAttachmentIndexInfo,
            *PipelineFragmentDensityMapLayeredCreateInfoVALVE,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PipelineCacheCreateInfo = extern struct {
    s_type: StructureType = .pipeline_cache_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineCacheCreateFlags = .none,
    initial_data_size: usize = 0,
    p_initial_data: ?*const anyopaque = null,
};
pub const PipelineCacheHeaderVersionOne = extern struct {
    header_size: u32 = 0,
    header_version: PipelineCacheHeaderVersion = @enumFromInt(0),
    vendor_id: u32 = 0,
    device_id: u32 = 0,
    pipeline_cache_uuid: [uuid_size]u8 = [_]u8{0} ** uuid_size,
};
pub const PushConstantRange = extern struct {
    stage_flags: ShaderStageFlags = .none,
    offset: u32 = 0,
    size: u32 = 0,
};
pub const PipelineBinaryCreateInfoKHR = extern struct {
    s_type: StructureType = .pipeline_binary_create_info_khr,
    p_next: ?*const anyopaque = null,
    p_keys_and_data_info: ?*const PipelineBinaryKeysAndDataKHR = null,
    pipeline: Pipeline = .null_handle,
    p_pipeline_create_info: ?*const PipelineCreateInfoKHR = null,
};
pub const PipelineBinaryHandlesInfoKHR = extern struct {
    s_type: StructureType = .pipeline_binary_handles_info_khr,
    p_next: ?*const anyopaque = null,
    pipeline_binary_count: u32 = 0,
    p_pipeline_binaries: ?[*]PipelineBinaryKHR = null,
};
pub const PipelineBinaryDataKHR = extern struct {
    data_size: usize = 0,
    p_data: ?*anyopaque = null,
};
pub const PipelineBinaryKeysAndDataKHR = extern struct {
    binary_count: u32 = 0,
    p_pipeline_binary_keys: ?[*]const PipelineBinaryKeyKHR = null,
    p_pipeline_binary_data: ?[*]const PipelineBinaryDataKHR = null,
};
pub const PipelineBinaryKeyKHR = extern struct {
    s_type: StructureType = .pipeline_binary_key_khr,
    p_next: ?*anyopaque = null,
    key_size: u32 = 0,
    key: [max_pipeline_binary_key_size_khr]u8 = [_]u8{0} ** max_pipeline_binary_key_size_khr,
};
pub const PipelineBinaryInfoKHR = extern struct {
    s_type: StructureType = .pipeline_binary_info_khr,
    p_next: ?*const anyopaque = null,
    binary_count: u32 = 0,
    p_pipeline_binaries: ?[*]const PipelineBinaryKHR = null,
};
pub const ReleaseCapturedPipelineDataInfoKHR = extern struct {
    s_type: StructureType = .release_captured_pipeline_data_info_khr,
    p_next: ?*anyopaque = null,
    pipeline: Pipeline = .null_handle,
};
pub const PipelineBinaryDataInfoKHR = extern struct {
    s_type: StructureType = .pipeline_binary_data_info_khr,
    p_next: ?*anyopaque = null,
    pipeline_binary: PipelineBinaryKHR = .null_handle,
};
pub const PipelineCreateInfoKHR = extern struct {
    s_type: StructureType = .pipeline_create_info_khr,
    p_next: ?*anyopaque = null,
};
pub const PipelineLayoutCreateInfo = extern struct {
    s_type: StructureType = .pipeline_layout_create_info,
    p_next: ?*const anyopaque = null,
    flags: PipelineLayoutCreateFlags = .none,
    set_layout_count: u32 = 0,
    p_set_layouts: ?[*]const DescriptorSetLayout = null,
    push_constant_range_count: u32 = 0,
    p_push_constant_ranges: ?[*]const PushConstantRange = null,
};
pub const SamplerCreateInfo = extern struct {
    s_type: StructureType = .sampler_create_info,
    p_next: ?*const anyopaque = null,
    flags: SamplerCreateFlags = .none,
    mag_filter: Filter = @enumFromInt(0),
    min_filter: Filter = @enumFromInt(0),
    mipmap_mode: SamplerMipmapMode = @enumFromInt(0),
    address_mode_u: SamplerAddressMode = @enumFromInt(0),
    address_mode_v: SamplerAddressMode = @enumFromInt(0),
    address_mode_w: SamplerAddressMode = @enumFromInt(0),
    mip_lod_bias: f32 = 0,
    anisotropy_enable: Bool32 = .false,
    max_anisotropy: f32 = 0,
    compare_enable: Bool32 = .false,
    compare_op: CompareOp = @enumFromInt(0),
    min_lod: f32 = 0,
    max_lod: f32 = 0,
    border_color: BorderColor = @enumFromInt(0),
    unnormalized_coordinates: Bool32 = .false,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *SamplerYcbcrConversionInfo,
            *SamplerReductionModeCreateInfo,
            *SamplerCustomBorderColorCreateInfoEXT,
            *SamplerBorderColorComponentMappingCreateInfoEXT,
            *OpaqueCaptureDescriptorDataCreateInfoEXT,
            *SamplerCubicWeightsCreateInfoQCOM,
            *SamplerBlockMatchWindowCreateInfoQCOM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const CommandPoolCreateInfo = extern struct {
    s_type: StructureType = .command_pool_create_info,
    p_next: ?*const anyopaque = null,
    flags: CommandPoolCreateFlags = .none,
    queue_family_index: u32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DataGraphProcessingEngineCreateInfoARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const CommandBufferAllocateInfo = extern struct {
    s_type: StructureType = .command_buffer_allocate_info,
    p_next: ?*const anyopaque = null,
    command_pool: CommandPool = .null_handle,
    level: CommandBufferLevel = @enumFromInt(0),
    command_buffer_count: u32 = 0,
};
pub const CommandBufferInheritanceInfo = extern struct {
    s_type: StructureType = .command_buffer_inheritance_info,
    p_next: ?*const anyopaque = null,
    render_pass: RenderPass = .null_handle,
    subpass: u32 = 0,
    framebuffer: Framebuffer = .null_handle,
    occlusion_query_enable: Bool32 = .false,
    query_flags: QueryControlFlags = .none,
    pipeline_statistics: QueryPipelineStatisticFlags = .none,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *CommandBufferInheritanceConditionalRenderingInfoEXT,
            *ExternalFormatANDROID,
            *CommandBufferInheritanceRenderPassTransformInfoQCOM,
            *CommandBufferInheritanceViewportScissorInfoNV,
            *CommandBufferInheritanceRenderingInfo,
            *AttachmentSampleCountInfoAMD,
            *MultiviewPerViewAttributesInfoNVX,
            *TileMemoryBindInfoQCOM,
            *RenderingAttachmentLocationInfo,
            *RenderingInputAttachmentIndexInfo,
            *RenderPassTileShadingCreateInfoQCOM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const CommandBufferBeginInfo = extern struct {
    s_type: StructureType = .command_buffer_begin_info,
    p_next: ?*const anyopaque = null,
    flags: CommandBufferUsageFlags = .none,
    p_inheritance_info: ?*const CommandBufferInheritanceInfo = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DeviceGroupCommandBufferBeginInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const RenderPassBeginInfo = extern struct {
    s_type: StructureType = .render_pass_begin_info,
    p_next: ?*const anyopaque = null,
    render_pass: RenderPass = .null_handle,
    framebuffer: Framebuffer = .null_handle,
    render_area: Rect2D = .{},
    clear_value_count: u32 = 0,
    p_clear_values: ?[*]const ClearValue = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DeviceGroupRenderPassBeginInfo,
            *RenderPassSampleLocationsBeginInfoEXT,
            *RenderPassAttachmentBeginInfo,
            *RenderPassTransformBeginInfoQCOM,
            *MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM,
            *RenderPassStripeBeginInfoARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const ClearColorValue = extern union {
    float32: [4]f32,
    int32: [4]i32,
    uint32: [4]u32,
};
pub const ClearDepthStencilValue = extern struct {
    depth: f32 = 0,
    stencil: u32 = 0,
};
pub const ClearValue = extern union {
    color: ClearColorValue,
    depth_stencil: ClearDepthStencilValue,
};
pub const ClearAttachment = extern struct {
    aspect_mask: ImageAspectFlags = .none,
    color_attachment: u32 = 0,
    clear_value: ClearValue = .{ .color = .{ .float32 = [_]f32{0} ** 4 } },
};
pub const AttachmentDescription = extern struct {
    flags: AttachmentDescriptionFlags = .none,
    format: Format = @enumFromInt(0),
    samples: SampleCountFlags = .none,
    load_op: AttachmentLoadOp = @enumFromInt(0),
    store_op: AttachmentStoreOp = @enumFromInt(0),
    stencil_load_op: AttachmentLoadOp = @enumFromInt(0),
    stencil_store_op: AttachmentStoreOp = @enumFromInt(0),
    initial_layout: ImageLayout = @enumFromInt(0),
    final_layout: ImageLayout = @enumFromInt(0),
};
pub const AttachmentReference = extern struct {
    attachment: u32 = 0,
    layout: ImageLayout = @enumFromInt(0),
};
pub const SubpassDescription = extern struct {
    flags: SubpassDescriptionFlags = .none,
    pipeline_bind_point: PipelineBindPoint = @enumFromInt(0),
    input_attachment_count: u32 = 0,
    p_input_attachments: ?[*]const AttachmentReference = null,
    color_attachment_count: u32 = 0,
    p_color_attachments: ?[*]const AttachmentReference = null,
    p_resolve_attachments: ?[*]const AttachmentReference = null,
    p_depth_stencil_attachment: ?*const AttachmentReference = null,
    preserve_attachment_count: u32 = 0,
    p_preserve_attachments: ?[*]const u32 = null,
};
pub const SubpassDependency = extern struct {
    src_subpass: u32 = 0,
    dst_subpass: u32 = 0,
    src_stage_mask: PipelineStageFlags = .none,
    dst_stage_mask: PipelineStageFlags = .none,
    src_access_mask: AccessFlags = .none,
    dst_access_mask: AccessFlags = .none,
    dependency_flags: DependencyFlags = .none,
};
pub const RenderPassCreateInfo = extern struct {
    s_type: StructureType = .render_pass_create_info,
    p_next: ?*const anyopaque = null,
    flags: RenderPassCreateFlags = .none,
    attachment_count: u32 = 0,
    p_attachments: ?[*]const AttachmentDescription = null,
    subpass_count: u32 = 0,
    p_subpasses: ?[*]const SubpassDescription = null,
    dependency_count: u32 = 0,
    p_dependencies: ?[*]const SubpassDependency = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *RenderPassMultiviewCreateInfo,
            *RenderPassInputAttachmentAspectCreateInfo,
            *RenderPassFragmentDensityMapCreateInfoEXT,
            *TileMemorySizeInfoQCOM,
            *RenderPassTileShadingCreateInfoQCOM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const EventCreateInfo = extern struct {
    s_type: StructureType = .event_create_info,
    p_next: ?*const anyopaque = null,
    flags: EventCreateFlags = .none,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ExportMetalObjectCreateInfoEXT,
            *ImportMetalSharedEventInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const FenceCreateInfo = extern struct {
    s_type: StructureType = .fence_create_info,
    p_next: ?*const anyopaque = null,
    flags: FenceCreateFlags = .none,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ExportFenceCreateInfo,
            *ExportFenceWin32HandleInfoKHR,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PhysicalDeviceFeatures = extern struct {
    robust_buffer_access: Bool32 = .false,
    full_draw_index_uint32: Bool32 = .false,
    image_cube_array: Bool32 = .false,
    independent_blend: Bool32 = .false,
    geometry_shader: Bool32 = .false,
    tessellation_shader: Bool32 = .false,
    sample_rate_shading: Bool32 = .false,
    dual_src_blend: Bool32 = .false,
    logic_op: Bool32 = .false,
    multi_draw_indirect: Bool32 = .false,
    draw_indirect_first_instance: Bool32 = .false,
    depth_clamp: Bool32 = .false,
    depth_bias_clamp: Bool32 = .false,
    fill_mode_non_solid: Bool32 = .false,
    depth_bounds: Bool32 = .false,
    wide_lines: Bool32 = .false,
    large_points: Bool32 = .false,
    alpha_to_one: Bool32 = .false,
    multi_viewport: Bool32 = .false,
    sampler_anisotropy: Bool32 = .false,
    texture_compression_etc2: Bool32 = .false,
    texture_compression_astc_ldr: Bool32 = .false,
    texture_compression_bc: Bool32 = .false,
    occlusion_query_precise: Bool32 = .false,
    pipeline_statistics_query: Bool32 = .false,
    vertex_pipeline_stores_and_atomics: Bool32 = .false,
    fragment_stores_and_atomics: Bool32 = .false,
    shader_tessellation_and_geometry_point_size: Bool32 = .false,
    shader_image_gather_extended: Bool32 = .false,
    shader_storage_image_extended_formats: Bool32 = .false,
    shader_storage_image_multisample: Bool32 = .false,
    shader_storage_image_read_without_format: Bool32 = .false,
    shader_storage_image_write_without_format: Bool32 = .false,
    shader_uniform_buffer_array_dynamic_indexing: Bool32 = .false,
    shader_sampled_image_array_dynamic_indexing: Bool32 = .false,
    shader_storage_buffer_array_dynamic_indexing: Bool32 = .false,
    shader_storage_image_array_dynamic_indexing: Bool32 = .false,
    shader_clip_distance: Bool32 = .false,
    shader_cull_distance: Bool32 = .false,
    shader_float64: Bool32 = .false,
    shader_int64: Bool32 = .false,
    shader_int16: Bool32 = .false,
    shader_resource_residency: Bool32 = .false,
    shader_resource_min_lod: Bool32 = .false,
    sparse_binding: Bool32 = .false,
    sparse_residency_buffer: Bool32 = .false,
    sparse_residency_image_2d: Bool32 = .false,
    sparse_residency_image_3d: Bool32 = .false,
    sparse_residency2_samples: Bool32 = .false,
    sparse_residency4_samples: Bool32 = .false,
    sparse_residency8_samples: Bool32 = .false,
    sparse_residency16_samples: Bool32 = .false,
    sparse_residency_aliased: Bool32 = .false,
    variable_multisample_rate: Bool32 = .false,
    inherited_queries: Bool32 = .false,
};
pub const PhysicalDeviceSparseProperties = extern struct {
    residency_standard_2d_block_shape: Bool32 = .false,
    residency_standard_2d_multisample_block_shape: Bool32 = .false,
    residency_standard_3d_block_shape: Bool32 = .false,
    residency_aligned_mip_size: Bool32 = .false,
    residency_non_resident_strict: Bool32 = .false,
};
pub const PhysicalDeviceLimits = extern struct {
    max_image_dimension_1d: u32 = 0,
    max_image_dimension_2d: u32 = 0,
    max_image_dimension_3d: u32 = 0,
    max_image_dimension_cube: u32 = 0,
    max_image_array_layers: u32 = 0,
    max_texel_buffer_elements: u32 = 0,
    max_uniform_buffer_range: u32 = 0,
    max_storage_buffer_range: u32 = 0,
    max_push_constants_size: u32 = 0,
    max_memory_allocation_count: u32 = 0,
    max_sampler_allocation_count: u32 = 0,
    buffer_image_granularity: DeviceSize = 0,
    sparse_address_space_size: DeviceSize = 0,
    max_bound_descriptor_sets: u32 = 0,
    max_per_stage_descriptor_samplers: u32 = 0,
    max_per_stage_descriptor_uniform_buffers: u32 = 0,
    max_per_stage_descriptor_storage_buffers: u32 = 0,
    max_per_stage_descriptor_sampled_images: u32 = 0,
    max_per_stage_descriptor_storage_images: u32 = 0,
    max_per_stage_descriptor_input_attachments: u32 = 0,
    max_per_stage_resources: u32 = 0,
    max_descriptor_set_samplers: u32 = 0,
    max_descriptor_set_uniform_buffers: u32 = 0,
    max_descriptor_set_uniform_buffers_dynamic: u32 = 0,
    max_descriptor_set_storage_buffers: u32 = 0,
    max_descriptor_set_storage_buffers_dynamic: u32 = 0,
    max_descriptor_set_sampled_images: u32 = 0,
    max_descriptor_set_storage_images: u32 = 0,
    max_descriptor_set_input_attachments: u32 = 0,
    max_vertex_input_attributes: u32 = 0,
    max_vertex_input_bindings: u32 = 0,
    max_vertex_input_attribute_offset: u32 = 0,
    max_vertex_input_binding_stride: u32 = 0,
    max_vertex_output_components: u32 = 0,
    max_tessellation_generation_level: u32 = 0,
    max_tessellation_patch_size: u32 = 0,
    max_tessellation_control_per_vertex_input_components: u32 = 0,
    max_tessellation_control_per_vertex_output_components: u32 = 0,
    max_tessellation_control_per_patch_output_components: u32 = 0,
    max_tessellation_control_total_output_components: u32 = 0,
    max_tessellation_evaluation_input_components: u32 = 0,
    max_tessellation_evaluation_output_components: u32 = 0,
    max_geometry_shader_invocations: u32 = 0,
    max_geometry_input_components: u32 = 0,
    max_geometry_output_components: u32 = 0,
    max_geometry_output_vertices: u32 = 0,
    max_geometry_total_output_components: u32 = 0,
    max_fragment_input_components: u32 = 0,
    max_fragment_output_attachments: u32 = 0,
    max_fragment_dual_src_attachments: u32 = 0,
    max_fragment_combined_output_resources: u32 = 0,
    max_compute_shared_memory_size: u32 = 0,
    max_compute_work_group_count: [3]u32 = [_]u32{0} ** 3,
    max_compute_work_group_invocations: u32 = 0,
    max_compute_work_group_size: [3]u32 = [_]u32{0} ** 3,
    sub_pixel_precision_bits: u32 = 0,
    sub_texel_precision_bits: u32 = 0,
    mipmap_precision_bits: u32 = 0,
    max_draw_indexed_index_value: u32 = 0,
    max_draw_indirect_count: u32 = 0,
    max_sampler_lod_bias: f32 = 0,
    max_sampler_anisotropy: f32 = 0,
    max_viewports: u32 = 0,
    max_viewport_dimensions: [2]u32 = [_]u32{0} ** 2,
    viewport_bounds_range: [2]f32 = [_]f32{0} ** 2,
    viewport_sub_pixel_bits: u32 = 0,
    min_memory_map_alignment: usize = 0,
    min_texel_buffer_offset_alignment: DeviceSize = 0,
    min_uniform_buffer_offset_alignment: DeviceSize = 0,
    min_storage_buffer_offset_alignment: DeviceSize = 0,
    min_texel_offset: i32 = 0,
    max_texel_offset: u32 = 0,
    min_texel_gather_offset: i32 = 0,
    max_texel_gather_offset: u32 = 0,
    min_interpolation_offset: f32 = 0,
    max_interpolation_offset: f32 = 0,
    sub_pixel_interpolation_offset_bits: u32 = 0,
    max_framebuffer_width: u32 = 0,
    max_framebuffer_height: u32 = 0,
    max_framebuffer_layers: u32 = 0,
    framebuffer_color_sample_counts: SampleCountFlags = .none,
    framebuffer_depth_sample_counts: SampleCountFlags = .none,
    framebuffer_stencil_sample_counts: SampleCountFlags = .none,
    framebuffer_no_attachments_sample_counts: SampleCountFlags = .none,
    max_color_attachments: u32 = 0,
    sampled_image_color_sample_counts: SampleCountFlags = .none,
    sampled_image_integer_sample_counts: SampleCountFlags = .none,
    sampled_image_depth_sample_counts: SampleCountFlags = .none,
    sampled_image_stencil_sample_counts: SampleCountFlags = .none,
    storage_image_sample_counts: SampleCountFlags = .none,
    max_sample_mask_words: u32 = 0,
    timestamp_compute_and_graphics: Bool32 = .false,
    timestamp_period: f32 = 0,
    max_clip_distances: u32 = 0,
    max_cull_distances: u32 = 0,
    max_combined_clip_and_cull_distances: u32 = 0,
    discrete_queue_priorities: u32 = 0,
    point_size_range: [2]f32 = [_]f32{0} ** 2,
    line_width_range: [2]f32 = [_]f32{0} ** 2,
    point_size_granularity: f32 = 0,
    line_width_granularity: f32 = 0,
    strict_lines: Bool32 = .false,
    standard_sample_locations: Bool32 = .false,
    optimal_buffer_copy_offset_alignment: DeviceSize = 0,
    optimal_buffer_copy_row_pitch_alignment: DeviceSize = 0,
    non_coherent_atom_size: DeviceSize = 0,
};
pub const SemaphoreCreateInfo = extern struct {
    s_type: StructureType = .semaphore_create_info,
    p_next: ?*const anyopaque = null,
    flags: SemaphoreCreateFlags = .none,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ExportSemaphoreCreateInfo,
            *ExportSemaphoreWin32HandleInfoKHR,
            *SemaphoreTypeCreateInfo,
            *ExportMetalObjectCreateInfoEXT,
            *ImportMetalSharedEventInfoEXT,
            *QueryLowLatencySupportNV,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const QueryPoolCreateInfo = extern struct {
    s_type: StructureType = .query_pool_create_info,
    p_next: ?*const anyopaque = null,
    flags: QueryPoolCreateFlags = .none,
    query_type: QueryType = @enumFromInt(0),
    query_count: u32 = 0,
    pipeline_statistics: QueryPipelineStatisticFlags = .none,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *QueryPoolPerformanceCreateInfoKHR,
            *QueryPoolPerformanceQueryCreateInfoINTEL,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const FramebufferCreateInfo = extern struct {
    s_type: StructureType = .framebuffer_create_info,
    p_next: ?*const anyopaque = null,
    flags: FramebufferCreateFlags = .none,
    render_pass: RenderPass = .null_handle,
    attachment_count: u32 = 0,
    p_attachments: ?[*]const ImageView = null,
    width: u32 = 0,
    height: u32 = 0,
    layers: u32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *FramebufferAttachmentsCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DrawIndirectCommand = extern struct {
    vertex_count: u32 = 0,
    instance_count: u32 = 0,
    first_vertex: u32 = 0,
    first_instance: u32 = 0,
};
pub const DrawIndexedIndirectCommand = extern struct {
    index_count: u32 = 0,
    instance_count: u32 = 0,
    first_index: u32 = 0,
    vertex_offset: i32 = 0,
    first_instance: u32 = 0,
};
pub const DispatchIndirectCommand = extern struct {
    x: u32 = 0,
    y: u32 = 0,
    z: u32 = 0,
};
pub const MultiDrawInfoEXT = extern struct {
    first_vertex: u32 = 0,
    vertex_count: u32 = 0,
};
pub const MultiDrawIndexedInfoEXT = extern struct {
    first_index: u32 = 0,
    index_count: u32 = 0,
    vertex_offset: i32 = 0,
};
pub const SubmitInfo = extern struct {
    s_type: StructureType = .submit_info,
    p_next: ?*const anyopaque = null,
    wait_semaphore_count: u32 = 0,
    p_wait_semaphores: ?[*]const Semaphore = null,
    p_wait_dst_stage_mask: ?[*]const PipelineStageFlags = null,
    command_buffer_count: u32 = 0,
    p_command_buffers: ?[*]const CommandBuffer = null,
    signal_semaphore_count: u32 = 0,
    p_signal_semaphores: ?[*]const Semaphore = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *Win32KeyedMutexAcquireReleaseInfoNV,
            *Win32KeyedMutexAcquireReleaseInfoKHR,
            *D3D12FenceSubmitInfoKHR,
            *DeviceGroupSubmitInfo,
            *ProtectedSubmitInfo,
            *TimelineSemaphoreSubmitInfo,
            *PerformanceQuerySubmitInfoKHR,
            *AmigoProfilingSubmitInfoSEC,
            *FrameBoundaryEXT,
            *LatencySubmissionPresentIdNV,
            *FrameBoundaryTensorsARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DisplayPropertiesKHR = extern struct {
    display: DisplayKHR = .null_handle,
    display_name: ?[*:0]const u8 = null,
    physical_dimensions: Extent2D = .{},
    physical_resolution: Extent2D = .{},
    supported_transforms: SurfaceTransformFlagsKHR = .none,
    plane_reorder_possible: Bool32 = .false,
    persistent_content: Bool32 = .false,
};
pub const DisplayPlanePropertiesKHR = extern struct {
    current_display: DisplayKHR = .null_handle,
    current_stack_index: u32 = 0,
};
pub const DisplayModeParametersKHR = extern struct {
    visible_region: Extent2D = .{},
    refresh_rate: u32 = 0,
};
pub const DisplayModePropertiesKHR = extern struct {
    display_mode: DisplayModeKHR = .null_handle,
    parameters: DisplayModeParametersKHR = .{},
};
pub const DisplayModeCreateInfoKHR = extern struct {
    s_type: StructureType = .display_mode_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: DisplayModeCreateFlagsKHR = .none,
    parameters: DisplayModeParametersKHR = .{},
};
pub const DisplayPlaneCapabilitiesKHR = extern struct {
    supported_alpha: DisplayPlaneAlphaFlagsKHR = .none,
    min_src_position: Offset2D = .{},
    max_src_position: Offset2D = .{},
    min_src_extent: Extent2D = .{},
    max_src_extent: Extent2D = .{},
    min_dst_position: Offset2D = .{},
    max_dst_position: Offset2D = .{},
    min_dst_extent: Extent2D = .{},
    max_dst_extent: Extent2D = .{},
};
pub const DisplaySurfaceCreateInfoKHR = extern struct {
    s_type: StructureType = .display_surface_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: DisplaySurfaceCreateFlagsKHR = .none,
    display_mode: DisplayModeKHR = .null_handle,
    plane_index: u32 = 0,
    plane_stack_index: u32 = 0,
    transform: SurfaceTransformFlagsKHR = .none,
    global_alpha: f32 = 0,
    alpha_mode: DisplayPlaneAlphaFlagsKHR = .none,
    image_extent: Extent2D = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DisplaySurfaceStereoCreateInfoNV,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DisplaySurfaceStereoCreateInfoNV = extern struct {
    s_type: StructureType = .display_surface_stereo_create_info_nv,
    p_next: ?*const anyopaque = null,
    stereo_type: DisplaySurfaceStereoTypeNV = @enumFromInt(0),
};
pub const DisplayPresentInfoKHR = extern struct {
    s_type: StructureType = .display_present_info_khr,
    p_next: ?*const anyopaque = null,
    src_rect: Rect2D = .{},
    dst_rect: Rect2D = .{},
    persistent: Bool32 = .false,
};
pub const SurfaceCapabilitiesKHR = extern struct {
    min_image_count: u32 = 0,
    max_image_count: u32 = 0,
    current_extent: Extent2D = .{},
    min_image_extent: Extent2D = .{},
    max_image_extent: Extent2D = .{},
    max_image_array_layers: u32 = 0,
    supported_transforms: SurfaceTransformFlagsKHR = .none,
    current_transform: SurfaceTransformFlagsKHR = .none,
    supported_composite_alpha: CompositeAlphaFlagsKHR = .none,
    supported_usage_flags: ImageUsageFlags = .none,
};
pub const AndroidSurfaceCreateInfoKHR = extern struct {
    s_type: StructureType = .android_surface_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: AndroidSurfaceCreateFlagsKHR = .none,
    window: ?*ANativeWindow = null,
};
pub const ViSurfaceCreateInfoNN = extern struct {
    s_type: StructureType = .vi_surface_create_info_nn,
    p_next: ?*const anyopaque = null,
    flags: ViSurfaceCreateFlagsNN = .none,
    window: ?*anyopaque = null,
};
pub const WaylandSurfaceCreateInfoKHR = extern struct {
    s_type: StructureType = .wayland_surface_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: WaylandSurfaceCreateFlagsKHR = .none,
    display: ?*wl_display = null,
    surface: ?*wl_surface = null,
};
pub const Win32SurfaceCreateInfoKHR = extern struct {
    s_type: StructureType = .win32_surface_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: Win32SurfaceCreateFlagsKHR = .none,
    hinstance: HINSTANCE = null,
    hwnd: HWND = null,
};
pub const XlibSurfaceCreateInfoKHR = extern struct {
    s_type: StructureType = .xlib_surface_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: XlibSurfaceCreateFlagsKHR = .none,
    dpy: ?*Display = null,
    window: Window = 0,
};
pub const XcbSurfaceCreateInfoKHR = extern struct {
    s_type: StructureType = .xcb_surface_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: XcbSurfaceCreateFlagsKHR = .none,
    connection: ?*xcb_connection_t = null,
    window: xcb_window_t = 0,
};
pub const DirectFBSurfaceCreateInfoEXT = extern struct {
    s_type: StructureType = .directfb_surface_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: DirectFBSurfaceCreateFlagsEXT = .none,
    dfb: ?*IDirectFB = null,
    surface: ?*IDirectFBSurface = null,
};
pub const ImagePipeSurfaceCreateInfoFUCHSIA = extern struct {
    s_type: StructureType = .imagepipe_surface_create_info_fuchsia,
    p_next: ?*const anyopaque = null,
    flags: ImagePipeSurfaceCreateFlagsFUCHSIA = .none,
    image_pipe_handle: zx_handle_t = 0,
};
pub const SurfaceFormatKHR = extern struct {
    format: Format = @enumFromInt(0),
    color_space: ColorSpaceKHR = @enumFromInt(0),
};
pub const SwapchainCreateInfoKHR = extern struct {
    s_type: StructureType = .swapchain_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: SwapchainCreateFlagsKHR = .none,
    surface: SurfaceKHR = .null_handle,
    min_image_count: u32 = 0,
    image_format: Format = @enumFromInt(0),
    image_color_space: ColorSpaceKHR = @enumFromInt(0),
    image_extent: Extent2D = .{},
    image_array_layers: u32 = 0,
    image_usage: ImageUsageFlags = .none,
    image_sharing_mode: SharingMode = @enumFromInt(0),
    queue_family_index_count: u32 = 0,
    p_queue_family_indices: ?[*]const u32 = null,
    pre_transform: SurfaceTransformFlagsKHR = .none,
    composite_alpha: CompositeAlphaFlagsKHR = .none,
    present_mode: PresentModeKHR = @enumFromInt(0),
    clipped: Bool32 = .false,
    old_swapchain: SwapchainKHR = .null_handle,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *SwapchainCounterCreateInfoEXT,
            *DeviceGroupSwapchainCreateInfoKHR,
            *SwapchainDisplayNativeHdrCreateInfoAMD,
            *ImageFormatListCreateInfo,
            *SurfaceFullScreenExclusiveInfoEXT,
            *SurfaceFullScreenExclusiveWin32InfoEXT,
            *SwapchainPresentBarrierCreateInfoNV,
            *ImageCompressionControlEXT,
            *SwapchainPresentModesCreateInfoKHR,
            *SwapchainPresentScalingCreateInfoKHR,
            *SwapchainLatencyCreateInfoNV,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PresentInfoKHR = extern struct {
    s_type: StructureType = .present_info_khr,
    p_next: ?*const anyopaque = null,
    wait_semaphore_count: u32 = 0,
    p_wait_semaphores: ?[*]const Semaphore = null,
    swapchain_count: u32 = 0,
    p_swapchains: ?[*]const SwapchainKHR = null,
    p_image_indices: ?[*]const u32 = null,
    p_results: ?[*]Result = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DisplayPresentInfoKHR,
            *PresentRegionsKHR,
            *DeviceGroupPresentInfoKHR,
            *PresentIdKHR,
            *PresentId2KHR,
            *PresentTimesInfoGOOGLE,
            *FrameBoundaryEXT,
            *SwapchainPresentFenceInfoKHR,
            *SwapchainPresentModeInfoKHR,
            *SetPresentConfigNV,
            *FrameBoundaryTensorsARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DebugReportCallbackCreateInfoEXT = extern struct {
    s_type: StructureType = .debug_report_callback_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: DebugReportFlagsEXT = .none,
    pfn_callback: ?FpDebugReportCallbackEXT = null,
    p_user_data: ?*anyopaque = null,
};
pub const ValidationFlagsEXT = extern struct {
    s_type: StructureType = .validation_flags_ext,
    p_next: ?*const anyopaque = null,
    disabled_validation_check_count: u32 = 0,
    p_disabled_validation_checks: ?[*]const ValidationCheckEXT = null,
};
pub const ValidationFeaturesEXT = extern struct {
    s_type: StructureType = .validation_features_ext,
    p_next: ?*const anyopaque = null,
    enabled_validation_feature_count: u32 = 0,
    p_enabled_validation_features: ?[*]const ValidationFeatureEnableEXT = null,
    disabled_validation_feature_count: u32 = 0,
    p_disabled_validation_features: ?[*]const ValidationFeatureDisableEXT = null,
};
pub const LayerSettingsCreateInfoEXT = extern struct {
    s_type: StructureType = .layer_settings_create_info_ext,
    p_next: ?*const anyopaque = null,
    setting_count: u32 = 0,
    p_settings: ?[*]const LayerSettingEXT = null,
};
pub const LayerSettingEXT = extern struct {
    p_layer_name: ?[*:0]const u8 = null,
    p_setting_name: ?[*:0]const u8 = null,
    type: LayerSettingTypeEXT = @enumFromInt(0),
    value_count: u32 = 0,
    p_values: ?*const anyopaque = null,
};
pub const PipelineRasterizationStateRasterizationOrderAMD = extern struct {
    s_type: StructureType = .pipeline_rasterization_state_rasterization_order_amd,
    p_next: ?*const anyopaque = null,
    rasterization_order: RasterizationOrderAMD = @enumFromInt(0),
};
pub const DebugMarkerObjectNameInfoEXT = extern struct {
    s_type: StructureType = .debug_marker_object_name_info_ext,
    p_next: ?*const anyopaque = null,
    object_type: DebugReportObjectTypeEXT = @enumFromInt(0),
    object: u64 = 0,
    p_object_name: ?[*:0]const u8 = null,
};
pub const DebugMarkerObjectTagInfoEXT = extern struct {
    s_type: StructureType = .debug_marker_object_tag_info_ext,
    p_next: ?*const anyopaque = null,
    object_type: DebugReportObjectTypeEXT = @enumFromInt(0),
    object: u64 = 0,
    tag_name: u64 = 0,
    tag_size: usize = 0,
    p_tag: ?*const anyopaque = null,
};
pub const DebugMarkerMarkerInfoEXT = extern struct {
    s_type: StructureType = .debug_marker_marker_info_ext,
    p_next: ?*const anyopaque = null,
    p_marker_name: ?[*:0]const u8 = null,
    color: [4]f32 = [_]f32{0} ** 4,
};
pub const DedicatedAllocationImageCreateInfoNV = extern struct {
    s_type: StructureType = .dedicated_allocation_image_create_info_nv,
    p_next: ?*const anyopaque = null,
    dedicated_allocation: Bool32 = .false,
};
pub const DedicatedAllocationBufferCreateInfoNV = extern struct {
    s_type: StructureType = .dedicated_allocation_buffer_create_info_nv,
    p_next: ?*const anyopaque = null,
    dedicated_allocation: Bool32 = .false,
};
pub const DedicatedAllocationMemoryAllocateInfoNV = extern struct {
    s_type: StructureType = .dedicated_allocation_memory_allocate_info_nv,
    p_next: ?*const anyopaque = null,
    image: Image = .null_handle,
    buffer: Buffer = .null_handle,
};
pub const ExternalImageFormatPropertiesNV = extern struct {
    image_format_properties: ImageFormatProperties = .{},
    external_memory_features: ExternalMemoryFeatureFlagsNV = .none,
    export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNV = .none,
    compatible_handle_types: ExternalMemoryHandleTypeFlagsNV = .none,
};
pub const ExternalMemoryImageCreateInfoNV = extern struct {
    s_type: StructureType = .external_memory_image_create_info_nv,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalMemoryHandleTypeFlagsNV = .none,
};
pub const ExportMemoryAllocateInfoNV = extern struct {
    s_type: StructureType = .export_memory_allocate_info_nv,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalMemoryHandleTypeFlagsNV = .none,
};
pub const ImportMemoryWin32HandleInfoNV = extern struct {
    s_type: StructureType = .import_memory_win32_handle_info_nv,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlagsNV = .none,
    handle: HANDLE = null,
};
pub const ExportMemoryWin32HandleInfoNV = extern struct {
    s_type: StructureType = .export_memory_win32_handle_info_nv,
    p_next: ?*const anyopaque = null,
    p_attributes: ?*const SECURITY_ATTRIBUTES = null,
    dw_access: DWORD = 0,
};
pub const Win32KeyedMutexAcquireReleaseInfoNV = extern struct {
    s_type: StructureType = .win32_keyed_mutex_acquire_release_info_nv,
    p_next: ?*const anyopaque = null,
    acquire_count: u32 = 0,
    p_acquire_syncs: ?[*]const DeviceMemory = null,
    p_acquire_keys: ?[*]const u64 = null,
    p_acquire_timeout_milliseconds: ?[*]const u32 = null,
    release_count: u32 = 0,
    p_release_syncs: ?[*]const DeviceMemory = null,
    p_release_keys: ?[*]const u64 = null,
};
pub const PhysicalDeviceDeviceGeneratedCommandsFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_device_generated_commands_features_nv,
    p_next: ?*anyopaque = null,
    device_generated_commands: Bool32 = .false,
};
pub const PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_device_generated_commands_compute_features_nv,
    p_next: ?*anyopaque = null,
    device_generated_compute: Bool32 = .false,
    device_generated_compute_pipelines: Bool32 = .false,
    device_generated_compute_capture_replay: Bool32 = .false,
};
pub const DevicePrivateDataCreateInfo = extern struct {
    s_type: StructureType = .device_private_data_create_info,
    p_next: ?*const anyopaque = null,
    private_data_slot_request_count: u32 = 0,
};
pub const DevicePrivateDataCreateInfoEXT = DevicePrivateDataCreateInfo;
pub const PrivateDataSlotCreateInfo = extern struct {
    s_type: StructureType = .private_data_slot_create_info,
    p_next: ?*const anyopaque = null,
    flags: PrivateDataSlotCreateFlags = .none,
};
pub const PrivateDataSlotCreateInfoEXT = PrivateDataSlotCreateInfo;
pub const PhysicalDevicePrivateDataFeatures = extern struct {
    s_type: StructureType = .physical_device_private_data_features,
    p_next: ?*anyopaque = null,
    private_data: Bool32 = .false,
};
pub const PhysicalDevicePrivateDataFeaturesEXT = PhysicalDevicePrivateDataFeatures;
pub const PhysicalDeviceDeviceGeneratedCommandsPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_device_generated_commands_properties_nv,
    p_next: ?*anyopaque = null,
    max_graphics_shader_group_count: u32 = 0,
    max_indirect_sequence_count: u32 = 0,
    max_indirect_commands_token_count: u32 = 0,
    max_indirect_commands_stream_count: u32 = 0,
    max_indirect_commands_token_offset: u32 = 0,
    max_indirect_commands_stream_stride: u32 = 0,
    min_sequences_count_buffer_offset_alignment: u32 = 0,
    min_sequences_index_buffer_offset_alignment: u32 = 0,
    min_indirect_commands_buffer_offset_alignment: u32 = 0,
};
pub const PhysicalDeviceClusterAccelerationStructureFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_cluster_acceleration_structure_features_nv,
    p_next: ?*anyopaque = null,
    cluster_acceleration_structure: Bool32 = .false,
};
pub const PhysicalDeviceClusterAccelerationStructurePropertiesNV = extern struct {
    s_type: StructureType = .physical_device_cluster_acceleration_structure_properties_nv,
    p_next: ?*anyopaque = null,
    max_vertices_per_cluster: u32 = 0,
    max_triangles_per_cluster: u32 = 0,
    cluster_scratch_byte_alignment: u32 = 0,
    cluster_byte_alignment: u32 = 0,
    cluster_template_byte_alignment: u32 = 0,
    cluster_bottom_level_byte_alignment: u32 = 0,
    cluster_template_bounds_byte_alignment: u32 = 0,
    max_cluster_geometry_index: u32 = 0,
};
pub const StridedDeviceAddressNV = extern struct {
    start_address: DeviceAddress = 0,
    stride_in_bytes: DeviceSize = 0,
};
pub const RayTracingPipelineClusterAccelerationStructureCreateInfoNV = extern struct {
    s_type: StructureType = .ray_tracing_pipeline_cluster_acceleration_structure_create_info_nv,
    p_next: ?*anyopaque = null,
    allow_cluster_acceleration_structure: Bool32 = .false,
};
pub const ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV = extern struct {
    geometry_index_and_reserved_and_geometry_flags: u32 = 0,
};
pub const ClusterAccelerationStructureMoveObjectsInfoNV = extern struct {
    src_acceleration_structure: DeviceAddress = 0,
};
pub const ClusterAccelerationStructureBuildClustersBottomLevelInfoNV = extern struct {
    cluster_references_count: u32 = 0,
    cluster_references_stride: u32 = 0,
    cluster_references: DeviceAddress = 0,
};
pub const ClusterAccelerationStructureGetTemplateIndicesInfoNV = extern struct {
    cluster_template_address: DeviceAddress = 0,
};
pub const ClusterAccelerationStructureBuildTriangleClusterInfoNV = extern struct {
    cluster_id: u32 = 0,
    cluster_flags: ClusterAccelerationStructureClusterFlagsNV = .none,
    triangle_count_and_vertex_count_and_position_truncate_bit_count_and_index_type_and_opacity_micromap_index_type: u32 = 0,
    base_geometry_index_and_geometry_flags: ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV = .{},
    index_buffer_stride: u16 = 0,
    vertex_buffer_stride: u16 = 0,
    geometry_index_and_flags_buffer_stride: u16 = 0,
    opacity_micromap_index_buffer_stride: u16 = 0,
    index_buffer: DeviceAddress = 0,
    vertex_buffer: DeviceAddress = 0,
    geometry_index_and_flags_buffer: DeviceAddress = 0,
    opacity_micromap_array: DeviceAddress = 0,
    opacity_micromap_index_buffer: DeviceAddress = 0,
};
pub const ClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV = extern struct {
    cluster_id: u32 = 0,
    cluster_flags: ClusterAccelerationStructureClusterFlagsNV = .none,
    triangle_count_and_vertex_count_and_position_truncate_bit_count_and_index_type_and_opacity_micromap_index_type: u32 = 0,
    base_geometry_index_and_geometry_flags: ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV = .{},
    index_buffer_stride: u16 = 0,
    vertex_buffer_stride: u16 = 0,
    geometry_index_and_flags_buffer_stride: u16 = 0,
    opacity_micromap_index_buffer_stride: u16 = 0,
    index_buffer: DeviceAddress = 0,
    vertex_buffer: DeviceAddress = 0,
    geometry_index_and_flags_buffer: DeviceAddress = 0,
    opacity_micromap_array: DeviceAddress = 0,
    opacity_micromap_index_buffer: DeviceAddress = 0,
    instantiation_bounding_box_limit: DeviceAddress = 0,
};
pub const ClusterAccelerationStructureInstantiateClusterInfoNV = extern struct {
    cluster_id_offset: u32 = 0,
    geometry_index_offset_and_reserved: u32 = 0,
    cluster_template_address: DeviceAddress = 0,
    vertex_buffer: StridedDeviceAddressNV = .{},
};
pub const ClusterAccelerationStructureClustersBottomLevelInputNV = extern struct {
    s_type: StructureType = .cluster_acceleration_structure_clusters_bottom_level_input_nv,
    p_next: ?*anyopaque = null,
    max_total_cluster_count: u32 = 0,
    max_cluster_count_per_acceleration_structure: u32 = 0,
};
pub const ClusterAccelerationStructureTriangleClusterInputNV = extern struct {
    s_type: StructureType = .cluster_acceleration_structure_triangle_cluster_input_nv,
    p_next: ?*anyopaque = null,
    vertex_format: Format = @enumFromInt(0),
    max_geometry_index_value: u32 = 0,
    max_cluster_unique_geometry_count: u32 = 0,
    max_cluster_triangle_count: u32 = 0,
    max_cluster_vertex_count: u32 = 0,
    max_total_triangle_count: u32 = 0,
    max_total_vertex_count: u32 = 0,
    min_position_truncate_bit_count: u32 = 0,
};
pub const ClusterAccelerationStructureMoveObjectsInputNV = extern struct {
    s_type: StructureType = .cluster_acceleration_structure_move_objects_input_nv,
    p_next: ?*anyopaque = null,
    type: ClusterAccelerationStructureTypeNV = @enumFromInt(0),
    no_move_overlap: Bool32 = .false,
    max_moved_bytes: DeviceSize = 0,
};
pub const ClusterAccelerationStructureOpInputNV = extern union {
    p_clusters_bottom_level: ?*ClusterAccelerationStructureClustersBottomLevelInputNV,
    p_triangle_clusters: ?*ClusterAccelerationStructureTriangleClusterInputNV,
    p_move_objects: ?*ClusterAccelerationStructureMoveObjectsInputNV,
};
pub const ClusterAccelerationStructureInputInfoNV = extern struct {
    s_type: StructureType = .cluster_acceleration_structure_input_info_nv,
    p_next: ?*anyopaque = null,
    max_acceleration_structure_count: u32 = 0,
    flags: BuildAccelerationStructureFlagsKHR = .none,
    op_type: ClusterAccelerationStructureOpTypeNV = @enumFromInt(0),
    op_mode: ClusterAccelerationStructureOpModeNV = @enumFromInt(0),
    op_input: ClusterAccelerationStructureOpInputNV = .{ .p_clusters_bottom_level = null },
};
pub const ClusterAccelerationStructureCommandsInfoNV = extern struct {
    s_type: StructureType = .cluster_acceleration_structure_commands_info_nv,
    p_next: ?*anyopaque = null,
    input: ClusterAccelerationStructureInputInfoNV = .{},
    dst_implicit_data: DeviceAddress = 0,
    scratch_data: DeviceAddress = 0,
    dst_addresses_array: StridedDeviceAddressRegionKHR = .{},
    dst_sizes_array: StridedDeviceAddressRegionKHR = .{},
    src_infos_array: StridedDeviceAddressRegionKHR = .{},
    src_infos_count: DeviceAddress = 0,
    address_resolution_flags: ClusterAccelerationStructureAddressResolutionFlagsNV = .none,
};
pub const PhysicalDeviceMultiDrawPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_multi_draw_properties_ext,
    p_next: ?*anyopaque = null,
    max_multi_draw_count: u32 = 0,
};
pub const GraphicsShaderGroupCreateInfoNV = extern struct {
    s_type: StructureType = .graphics_shader_group_create_info_nv,
    p_next: ?*const anyopaque = null,
    stage_count: u32 = 0,
    p_stages: ?[*]const PipelineShaderStageCreateInfo = null,
    p_vertex_input_state: ?*const PipelineVertexInputStateCreateInfo = null,
    p_tessellation_state: ?*const PipelineTessellationStateCreateInfo = null,
};
pub const GraphicsPipelineShaderGroupsCreateInfoNV = extern struct {
    s_type: StructureType = .graphics_pipeline_shader_groups_create_info_nv,
    p_next: ?*const anyopaque = null,
    group_count: u32 = 0,
    p_groups: ?[*]const GraphicsShaderGroupCreateInfoNV = null,
    pipeline_count: u32 = 0,
    p_pipelines: ?[*]const Pipeline = null,
};
pub const BindShaderGroupIndirectCommandNV = extern struct {
    group_index: u32 = 0,
};
pub const BindIndexBufferIndirectCommandNV = extern struct {
    buffer_address: DeviceAddress = 0,
    size: u32 = 0,
    index_type: IndexType = @enumFromInt(0),
};
pub const BindVertexBufferIndirectCommandNV = extern struct {
    buffer_address: DeviceAddress = 0,
    size: u32 = 0,
    stride: u32 = 0,
};
pub const SetStateFlagsIndirectCommandNV = extern struct {
    data: u32 = 0,
};
pub const IndirectCommandsStreamNV = extern struct {
    buffer: Buffer = .null_handle,
    offset: DeviceSize = 0,
};
pub const IndirectCommandsLayoutTokenNV = extern struct {
    s_type: StructureType = .indirect_commands_layout_token_nv,
    p_next: ?*const anyopaque = null,
    token_type: IndirectCommandsTokenTypeNV = @enumFromInt(0),
    stream: u32 = 0,
    offset: u32 = 0,
    vertex_binding_unit: u32 = 0,
    vertex_dynamic_stride: Bool32 = .false,
    pushconstant_pipeline_layout: PipelineLayout = .null_handle,
    pushconstant_shader_stage_flags: ShaderStageFlags = .none,
    pushconstant_offset: u32 = 0,
    pushconstant_size: u32 = 0,
    indirect_state_flags: IndirectStateFlagsNV = .none,
    index_type_count: u32 = 0,
    p_index_types: ?[*]const IndexType = null,
    p_index_type_values: ?[*]const u32 = null,
};
pub const IndirectCommandsLayoutCreateInfoNV = extern struct {
    s_type: StructureType = .indirect_commands_layout_create_info_nv,
    p_next: ?*const anyopaque = null,
    flags: IndirectCommandsLayoutUsageFlagsNV = .none,
    pipeline_bind_point: PipelineBindPoint = @enumFromInt(0),
    token_count: u32 = 0,
    p_tokens: ?[*]const IndirectCommandsLayoutTokenNV = null,
    stream_count: u32 = 0,
    p_stream_strides: ?[*]const u32 = null,
};
pub const GeneratedCommandsInfoNV = extern struct {
    s_type: StructureType = .generated_commands_info_nv,
    p_next: ?*const anyopaque = null,
    pipeline_bind_point: PipelineBindPoint = @enumFromInt(0),
    pipeline: Pipeline = .null_handle,
    indirect_commands_layout: IndirectCommandsLayoutNV = .null_handle,
    stream_count: u32 = 0,
    p_streams: ?[*]const IndirectCommandsStreamNV = null,
    sequences_count: u32 = 0,
    preprocess_buffer: Buffer = .null_handle,
    preprocess_offset: DeviceSize = 0,
    preprocess_size: DeviceSize = 0,
    sequences_count_buffer: Buffer = .null_handle,
    sequences_count_offset: DeviceSize = 0,
    sequences_index_buffer: Buffer = .null_handle,
    sequences_index_offset: DeviceSize = 0,
};
pub const GeneratedCommandsMemoryRequirementsInfoNV = extern struct {
    s_type: StructureType = .generated_commands_memory_requirements_info_nv,
    p_next: ?*const anyopaque = null,
    pipeline_bind_point: PipelineBindPoint = @enumFromInt(0),
    pipeline: Pipeline = .null_handle,
    indirect_commands_layout: IndirectCommandsLayoutNV = .null_handle,
    max_sequences_count: u32 = 0,
};
pub const PipelineIndirectDeviceAddressInfoNV = extern struct {
    s_type: StructureType = .pipeline_indirect_device_address_info_nv,
    p_next: ?*const anyopaque = null,
    pipeline_bind_point: PipelineBindPoint = @enumFromInt(0),
    pipeline: Pipeline = .null_handle,
};
pub const BindPipelineIndirectCommandNV = extern struct {
    pipeline_address: DeviceAddress = 0,
};
pub const PhysicalDeviceFeatures2 = extern struct {
    s_type: StructureType = .physical_device_features_2,
    p_next: ?*anyopaque = null,
    features: PhysicalDeviceFeatures = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PhysicalDeviceDeviceGeneratedCommandsFeaturesNV,
            *PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV,
            *PhysicalDevicePrivateDataFeatures,
            *PhysicalDeviceClusterAccelerationStructureFeaturesNV,
            *PhysicalDeviceVariablePointersFeatures,
            *PhysicalDeviceMultiviewFeatures,
            *PhysicalDevicePresentIdFeaturesKHR,
            *PhysicalDevicePresentId2FeaturesKHR,
            *PhysicalDevicePresentWaitFeaturesKHR,
            *PhysicalDevicePresentWait2FeaturesKHR,
            *PhysicalDevice16BitStorageFeatures,
            *PhysicalDeviceShaderSubgroupExtendedTypesFeatures,
            *PhysicalDeviceSamplerYcbcrConversionFeatures,
            *PhysicalDeviceProtectedMemoryFeatures,
            *PhysicalDeviceBlendOperationAdvancedFeaturesEXT,
            *PhysicalDeviceMultiDrawFeaturesEXT,
            *PhysicalDeviceInlineUniformBlockFeatures,
            *PhysicalDeviceMaintenance4Features,
            *PhysicalDeviceMaintenance5Features,
            *PhysicalDeviceMaintenance6Features,
            *PhysicalDeviceMaintenance7FeaturesKHR,
            *PhysicalDeviceMaintenance8FeaturesKHR,
            *PhysicalDeviceMaintenance9FeaturesKHR,
            *PhysicalDeviceShaderDrawParametersFeatures,
            *PhysicalDeviceShaderFloat16Int8Features,
            *PhysicalDeviceHostQueryResetFeatures,
            *PhysicalDeviceGlobalPriorityQueryFeatures,
            *PhysicalDeviceDeviceMemoryReportFeaturesEXT,
            *PhysicalDeviceDescriptorIndexingFeatures,
            *PhysicalDeviceTimelineSemaphoreFeatures,
            *PhysicalDevice8BitStorageFeatures,
            *PhysicalDeviceConditionalRenderingFeaturesEXT,
            *PhysicalDeviceVulkanMemoryModelFeatures,
            *PhysicalDeviceShaderAtomicInt64Features,
            *PhysicalDeviceShaderAtomicFloatFeaturesEXT,
            *PhysicalDeviceShaderAtomicFloat2FeaturesEXT,
            *PhysicalDeviceVertexAttributeDivisorFeatures,
            *PhysicalDeviceASTCDecodeFeaturesEXT,
            *PhysicalDeviceTransformFeedbackFeaturesEXT,
            *PhysicalDeviceRepresentativeFragmentTestFeaturesNV,
            *PhysicalDeviceExclusiveScissorFeaturesNV,
            *PhysicalDeviceCornerSampledImageFeaturesNV,
            *PhysicalDeviceComputeShaderDerivativesFeaturesKHR,
            *PhysicalDeviceShaderImageFootprintFeaturesNV,
            *PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,
            *PhysicalDeviceCopyMemoryIndirectFeaturesNV,
            *PhysicalDeviceMemoryDecompressionFeaturesNV,
            *PhysicalDeviceShadingRateImageFeaturesNV,
            *PhysicalDeviceInvocationMaskFeaturesHUAWEI,
            *PhysicalDeviceMeshShaderFeaturesNV,
            *PhysicalDeviceMeshShaderFeaturesEXT,
            *PhysicalDeviceAccelerationStructureFeaturesKHR,
            *PhysicalDeviceRayTracingPipelineFeaturesKHR,
            *PhysicalDeviceRayQueryFeaturesKHR,
            *PhysicalDeviceRayTracingMaintenance1FeaturesKHR,
            *PhysicalDeviceFragmentDensityMapFeaturesEXT,
            *PhysicalDeviceFragmentDensityMap2FeaturesEXT,
            *PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT,
            *PhysicalDeviceScalarBlockLayoutFeatures,
            *PhysicalDeviceUniformBufferStandardLayoutFeatures,
            *PhysicalDeviceDepthClipEnableFeaturesEXT,
            *PhysicalDeviceMemoryPriorityFeaturesEXT,
            *PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT,
            *PhysicalDeviceBufferDeviceAddressFeatures,
            *PhysicalDeviceBufferDeviceAddressFeaturesEXT,
            *PhysicalDeviceImagelessFramebufferFeatures,
            *PhysicalDeviceTextureCompressionASTCHDRFeatures,
            *PhysicalDeviceCooperativeMatrixFeaturesNV,
            *PhysicalDeviceYcbcrImageArraysFeaturesEXT,
            *PhysicalDevicePresentBarrierFeaturesNV,
            *PhysicalDevicePerformanceQueryFeaturesKHR,
            *PhysicalDeviceCoverageReductionModeFeaturesNV,
            *PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,
            *PhysicalDeviceShaderClockFeaturesKHR,
            *PhysicalDeviceIndexTypeUint8Features,
            *PhysicalDeviceShaderSMBuiltinsFeaturesNV,
            *PhysicalDeviceFragmentShaderInterlockFeaturesEXT,
            *PhysicalDeviceSeparateDepthStencilLayoutsFeatures,
            *PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT,
            *PhysicalDevicePipelineExecutablePropertiesFeaturesKHR,
            *PhysicalDeviceShaderDemoteToHelperInvocationFeatures,
            *PhysicalDeviceTexelBufferAlignmentFeaturesEXT,
            *PhysicalDeviceSubgroupSizeControlFeatures,
            *PhysicalDeviceLineRasterizationFeatures,
            *PhysicalDevicePipelineCreationCacheControlFeatures,
            *PhysicalDeviceVulkan11Features,
            *PhysicalDeviceVulkan12Features,
            *PhysicalDeviceVulkan13Features,
            *PhysicalDeviceVulkan14Features,
            *PhysicalDeviceCoherentMemoryFeaturesAMD,
            *PhysicalDeviceCustomBorderColorFeaturesEXT,
            *PhysicalDeviceBorderColorSwizzleFeaturesEXT,
            *PhysicalDeviceExtendedDynamicStateFeaturesEXT,
            *PhysicalDeviceExtendedDynamicState2FeaturesEXT,
            *PhysicalDeviceExtendedDynamicState3FeaturesEXT,
            *PhysicalDevicePartitionedAccelerationStructureFeaturesNV,
            *PhysicalDeviceDiagnosticsConfigFeaturesNV,
            *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures,
            *PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR,
            *PhysicalDeviceRobustness2FeaturesKHR,
            *PhysicalDeviceImageRobustnessFeatures,
            *PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR,
            *PhysicalDevicePortabilitySubsetFeaturesKHR,
            *PhysicalDevice4444FormatsFeaturesEXT,
            *PhysicalDeviceSubpassShadingFeaturesHUAWEI,
            *PhysicalDeviceClusterCullingShaderFeaturesHUAWEI,
            *PhysicalDeviceShaderImageAtomicInt64FeaturesEXT,
            *PhysicalDeviceFragmentShadingRateFeaturesKHR,
            *PhysicalDeviceShaderTerminateInvocationFeatures,
            *PhysicalDeviceFragmentShadingRateEnumsFeaturesNV,
            *PhysicalDeviceImage2DViewOf3DFeaturesEXT,
            *PhysicalDeviceImageSlicedViewOf3DFeaturesEXT,
            *PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT,
            *PhysicalDeviceLegacyVertexAttributesFeaturesEXT,
            *PhysicalDeviceMutableDescriptorTypeFeaturesEXT,
            *PhysicalDeviceDepthClipControlFeaturesEXT,
            *PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT,
            *PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT,
            *PhysicalDeviceDepthClampControlFeaturesEXT,
            *PhysicalDeviceVertexInputDynamicStateFeaturesEXT,
            *PhysicalDeviceExternalMemoryRDMAFeaturesNV,
            *PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR,
            *PhysicalDeviceColorWriteEnableFeaturesEXT,
            *PhysicalDeviceSynchronization2Features,
            *PhysicalDeviceUnifiedImageLayoutsFeaturesKHR,
            *PhysicalDeviceHostImageCopyFeatures,
            *PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT,
            *PhysicalDeviceLegacyDitheringFeaturesEXT,
            *PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT,
            *PhysicalDevicePipelineProtectedAccessFeatures,
            *PhysicalDeviceInheritedViewportScissorFeaturesNV,
            *PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT,
            *PhysicalDeviceProvokingVertexFeaturesEXT,
            *PhysicalDeviceDescriptorBufferFeaturesEXT,
            *PhysicalDeviceShaderIntegerDotProductFeatures,
            *PhysicalDeviceFragmentShaderBarycentricFeaturesKHR,
            *PhysicalDeviceRayTracingMotionBlurFeaturesNV,
            *PhysicalDeviceRayTracingValidationFeaturesNV,
            *PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV,
            *PhysicalDeviceRGBA10X6FormatsFeaturesEXT,
            *PhysicalDeviceDynamicRenderingFeatures,
            *PhysicalDeviceImageViewMinLodFeaturesEXT,
            *PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT,
            *PhysicalDeviceLinearColorAttachmentFeaturesNV,
            *PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT,
            *PhysicalDevicePipelineBinaryFeaturesKHR,
            *PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE,
            *PhysicalDeviceNestedCommandBufferFeaturesEXT,
            *PhysicalDeviceShaderModuleIdentifierFeaturesEXT,
            *PhysicalDeviceImageCompressionControlFeaturesEXT,
            *PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT,
            *PhysicalDeviceSubpassMergeFeedbackFeaturesEXT,
            *PhysicalDeviceOpacityMicromapFeaturesEXT,
            *PhysicalDeviceDisplacementMicromapFeaturesNV,
            *PhysicalDevicePipelinePropertiesFeaturesEXT,
            *PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD,
            *PhysicalDeviceNonSeamlessCubeMapFeaturesEXT,
            *PhysicalDevicePipelineRobustnessFeatures,
            *PhysicalDeviceImageProcessingFeaturesQCOM,
            *PhysicalDeviceTilePropertiesFeaturesQCOM,
            *PhysicalDeviceAmigoProfilingFeaturesSEC,
            *PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT,
            *PhysicalDeviceAddressBindingReportFeaturesEXT,
            *PhysicalDeviceOpticalFlowFeaturesNV,
            *PhysicalDeviceFaultFeaturesEXT,
            *PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT,
            *PhysicalDeviceShaderCoreBuiltinsFeaturesARM,
            *PhysicalDeviceFrameBoundaryFeaturesEXT,
            *PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT,
            *PhysicalDeviceSwapchainMaintenance1FeaturesKHR,
            *PhysicalDeviceDepthBiasControlFeaturesEXT,
            *PhysicalDeviceRayTracingInvocationReorderFeaturesNV,
            *PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV,
            *PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM,
            *PhysicalDeviceRayTracingPositionFetchFeaturesKHR,
            *PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM,
            *PhysicalDeviceShaderObjectFeaturesEXT,
            *PhysicalDeviceShaderTileImageFeaturesEXT,
            *PhysicalDeviceCooperativeMatrixFeaturesKHR,
            *PhysicalDeviceShaderEnqueueFeaturesAMDX,
            *PhysicalDeviceAntiLagFeaturesAMD,
            *PhysicalDeviceTileMemoryHeapFeaturesQCOM,
            *PhysicalDeviceCubicClampFeaturesQCOM,
            *PhysicalDeviceYcbcrDegammaFeaturesQCOM,
            *PhysicalDeviceCubicWeightsFeaturesQCOM,
            *PhysicalDeviceImageProcessing2FeaturesQCOM,
            *PhysicalDeviceDescriptorPoolOverallocationFeaturesNV,
            *PhysicalDevicePerStageDescriptorSetFeaturesNV,
            *PhysicalDeviceExternalFormatResolveFeaturesANDROID,
            *PhysicalDeviceCudaKernelLaunchFeaturesNV,
            *PhysicalDeviceSchedulingControlsFeaturesARM,
            *PhysicalDeviceRelaxedLineRasterizationFeaturesIMG,
            *PhysicalDeviceRenderPassStripedFeaturesARM,
            *PhysicalDevicePipelineOpacityMicromapFeaturesARM,
            *PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR,
            *PhysicalDeviceShaderSubgroupRotateFeatures,
            *PhysicalDeviceShaderExpectAssumeFeatures,
            *PhysicalDeviceShaderFloatControls2Features,
            *PhysicalDeviceDynamicRenderingLocalReadFeatures,
            *PhysicalDeviceShaderQuadControlFeaturesKHR,
            *PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV,
            *PhysicalDeviceMapMemoryPlacedFeaturesEXT,
            *PhysicalDeviceShaderBfloat16FeaturesKHR,
            *PhysicalDeviceRawAccessChainsFeaturesNV,
            *PhysicalDeviceCommandBufferInheritanceFeaturesNV,
            *PhysicalDeviceImageAlignmentControlFeaturesMESA,
            *PhysicalDeviceShaderReplicatedCompositesFeaturesEXT,
            *PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR,
            *PhysicalDeviceCooperativeMatrix2FeaturesNV,
            *PhysicalDeviceHdrVividFeaturesHUAWEI,
            *PhysicalDeviceVertexAttributeRobustnessFeaturesEXT,
            *PhysicalDeviceDenseGeometryFormatFeaturesAMDX,
            *PhysicalDeviceDepthClampZeroOneFeaturesKHR,
            *PhysicalDeviceCooperativeVectorFeaturesNV,
            *PhysicalDeviceTileShadingFeaturesQCOM,
            *PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE,
            *PhysicalDevicePresentMeteringFeaturesNV,
            *PhysicalDeviceFormatPackFeaturesARM,
            *PhysicalDeviceTensorFeaturesARM,
            *PhysicalDeviceDescriptorBufferTensorFeaturesARM,
            *PhysicalDeviceShaderFloat8FeaturesEXT,
            *PhysicalDeviceDataGraphFeaturesARM,
            *PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC,
            *PhysicalDeviceShaderUntypedPointersFeaturesKHR,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PhysicalDeviceFeatures2KHR = PhysicalDeviceFeatures2;
pub const PhysicalDeviceProperties2 = extern struct {
    s_type: StructureType = .physical_device_properties_2,
    p_next: ?*anyopaque = null,
    properties: PhysicalDeviceProperties = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
            *PhysicalDeviceClusterAccelerationStructurePropertiesNV,
            *PhysicalDeviceMultiDrawPropertiesEXT,
            *PhysicalDevicePushDescriptorProperties,
            *PhysicalDeviceDriverProperties,
            *PhysicalDeviceIDProperties,
            *PhysicalDeviceMultiviewProperties,
            *PhysicalDeviceDiscardRectanglePropertiesEXT,
            *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,
            *PhysicalDeviceSubgroupProperties,
            *PhysicalDevicePointClippingProperties,
            *PhysicalDeviceProtectedMemoryProperties,
            *PhysicalDeviceSamplerFilterMinmaxProperties,
            *PhysicalDeviceSampleLocationsPropertiesEXT,
            *PhysicalDeviceBlendOperationAdvancedPropertiesEXT,
            *PhysicalDeviceInlineUniformBlockProperties,
            *PhysicalDeviceMaintenance3Properties,
            *PhysicalDeviceMaintenance4Properties,
            *PhysicalDeviceMaintenance5Properties,
            *PhysicalDeviceMaintenance6Properties,
            *PhysicalDeviceMaintenance7PropertiesKHR,
            *PhysicalDeviceLayeredApiPropertiesListKHR,
            *PhysicalDeviceMaintenance9PropertiesKHR,
            *PhysicalDeviceFloatControlsProperties,
            *PhysicalDeviceExternalMemoryHostPropertiesEXT,
            *PhysicalDeviceConservativeRasterizationPropertiesEXT,
            *PhysicalDeviceShaderCorePropertiesAMD,
            *PhysicalDeviceShaderCoreProperties2AMD,
            *PhysicalDeviceDescriptorIndexingProperties,
            *PhysicalDeviceTimelineSemaphoreProperties,
            *PhysicalDeviceVertexAttributeDivisorPropertiesEXT,
            *PhysicalDeviceVertexAttributeDivisorProperties,
            *PhysicalDevicePCIBusInfoPropertiesEXT,
            *PhysicalDeviceDepthStencilResolveProperties,
            *PhysicalDeviceTransformFeedbackPropertiesEXT,
            *PhysicalDeviceComputeShaderDerivativesPropertiesKHR,
            *PhysicalDeviceCopyMemoryIndirectPropertiesNV,
            *PhysicalDeviceMemoryDecompressionPropertiesNV,
            *PhysicalDeviceShadingRateImagePropertiesNV,
            *PhysicalDeviceMeshShaderPropertiesNV,
            *PhysicalDeviceMeshShaderPropertiesEXT,
            *PhysicalDeviceAccelerationStructurePropertiesKHR,
            *PhysicalDeviceRayTracingPipelinePropertiesKHR,
            *PhysicalDeviceRayTracingPropertiesNV,
            *PhysicalDeviceFragmentDensityMapPropertiesEXT,
            *PhysicalDeviceFragmentDensityMap2PropertiesEXT,
            *PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT,
            *PhysicalDeviceCooperativeMatrixPropertiesNV,
            *PhysicalDevicePerformanceQueryPropertiesKHR,
            *PhysicalDeviceShaderSMBuiltinsPropertiesNV,
            *PhysicalDeviceTexelBufferAlignmentProperties,
            *PhysicalDeviceSubgroupSizeControlProperties,
            *PhysicalDeviceSubpassShadingPropertiesHUAWEI,
            *PhysicalDeviceClusterCullingShaderPropertiesHUAWEI,
            *PhysicalDeviceLineRasterizationProperties,
            *PhysicalDeviceVulkan11Properties,
            *PhysicalDeviceVulkan12Properties,
            *PhysicalDeviceVulkan13Properties,
            *PhysicalDeviceVulkan14Properties,
            *PhysicalDeviceCustomBorderColorPropertiesEXT,
            *PhysicalDeviceExtendedDynamicState3PropertiesEXT,
            *PhysicalDevicePartitionedAccelerationStructurePropertiesNV,
            *PhysicalDeviceRobustness2PropertiesKHR,
            *PhysicalDevicePortabilitySubsetPropertiesKHR,
            *PhysicalDeviceFragmentShadingRatePropertiesKHR,
            *PhysicalDeviceFragmentShadingRateEnumsPropertiesNV,
            *PhysicalDeviceLegacyVertexAttributesPropertiesEXT,
            *PhysicalDeviceDeviceGeneratedCommandsPropertiesEXT,
            *PhysicalDeviceHostImageCopyProperties,
            *PhysicalDeviceProvokingVertexPropertiesEXT,
            *PhysicalDeviceDescriptorBufferPropertiesEXT,
            *PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT,
            *PhysicalDeviceShaderIntegerDotProductProperties,
            *PhysicalDeviceDrmPropertiesEXT,
            *PhysicalDeviceFragmentShaderBarycentricPropertiesKHR,
            *PhysicalDevicePipelineBinaryPropertiesKHR,
            *PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT,
            *PhysicalDeviceNestedCommandBufferPropertiesEXT,
            *PhysicalDeviceShaderModuleIdentifierPropertiesEXT,
            *PhysicalDeviceOpacityMicromapPropertiesEXT,
            *PhysicalDeviceDisplacementMicromapPropertiesNV,
            *PhysicalDevicePipelineRobustnessProperties,
            *PhysicalDeviceImageProcessingPropertiesQCOM,
            *PhysicalDeviceOpticalFlowPropertiesNV,
            *PhysicalDeviceShaderCoreBuiltinsPropertiesARM,
            *PhysicalDeviceRayTracingInvocationReorderPropertiesNV,
            *PhysicalDeviceExtendedSparseAddressSpacePropertiesNV,
            *PhysicalDeviceShaderCorePropertiesARM,
            *PhysicalDeviceShaderObjectPropertiesEXT,
            *PhysicalDeviceShaderTileImagePropertiesEXT,
            *PhysicalDeviceCooperativeMatrixPropertiesKHR,
            *PhysicalDeviceShaderEnqueuePropertiesAMDX,
            *PhysicalDeviceTileMemoryHeapPropertiesQCOM,
            *PhysicalDeviceImageProcessing2PropertiesQCOM,
            *PhysicalDeviceLayeredDriverPropertiesMSFT,
            *PhysicalDeviceExternalFormatResolvePropertiesANDROID,
            *PhysicalDeviceCudaKernelLaunchPropertiesNV,
            *PhysicalDeviceSchedulingControlsPropertiesARM,
            *PhysicalDeviceRenderPassStripedPropertiesARM,
            *PhysicalDeviceMapMemoryPlacedPropertiesEXT,
            *PhysicalDeviceImageAlignmentControlPropertiesMESA,
            *PhysicalDeviceCooperativeMatrix2PropertiesNV,
            *PhysicalDeviceCooperativeVectorPropertiesNV,
            *PhysicalDeviceTileShadingPropertiesQCOM,
            *PhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE,
            *PhysicalDeviceExternalComputeQueuePropertiesNV,
            *PhysicalDeviceTensorPropertiesARM,
            *PhysicalDeviceDescriptorBufferTensorPropertiesARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PhysicalDeviceProperties2KHR = PhysicalDeviceProperties2;
pub const FormatProperties2 = extern struct {
    s_type: StructureType = .format_properties_2,
    p_next: ?*anyopaque = null,
    format_properties: FormatProperties = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DrmFormatModifierPropertiesListEXT,
            *SubpassResolvePerformanceQueryEXT,
            *FormatProperties3,
            *DrmFormatModifierPropertiesList2EXT,
            *TensorFormatPropertiesARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const FormatProperties2KHR = FormatProperties2;
pub const ImageFormatProperties2 = extern struct {
    s_type: StructureType = .image_format_properties_2,
    p_next: ?*anyopaque = null,
    image_format_properties: ImageFormatProperties = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ExternalImageFormatProperties,
            *SamplerYcbcrConversionImageFormatProperties,
            *TextureLODGatherFormatPropertiesAMD,
            *AndroidHardwareBufferUsageANDROID,
            *FilterCubicImageViewImageFormatPropertiesEXT,
            *HostImageCopyDevicePerformanceQuery,
            *ImageCompressionPropertiesEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const ImageFormatProperties2KHR = ImageFormatProperties2;
pub const PhysicalDeviceImageFormatInfo2 = extern struct {
    s_type: StructureType = .physical_device_image_format_info_2,
    p_next: ?*const anyopaque = null,
    format: Format = @enumFromInt(0),
    type: ImageType = @enumFromInt(0),
    tiling: ImageTiling = @enumFromInt(0),
    usage: ImageUsageFlags = .none,
    flags: ImageCreateFlags = .none,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PhysicalDeviceExternalImageFormatInfo,
            *ImageFormatListCreateInfo,
            *PhysicalDeviceImageDrmFormatModifierInfoEXT,
            *ImageStencilUsageCreateInfo,
            *PhysicalDeviceImageViewImageFormatInfoEXT,
            *ImageCompressionControlEXT,
            *OpticalFlowImageFormatInfoNV,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PhysicalDeviceImageFormatInfo2KHR = PhysicalDeviceImageFormatInfo2;
pub const QueueFamilyProperties2 = extern struct {
    s_type: StructureType = .queue_family_properties_2,
    p_next: ?*anyopaque = null,
    queue_family_properties: QueueFamilyProperties = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *QueueFamilyOwnershipTransferPropertiesKHR,
            *QueueFamilyGlobalPriorityProperties,
            *QueueFamilyCheckpointPropertiesNV,
            *QueueFamilyCheckpointProperties2NV,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const QueueFamilyProperties2KHR = QueueFamilyProperties2;
pub const PhysicalDeviceMemoryProperties2 = extern struct {
    s_type: StructureType = .physical_device_memory_properties_2,
    p_next: ?*anyopaque = null,
    memory_properties: PhysicalDeviceMemoryProperties = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PhysicalDeviceMemoryBudgetPropertiesEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PhysicalDeviceMemoryProperties2KHR = PhysicalDeviceMemoryProperties2;
pub const SparseImageFormatProperties2 = extern struct {
    s_type: StructureType = .sparse_image_format_properties_2,
    p_next: ?*anyopaque = null,
    properties: SparseImageFormatProperties = .{},
};
pub const SparseImageFormatProperties2KHR = SparseImageFormatProperties2;
pub const PhysicalDeviceSparseImageFormatInfo2 = extern struct {
    s_type: StructureType = .physical_device_sparse_image_format_info_2,
    p_next: ?*const anyopaque = null,
    format: Format = @enumFromInt(0),
    type: ImageType = @enumFromInt(0),
    samples: SampleCountFlags = .none,
    usage: ImageUsageFlags = .none,
    tiling: ImageTiling = @enumFromInt(0),
};
pub const PhysicalDeviceSparseImageFormatInfo2KHR = PhysicalDeviceSparseImageFormatInfo2;
pub const PhysicalDevicePushDescriptorProperties = extern struct {
    s_type: StructureType = .physical_device_push_descriptor_properties,
    p_next: ?*anyopaque = null,
    max_push_descriptors: u32 = 0,
};
pub const PhysicalDevicePushDescriptorPropertiesKHR = PhysicalDevicePushDescriptorProperties;
pub const ConformanceVersion = extern struct {
    major: u8 = 0,
    minor: u8 = 0,
    subminor: u8 = 0,
    patch: u8 = 0,
};
pub const ConformanceVersionKHR = ConformanceVersion;
pub const PhysicalDeviceDriverProperties = extern struct {
    s_type: StructureType = .physical_device_driver_properties,
    p_next: ?*anyopaque = null,
    driver_id: DriverId = @enumFromInt(0),
    driver_name: [max_driver_name_size - 1:0]u8 = [_:0]u8{0} ** (max_driver_name_size - 1),
    driver_info: [max_driver_info_size - 1:0]u8 = [_:0]u8{0} ** (max_driver_info_size - 1),
    conformance_version: ConformanceVersion = .{},
};
pub const PhysicalDeviceDriverPropertiesKHR = PhysicalDeviceDriverProperties;
pub const PresentRegionsKHR = extern struct {
    s_type: StructureType = .present_regions_khr,
    p_next: ?*const anyopaque = null,
    swapchain_count: u32 = 0,
    p_regions: ?[*]const PresentRegionKHR = null,
};
pub const PresentRegionKHR = extern struct {
    rectangle_count: u32 = 0,
    p_rectangles: ?[*]const RectLayerKHR = null,
};
pub const RectLayerKHR = extern struct {
    offset: Offset2D = .{},
    extent: Extent2D = .{},
    layer: u32 = 0,
};
pub const PhysicalDeviceVariablePointersFeatures = extern struct {
    s_type: StructureType = .physical_device_variable_pointers_features,
    p_next: ?*anyopaque = null,
    variable_pointers_storage_buffer: Bool32 = .false,
    variable_pointers: Bool32 = .false,
};
pub const PhysicalDeviceVariablePointersFeaturesKHR = PhysicalDeviceVariablePointersFeatures;
pub const PhysicalDeviceVariablePointerFeaturesKHR = PhysicalDeviceVariablePointersFeatures;
pub const PhysicalDeviceVariablePointerFeatures = PhysicalDeviceVariablePointersFeatures;
pub const ExternalMemoryProperties = extern struct {
    external_memory_features: ExternalMemoryFeatureFlags = .none,
    export_from_imported_handle_types: ExternalMemoryHandleTypeFlags = .none,
    compatible_handle_types: ExternalMemoryHandleTypeFlags = .none,
};
pub const ExternalMemoryPropertiesKHR = ExternalMemoryProperties;
pub const PhysicalDeviceExternalImageFormatInfo = extern struct {
    s_type: StructureType = .physical_device_external_image_format_info,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlags = .none,
};
pub const PhysicalDeviceExternalImageFormatInfoKHR = PhysicalDeviceExternalImageFormatInfo;
pub const ExternalImageFormatProperties = extern struct {
    s_type: StructureType = .external_image_format_properties,
    p_next: ?*anyopaque = null,
    external_memory_properties: ExternalMemoryProperties = .{},
};
pub const ExternalImageFormatPropertiesKHR = ExternalImageFormatProperties;
pub const PhysicalDeviceExternalBufferInfo = extern struct {
    s_type: StructureType = .physical_device_external_buffer_info,
    p_next: ?*const anyopaque = null,
    flags: BufferCreateFlags = .none,
    usage: BufferUsageFlags = .none,
    handle_type: ExternalMemoryHandleTypeFlags = .none,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *BufferUsageFlags2CreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PhysicalDeviceExternalBufferInfoKHR = PhysicalDeviceExternalBufferInfo;
pub const ExternalBufferProperties = extern struct {
    s_type: StructureType = .external_buffer_properties,
    p_next: ?*anyopaque = null,
    external_memory_properties: ExternalMemoryProperties = .{},
};
pub const ExternalBufferPropertiesKHR = ExternalBufferProperties;
pub const PhysicalDeviceIDProperties = extern struct {
    s_type: StructureType = .physical_device_id_properties,
    p_next: ?*anyopaque = null,
    device_uuid: [uuid_size]u8 = [_]u8{0} ** uuid_size,
    driver_uuid: [uuid_size]u8 = [_]u8{0} ** uuid_size,
    device_luid: [luid_size]u8 = [_]u8{0} ** luid_size,
    device_node_mask: u32 = 0,
    device_luid_valid: Bool32 = .false,
};
pub const PhysicalDeviceIDPropertiesKHR = PhysicalDeviceIDProperties;
pub const ExternalMemoryImageCreateInfo = extern struct {
    s_type: StructureType = .external_memory_image_create_info,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalMemoryHandleTypeFlags = .none,
};
pub const ExternalMemoryImageCreateInfoKHR = ExternalMemoryImageCreateInfo;
pub const ExternalMemoryBufferCreateInfo = extern struct {
    s_type: StructureType = .external_memory_buffer_create_info,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalMemoryHandleTypeFlags = .none,
};
pub const ExternalMemoryBufferCreateInfoKHR = ExternalMemoryBufferCreateInfo;
pub const ExportMemoryAllocateInfo = extern struct {
    s_type: StructureType = .export_memory_allocate_info,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalMemoryHandleTypeFlags = .none,
};
pub const ExportMemoryAllocateInfoKHR = ExportMemoryAllocateInfo;
pub const ImportMemoryWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .import_memory_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlags = .none,
    handle: HANDLE = null,
    name: LPCWSTR = null,
};
pub const ExportMemoryWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .export_memory_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    p_attributes: ?*const SECURITY_ATTRIBUTES = null,
    dw_access: DWORD = 0,
    name: LPCWSTR = null,
};
pub const ImportMemoryZirconHandleInfoFUCHSIA = extern struct {
    s_type: StructureType = .import_memory_zircon_handle_info_fuchsia,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlags = .none,
    handle: zx_handle_t = 0,
};
pub const MemoryZirconHandlePropertiesFUCHSIA = extern struct {
    s_type: StructureType = .memory_zircon_handle_properties_fuchsia,
    p_next: ?*anyopaque = null,
    memory_type_bits: u32 = 0,
};
pub const MemoryGetZirconHandleInfoFUCHSIA = extern struct {
    s_type: StructureType = .memory_get_zircon_handle_info_fuchsia,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory = .null_handle,
    handle_type: ExternalMemoryHandleTypeFlags = .none,
};
pub const MemoryWin32HandlePropertiesKHR = extern struct {
    s_type: StructureType = .memory_win32_handle_properties_khr,
    p_next: ?*anyopaque = null,
    memory_type_bits: u32 = 0,
};
pub const MemoryGetWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .memory_get_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory = .null_handle,
    handle_type: ExternalMemoryHandleTypeFlags = .none,
};
pub const ImportMemoryFdInfoKHR = extern struct {
    s_type: StructureType = .import_memory_fd_info_khr,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlags = .none,
    fd: c_int = 0,
};
pub const MemoryFdPropertiesKHR = extern struct {
    s_type: StructureType = .memory_fd_properties_khr,
    p_next: ?*anyopaque = null,
    memory_type_bits: u32 = 0,
};
pub const MemoryGetFdInfoKHR = extern struct {
    s_type: StructureType = .memory_get_fd_info_khr,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory = .null_handle,
    handle_type: ExternalMemoryHandleTypeFlags = .none,
};
pub const Win32KeyedMutexAcquireReleaseInfoKHR = extern struct {
    s_type: StructureType = .win32_keyed_mutex_acquire_release_info_khr,
    p_next: ?*const anyopaque = null,
    acquire_count: u32 = 0,
    p_acquire_syncs: ?[*]const DeviceMemory = null,
    p_acquire_keys: ?[*]const u64 = null,
    p_acquire_timeouts: ?[*]const u32 = null,
    release_count: u32 = 0,
    p_release_syncs: ?[*]const DeviceMemory = null,
    p_release_keys: ?[*]const u64 = null,
};
pub const ImportMemoryMetalHandleInfoEXT = extern struct {
    s_type: StructureType = .import_memory_metal_handle_info_ext,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlags = .none,
    handle: ?*anyopaque = null,
};
pub const MemoryMetalHandlePropertiesEXT = extern struct {
    s_type: StructureType = .memory_metal_handle_properties_ext,
    p_next: ?*anyopaque = null,
    memory_type_bits: u32 = 0,
};
pub const MemoryGetMetalHandleInfoEXT = extern struct {
    s_type: StructureType = .memory_get_metal_handle_info_ext,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory = .null_handle,
    handle_type: ExternalMemoryHandleTypeFlags = .none,
};
pub const PhysicalDeviceExternalSemaphoreInfo = extern struct {
    s_type: StructureType = .physical_device_external_semaphore_info,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalSemaphoreHandleTypeFlags = .none,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *SemaphoreTypeCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PhysicalDeviceExternalSemaphoreInfoKHR = PhysicalDeviceExternalSemaphoreInfo;
pub const ExternalSemaphoreProperties = extern struct {
    s_type: StructureType = .external_semaphore_properties,
    p_next: ?*anyopaque = null,
    export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlags = .none,
    compatible_handle_types: ExternalSemaphoreHandleTypeFlags = .none,
    external_semaphore_features: ExternalSemaphoreFeatureFlags = .none,
};
pub const ExternalSemaphorePropertiesKHR = ExternalSemaphoreProperties;
pub const ExportSemaphoreCreateInfo = extern struct {
    s_type: StructureType = .export_semaphore_create_info,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalSemaphoreHandleTypeFlags = .none,
};
pub const ExportSemaphoreCreateInfoKHR = ExportSemaphoreCreateInfo;
pub const ImportSemaphoreWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .import_semaphore_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore = .null_handle,
    flags: SemaphoreImportFlags = .none,
    handle_type: ExternalSemaphoreHandleTypeFlags = .none,
    handle: HANDLE = null,
    name: LPCWSTR = null,
};
pub const ExportSemaphoreWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .export_semaphore_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    p_attributes: ?*const SECURITY_ATTRIBUTES = null,
    dw_access: DWORD = 0,
    name: LPCWSTR = null,
};
pub const D3D12FenceSubmitInfoKHR = extern struct {
    s_type: StructureType = .d3d12_fence_submit_info_khr,
    p_next: ?*const anyopaque = null,
    wait_semaphore_values_count: u32 = 0,
    p_wait_semaphore_values: ?[*]const u64 = null,
    signal_semaphore_values_count: u32 = 0,
    p_signal_semaphore_values: ?[*]const u64 = null,
};
pub const SemaphoreGetWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .semaphore_get_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore = .null_handle,
    handle_type: ExternalSemaphoreHandleTypeFlags = .none,
};
pub const ImportSemaphoreFdInfoKHR = extern struct {
    s_type: StructureType = .import_semaphore_fd_info_khr,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore = .null_handle,
    flags: SemaphoreImportFlags = .none,
    handle_type: ExternalSemaphoreHandleTypeFlags = .none,
    fd: c_int = 0,
};
pub const SemaphoreGetFdInfoKHR = extern struct {
    s_type: StructureType = .semaphore_get_fd_info_khr,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore = .null_handle,
    handle_type: ExternalSemaphoreHandleTypeFlags = .none,
};
pub const ImportSemaphoreZirconHandleInfoFUCHSIA = extern struct {
    s_type: StructureType = .import_semaphore_zircon_handle_info_fuchsia,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore = .null_handle,
    flags: SemaphoreImportFlags = .none,
    handle_type: ExternalSemaphoreHandleTypeFlags = .none,
    zircon_handle: zx_handle_t = 0,
};
pub const SemaphoreGetZirconHandleInfoFUCHSIA = extern struct {
    s_type: StructureType = .semaphore_get_zircon_handle_info_fuchsia,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore = .null_handle,
    handle_type: ExternalSemaphoreHandleTypeFlags = .none,
};
pub const PhysicalDeviceExternalFenceInfo = extern struct {
    s_type: StructureType = .physical_device_external_fence_info,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalFenceHandleTypeFlags = .none,
};
pub const PhysicalDeviceExternalFenceInfoKHR = PhysicalDeviceExternalFenceInfo;
pub const ExternalFenceProperties = extern struct {
    s_type: StructureType = .external_fence_properties,
    p_next: ?*anyopaque = null,
    export_from_imported_handle_types: ExternalFenceHandleTypeFlags = .none,
    compatible_handle_types: ExternalFenceHandleTypeFlags = .none,
    external_fence_features: ExternalFenceFeatureFlags = .none,
};
pub const ExternalFencePropertiesKHR = ExternalFenceProperties;
pub const ExportFenceCreateInfo = extern struct {
    s_type: StructureType = .export_fence_create_info,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalFenceHandleTypeFlags = .none,
};
pub const ExportFenceCreateInfoKHR = ExportFenceCreateInfo;
pub const ImportFenceWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .import_fence_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    fence: Fence = .null_handle,
    flags: FenceImportFlags = .none,
    handle_type: ExternalFenceHandleTypeFlags = .none,
    handle: HANDLE = null,
    name: LPCWSTR = null,
};
pub const ExportFenceWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .export_fence_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    p_attributes: ?*const SECURITY_ATTRIBUTES = null,
    dw_access: DWORD = 0,
    name: LPCWSTR = null,
};
pub const FenceGetWin32HandleInfoKHR = extern struct {
    s_type: StructureType = .fence_get_win32_handle_info_khr,
    p_next: ?*const anyopaque = null,
    fence: Fence = .null_handle,
    handle_type: ExternalFenceHandleTypeFlags = .none,
};
pub const ImportFenceFdInfoKHR = extern struct {
    s_type: StructureType = .import_fence_fd_info_khr,
    p_next: ?*const anyopaque = null,
    fence: Fence = .null_handle,
    flags: FenceImportFlags = .none,
    handle_type: ExternalFenceHandleTypeFlags = .none,
    fd: c_int = 0,
};
pub const FenceGetFdInfoKHR = extern struct {
    s_type: StructureType = .fence_get_fd_info_khr,
    p_next: ?*const anyopaque = null,
    fence: Fence = .null_handle,
    handle_type: ExternalFenceHandleTypeFlags = .none,
};
pub const PhysicalDeviceMultiviewFeatures = extern struct {
    s_type: StructureType = .physical_device_multiview_features,
    p_next: ?*anyopaque = null,
    multiview: Bool32 = .false,
    multiview_geometry_shader: Bool32 = .false,
    multiview_tessellation_shader: Bool32 = .false,
};
pub const PhysicalDeviceMultiviewFeaturesKHR = PhysicalDeviceMultiviewFeatures;
pub const PhysicalDeviceMultiviewProperties = extern struct {
    s_type: StructureType = .physical_device_multiview_properties,
    p_next: ?*anyopaque = null,
    max_multiview_view_count: u32 = 0,
    max_multiview_instance_index: u32 = 0,
};
pub const PhysicalDeviceMultiviewPropertiesKHR = PhysicalDeviceMultiviewProperties;
pub const RenderPassMultiviewCreateInfo = extern struct {
    s_type: StructureType = .render_pass_multiview_create_info,
    p_next: ?*const anyopaque = null,
    subpass_count: u32 = 0,
    p_view_masks: ?[*]const u32 = null,
    dependency_count: u32 = 0,
    p_view_offsets: ?[*]const i32 = null,
    correlation_mask_count: u32 = 0,
    p_correlation_masks: ?[*]const u32 = null,
};
pub const RenderPassMultiviewCreateInfoKHR = RenderPassMultiviewCreateInfo;
pub const SurfaceCapabilities2EXT = extern struct {
    s_type: StructureType = .surface_capabilities_2_ext,
    p_next: ?*anyopaque = null,
    min_image_count: u32 = 0,
    max_image_count: u32 = 0,
    current_extent: Extent2D = .{},
    min_image_extent: Extent2D = .{},
    max_image_extent: Extent2D = .{},
    max_image_array_layers: u32 = 0,
    supported_transforms: SurfaceTransformFlagsKHR = .none,
    current_transform: SurfaceTransformFlagsKHR = .none,
    supported_composite_alpha: CompositeAlphaFlagsKHR = .none,
    supported_usage_flags: ImageUsageFlags = .none,
    supported_surface_counters: SurfaceCounterFlagsEXT = .none,
};
pub const DisplayPowerInfoEXT = extern struct {
    s_type: StructureType = .display_power_info_ext,
    p_next: ?*const anyopaque = null,
    power_state: DisplayPowerStateEXT = @enumFromInt(0),
};
pub const DeviceEventInfoEXT = extern struct {
    s_type: StructureType = .device_event_info_ext,
    p_next: ?*const anyopaque = null,
    device_event: DeviceEventTypeEXT = @enumFromInt(0),
};
pub const DisplayEventInfoEXT = extern struct {
    s_type: StructureType = .display_event_info_ext,
    p_next: ?*const anyopaque = null,
    display_event: DisplayEventTypeEXT = @enumFromInt(0),
};
pub const SwapchainCounterCreateInfoEXT = extern struct {
    s_type: StructureType = .swapchain_counter_create_info_ext,
    p_next: ?*const anyopaque = null,
    surface_counters: SurfaceCounterFlagsEXT = .none,
};
pub const PhysicalDeviceGroupProperties = extern struct {
    s_type: StructureType = .physical_device_group_properties,
    p_next: ?*anyopaque = null,
    physical_device_count: u32 = 0,
    physical_devices: [max_device_group_size]PhysicalDevice = [_]PhysicalDevice{.null_handle} ** max_device_group_size,
    subset_allocation: Bool32 = .false,
};
pub const PhysicalDeviceGroupPropertiesKHR = PhysicalDeviceGroupProperties;
pub const MemoryAllocateFlagsInfo = extern struct {
    s_type: StructureType = .memory_allocate_flags_info,
    p_next: ?*const anyopaque = null,
    flags: MemoryAllocateFlags = .none,
    device_mask: u32 = 0,
};
pub const MemoryAllocateFlagsInfoKHR = MemoryAllocateFlagsInfo;
pub const BindBufferMemoryInfo = extern struct {
    s_type: StructureType = .bind_buffer_memory_info,
    p_next: ?*const anyopaque = null,
    buffer: Buffer = .null_handle,
    memory: DeviceMemory = .null_handle,
    memory_offset: DeviceSize = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *BindBufferMemoryDeviceGroupInfo,
            *BindMemoryStatus,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const BindBufferMemoryInfoKHR = BindBufferMemoryInfo;
pub const BindBufferMemoryDeviceGroupInfo = extern struct {
    s_type: StructureType = .bind_buffer_memory_device_group_info,
    p_next: ?*const anyopaque = null,
    device_index_count: u32 = 0,
    p_device_indices: ?[*]const u32 = null,
};
pub const BindBufferMemoryDeviceGroupInfoKHR = BindBufferMemoryDeviceGroupInfo;
pub const BindImageMemoryInfo = extern struct {
    s_type: StructureType = .bind_image_memory_info,
    p_next: ?*const anyopaque = null,
    image: Image = .null_handle,
    memory: DeviceMemory = .null_handle,
    memory_offset: DeviceSize = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *BindImageMemoryDeviceGroupInfo,
            *BindImageMemorySwapchainInfoKHR,
            *BindImagePlaneMemoryInfo,
            *BindMemoryStatus,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const BindImageMemoryInfoKHR = BindImageMemoryInfo;
pub const BindImageMemoryDeviceGroupInfo = extern struct {
    s_type: StructureType = .bind_image_memory_device_group_info,
    p_next: ?*const anyopaque = null,
    device_index_count: u32 = 0,
    p_device_indices: ?[*]const u32 = null,
    split_instance_bind_region_count: u32 = 0,
    p_split_instance_bind_regions: ?[*]const Rect2D = null,
};
pub const BindImageMemoryDeviceGroupInfoKHR = BindImageMemoryDeviceGroupInfo;
pub const DeviceGroupRenderPassBeginInfo = extern struct {
    s_type: StructureType = .device_group_render_pass_begin_info,
    p_next: ?*const anyopaque = null,
    device_mask: u32 = 0,
    device_render_area_count: u32 = 0,
    p_device_render_areas: ?[*]const Rect2D = null,
};
pub const DeviceGroupRenderPassBeginInfoKHR = DeviceGroupRenderPassBeginInfo;
pub const DeviceGroupCommandBufferBeginInfo = extern struct {
    s_type: StructureType = .device_group_command_buffer_begin_info,
    p_next: ?*const anyopaque = null,
    device_mask: u32 = 0,
};
pub const DeviceGroupCommandBufferBeginInfoKHR = DeviceGroupCommandBufferBeginInfo;
pub const DeviceGroupSubmitInfo = extern struct {
    s_type: StructureType = .device_group_submit_info,
    p_next: ?*const anyopaque = null,
    wait_semaphore_count: u32 = 0,
    p_wait_semaphore_device_indices: ?[*]const u32 = null,
    command_buffer_count: u32 = 0,
    p_command_buffer_device_masks: ?[*]const u32 = null,
    signal_semaphore_count: u32 = 0,
    p_signal_semaphore_device_indices: ?[*]const u32 = null,
};
pub const DeviceGroupSubmitInfoKHR = DeviceGroupSubmitInfo;
pub const DeviceGroupBindSparseInfo = extern struct {
    s_type: StructureType = .device_group_bind_sparse_info,
    p_next: ?*const anyopaque = null,
    resource_device_index: u32 = 0,
    memory_device_index: u32 = 0,
};
pub const DeviceGroupBindSparseInfoKHR = DeviceGroupBindSparseInfo;
pub const DeviceGroupPresentCapabilitiesKHR = extern struct {
    s_type: StructureType = .device_group_present_capabilities_khr,
    p_next: ?*anyopaque = null,
    present_mask: [max_device_group_size]u32 = [_]u32{0} ** max_device_group_size,
    modes: DeviceGroupPresentModeFlagsKHR = .none,
};
pub const ImageSwapchainCreateInfoKHR = extern struct {
    s_type: StructureType = .image_swapchain_create_info_khr,
    p_next: ?*const anyopaque = null,
    swapchain: SwapchainKHR = .null_handle,
};
pub const BindImageMemorySwapchainInfoKHR = extern struct {
    s_type: StructureType = .bind_image_memory_swapchain_info_khr,
    p_next: ?*const anyopaque = null,
    swapchain: SwapchainKHR = .null_handle,
    image_index: u32 = 0,
};
pub const AcquireNextImageInfoKHR = extern struct {
    s_type: StructureType = .acquire_next_image_info_khr,
    p_next: ?*const anyopaque = null,
    swapchain: SwapchainKHR = .null_handle,
    timeout: u64 = 0,
    semaphore: Semaphore = .null_handle,
    fence: Fence = .null_handle,
    device_mask: u32 = 0,
};
pub const DeviceGroupPresentInfoKHR = extern struct {
    s_type: StructureType = .device_group_present_info_khr,
    p_next: ?*const anyopaque = null,
    swapchain_count: u32 = 0,
    p_device_masks: ?[*]const u32 = null,
    mode: DeviceGroupPresentModeFlagsKHR = .none,
};
pub const DeviceGroupDeviceCreateInfo = extern struct {
    s_type: StructureType = .device_group_device_create_info,
    p_next: ?*const anyopaque = null,
    physical_device_count: u32 = 0,
    p_physical_devices: ?[*]const PhysicalDevice = null,
};
pub const DeviceGroupDeviceCreateInfoKHR = DeviceGroupDeviceCreateInfo;
pub const DeviceGroupSwapchainCreateInfoKHR = extern struct {
    s_type: StructureType = .device_group_swapchain_create_info_khr,
    p_next: ?*const anyopaque = null,
    modes: DeviceGroupPresentModeFlagsKHR = .none,
};
pub const DescriptorUpdateTemplateEntry = extern struct {
    dst_binding: u32 = 0,
    dst_array_element: u32 = 0,
    descriptor_count: u32 = 0,
    descriptor_type: DescriptorType = @enumFromInt(0),
    offset: usize = 0,
    stride: usize = 0,
};
pub const DescriptorUpdateTemplateEntryKHR = DescriptorUpdateTemplateEntry;
pub const DescriptorUpdateTemplateCreateInfo = extern struct {
    s_type: StructureType = .descriptor_update_template_create_info,
    p_next: ?*const anyopaque = null,
    flags: DescriptorUpdateTemplateCreateFlags = .none,
    descriptor_update_entry_count: u32 = 0,
    p_descriptor_update_entries: ?[*]const DescriptorUpdateTemplateEntry = null,
    template_type: DescriptorUpdateTemplateType = @enumFromInt(0),
    descriptor_set_layout: DescriptorSetLayout = .null_handle,
    pipeline_bind_point: PipelineBindPoint = @enumFromInt(0),
    pipeline_layout: PipelineLayout = .null_handle,
    set: u32 = 0,
};
pub const DescriptorUpdateTemplateCreateInfoKHR = DescriptorUpdateTemplateCreateInfo;
pub const XYColorEXT = extern struct {
    x: f32 = 0,
    y: f32 = 0,
};
pub const PhysicalDevicePresentIdFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_present_id_features_khr,
    p_next: ?*anyopaque = null,
    present_id: Bool32 = .false,
};
pub const PresentIdKHR = extern struct {
    s_type: StructureType = .present_id_khr,
    p_next: ?*const anyopaque = null,
    swapchain_count: u32 = 0,
    p_present_ids: ?[*]const u64 = null,
};
pub const PhysicalDevicePresentId2FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_present_id_2_features_khr,
    p_next: ?*anyopaque = null,
    present_id2: Bool32 = .false,
};
pub const PresentId2KHR = extern struct {
    s_type: StructureType = .present_id_2_khr,
    p_next: ?*const anyopaque = null,
    swapchain_count: u32 = 0,
    p_present_ids: ?[*]const u64 = null,
};
pub const PresentWait2InfoKHR = extern struct {
    s_type: StructureType = .present_wait_2_info_khr,
    p_next: ?*const anyopaque = null,
    present_id: u64 = 0,
    timeout: u64 = 0,
};
pub const PhysicalDevicePresentWaitFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_present_wait_features_khr,
    p_next: ?*anyopaque = null,
    present_wait: Bool32 = .false,
};
pub const PhysicalDevicePresentWait2FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_present_wait_2_features_khr,
    p_next: ?*anyopaque = null,
    present_wait2: Bool32 = .false,
};
pub const HdrMetadataEXT = extern struct {
    s_type: StructureType = .hdr_metadata_ext,
    p_next: ?*const anyopaque = null,
    display_primary_red: XYColorEXT = .{},
    display_primary_green: XYColorEXT = .{},
    display_primary_blue: XYColorEXT = .{},
    white_point: XYColorEXT = .{},
    max_luminance: f32 = 0,
    min_luminance: f32 = 0,
    max_content_light_level: f32 = 0,
    max_frame_average_light_level: f32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *HdrVividDynamicMetadataHUAWEI,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const HdrVividDynamicMetadataHUAWEI = extern struct {
    s_type: StructureType = .hdr_vivid_dynamic_metadata_huawei,
    p_next: ?*const anyopaque = null,
    dynamic_metadata_size: usize = 0,
    p_dynamic_metadata: ?*const anyopaque = null,
};
pub const DisplayNativeHdrSurfaceCapabilitiesAMD = extern struct {
    s_type: StructureType = .display_native_hdr_surface_capabilities_amd,
    p_next: ?*anyopaque = null,
    local_dimming_support: Bool32 = .false,
};
pub const SwapchainDisplayNativeHdrCreateInfoAMD = extern struct {
    s_type: StructureType = .swapchain_display_native_hdr_create_info_amd,
    p_next: ?*const anyopaque = null,
    local_dimming_enable: Bool32 = .false,
};
pub const RefreshCycleDurationGOOGLE = extern struct {
    refresh_duration: u64 = 0,
};
pub const PastPresentationTimingGOOGLE = extern struct {
    present_id: u32 = 0,
    desired_present_time: u64 = 0,
    actual_present_time: u64 = 0,
    earliest_present_time: u64 = 0,
    present_margin: u64 = 0,
};
pub const PresentTimesInfoGOOGLE = extern struct {
    s_type: StructureType = .present_times_info_google,
    p_next: ?*const anyopaque = null,
    swapchain_count: u32 = 0,
    p_times: ?[*]const PresentTimeGOOGLE = null,
};
pub const PresentTimeGOOGLE = extern struct {
    present_id: u32 = 0,
    desired_present_time: u64 = 0,
};
pub const IOSSurfaceCreateInfoMVK = extern struct {
    s_type: StructureType = .ios_surface_create_info_mvk,
    p_next: ?*const anyopaque = null,
    flags: IOSSurfaceCreateFlagsMVK = .none,
    p_view: ?*const anyopaque = null,
};
pub const MacOSSurfaceCreateInfoMVK = extern struct {
    s_type: StructureType = .macos_surface_create_info_mvk,
    p_next: ?*const anyopaque = null,
    flags: MacOSSurfaceCreateFlagsMVK = .none,
    p_view: ?*const anyopaque = null,
};
pub const MetalSurfaceCreateInfoEXT = extern struct {
    s_type: StructureType = .metal_surface_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: MetalSurfaceCreateFlagsEXT = .none,
    p_layer: ?*const CAMetalLayer = null,
};
pub const ViewportWScalingNV = extern struct {
    xcoeff: f32 = 0,
    ycoeff: f32 = 0,
};
pub const PipelineViewportWScalingStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_viewport_w_scaling_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    viewport_w_scaling_enable: Bool32 = .false,
    viewport_count: u32 = 0,
    p_viewport_w_scalings: ?[*]const ViewportWScalingNV = null,
};
pub const ViewportSwizzleNV = extern struct {
    x: ViewportCoordinateSwizzleNV = @enumFromInt(0),
    y: ViewportCoordinateSwizzleNV = @enumFromInt(0),
    z: ViewportCoordinateSwizzleNV = @enumFromInt(0),
    w: ViewportCoordinateSwizzleNV = @enumFromInt(0),
};
pub const PipelineViewportSwizzleStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_viewport_swizzle_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    flags: PipelineViewportSwizzleStateCreateFlagsNV = .none,
    viewport_count: u32 = 0,
    p_viewport_swizzles: ?[*]const ViewportSwizzleNV = null,
};
pub const PhysicalDeviceDiscardRectanglePropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_discard_rectangle_properties_ext,
    p_next: ?*anyopaque = null,
    max_discard_rectangles: u32 = 0,
};
pub const PipelineDiscardRectangleStateCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_discard_rectangle_state_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: PipelineDiscardRectangleStateCreateFlagsEXT = .none,
    discard_rectangle_mode: DiscardRectangleModeEXT = @enumFromInt(0),
    discard_rectangle_count: u32 = 0,
    p_discard_rectangles: ?[*]const Rect2D = null,
};
pub const PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = extern struct {
    s_type: StructureType = .physical_device_multiview_per_view_attributes_properties_nvx,
    p_next: ?*anyopaque = null,
    per_view_position_all_components: Bool32 = .false,
};
pub const InputAttachmentAspectReference = extern struct {
    subpass: u32 = 0,
    input_attachment_index: u32 = 0,
    aspect_mask: ImageAspectFlags = .none,
};
pub const InputAttachmentAspectReferenceKHR = InputAttachmentAspectReference;
pub const RenderPassInputAttachmentAspectCreateInfo = extern struct {
    s_type: StructureType = .render_pass_input_attachment_aspect_create_info,
    p_next: ?*const anyopaque = null,
    aspect_reference_count: u32 = 0,
    p_aspect_references: ?[*]const InputAttachmentAspectReference = null,
};
pub const RenderPassInputAttachmentAspectCreateInfoKHR = RenderPassInputAttachmentAspectCreateInfo;
pub const PhysicalDeviceSurfaceInfo2KHR = extern struct {
    s_type: StructureType = .physical_device_surface_info_2_khr,
    p_next: ?*const anyopaque = null,
    surface: SurfaceKHR = .null_handle,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *SurfaceFullScreenExclusiveInfoEXT,
            *SurfaceFullScreenExclusiveWin32InfoEXT,
            *SurfacePresentModeKHR,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const SurfaceCapabilities2KHR = extern struct {
    s_type: StructureType = .surface_capabilities_2_khr,
    p_next: ?*anyopaque = null,
    surface_capabilities: SurfaceCapabilitiesKHR = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DisplayNativeHdrSurfaceCapabilitiesAMD,
            *SharedPresentSurfaceCapabilitiesKHR,
            *SurfaceProtectedCapabilitiesKHR,
            *SurfaceCapabilitiesFullScreenExclusiveEXT,
            *SurfaceCapabilitiesPresentBarrierNV,
            *SurfaceCapabilitiesPresentId2KHR,
            *SurfaceCapabilitiesPresentWait2KHR,
            *SurfacePresentScalingCapabilitiesKHR,
            *SurfacePresentModeCompatibilityKHR,
            *LatencySurfaceCapabilitiesNV,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const SurfaceFormat2KHR = extern struct {
    s_type: StructureType = .surface_format_2_khr,
    p_next: ?*anyopaque = null,
    surface_format: SurfaceFormatKHR = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ImageCompressionPropertiesEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DisplayProperties2KHR = extern struct {
    s_type: StructureType = .display_properties_2_khr,
    p_next: ?*anyopaque = null,
    display_properties: DisplayPropertiesKHR = .{},
};
pub const DisplayPlaneProperties2KHR = extern struct {
    s_type: StructureType = .display_plane_properties_2_khr,
    p_next: ?*anyopaque = null,
    display_plane_properties: DisplayPlanePropertiesKHR = .{},
};
pub const DisplayModeProperties2KHR = extern struct {
    s_type: StructureType = .display_mode_properties_2_khr,
    p_next: ?*anyopaque = null,
    display_mode_properties: DisplayModePropertiesKHR = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DisplayModeStereoPropertiesNV,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DisplayModeStereoPropertiesNV = extern struct {
    s_type: StructureType = .display_mode_stereo_properties_nv,
    p_next: ?*const anyopaque = null,
    hdmi_3d_supported: Bool32 = .false,
};
pub const DisplayPlaneInfo2KHR = extern struct {
    s_type: StructureType = .display_plane_info_2_khr,
    p_next: ?*const anyopaque = null,
    mode: DisplayModeKHR = .null_handle,
    plane_index: u32 = 0,
};
pub const DisplayPlaneCapabilities2KHR = extern struct {
    s_type: StructureType = .display_plane_capabilities_2_khr,
    p_next: ?*anyopaque = null,
    capabilities: DisplayPlaneCapabilitiesKHR = .{},
};
pub const SharedPresentSurfaceCapabilitiesKHR = extern struct {
    s_type: StructureType = .shared_present_surface_capabilities_khr,
    p_next: ?*anyopaque = null,
    shared_present_supported_usage_flags: ImageUsageFlags = .none,
};
pub const PhysicalDevice16BitStorageFeatures = extern struct {
    s_type: StructureType = .physical_device_16bit_storage_features,
    p_next: ?*anyopaque = null,
    storage_buffer16_bit_access: Bool32 = .false,
    uniform_and_storage_buffer16_bit_access: Bool32 = .false,
    storage_push_constant16: Bool32 = .false,
    storage_input_output16: Bool32 = .false,
};
pub const PhysicalDevice16BitStorageFeaturesKHR = PhysicalDevice16BitStorageFeatures;
pub const PhysicalDeviceSubgroupProperties = extern struct {
    s_type: StructureType = .physical_device_subgroup_properties,
    p_next: ?*anyopaque = null,
    subgroup_size: u32 = 0,
    supported_stages: ShaderStageFlags = .none,
    supported_operations: SubgroupFeatureFlags = .none,
    quad_operations_in_all_stages: Bool32 = .false,
};
pub const PhysicalDeviceShaderSubgroupExtendedTypesFeatures = extern struct {
    s_type: StructureType = .physical_device_shader_subgroup_extended_types_features,
    p_next: ?*anyopaque = null,
    shader_subgroup_extended_types: Bool32 = .false,
};
pub const PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
pub const BufferMemoryRequirementsInfo2 = extern struct {
    s_type: StructureType = .buffer_memory_requirements_info_2,
    p_next: ?*const anyopaque = null,
    buffer: Buffer = .null_handle,
};
pub const BufferMemoryRequirementsInfo2KHR = BufferMemoryRequirementsInfo2;
pub const DeviceBufferMemoryRequirements = extern struct {
    s_type: StructureType = .device_buffer_memory_requirements,
    p_next: ?*const anyopaque = null,
    p_create_info: ?*const BufferCreateInfo = null,
};
pub const DeviceBufferMemoryRequirementsKHR = DeviceBufferMemoryRequirements;
pub const ImageMemoryRequirementsInfo2 = extern struct {
    s_type: StructureType = .image_memory_requirements_info_2,
    p_next: ?*const anyopaque = null,
    image: Image = .null_handle,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ImagePlaneMemoryRequirementsInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const ImageMemoryRequirementsInfo2KHR = ImageMemoryRequirementsInfo2;
pub const ImageSparseMemoryRequirementsInfo2 = extern struct {
    s_type: StructureType = .image_sparse_memory_requirements_info_2,
    p_next: ?*const anyopaque = null,
    image: Image = .null_handle,
};
pub const ImageSparseMemoryRequirementsInfo2KHR = ImageSparseMemoryRequirementsInfo2;
pub const DeviceImageMemoryRequirements = extern struct {
    s_type: StructureType = .device_image_memory_requirements,
    p_next: ?*const anyopaque = null,
    p_create_info: ?*const ImageCreateInfo = null,
    plane_aspect: ImageAspectFlags = .none,
};
pub const DeviceImageMemoryRequirementsKHR = DeviceImageMemoryRequirements;
pub const MemoryRequirements2 = extern struct {
    s_type: StructureType = .memory_requirements_2,
    p_next: ?*anyopaque = null,
    memory_requirements: MemoryRequirements = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *MemoryDedicatedRequirements,
            *TileMemoryRequirementsQCOM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const MemoryRequirements2KHR = MemoryRequirements2;
pub const SparseImageMemoryRequirements2 = extern struct {
    s_type: StructureType = .sparse_image_memory_requirements_2,
    p_next: ?*anyopaque = null,
    memory_requirements: SparseImageMemoryRequirements = .{},
};
pub const SparseImageMemoryRequirements2KHR = SparseImageMemoryRequirements2;
pub const PhysicalDevicePointClippingProperties = extern struct {
    s_type: StructureType = .physical_device_point_clipping_properties,
    p_next: ?*anyopaque = null,
    point_clipping_behavior: PointClippingBehavior = @enumFromInt(0),
};
pub const PhysicalDevicePointClippingPropertiesKHR = PhysicalDevicePointClippingProperties;
pub const MemoryDedicatedRequirements = extern struct {
    s_type: StructureType = .memory_dedicated_requirements,
    p_next: ?*anyopaque = null,
    prefers_dedicated_allocation: Bool32 = .false,
    requires_dedicated_allocation: Bool32 = .false,
};
pub const MemoryDedicatedRequirementsKHR = MemoryDedicatedRequirements;
pub const MemoryDedicatedAllocateInfo = extern struct {
    s_type: StructureType = .memory_dedicated_allocate_info,
    p_next: ?*const anyopaque = null,
    image: Image = .null_handle,
    buffer: Buffer = .null_handle,
};
pub const MemoryDedicatedAllocateInfoKHR = MemoryDedicatedAllocateInfo;
pub const ImageViewUsageCreateInfo = extern struct {
    s_type: StructureType = .image_view_usage_create_info,
    p_next: ?*const anyopaque = null,
    usage: ImageUsageFlags = .none,
};
pub const ImageViewSlicedCreateInfoEXT = extern struct {
    s_type: StructureType = .image_view_sliced_create_info_ext,
    p_next: ?*const anyopaque = null,
    slice_offset: u32 = 0,
    slice_count: u32 = 0,
};
pub const ImageViewUsageCreateInfoKHR = ImageViewUsageCreateInfo;
pub const PipelineTessellationDomainOriginStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_tessellation_domain_origin_state_create_info,
    p_next: ?*const anyopaque = null,
    domain_origin: TessellationDomainOrigin = @enumFromInt(0),
};
pub const PipelineTessellationDomainOriginStateCreateInfoKHR = PipelineTessellationDomainOriginStateCreateInfo;
pub const SamplerYcbcrConversionInfo = extern struct {
    s_type: StructureType = .sampler_ycbcr_conversion_info,
    p_next: ?*const anyopaque = null,
    conversion: SamplerYcbcrConversion = .null_handle,
};
pub const SamplerYcbcrConversionInfoKHR = SamplerYcbcrConversionInfo;
pub const SamplerYcbcrConversionCreateInfo = extern struct {
    s_type: StructureType = .sampler_ycbcr_conversion_create_info,
    p_next: ?*const anyopaque = null,
    format: Format = @enumFromInt(0),
    ycbcr_model: SamplerYcbcrModelConversion = @enumFromInt(0),
    ycbcr_range: SamplerYcbcrRange = @enumFromInt(0),
    components: ComponentMapping = .{},
    x_chroma_offset: ChromaLocation = @enumFromInt(0),
    y_chroma_offset: ChromaLocation = @enumFromInt(0),
    chroma_filter: Filter = @enumFromInt(0),
    force_explicit_reconstruction: Bool32 = .false,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ExternalFormatANDROID,
            *SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const SamplerYcbcrConversionCreateInfoKHR = SamplerYcbcrConversionCreateInfo;
pub const BindImagePlaneMemoryInfo = extern struct {
    s_type: StructureType = .bind_image_plane_memory_info,
    p_next: ?*const anyopaque = null,
    plane_aspect: ImageAspectFlags = .none,
};
pub const BindImagePlaneMemoryInfoKHR = BindImagePlaneMemoryInfo;
pub const ImagePlaneMemoryRequirementsInfo = extern struct {
    s_type: StructureType = .image_plane_memory_requirements_info,
    p_next: ?*const anyopaque = null,
    plane_aspect: ImageAspectFlags = .none,
};
pub const ImagePlaneMemoryRequirementsInfoKHR = ImagePlaneMemoryRequirementsInfo;
pub const PhysicalDeviceSamplerYcbcrConversionFeatures = extern struct {
    s_type: StructureType = .physical_device_sampler_ycbcr_conversion_features,
    p_next: ?*anyopaque = null,
    sampler_ycbcr_conversion: Bool32 = .false,
};
pub const PhysicalDeviceSamplerYcbcrConversionFeaturesKHR = PhysicalDeviceSamplerYcbcrConversionFeatures;
pub const SamplerYcbcrConversionImageFormatProperties = extern struct {
    s_type: StructureType = .sampler_ycbcr_conversion_image_format_properties,
    p_next: ?*anyopaque = null,
    combined_image_sampler_descriptor_count: u32 = 0,
};
pub const SamplerYcbcrConversionImageFormatPropertiesKHR = SamplerYcbcrConversionImageFormatProperties;
pub const TextureLODGatherFormatPropertiesAMD = extern struct {
    s_type: StructureType = .texture_lod_gather_format_properties_amd,
    p_next: ?*anyopaque = null,
    supports_texture_gather_lod_bias_amd: Bool32 = .false,
};
pub const ConditionalRenderingBeginInfoEXT = extern struct {
    s_type: StructureType = .conditional_rendering_begin_info_ext,
    p_next: ?*const anyopaque = null,
    buffer: Buffer = .null_handle,
    offset: DeviceSize = 0,
    flags: ConditionalRenderingFlagsEXT = .none,
};
pub const ProtectedSubmitInfo = extern struct {
    s_type: StructureType = .protected_submit_info,
    p_next: ?*const anyopaque = null,
    protected_submit: Bool32 = .false,
};
pub const PhysicalDeviceProtectedMemoryFeatures = extern struct {
    s_type: StructureType = .physical_device_protected_memory_features,
    p_next: ?*anyopaque = null,
    protected_memory: Bool32 = .false,
};
pub const PhysicalDeviceProtectedMemoryProperties = extern struct {
    s_type: StructureType = .physical_device_protected_memory_properties,
    p_next: ?*anyopaque = null,
    protected_no_fault: Bool32 = .false,
};
pub const DeviceQueueInfo2 = extern struct {
    s_type: StructureType = .device_queue_info_2,
    p_next: ?*const anyopaque = null,
    flags: DeviceQueueCreateFlags = .none,
    queue_family_index: u32 = 0,
    queue_index: u32 = 0,
};
pub const PipelineCoverageToColorStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_coverage_to_color_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    flags: PipelineCoverageToColorStateCreateFlagsNV = .none,
    coverage_to_color_enable: Bool32 = .false,
    coverage_to_color_location: u32 = 0,
};
pub const PhysicalDeviceSamplerFilterMinmaxProperties = extern struct {
    s_type: StructureType = .physical_device_sampler_filter_minmax_properties,
    p_next: ?*anyopaque = null,
    filter_minmax_single_component_formats: Bool32 = .false,
    filter_minmax_image_component_mapping: Bool32 = .false,
};
pub const PhysicalDeviceSamplerFilterMinmaxPropertiesEXT = PhysicalDeviceSamplerFilterMinmaxProperties;
pub const SampleLocationEXT = extern struct {
    x: f32 = 0,
    y: f32 = 0,
};
pub const SampleLocationsInfoEXT = extern struct {
    s_type: StructureType = .sample_locations_info_ext,
    p_next: ?*const anyopaque = null,
    sample_locations_per_pixel: SampleCountFlags = .none,
    sample_location_grid_size: Extent2D = .{},
    sample_locations_count: u32 = 0,
    p_sample_locations: ?[*]const SampleLocationEXT = null,
};
pub const AttachmentSampleLocationsEXT = extern struct {
    attachment_index: u32 = 0,
    sample_locations_info: SampleLocationsInfoEXT = .{},
};
pub const SubpassSampleLocationsEXT = extern struct {
    subpass_index: u32 = 0,
    sample_locations_info: SampleLocationsInfoEXT = .{},
};
pub const RenderPassSampleLocationsBeginInfoEXT = extern struct {
    s_type: StructureType = .render_pass_sample_locations_begin_info_ext,
    p_next: ?*const anyopaque = null,
    attachment_initial_sample_locations_count: u32 = 0,
    p_attachment_initial_sample_locations: ?[*]const AttachmentSampleLocationsEXT = null,
    post_subpass_sample_locations_count: u32 = 0,
    p_post_subpass_sample_locations: ?[*]const SubpassSampleLocationsEXT = null,
};
pub const PipelineSampleLocationsStateCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_sample_locations_state_create_info_ext,
    p_next: ?*const anyopaque = null,
    sample_locations_enable: Bool32 = .false,
    sample_locations_info: SampleLocationsInfoEXT = .{},
};
pub const PhysicalDeviceSampleLocationsPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_sample_locations_properties_ext,
    p_next: ?*anyopaque = null,
    sample_location_sample_counts: SampleCountFlags = .none,
    max_sample_location_grid_size: Extent2D = .{},
    sample_location_coordinate_range: [2]f32 = [_]f32{0} ** 2,
    sample_location_sub_pixel_bits: u32 = 0,
    variable_sample_locations: Bool32 = .false,
};
pub const MultisamplePropertiesEXT = extern struct {
    s_type: StructureType = .multisample_properties_ext,
    p_next: ?*anyopaque = null,
    max_sample_location_grid_size: Extent2D = .{},
};
pub const SamplerReductionModeCreateInfo = extern struct {
    s_type: StructureType = .sampler_reduction_mode_create_info,
    p_next: ?*const anyopaque = null,
    reduction_mode: SamplerReductionMode = @enumFromInt(0),
};
pub const SamplerReductionModeCreateInfoEXT = SamplerReductionModeCreateInfo;
pub const PhysicalDeviceBlendOperationAdvancedFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_blend_operation_advanced_features_ext,
    p_next: ?*anyopaque = null,
    advanced_blend_coherent_operations: Bool32 = .false,
};
pub const PhysicalDeviceMultiDrawFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_multi_draw_features_ext,
    p_next: ?*anyopaque = null,
    multi_draw: Bool32 = .false,
};
pub const PhysicalDeviceBlendOperationAdvancedPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_blend_operation_advanced_properties_ext,
    p_next: ?*anyopaque = null,
    advanced_blend_max_color_attachments: u32 = 0,
    advanced_blend_independent_blend: Bool32 = .false,
    advanced_blend_non_premultiplied_src_color: Bool32 = .false,
    advanced_blend_non_premultiplied_dst_color: Bool32 = .false,
    advanced_blend_correlated_overlap: Bool32 = .false,
    advanced_blend_all_operations: Bool32 = .false,
};
pub const PipelineColorBlendAdvancedStateCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_color_blend_advanced_state_create_info_ext,
    p_next: ?*const anyopaque = null,
    src_premultiplied: Bool32 = .false,
    dst_premultiplied: Bool32 = .false,
    blend_overlap: BlendOverlapEXT = @enumFromInt(0),
};
pub const PhysicalDeviceInlineUniformBlockFeatures = extern struct {
    s_type: StructureType = .physical_device_inline_uniform_block_features,
    p_next: ?*anyopaque = null,
    inline_uniform_block: Bool32 = .false,
    descriptor_binding_inline_uniform_block_update_after_bind: Bool32 = .false,
};
pub const PhysicalDeviceInlineUniformBlockFeaturesEXT = PhysicalDeviceInlineUniformBlockFeatures;
pub const PhysicalDeviceInlineUniformBlockProperties = extern struct {
    s_type: StructureType = .physical_device_inline_uniform_block_properties,
    p_next: ?*anyopaque = null,
    max_inline_uniform_block_size: u32 = 0,
    max_per_stage_descriptor_inline_uniform_blocks: u32 = 0,
    max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32 = 0,
    max_descriptor_set_inline_uniform_blocks: u32 = 0,
    max_descriptor_set_update_after_bind_inline_uniform_blocks: u32 = 0,
};
pub const PhysicalDeviceInlineUniformBlockPropertiesEXT = PhysicalDeviceInlineUniformBlockProperties;
pub const WriteDescriptorSetInlineUniformBlock = extern struct {
    s_type: StructureType = .write_descriptor_set_inline_uniform_block,
    p_next: ?*const anyopaque = null,
    data_size: u32 = 0,
    p_data: ?*const anyopaque = null,
};
pub const WriteDescriptorSetInlineUniformBlockEXT = WriteDescriptorSetInlineUniformBlock;
pub const DescriptorPoolInlineUniformBlockCreateInfo = extern struct {
    s_type: StructureType = .descriptor_pool_inline_uniform_block_create_info,
    p_next: ?*const anyopaque = null,
    max_inline_uniform_block_bindings: u32 = 0,
};
pub const DescriptorPoolInlineUniformBlockCreateInfoEXT = DescriptorPoolInlineUniformBlockCreateInfo;
pub const PipelineCoverageModulationStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_coverage_modulation_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    flags: PipelineCoverageModulationStateCreateFlagsNV = .none,
    coverage_modulation_mode: CoverageModulationModeNV = @enumFromInt(0),
    coverage_modulation_table_enable: Bool32 = .false,
    coverage_modulation_table_count: u32 = 0,
    p_coverage_modulation_table: ?[*]const f32 = null,
};
pub const ImageFormatListCreateInfo = extern struct {
    s_type: StructureType = .image_format_list_create_info,
    p_next: ?*const anyopaque = null,
    view_format_count: u32 = 0,
    p_view_formats: ?[*]const Format = null,
};
pub const ImageFormatListCreateInfoKHR = ImageFormatListCreateInfo;
pub const ValidationCacheCreateInfoEXT = extern struct {
    s_type: StructureType = .validation_cache_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: ValidationCacheCreateFlagsEXT = .none,
    initial_data_size: usize = 0,
    p_initial_data: ?*const anyopaque = null,
};
pub const ShaderModuleValidationCacheCreateInfoEXT = extern struct {
    s_type: StructureType = .shader_module_validation_cache_create_info_ext,
    p_next: ?*const anyopaque = null,
    validation_cache: ValidationCacheEXT = .null_handle,
};
pub const PhysicalDeviceMaintenance3Properties = extern struct {
    s_type: StructureType = .physical_device_maintenance_3_properties,
    p_next: ?*anyopaque = null,
    max_per_set_descriptors: u32 = 0,
    max_memory_allocation_size: DeviceSize = 0,
};
pub const PhysicalDeviceMaintenance3PropertiesKHR = PhysicalDeviceMaintenance3Properties;
pub const PhysicalDeviceMaintenance4Features = extern struct {
    s_type: StructureType = .physical_device_maintenance_4_features,
    p_next: ?*anyopaque = null,
    maintenance4: Bool32 = .false,
};
pub const PhysicalDeviceMaintenance4FeaturesKHR = PhysicalDeviceMaintenance4Features;
pub const PhysicalDeviceMaintenance4Properties = extern struct {
    s_type: StructureType = .physical_device_maintenance_4_properties,
    p_next: ?*anyopaque = null,
    max_buffer_size: DeviceSize = 0,
};
pub const PhysicalDeviceMaintenance4PropertiesKHR = PhysicalDeviceMaintenance4Properties;
pub const PhysicalDeviceMaintenance5Features = extern struct {
    s_type: StructureType = .physical_device_maintenance_5_features,
    p_next: ?*anyopaque = null,
    maintenance5: Bool32 = .false,
};
pub const PhysicalDeviceMaintenance5FeaturesKHR = PhysicalDeviceMaintenance5Features;
pub const PhysicalDeviceMaintenance5Properties = extern struct {
    s_type: StructureType = .physical_device_maintenance_5_properties,
    p_next: ?*anyopaque = null,
    early_fragment_multisample_coverage_after_sample_counting: Bool32 = .false,
    early_fragment_sample_mask_test_before_sample_counting: Bool32 = .false,
    depth_stencil_swizzle_one_support: Bool32 = .false,
    polygon_mode_point_size: Bool32 = .false,
    non_strict_single_pixel_wide_lines_use_parallelogram: Bool32 = .false,
    non_strict_wide_lines_use_parallelogram: Bool32 = .false,
};
pub const PhysicalDeviceMaintenance5PropertiesKHR = PhysicalDeviceMaintenance5Properties;
pub const PhysicalDeviceMaintenance6Features = extern struct {
    s_type: StructureType = .physical_device_maintenance_6_features,
    p_next: ?*anyopaque = null,
    maintenance6: Bool32 = .false,
};
pub const PhysicalDeviceMaintenance6FeaturesKHR = PhysicalDeviceMaintenance6Features;
pub const PhysicalDeviceMaintenance6Properties = extern struct {
    s_type: StructureType = .physical_device_maintenance_6_properties,
    p_next: ?*anyopaque = null,
    block_texel_view_compatible_multiple_layers: Bool32 = .false,
    max_combined_image_sampler_descriptor_count: u32 = 0,
    fragment_shading_rate_clamp_combiner_inputs: Bool32 = .false,
};
pub const PhysicalDeviceMaintenance6PropertiesKHR = PhysicalDeviceMaintenance6Properties;
pub const PhysicalDeviceMaintenance7FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_maintenance_7_features_khr,
    p_next: ?*anyopaque = null,
    maintenance7: Bool32 = .false,
};
pub const PhysicalDeviceMaintenance7PropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_maintenance_7_properties_khr,
    p_next: ?*anyopaque = null,
    robust_fragment_shading_rate_attachment_access: Bool32 = .false,
    separate_depth_stencil_attachment_access: Bool32 = .false,
    max_descriptor_set_total_uniform_buffers_dynamic: u32 = 0,
    max_descriptor_set_total_storage_buffers_dynamic: u32 = 0,
    max_descriptor_set_total_buffers_dynamic: u32 = 0,
    max_descriptor_set_update_after_bind_total_uniform_buffers_dynamic: u32 = 0,
    max_descriptor_set_update_after_bind_total_storage_buffers_dynamic: u32 = 0,
    max_descriptor_set_update_after_bind_total_buffers_dynamic: u32 = 0,
};
pub const PhysicalDeviceLayeredApiPropertiesListKHR = extern struct {
    s_type: StructureType = .physical_device_layered_api_properties_list_khr,
    p_next: ?*anyopaque = null,
    layered_api_count: u32 = 0,
    p_layered_apis: ?[*]PhysicalDeviceLayeredApiPropertiesKHR = null,
};
pub const PhysicalDeviceLayeredApiPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_layered_api_properties_khr,
    p_next: ?*anyopaque = null,
    vendor_id: u32 = 0,
    device_id: u32 = 0,
    layered_api: PhysicalDeviceLayeredApiKHR = @enumFromInt(0),
    device_name: [max_physical_device_name_size]u8 = [_]u8{0} ** max_physical_device_name_size,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PhysicalDeviceLayeredApiVulkanPropertiesKHR,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PhysicalDeviceLayeredApiVulkanPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_layered_api_vulkan_properties_khr,
    p_next: ?*anyopaque = null,
    properties: PhysicalDeviceProperties2 = .{},
};
pub const PhysicalDeviceMaintenance8FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_maintenance_8_features_khr,
    p_next: ?*anyopaque = null,
    maintenance8: Bool32 = .false,
};
pub const PhysicalDeviceMaintenance9FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_maintenance_9_features_khr,
    p_next: ?*anyopaque = null,
    maintenance9: Bool32 = .false,
};
pub const PhysicalDeviceMaintenance9PropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_maintenance_9_properties_khr,
    p_next: ?*anyopaque = null,
    image_2d_view_of_3d_sparse: Bool32 = .false,
    default_vertex_attribute_value: DefaultVertexAttributeValueKHR = @enumFromInt(0),
};
pub const QueueFamilyOwnershipTransferPropertiesKHR = extern struct {
    s_type: StructureType = .queue_family_ownership_transfer_properties_khr,
    p_next: ?*anyopaque = null,
    optimal_image_transfer_to_queue_families: u32 = 0,
};
pub const RenderingAreaInfo = extern struct {
    s_type: StructureType = .rendering_area_info,
    p_next: ?*const anyopaque = null,
    view_mask: u32 = 0,
    color_attachment_count: u32 = 0,
    p_color_attachment_formats: ?[*]const Format = null,
    depth_attachment_format: Format = @enumFromInt(0),
    stencil_attachment_format: Format = @enumFromInt(0),
};
pub const RenderingAreaInfoKHR = RenderingAreaInfo;
pub const DescriptorSetLayoutSupport = extern struct {
    s_type: StructureType = .descriptor_set_layout_support,
    p_next: ?*anyopaque = null,
    supported: Bool32 = .false,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DescriptorSetVariableDescriptorCountLayoutSupport,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DescriptorSetLayoutSupportKHR = DescriptorSetLayoutSupport;
pub const PhysicalDeviceShaderDrawParametersFeatures = extern struct {
    s_type: StructureType = .physical_device_shader_draw_parameters_features,
    p_next: ?*anyopaque = null,
    shader_draw_parameters: Bool32 = .false,
};
pub const PhysicalDeviceShaderDrawParameterFeatures = PhysicalDeviceShaderDrawParametersFeatures;
pub const PhysicalDeviceShaderFloat16Int8Features = extern struct {
    s_type: StructureType = .physical_device_shader_float16_int8_features,
    p_next: ?*anyopaque = null,
    shader_float16: Bool32 = .false,
    shader_int8: Bool32 = .false,
};
pub const PhysicalDeviceShaderFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;
pub const PhysicalDeviceFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;
pub const PhysicalDeviceFloatControlsProperties = extern struct {
    s_type: StructureType = .physical_device_float_controls_properties,
    p_next: ?*anyopaque = null,
    denorm_behavior_independence: ShaderFloatControlsIndependence = @enumFromInt(0),
    rounding_mode_independence: ShaderFloatControlsIndependence = @enumFromInt(0),
    shader_signed_zero_inf_nan_preserve_float16: Bool32 = .false,
    shader_signed_zero_inf_nan_preserve_float32: Bool32 = .false,
    shader_signed_zero_inf_nan_preserve_float64: Bool32 = .false,
    shader_denorm_preserve_float16: Bool32 = .false,
    shader_denorm_preserve_float32: Bool32 = .false,
    shader_denorm_preserve_float64: Bool32 = .false,
    shader_denorm_flush_to_zero_float16: Bool32 = .false,
    shader_denorm_flush_to_zero_float32: Bool32 = .false,
    shader_denorm_flush_to_zero_float64: Bool32 = .false,
    shader_rounding_mode_rte_float16: Bool32 = .false,
    shader_rounding_mode_rte_float32: Bool32 = .false,
    shader_rounding_mode_rte_float64: Bool32 = .false,
    shader_rounding_mode_rtz_float16: Bool32 = .false,
    shader_rounding_mode_rtz_float32: Bool32 = .false,
    shader_rounding_mode_rtz_float64: Bool32 = .false,
};
pub const PhysicalDeviceFloatControlsPropertiesKHR = PhysicalDeviceFloatControlsProperties;
pub const PhysicalDeviceHostQueryResetFeatures = extern struct {
    s_type: StructureType = .physical_device_host_query_reset_features,
    p_next: ?*anyopaque = null,
    host_query_reset: Bool32 = .false,
};
pub const PhysicalDeviceHostQueryResetFeaturesEXT = PhysicalDeviceHostQueryResetFeatures;
pub const ShaderResourceUsageAMD = extern struct {
    num_used_vgprs: u32 = 0,
    num_used_sgprs: u32 = 0,
    lds_size_per_local_work_group: u32 = 0,
    lds_usage_size_in_bytes: usize = 0,
    scratch_mem_usage_in_bytes: usize = 0,
};
pub const ShaderStatisticsInfoAMD = extern struct {
    shader_stage_mask: ShaderStageFlags = .none,
    resource_usage: ShaderResourceUsageAMD = .{},
    num_physical_vgprs: u32 = 0,
    num_physical_sgprs: u32 = 0,
    num_available_vgprs: u32 = 0,
    num_available_sgprs: u32 = 0,
    compute_work_group_size: [3]u32 = [_]u32{0} ** 3,
};
pub const DeviceQueueGlobalPriorityCreateInfo = extern struct {
    s_type: StructureType = .device_queue_global_priority_create_info,
    p_next: ?*const anyopaque = null,
    global_priority: QueueGlobalPriority = @enumFromInt(0),
};
pub const DeviceQueueGlobalPriorityCreateInfoKHR = DeviceQueueGlobalPriorityCreateInfo;
pub const DeviceQueueGlobalPriorityCreateInfoEXT = DeviceQueueGlobalPriorityCreateInfo;
pub const PhysicalDeviceGlobalPriorityQueryFeatures = extern struct {
    s_type: StructureType = .physical_device_global_priority_query_features,
    p_next: ?*anyopaque = null,
    global_priority_query: Bool32 = .false,
};
pub const PhysicalDeviceGlobalPriorityQueryFeaturesKHR = PhysicalDeviceGlobalPriorityQueryFeatures;
pub const PhysicalDeviceGlobalPriorityQueryFeaturesEXT = PhysicalDeviceGlobalPriorityQueryFeatures;
pub const QueueFamilyGlobalPriorityProperties = extern struct {
    s_type: StructureType = .queue_family_global_priority_properties,
    p_next: ?*anyopaque = null,
    priority_count: u32 = 0,
    priorities: [max_global_priority_size]QueueGlobalPriority = [_]QueueGlobalPriority{@enumFromInt(0)} ** max_global_priority_size,
};
pub const QueueFamilyGlobalPriorityPropertiesKHR = QueueFamilyGlobalPriorityProperties;
pub const QueueFamilyGlobalPriorityPropertiesEXT = QueueFamilyGlobalPriorityProperties;
pub const DebugUtilsObjectNameInfoEXT = extern struct {
    s_type: StructureType = .debug_utils_object_name_info_ext,
    p_next: ?*const anyopaque = null,
    object_type: ObjectType = @enumFromInt(0),
    object_handle: u64 = 0,
    p_object_name: ?[*:0]const u8 = null,
};
pub const DebugUtilsObjectTagInfoEXT = extern struct {
    s_type: StructureType = .debug_utils_object_tag_info_ext,
    p_next: ?*const anyopaque = null,
    object_type: ObjectType = @enumFromInt(0),
    object_handle: u64 = 0,
    tag_name: u64 = 0,
    tag_size: usize = 0,
    p_tag: ?*const anyopaque = null,
};
pub const DebugUtilsLabelEXT = extern struct {
    s_type: StructureType = .debug_utils_label_ext,
    p_next: ?*const anyopaque = null,
    p_label_name: ?[*:0]const u8 = null,
    color: [4]f32 = [_]f32{0} ** 4,
};
pub const DebugUtilsMessengerCreateInfoEXT = extern struct {
    s_type: StructureType = .debug_utils_messenger_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: DebugUtilsMessengerCreateFlagsEXT = .none,
    message_severity: DebugUtilsMessageSeverityFlagsEXT = .none,
    message_type: DebugUtilsMessageTypeFlagsEXT = .none,
    pfn_user_callback: ?FpDebugUtilsMessengerCallbackEXT = null,
    p_user_data: ?*anyopaque = null,
};
pub const DebugUtilsMessengerCallbackDataEXT = extern struct {
    s_type: StructureType = .debug_utils_messenger_callback_data_ext,
    p_next: ?*const anyopaque = null,
    flags: DebugUtilsMessengerCallbackDataFlagsEXT = .none,
    p_message_id_name: ?[*:0]const u8 = null,
    message_id_number: i32 = 0,
    p_message: ?[*:0]const u8 = null,
    queue_label_count: u32 = 0,
    p_queue_labels: ?[*]const DebugUtilsLabelEXT = null,
    cmd_buf_label_count: u32 = 0,
    p_cmd_buf_labels: ?[*]const DebugUtilsLabelEXT = null,
    object_count: u32 = 0,
    p_objects: ?[*]const DebugUtilsObjectNameInfoEXT = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DeviceAddressBindingCallbackDataEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PhysicalDeviceDeviceMemoryReportFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_device_memory_report_features_ext,
    p_next: ?*anyopaque = null,
    device_memory_report: Bool32 = .false,
};
pub const DeviceDeviceMemoryReportCreateInfoEXT = extern struct {
    s_type: StructureType = .device_device_memory_report_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: DeviceMemoryReportFlagsEXT = .none,
    pfn_user_callback: ?FpDeviceMemoryReportCallbackEXT = null,
    p_user_data: ?*anyopaque = null,
};
pub const DeviceMemoryReportCallbackDataEXT = extern struct {
    s_type: StructureType = .device_memory_report_callback_data_ext,
    p_next: ?*anyopaque = null,
    flags: DeviceMemoryReportFlagsEXT = .none,
    type: DeviceMemoryReportEventTypeEXT = @enumFromInt(0),
    memory_object_id: u64 = 0,
    size: DeviceSize = 0,
    object_type: ObjectType = @enumFromInt(0),
    object_handle: u64 = 0,
    heap_index: u32 = 0,
};
pub const ImportMemoryHostPointerInfoEXT = extern struct {
    s_type: StructureType = .import_memory_host_pointer_info_ext,
    p_next: ?*const anyopaque = null,
    handle_type: ExternalMemoryHandleTypeFlags = .none,
    p_host_pointer: ?*anyopaque = null,
};
pub const MemoryHostPointerPropertiesEXT = extern struct {
    s_type: StructureType = .memory_host_pointer_properties_ext,
    p_next: ?*anyopaque = null,
    memory_type_bits: u32 = 0,
};
pub const PhysicalDeviceExternalMemoryHostPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_external_memory_host_properties_ext,
    p_next: ?*anyopaque = null,
    min_imported_host_pointer_alignment: DeviceSize = 0,
};
pub const PhysicalDeviceConservativeRasterizationPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_conservative_rasterization_properties_ext,
    p_next: ?*anyopaque = null,
    primitive_overestimation_size: f32 = 0,
    max_extra_primitive_overestimation_size: f32 = 0,
    extra_primitive_overestimation_size_granularity: f32 = 0,
    primitive_underestimation: Bool32 = .false,
    conservative_point_and_line_rasterization: Bool32 = .false,
    degenerate_triangles_rasterized: Bool32 = .false,
    degenerate_lines_rasterized: Bool32 = .false,
    fully_covered_fragment_shader_input_variable: Bool32 = .false,
    conservative_rasterization_post_depth_coverage: Bool32 = .false,
};
pub const CalibratedTimestampInfoKHR = extern struct {
    s_type: StructureType = .calibrated_timestamp_info_khr,
    p_next: ?*const anyopaque = null,
    time_domain: TimeDomainKHR = @enumFromInt(0),
};
pub const CalibratedTimestampInfoEXT = CalibratedTimestampInfoKHR;
pub const PhysicalDeviceShaderCorePropertiesAMD = extern struct {
    s_type: StructureType = .physical_device_shader_core_properties_amd,
    p_next: ?*anyopaque = null,
    shader_engine_count: u32 = 0,
    shader_arrays_per_engine_count: u32 = 0,
    compute_units_per_shader_array: u32 = 0,
    simd_per_compute_unit: u32 = 0,
    wavefronts_per_simd: u32 = 0,
    wavefront_size: u32 = 0,
    sgprs_per_simd: u32 = 0,
    min_sgpr_allocation: u32 = 0,
    max_sgpr_allocation: u32 = 0,
    sgpr_allocation_granularity: u32 = 0,
    vgprs_per_simd: u32 = 0,
    min_vgpr_allocation: u32 = 0,
    max_vgpr_allocation: u32 = 0,
    vgpr_allocation_granularity: u32 = 0,
};
pub const PhysicalDeviceShaderCoreProperties2AMD = extern struct {
    s_type: StructureType = .physical_device_shader_core_properties_2_amd,
    p_next: ?*anyopaque = null,
    shader_core_features: ShaderCorePropertiesFlagsAMD = .none,
    active_compute_unit_count: u32 = 0,
};
pub const PipelineRasterizationConservativeStateCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_rasterization_conservative_state_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: PipelineRasterizationConservativeStateCreateFlagsEXT = .none,
    conservative_rasterization_mode: ConservativeRasterizationModeEXT = @enumFromInt(0),
    extra_primitive_overestimation_size: f32 = 0,
};
pub const PhysicalDeviceDescriptorIndexingFeatures = extern struct {
    s_type: StructureType = .physical_device_descriptor_indexing_features,
    p_next: ?*anyopaque = null,
    shader_input_attachment_array_dynamic_indexing: Bool32 = .false,
    shader_uniform_texel_buffer_array_dynamic_indexing: Bool32 = .false,
    shader_storage_texel_buffer_array_dynamic_indexing: Bool32 = .false,
    shader_uniform_buffer_array_non_uniform_indexing: Bool32 = .false,
    shader_sampled_image_array_non_uniform_indexing: Bool32 = .false,
    shader_storage_buffer_array_non_uniform_indexing: Bool32 = .false,
    shader_storage_image_array_non_uniform_indexing: Bool32 = .false,
    shader_input_attachment_array_non_uniform_indexing: Bool32 = .false,
    shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32 = .false,
    shader_storage_texel_buffer_array_non_uniform_indexing: Bool32 = .false,
    descriptor_binding_uniform_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_sampled_image_update_after_bind: Bool32 = .false,
    descriptor_binding_storage_image_update_after_bind: Bool32 = .false,
    descriptor_binding_storage_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_storage_texel_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_update_unused_while_pending: Bool32 = .false,
    descriptor_binding_partially_bound: Bool32 = .false,
    descriptor_binding_variable_descriptor_count: Bool32 = .false,
    runtime_descriptor_array: Bool32 = .false,
};
pub const PhysicalDeviceDescriptorIndexingFeaturesEXT = PhysicalDeviceDescriptorIndexingFeatures;
pub const PhysicalDeviceDescriptorIndexingProperties = extern struct {
    s_type: StructureType = .physical_device_descriptor_indexing_properties,
    p_next: ?*anyopaque = null,
    max_update_after_bind_descriptors_in_all_pools: u32 = 0,
    shader_uniform_buffer_array_non_uniform_indexing_native: Bool32 = .false,
    shader_sampled_image_array_non_uniform_indexing_native: Bool32 = .false,
    shader_storage_buffer_array_non_uniform_indexing_native: Bool32 = .false,
    shader_storage_image_array_non_uniform_indexing_native: Bool32 = .false,
    shader_input_attachment_array_non_uniform_indexing_native: Bool32 = .false,
    robust_buffer_access_update_after_bind: Bool32 = .false,
    quad_divergent_implicit_lod: Bool32 = .false,
    max_per_stage_descriptor_update_after_bind_samplers: u32 = 0,
    max_per_stage_descriptor_update_after_bind_uniform_buffers: u32 = 0,
    max_per_stage_descriptor_update_after_bind_storage_buffers: u32 = 0,
    max_per_stage_descriptor_update_after_bind_sampled_images: u32 = 0,
    max_per_stage_descriptor_update_after_bind_storage_images: u32 = 0,
    max_per_stage_descriptor_update_after_bind_input_attachments: u32 = 0,
    max_per_stage_update_after_bind_resources: u32 = 0,
    max_descriptor_set_update_after_bind_samplers: u32 = 0,
    max_descriptor_set_update_after_bind_uniform_buffers: u32 = 0,
    max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32 = 0,
    max_descriptor_set_update_after_bind_storage_buffers: u32 = 0,
    max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32 = 0,
    max_descriptor_set_update_after_bind_sampled_images: u32 = 0,
    max_descriptor_set_update_after_bind_storage_images: u32 = 0,
    max_descriptor_set_update_after_bind_input_attachments: u32 = 0,
};
pub const PhysicalDeviceDescriptorIndexingPropertiesEXT = PhysicalDeviceDescriptorIndexingProperties;
pub const DescriptorSetLayoutBindingFlagsCreateInfo = extern struct {
    s_type: StructureType = .descriptor_set_layout_binding_flags_create_info,
    p_next: ?*const anyopaque = null,
    binding_count: u32 = 0,
    p_binding_flags: ?[*]const DescriptorBindingFlags = null,
};
pub const DescriptorSetLayoutBindingFlagsCreateInfoEXT = DescriptorSetLayoutBindingFlagsCreateInfo;
pub const DescriptorSetVariableDescriptorCountAllocateInfo = extern struct {
    s_type: StructureType = .descriptor_set_variable_descriptor_count_allocate_info,
    p_next: ?*const anyopaque = null,
    descriptor_set_count: u32 = 0,
    p_descriptor_counts: ?[*]const u32 = null,
};
pub const DescriptorSetVariableDescriptorCountAllocateInfoEXT = DescriptorSetVariableDescriptorCountAllocateInfo;
pub const DescriptorSetVariableDescriptorCountLayoutSupport = extern struct {
    s_type: StructureType = .descriptor_set_variable_descriptor_count_layout_support,
    p_next: ?*anyopaque = null,
    max_variable_descriptor_count: u32 = 0,
};
pub const DescriptorSetVariableDescriptorCountLayoutSupportEXT = DescriptorSetVariableDescriptorCountLayoutSupport;
pub const AttachmentDescription2 = extern struct {
    s_type: StructureType = .attachment_description_2,
    p_next: ?*const anyopaque = null,
    flags: AttachmentDescriptionFlags = .none,
    format: Format = @enumFromInt(0),
    samples: SampleCountFlags = .none,
    load_op: AttachmentLoadOp = @enumFromInt(0),
    store_op: AttachmentStoreOp = @enumFromInt(0),
    stencil_load_op: AttachmentLoadOp = @enumFromInt(0),
    stencil_store_op: AttachmentStoreOp = @enumFromInt(0),
    initial_layout: ImageLayout = @enumFromInt(0),
    final_layout: ImageLayout = @enumFromInt(0),
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ExternalFormatANDROID,
            *AttachmentDescriptionStencilLayout,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const AttachmentDescription2KHR = AttachmentDescription2;
pub const AttachmentReference2 = extern struct {
    s_type: StructureType = .attachment_reference_2,
    p_next: ?*const anyopaque = null,
    attachment: u32 = 0,
    layout: ImageLayout = @enumFromInt(0),
    aspect_mask: ImageAspectFlags = .none,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *AttachmentReferenceStencilLayout,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const AttachmentReference2KHR = AttachmentReference2;
pub const SubpassDescription2 = extern struct {
    s_type: StructureType = .subpass_description_2,
    p_next: ?*const anyopaque = null,
    flags: SubpassDescriptionFlags = .none,
    pipeline_bind_point: PipelineBindPoint = @enumFromInt(0),
    view_mask: u32 = 0,
    input_attachment_count: u32 = 0,
    p_input_attachments: ?[*]const AttachmentReference2 = null,
    color_attachment_count: u32 = 0,
    p_color_attachments: ?[*]const AttachmentReference2 = null,
    p_resolve_attachments: ?[*]const AttachmentReference2 = null,
    p_depth_stencil_attachment: ?*const AttachmentReference2 = null,
    preserve_attachment_count: u32 = 0,
    p_preserve_attachments: ?[*]const u32 = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *SubpassDescriptionDepthStencilResolve,
            *FragmentShadingRateAttachmentInfoKHR,
            *MultisampledRenderToSingleSampledInfoEXT,
            *RenderPassCreationControlEXT,
            *RenderPassSubpassFeedbackCreateInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const SubpassDescription2KHR = SubpassDescription2;
pub const SubpassDependency2 = extern struct {
    s_type: StructureType = .subpass_dependency_2,
    p_next: ?*const anyopaque = null,
    src_subpass: u32 = 0,
    dst_subpass: u32 = 0,
    src_stage_mask: PipelineStageFlags = .none,
    dst_stage_mask: PipelineStageFlags = .none,
    src_access_mask: AccessFlags = .none,
    dst_access_mask: AccessFlags = .none,
    dependency_flags: DependencyFlags = .none,
    view_offset: i32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *MemoryBarrier2,
            *MemoryBarrierAccessFlags3KHR,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const SubpassDependency2KHR = SubpassDependency2;
pub const RenderPassCreateInfo2 = extern struct {
    s_type: StructureType = .render_pass_create_info_2,
    p_next: ?*const anyopaque = null,
    flags: RenderPassCreateFlags = .none,
    attachment_count: u32 = 0,
    p_attachments: ?[*]const AttachmentDescription2 = null,
    subpass_count: u32 = 0,
    p_subpasses: ?[*]const SubpassDescription2 = null,
    dependency_count: u32 = 0,
    p_dependencies: ?[*]const SubpassDependency2 = null,
    correlated_view_mask_count: u32 = 0,
    p_correlated_view_masks: ?[*]const u32 = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *RenderPassFragmentDensityMapCreateInfoEXT,
            *RenderPassCreationControlEXT,
            *RenderPassCreationFeedbackCreateInfoEXT,
            *TileMemorySizeInfoQCOM,
            *RenderPassTileShadingCreateInfoQCOM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const RenderPassCreateInfo2KHR = RenderPassCreateInfo2;
pub const SubpassBeginInfo = extern struct {
    s_type: StructureType = .subpass_begin_info,
    p_next: ?*const anyopaque = null,
    contents: SubpassContents = @enumFromInt(0),
};
pub const SubpassBeginInfoKHR = SubpassBeginInfo;
pub const SubpassEndInfo = extern struct {
    s_type: StructureType = .subpass_end_info,
    p_next: ?*const anyopaque = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *RenderPassFragmentDensityMapOffsetEndInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const SubpassEndInfoKHR = SubpassEndInfo;
pub const PhysicalDeviceTimelineSemaphoreFeatures = extern struct {
    s_type: StructureType = .physical_device_timeline_semaphore_features,
    p_next: ?*anyopaque = null,
    timeline_semaphore: Bool32 = .false,
};
pub const PhysicalDeviceTimelineSemaphoreFeaturesKHR = PhysicalDeviceTimelineSemaphoreFeatures;
pub const PhysicalDeviceTimelineSemaphoreProperties = extern struct {
    s_type: StructureType = .physical_device_timeline_semaphore_properties,
    p_next: ?*anyopaque = null,
    max_timeline_semaphore_value_difference: u64 = 0,
};
pub const PhysicalDeviceTimelineSemaphorePropertiesKHR = PhysicalDeviceTimelineSemaphoreProperties;
pub const SemaphoreTypeCreateInfo = extern struct {
    s_type: StructureType = .semaphore_type_create_info,
    p_next: ?*const anyopaque = null,
    semaphore_type: SemaphoreType = @enumFromInt(0),
    initial_value: u64 = 0,
};
pub const SemaphoreTypeCreateInfoKHR = SemaphoreTypeCreateInfo;
pub const TimelineSemaphoreSubmitInfo = extern struct {
    s_type: StructureType = .timeline_semaphore_submit_info,
    p_next: ?*const anyopaque = null,
    wait_semaphore_value_count: u32 = 0,
    p_wait_semaphore_values: ?[*]const u64 = null,
    signal_semaphore_value_count: u32 = 0,
    p_signal_semaphore_values: ?[*]const u64 = null,
};
pub const TimelineSemaphoreSubmitInfoKHR = TimelineSemaphoreSubmitInfo;
pub const SemaphoreWaitInfo = extern struct {
    s_type: StructureType = .semaphore_wait_info,
    p_next: ?*const anyopaque = null,
    flags: SemaphoreWaitFlags = .none,
    semaphore_count: u32 = 0,
    p_semaphores: ?[*]const Semaphore = null,
    p_values: ?[*]const u64 = null,
};
pub const SemaphoreWaitInfoKHR = SemaphoreWaitInfo;
pub const SemaphoreSignalInfo = extern struct {
    s_type: StructureType = .semaphore_signal_info,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore = .null_handle,
    value: u64 = 0,
};
pub const SemaphoreSignalInfoKHR = SemaphoreSignalInfo;
pub const VertexInputBindingDivisorDescription = extern struct {
    binding: u32 = 0,
    divisor: u32 = 0,
};
pub const VertexInputBindingDivisorDescriptionKHR = VertexInputBindingDivisorDescription;
pub const VertexInputBindingDivisorDescriptionEXT = VertexInputBindingDivisorDescription;
pub const PipelineVertexInputDivisorStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_vertex_input_divisor_state_create_info,
    p_next: ?*const anyopaque = null,
    vertex_binding_divisor_count: u32 = 0,
    p_vertex_binding_divisors: ?[*]const VertexInputBindingDivisorDescription = null,
};
pub const PipelineVertexInputDivisorStateCreateInfoKHR = PipelineVertexInputDivisorStateCreateInfo;
pub const PipelineVertexInputDivisorStateCreateInfoEXT = PipelineVertexInputDivisorStateCreateInfo;
pub const PhysicalDeviceVertexAttributeDivisorPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_vertex_attribute_divisor_properties_ext,
    p_next: ?*anyopaque = null,
    max_vertex_attrib_divisor: u32 = 0,
};
pub const PhysicalDeviceVertexAttributeDivisorProperties = extern struct {
    s_type: StructureType = .physical_device_vertex_attribute_divisor_properties,
    p_next: ?*anyopaque = null,
    max_vertex_attrib_divisor: u32 = 0,
    supports_non_zero_first_instance: Bool32 = .false,
};
pub const PhysicalDeviceVertexAttributeDivisorPropertiesKHR = PhysicalDeviceVertexAttributeDivisorProperties;
pub const PhysicalDevicePCIBusInfoPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_pci_bus_info_properties_ext,
    p_next: ?*anyopaque = null,
    pci_domain: u32 = 0,
    pci_bus: u32 = 0,
    pci_device: u32 = 0,
    pci_function: u32 = 0,
};
pub const ImportAndroidHardwareBufferInfoANDROID = extern struct {
    s_type: StructureType = .import_android_hardware_buffer_info_android,
    p_next: ?*const anyopaque = null,
    buffer: ?*AHardwareBuffer = null,
};
pub const AndroidHardwareBufferUsageANDROID = extern struct {
    s_type: StructureType = .android_hardware_buffer_usage_android,
    p_next: ?*anyopaque = null,
    android_hardware_buffer_usage: u64 = 0,
};
pub const AndroidHardwareBufferPropertiesANDROID = extern struct {
    s_type: StructureType = .android_hardware_buffer_properties_android,
    p_next: ?*anyopaque = null,
    allocation_size: DeviceSize = 0,
    memory_type_bits: u32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *AndroidHardwareBufferFormatPropertiesANDROID,
            *AndroidHardwareBufferFormatProperties2ANDROID,
            *AndroidHardwareBufferFormatResolvePropertiesANDROID,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const MemoryGetAndroidHardwareBufferInfoANDROID = extern struct {
    s_type: StructureType = .memory_get_android_hardware_buffer_info_android,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory = .null_handle,
};
pub const AndroidHardwareBufferFormatPropertiesANDROID = extern struct {
    s_type: StructureType = .android_hardware_buffer_format_properties_android,
    p_next: ?*anyopaque = null,
    format: Format = @enumFromInt(0),
    external_format: u64 = 0,
    format_features: FormatFeatureFlags = .none,
    sampler_ycbcr_conversion_components: ComponentMapping = .{},
    suggested_ycbcr_model: SamplerYcbcrModelConversion = @enumFromInt(0),
    suggested_ycbcr_range: SamplerYcbcrRange = @enumFromInt(0),
    suggested_x_chroma_offset: ChromaLocation = @enumFromInt(0),
    suggested_y_chroma_offset: ChromaLocation = @enumFromInt(0),
};
pub const CommandBufferInheritanceConditionalRenderingInfoEXT = extern struct {
    s_type: StructureType = .command_buffer_inheritance_conditional_rendering_info_ext,
    p_next: ?*const anyopaque = null,
    conditional_rendering_enable: Bool32 = .false,
};
pub const ExternalFormatANDROID = extern struct {
    s_type: StructureType = .external_format_android,
    p_next: ?*anyopaque = null,
    external_format: u64 = 0,
};
pub const PhysicalDevice8BitStorageFeatures = extern struct {
    s_type: StructureType = .physical_device_8bit_storage_features,
    p_next: ?*anyopaque = null,
    storage_buffer8_bit_access: Bool32 = .false,
    uniform_and_storage_buffer8_bit_access: Bool32 = .false,
    storage_push_constant8: Bool32 = .false,
};
pub const PhysicalDevice8BitStorageFeaturesKHR = PhysicalDevice8BitStorageFeatures;
pub const PhysicalDeviceConditionalRenderingFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_conditional_rendering_features_ext,
    p_next: ?*anyopaque = null,
    conditional_rendering: Bool32 = .false,
    inherited_conditional_rendering: Bool32 = .false,
};
pub const PhysicalDeviceVulkanMemoryModelFeatures = extern struct {
    s_type: StructureType = .physical_device_vulkan_memory_model_features,
    p_next: ?*anyopaque = null,
    vulkan_memory_model: Bool32 = .false,
    vulkan_memory_model_device_scope: Bool32 = .false,
    vulkan_memory_model_availability_visibility_chains: Bool32 = .false,
};
pub const PhysicalDeviceVulkanMemoryModelFeaturesKHR = PhysicalDeviceVulkanMemoryModelFeatures;
pub const PhysicalDeviceShaderAtomicInt64Features = extern struct {
    s_type: StructureType = .physical_device_shader_atomic_int64_features,
    p_next: ?*anyopaque = null,
    shader_buffer_int64_atomics: Bool32 = .false,
    shader_shared_int64_atomics: Bool32 = .false,
};
pub const PhysicalDeviceShaderAtomicInt64FeaturesKHR = PhysicalDeviceShaderAtomicInt64Features;
pub const PhysicalDeviceShaderAtomicFloatFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_atomic_float_features_ext,
    p_next: ?*anyopaque = null,
    shader_buffer_float32_atomics: Bool32 = .false,
    shader_buffer_float32_atomic_add: Bool32 = .false,
    shader_buffer_float64_atomics: Bool32 = .false,
    shader_buffer_float64_atomic_add: Bool32 = .false,
    shader_shared_float32_atomics: Bool32 = .false,
    shader_shared_float32_atomic_add: Bool32 = .false,
    shader_shared_float64_atomics: Bool32 = .false,
    shader_shared_float64_atomic_add: Bool32 = .false,
    shader_image_float32_atomics: Bool32 = .false,
    shader_image_float32_atomic_add: Bool32 = .false,
    sparse_image_float32_atomics: Bool32 = .false,
    sparse_image_float32_atomic_add: Bool32 = .false,
};
pub const PhysicalDeviceShaderAtomicFloat2FeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_atomic_float_2_features_ext,
    p_next: ?*anyopaque = null,
    shader_buffer_float16_atomics: Bool32 = .false,
    shader_buffer_float16_atomic_add: Bool32 = .false,
    shader_buffer_float16_atomic_min_max: Bool32 = .false,
    shader_buffer_float32_atomic_min_max: Bool32 = .false,
    shader_buffer_float64_atomic_min_max: Bool32 = .false,
    shader_shared_float16_atomics: Bool32 = .false,
    shader_shared_float16_atomic_add: Bool32 = .false,
    shader_shared_float16_atomic_min_max: Bool32 = .false,
    shader_shared_float32_atomic_min_max: Bool32 = .false,
    shader_shared_float64_atomic_min_max: Bool32 = .false,
    shader_image_float32_atomic_min_max: Bool32 = .false,
    sparse_image_float32_atomic_min_max: Bool32 = .false,
};
pub const PhysicalDeviceVertexAttributeDivisorFeatures = extern struct {
    s_type: StructureType = .physical_device_vertex_attribute_divisor_features,
    p_next: ?*anyopaque = null,
    vertex_attribute_instance_rate_divisor: Bool32 = .false,
    vertex_attribute_instance_rate_zero_divisor: Bool32 = .false,
};
pub const PhysicalDeviceVertexAttributeDivisorFeaturesKHR = PhysicalDeviceVertexAttributeDivisorFeatures;
pub const PhysicalDeviceVertexAttributeDivisorFeaturesEXT = PhysicalDeviceVertexAttributeDivisorFeatures;
pub const QueueFamilyCheckpointPropertiesNV = extern struct {
    s_type: StructureType = .queue_family_checkpoint_properties_nv,
    p_next: ?*anyopaque = null,
    checkpoint_execution_stage_mask: PipelineStageFlags = .none,
};
pub const CheckpointDataNV = extern struct {
    s_type: StructureType = .checkpoint_data_nv,
    p_next: ?*anyopaque = null,
    stage: PipelineStageFlags = .none,
    p_checkpoint_marker: ?*anyopaque = null,
};
pub const PhysicalDeviceDepthStencilResolveProperties = extern struct {
    s_type: StructureType = .physical_device_depth_stencil_resolve_properties,
    p_next: ?*anyopaque = null,
    supported_depth_resolve_modes: ResolveModeFlags = .none,
    supported_stencil_resolve_modes: ResolveModeFlags = .none,
    independent_resolve_none: Bool32 = .false,
    independent_resolve: Bool32 = .false,
};
pub const PhysicalDeviceDepthStencilResolvePropertiesKHR = PhysicalDeviceDepthStencilResolveProperties;
pub const SubpassDescriptionDepthStencilResolve = extern struct {
    s_type: StructureType = .subpass_description_depth_stencil_resolve,
    p_next: ?*const anyopaque = null,
    depth_resolve_mode: ResolveModeFlags = .none,
    stencil_resolve_mode: ResolveModeFlags = .none,
    p_depth_stencil_resolve_attachment: ?*const AttachmentReference2 = null,
};
pub const SubpassDescriptionDepthStencilResolveKHR = SubpassDescriptionDepthStencilResolve;
pub const ImageViewASTCDecodeModeEXT = extern struct {
    s_type: StructureType = .image_view_astc_decode_mode_ext,
    p_next: ?*const anyopaque = null,
    decode_mode: Format = @enumFromInt(0),
};
pub const PhysicalDeviceASTCDecodeFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_astc_decode_features_ext,
    p_next: ?*anyopaque = null,
    decode_mode_shared_exponent: Bool32 = .false,
};
pub const PhysicalDeviceTransformFeedbackFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_transform_feedback_features_ext,
    p_next: ?*anyopaque = null,
    transform_feedback: Bool32 = .false,
    geometry_streams: Bool32 = .false,
};
pub const PhysicalDeviceTransformFeedbackPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_transform_feedback_properties_ext,
    p_next: ?*anyopaque = null,
    max_transform_feedback_streams: u32 = 0,
    max_transform_feedback_buffers: u32 = 0,
    max_transform_feedback_buffer_size: DeviceSize = 0,
    max_transform_feedback_stream_data_size: u32 = 0,
    max_transform_feedback_buffer_data_size: u32 = 0,
    max_transform_feedback_buffer_data_stride: u32 = 0,
    transform_feedback_queries: Bool32 = .false,
    transform_feedback_streams_lines_triangles: Bool32 = .false,
    transform_feedback_rasterization_stream_select: Bool32 = .false,
    transform_feedback_draw: Bool32 = .false,
};
pub const PipelineRasterizationStateStreamCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_rasterization_state_stream_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: PipelineRasterizationStateStreamCreateFlagsEXT = .none,
    rasterization_stream: u32 = 0,
};
pub const PhysicalDeviceRepresentativeFragmentTestFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_representative_fragment_test_features_nv,
    p_next: ?*anyopaque = null,
    representative_fragment_test: Bool32 = .false,
};
pub const PipelineRepresentativeFragmentTestStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_representative_fragment_test_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    representative_fragment_test_enable: Bool32 = .false,
};
pub const PhysicalDeviceExclusiveScissorFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_exclusive_scissor_features_nv,
    p_next: ?*anyopaque = null,
    exclusive_scissor: Bool32 = .false,
};
pub const PipelineViewportExclusiveScissorStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_viewport_exclusive_scissor_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    exclusive_scissor_count: u32 = 0,
    p_exclusive_scissors: ?[*]const Rect2D = null,
};
pub const PhysicalDeviceCornerSampledImageFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_corner_sampled_image_features_nv,
    p_next: ?*anyopaque = null,
    corner_sampled_image: Bool32 = .false,
};
pub const PhysicalDeviceComputeShaderDerivativesFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_compute_shader_derivatives_features_khr,
    p_next: ?*anyopaque = null,
    compute_derivative_group_quads: Bool32 = .false,
    compute_derivative_group_linear: Bool32 = .false,
};
pub const PhysicalDeviceComputeShaderDerivativesFeaturesNV = PhysicalDeviceComputeShaderDerivativesFeaturesKHR;
pub const PhysicalDeviceComputeShaderDerivativesPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_compute_shader_derivatives_properties_khr,
    p_next: ?*anyopaque = null,
    mesh_and_task_shader_derivatives: Bool32 = .false,
};
pub const PhysicalDeviceFragmentShaderBarycentricFeaturesNV = PhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
pub const PhysicalDeviceShaderImageFootprintFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_shader_image_footprint_features_nv,
    p_next: ?*anyopaque = null,
    image_footprint: Bool32 = .false,
};
pub const PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_dedicated_allocation_image_aliasing_features_nv,
    p_next: ?*anyopaque = null,
    dedicated_allocation_image_aliasing: Bool32 = .false,
};
pub const PhysicalDeviceCopyMemoryIndirectFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_copy_memory_indirect_features_nv,
    p_next: ?*anyopaque = null,
    indirect_copy: Bool32 = .false,
};
pub const PhysicalDeviceCopyMemoryIndirectPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_copy_memory_indirect_properties_nv,
    p_next: ?*anyopaque = null,
    supported_queues: QueueFlags = .none,
};
pub const PhysicalDeviceMemoryDecompressionFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_memory_decompression_features_nv,
    p_next: ?*anyopaque = null,
    memory_decompression: Bool32 = .false,
};
pub const PhysicalDeviceMemoryDecompressionPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_memory_decompression_properties_nv,
    p_next: ?*anyopaque = null,
    decompression_methods: MemoryDecompressionMethodFlagsNV = .none,
    max_decompression_indirect_count: u64 = 0,
};
pub const ShadingRatePaletteNV = extern struct {
    shading_rate_palette_entry_count: u32 = 0,
    p_shading_rate_palette_entries: ?[*]const ShadingRatePaletteEntryNV = null,
};
pub const PipelineViewportShadingRateImageStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_viewport_shading_rate_image_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    shading_rate_image_enable: Bool32 = .false,
    viewport_count: u32 = 0,
    p_shading_rate_palettes: ?[*]const ShadingRatePaletteNV = null,
};
pub const PhysicalDeviceShadingRateImageFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_shading_rate_image_features_nv,
    p_next: ?*anyopaque = null,
    shading_rate_image: Bool32 = .false,
    shading_rate_coarse_sample_order: Bool32 = .false,
};
pub const PhysicalDeviceShadingRateImagePropertiesNV = extern struct {
    s_type: StructureType = .physical_device_shading_rate_image_properties_nv,
    p_next: ?*anyopaque = null,
    shading_rate_texel_size: Extent2D = .{},
    shading_rate_palette_size: u32 = 0,
    shading_rate_max_coarse_samples: u32 = 0,
};
pub const PhysicalDeviceInvocationMaskFeaturesHUAWEI = extern struct {
    s_type: StructureType = .physical_device_invocation_mask_features_huawei,
    p_next: ?*anyopaque = null,
    invocation_mask: Bool32 = .false,
};
pub const CoarseSampleLocationNV = extern struct {
    pixel_x: u32 = 0,
    pixel_y: u32 = 0,
    sample: u32 = 0,
};
pub const CoarseSampleOrderCustomNV = extern struct {
    shading_rate: ShadingRatePaletteEntryNV = @enumFromInt(0),
    sample_count: u32 = 0,
    sample_location_count: u32 = 0,
    p_sample_locations: ?[*]const CoarseSampleLocationNV = null,
};
pub const PipelineViewportCoarseSampleOrderStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_viewport_coarse_sample_order_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    sample_order_type: CoarseSampleOrderTypeNV = @enumFromInt(0),
    custom_sample_order_count: u32 = 0,
    p_custom_sample_orders: ?[*]const CoarseSampleOrderCustomNV = null,
};
pub const PhysicalDeviceMeshShaderFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_mesh_shader_features_nv,
    p_next: ?*anyopaque = null,
    task_shader: Bool32 = .false,
    mesh_shader: Bool32 = .false,
};
pub const PhysicalDeviceMeshShaderPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_mesh_shader_properties_nv,
    p_next: ?*anyopaque = null,
    max_draw_mesh_tasks_count: u32 = 0,
    max_task_work_group_invocations: u32 = 0,
    max_task_work_group_size: [3]u32 = [_]u32{0} ** 3,
    max_task_total_memory_size: u32 = 0,
    max_task_output_count: u32 = 0,
    max_mesh_work_group_invocations: u32 = 0,
    max_mesh_work_group_size: [3]u32 = [_]u32{0} ** 3,
    max_mesh_total_memory_size: u32 = 0,
    max_mesh_output_vertices: u32 = 0,
    max_mesh_output_primitives: u32 = 0,
    max_mesh_multiview_view_count: u32 = 0,
    mesh_output_per_vertex_granularity: u32 = 0,
    mesh_output_per_primitive_granularity: u32 = 0,
};
pub const DrawMeshTasksIndirectCommandNV = extern struct {
    task_count: u32 = 0,
    first_task: u32 = 0,
};
pub const PhysicalDeviceMeshShaderFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_mesh_shader_features_ext,
    p_next: ?*anyopaque = null,
    task_shader: Bool32 = .false,
    mesh_shader: Bool32 = .false,
    multiview_mesh_shader: Bool32 = .false,
    primitive_fragment_shading_rate_mesh_shader: Bool32 = .false,
    mesh_shader_queries: Bool32 = .false,
};
pub const PhysicalDeviceMeshShaderPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_mesh_shader_properties_ext,
    p_next: ?*anyopaque = null,
    max_task_work_group_total_count: u32 = 0,
    max_task_work_group_count: [3]u32 = [_]u32{0} ** 3,
    max_task_work_group_invocations: u32 = 0,
    max_task_work_group_size: [3]u32 = [_]u32{0} ** 3,
    max_task_payload_size: u32 = 0,
    max_task_shared_memory_size: u32 = 0,
    max_task_payload_and_shared_memory_size: u32 = 0,
    max_mesh_work_group_total_count: u32 = 0,
    max_mesh_work_group_count: [3]u32 = [_]u32{0} ** 3,
    max_mesh_work_group_invocations: u32 = 0,
    max_mesh_work_group_size: [3]u32 = [_]u32{0} ** 3,
    max_mesh_shared_memory_size: u32 = 0,
    max_mesh_payload_and_shared_memory_size: u32 = 0,
    max_mesh_output_memory_size: u32 = 0,
    max_mesh_payload_and_output_memory_size: u32 = 0,
    max_mesh_output_components: u32 = 0,
    max_mesh_output_vertices: u32 = 0,
    max_mesh_output_primitives: u32 = 0,
    max_mesh_output_layers: u32 = 0,
    max_mesh_multiview_view_count: u32 = 0,
    mesh_output_per_vertex_granularity: u32 = 0,
    mesh_output_per_primitive_granularity: u32 = 0,
    max_preferred_task_work_group_invocations: u32 = 0,
    max_preferred_mesh_work_group_invocations: u32 = 0,
    prefers_local_invocation_vertex_output: Bool32 = .false,
    prefers_local_invocation_primitive_output: Bool32 = .false,
    prefers_compact_vertex_output: Bool32 = .false,
    prefers_compact_primitive_output: Bool32 = .false,
};
pub const DrawMeshTasksIndirectCommandEXT = extern struct {
    group_count_x: u32 = 0,
    group_count_y: u32 = 0,
    group_count_z: u32 = 0,
};
pub const RayTracingShaderGroupCreateInfoNV = extern struct {
    s_type: StructureType = .ray_tracing_shader_group_create_info_nv,
    p_next: ?*const anyopaque = null,
    type: RayTracingShaderGroupTypeKHR = @enumFromInt(0),
    general_shader: u32 = 0,
    closest_hit_shader: u32 = 0,
    any_hit_shader: u32 = 0,
    intersection_shader: u32 = 0,
};
pub const RayTracingShaderGroupCreateInfoKHR = extern struct {
    s_type: StructureType = .ray_tracing_shader_group_create_info_khr,
    p_next: ?*const anyopaque = null,
    type: RayTracingShaderGroupTypeKHR = @enumFromInt(0),
    general_shader: u32 = 0,
    closest_hit_shader: u32 = 0,
    any_hit_shader: u32 = 0,
    intersection_shader: u32 = 0,
    p_shader_group_capture_replay_handle: ?*const anyopaque = null,
};
pub const RayTracingPipelineCreateInfoNV = extern struct {
    s_type: StructureType = .ray_tracing_pipeline_create_info_nv,
    p_next: ?*const anyopaque = null,
    flags: PipelineCreateFlags = .none,
    stage_count: u32 = 0,
    p_stages: ?[*]const PipelineShaderStageCreateInfo = null,
    group_count: u32 = 0,
    p_groups: ?[*]const RayTracingShaderGroupCreateInfoNV = null,
    max_recursion_depth: u32 = 0,
    layout: PipelineLayout = .null_handle,
    base_pipeline_handle: Pipeline = .null_handle,
    base_pipeline_index: i32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineCreateFlags2CreateInfo,
            *PipelineCreationFeedbackCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const RayTracingPipelineCreateInfoKHR = extern struct {
    s_type: StructureType = .ray_tracing_pipeline_create_info_khr,
    p_next: ?*const anyopaque = null,
    flags: PipelineCreateFlags = .none,
    stage_count: u32 = 0,
    p_stages: ?[*]const PipelineShaderStageCreateInfo = null,
    group_count: u32 = 0,
    p_groups: ?[*]const RayTracingShaderGroupCreateInfoKHR = null,
    max_pipeline_ray_recursion_depth: u32 = 0,
    p_library_info: ?*const PipelineLibraryCreateInfoKHR = null,
    p_library_interface: ?*const RayTracingPipelineInterfaceCreateInfoKHR = null,
    p_dynamic_state: ?*const PipelineDynamicStateCreateInfo = null,
    layout: PipelineLayout = .null_handle,
    base_pipeline_handle: Pipeline = .null_handle,
    base_pipeline_index: i32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineCreateFlags2CreateInfo,
            *PipelineBinaryInfoKHR,
            *RayTracingPipelineClusterAccelerationStructureCreateInfoNV,
            *PipelineCreationFeedbackCreateInfo,
            *PipelineRobustnessCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const GeometryTrianglesNV = extern struct {
    s_type: StructureType = .geometry_triangles_nv,
    p_next: ?*const anyopaque = null,
    vertex_data: Buffer = .null_handle,
    vertex_offset: DeviceSize = 0,
    vertex_count: u32 = 0,
    vertex_stride: DeviceSize = 0,
    vertex_format: Format = @enumFromInt(0),
    index_data: Buffer = .null_handle,
    index_offset: DeviceSize = 0,
    index_count: u32 = 0,
    index_type: IndexType = @enumFromInt(0),
    transform_data: Buffer = .null_handle,
    transform_offset: DeviceSize = 0,
};
pub const GeometryAABBNV = extern struct {
    s_type: StructureType = .geometry_aabb_nv,
    p_next: ?*const anyopaque = null,
    aabb_data: Buffer = .null_handle,
    num_aab_bs: u32 = 0,
    stride: u32 = 0,
    offset: DeviceSize = 0,
};
pub const GeometryDataNV = extern struct {
    triangles: GeometryTrianglesNV = .{},
    aabbs: GeometryAABBNV = .{},
};
pub const GeometryNV = extern struct {
    s_type: StructureType = .geometry_nv,
    p_next: ?*const anyopaque = null,
    geometry_type: GeometryTypeKHR = @enumFromInt(0),
    geometry: GeometryDataNV = .{},
    flags: GeometryFlagsKHR = .none,
};
pub const AccelerationStructureInfoNV = extern struct {
    s_type: StructureType = .acceleration_structure_info_nv,
    p_next: ?*const anyopaque = null,
    type: AccelerationStructureTypeNV = @enumFromInt(0),
    flags: BuildAccelerationStructureFlagsNV = .none,
    instance_count: u32 = 0,
    geometry_count: u32 = 0,
    p_geometries: ?[*]const GeometryNV = null,
};
pub const AccelerationStructureCreateInfoNV = extern struct {
    s_type: StructureType = .acceleration_structure_create_info_nv,
    p_next: ?*const anyopaque = null,
    compacted_size: DeviceSize = 0,
    info: AccelerationStructureInfoNV = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *OpaqueCaptureDescriptorDataCreateInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const BindAccelerationStructureMemoryInfoNV = extern struct {
    s_type: StructureType = .bind_acceleration_structure_memory_info_nv,
    p_next: ?*const anyopaque = null,
    acceleration_structure: AccelerationStructureNV = .null_handle,
    memory: DeviceMemory = .null_handle,
    memory_offset: DeviceSize = 0,
    device_index_count: u32 = 0,
    p_device_indices: ?[*]const u32 = null,
};
pub const WriteDescriptorSetAccelerationStructureKHR = extern struct {
    s_type: StructureType = .write_descriptor_set_acceleration_structure_khr,
    p_next: ?*const anyopaque = null,
    acceleration_structure_count: u32 = 0,
    p_acceleration_structures: ?[*]const AccelerationStructureKHR = null,
};
pub const WriteDescriptorSetAccelerationStructureNV = extern struct {
    s_type: StructureType = .write_descriptor_set_acceleration_structure_nv,
    p_next: ?*const anyopaque = null,
    acceleration_structure_count: u32 = 0,
    p_acceleration_structures: ?[*]const AccelerationStructureNV = null,
};
pub const AccelerationStructureMemoryRequirementsInfoNV = extern struct {
    s_type: StructureType = .acceleration_structure_memory_requirements_info_nv,
    p_next: ?*const anyopaque = null,
    type: AccelerationStructureMemoryRequirementsTypeNV = @enumFromInt(0),
    acceleration_structure: AccelerationStructureNV = .null_handle,
};
pub const PhysicalDeviceAccelerationStructureFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_acceleration_structure_features_khr,
    p_next: ?*anyopaque = null,
    acceleration_structure: Bool32 = .false,
    acceleration_structure_capture_replay: Bool32 = .false,
    acceleration_structure_indirect_build: Bool32 = .false,
    acceleration_structure_host_commands: Bool32 = .false,
    descriptor_binding_acceleration_structure_update_after_bind: Bool32 = .false,
};
pub const PhysicalDeviceRayTracingPipelineFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_pipeline_features_khr,
    p_next: ?*anyopaque = null,
    ray_tracing_pipeline: Bool32 = .false,
    ray_tracing_pipeline_shader_group_handle_capture_replay: Bool32 = .false,
    ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: Bool32 = .false,
    ray_tracing_pipeline_trace_rays_indirect: Bool32 = .false,
    ray_traversal_primitive_culling: Bool32 = .false,
};
pub const PhysicalDeviceRayQueryFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_ray_query_features_khr,
    p_next: ?*anyopaque = null,
    ray_query: Bool32 = .false,
};
pub const PhysicalDeviceAccelerationStructurePropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_acceleration_structure_properties_khr,
    p_next: ?*anyopaque = null,
    max_geometry_count: u64 = 0,
    max_instance_count: u64 = 0,
    max_primitive_count: u64 = 0,
    max_per_stage_descriptor_acceleration_structures: u32 = 0,
    max_per_stage_descriptor_update_after_bind_acceleration_structures: u32 = 0,
    max_descriptor_set_acceleration_structures: u32 = 0,
    max_descriptor_set_update_after_bind_acceleration_structures: u32 = 0,
    min_acceleration_structure_scratch_offset_alignment: u32 = 0,
};
pub const PhysicalDeviceRayTracingPipelinePropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_pipeline_properties_khr,
    p_next: ?*anyopaque = null,
    shader_group_handle_size: u32 = 0,
    max_ray_recursion_depth: u32 = 0,
    max_shader_group_stride: u32 = 0,
    shader_group_base_alignment: u32 = 0,
    shader_group_handle_capture_replay_size: u32 = 0,
    max_ray_dispatch_invocation_count: u32 = 0,
    shader_group_handle_alignment: u32 = 0,
    max_ray_hit_attribute_size: u32 = 0,
};
pub const PhysicalDeviceRayTracingPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_properties_nv,
    p_next: ?*anyopaque = null,
    shader_group_handle_size: u32 = 0,
    max_recursion_depth: u32 = 0,
    max_shader_group_stride: u32 = 0,
    shader_group_base_alignment: u32 = 0,
    max_geometry_count: u64 = 0,
    max_instance_count: u64 = 0,
    max_triangle_count: u64 = 0,
    max_descriptor_set_acceleration_structures: u32 = 0,
};
pub const StridedDeviceAddressRegionKHR = extern struct {
    device_address: DeviceAddress = 0,
    stride: DeviceSize = 0,
    size: DeviceSize = 0,
};
pub const TraceRaysIndirectCommandKHR = extern struct {
    width: u32 = 0,
    height: u32 = 0,
    depth: u32 = 0,
};
pub const TraceRaysIndirectCommand2KHR = extern struct {
    raygen_shader_record_address: DeviceAddress = 0,
    raygen_shader_record_size: DeviceSize = 0,
    miss_shader_binding_table_address: DeviceAddress = 0,
    miss_shader_binding_table_size: DeviceSize = 0,
    miss_shader_binding_table_stride: DeviceSize = 0,
    hit_shader_binding_table_address: DeviceAddress = 0,
    hit_shader_binding_table_size: DeviceSize = 0,
    hit_shader_binding_table_stride: DeviceSize = 0,
    callable_shader_binding_table_address: DeviceAddress = 0,
    callable_shader_binding_table_size: DeviceSize = 0,
    callable_shader_binding_table_stride: DeviceSize = 0,
    width: u32 = 0,
    height: u32 = 0,
    depth: u32 = 0,
};
pub const PhysicalDeviceRayTracingMaintenance1FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_maintenance_1_features_khr,
    p_next: ?*anyopaque = null,
    ray_tracing_maintenance1: Bool32 = .false,
    ray_tracing_pipeline_trace_rays_indirect2: Bool32 = .false,
};
pub const DrmFormatModifierPropertiesListEXT = extern struct {
    s_type: StructureType = .drm_format_modifier_properties_list_ext,
    p_next: ?*anyopaque = null,
    drm_format_modifier_count: u32 = 0,
    p_drm_format_modifier_properties: ?[*]DrmFormatModifierPropertiesEXT = null,
};
pub const DrmFormatModifierPropertiesEXT = extern struct {
    drm_format_modifier: u64 = 0,
    drm_format_modifier_plane_count: u32 = 0,
    drm_format_modifier_tiling_features: FormatFeatureFlags = .none,
};
pub const PhysicalDeviceImageDrmFormatModifierInfoEXT = extern struct {
    s_type: StructureType = .physical_device_image_drm_format_modifier_info_ext,
    p_next: ?*const anyopaque = null,
    drm_format_modifier: u64 = 0,
    sharing_mode: SharingMode = @enumFromInt(0),
    queue_family_index_count: u32 = 0,
    p_queue_family_indices: ?[*]const u32 = null,
};
pub const ImageDrmFormatModifierListCreateInfoEXT = extern struct {
    s_type: StructureType = .image_drm_format_modifier_list_create_info_ext,
    p_next: ?*const anyopaque = null,
    drm_format_modifier_count: u32 = 0,
    p_drm_format_modifiers: ?[*]const u64 = null,
};
pub const ImageDrmFormatModifierExplicitCreateInfoEXT = extern struct {
    s_type: StructureType = .image_drm_format_modifier_explicit_create_info_ext,
    p_next: ?*const anyopaque = null,
    drm_format_modifier: u64 = 0,
    drm_format_modifier_plane_count: u32 = 0,
    p_plane_layouts: ?[*]const SubresourceLayout = null,
};
pub const ImageDrmFormatModifierPropertiesEXT = extern struct {
    s_type: StructureType = .image_drm_format_modifier_properties_ext,
    p_next: ?*anyopaque = null,
    drm_format_modifier: u64 = 0,
};
pub const ImageStencilUsageCreateInfo = extern struct {
    s_type: StructureType = .image_stencil_usage_create_info,
    p_next: ?*const anyopaque = null,
    stencil_usage: ImageUsageFlags = .none,
};
pub const ImageStencilUsageCreateInfoEXT = ImageStencilUsageCreateInfo;
pub const DeviceMemoryOverallocationCreateInfoAMD = extern struct {
    s_type: StructureType = .device_memory_overallocation_create_info_amd,
    p_next: ?*const anyopaque = null,
    overallocation_behavior: MemoryOverallocationBehaviorAMD = @enumFromInt(0),
};
pub const PhysicalDeviceFragmentDensityMapFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_features_ext,
    p_next: ?*anyopaque = null,
    fragment_density_map: Bool32 = .false,
    fragment_density_map_dynamic: Bool32 = .false,
    fragment_density_map_non_subsampled_images: Bool32 = .false,
};
pub const PhysicalDeviceFragmentDensityMap2FeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_2_features_ext,
    p_next: ?*anyopaque = null,
    fragment_density_map_deferred: Bool32 = .false,
};
pub const PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_offset_features_ext,
    p_next: ?*anyopaque = null,
    fragment_density_map_offset: Bool32 = .false,
};
pub const PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM = PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT;
pub const PhysicalDeviceFragmentDensityMapPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_properties_ext,
    p_next: ?*anyopaque = null,
    min_fragment_density_texel_size: Extent2D = .{},
    max_fragment_density_texel_size: Extent2D = .{},
    fragment_density_invocations: Bool32 = .false,
};
pub const PhysicalDeviceFragmentDensityMap2PropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_2_properties_ext,
    p_next: ?*anyopaque = null,
    subsampled_loads: Bool32 = .false,
    subsampled_coarse_reconstruction_early_access: Bool32 = .false,
    max_subsampled_array_layers: u32 = 0,
    max_descriptor_set_subsampled_samplers: u32 = 0,
};
pub const PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_offset_properties_ext,
    p_next: ?*anyopaque = null,
    fragment_density_offset_granularity: Extent2D = .{},
};
pub const PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM = PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT;
pub const RenderPassFragmentDensityMapCreateInfoEXT = extern struct {
    s_type: StructureType = .render_pass_fragment_density_map_create_info_ext,
    p_next: ?*const anyopaque = null,
    fragment_density_map_attachment: AttachmentReference = .{},
};
pub const RenderPassFragmentDensityMapOffsetEndInfoEXT = extern struct {
    s_type: StructureType = .render_pass_fragment_density_map_offset_end_info_ext,
    p_next: ?*const anyopaque = null,
    fragment_density_offset_count: u32 = 0,
    p_fragment_density_offsets: ?[*]const Offset2D = null,
};
pub const SubpassFragmentDensityMapOffsetEndInfoQCOM = RenderPassFragmentDensityMapOffsetEndInfoEXT;
pub const PhysicalDeviceScalarBlockLayoutFeatures = extern struct {
    s_type: StructureType = .physical_device_scalar_block_layout_features,
    p_next: ?*anyopaque = null,
    scalar_block_layout: Bool32 = .false,
};
pub const PhysicalDeviceScalarBlockLayoutFeaturesEXT = PhysicalDeviceScalarBlockLayoutFeatures;
pub const SurfaceProtectedCapabilitiesKHR = extern struct {
    s_type: StructureType = .surface_protected_capabilities_khr,
    p_next: ?*const anyopaque = null,
    supports_protected: Bool32 = .false,
};
pub const PhysicalDeviceUniformBufferStandardLayoutFeatures = extern struct {
    s_type: StructureType = .physical_device_uniform_buffer_standard_layout_features,
    p_next: ?*anyopaque = null,
    uniform_buffer_standard_layout: Bool32 = .false,
};
pub const PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = PhysicalDeviceUniformBufferStandardLayoutFeatures;
pub const PhysicalDeviceDepthClipEnableFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_depth_clip_enable_features_ext,
    p_next: ?*anyopaque = null,
    depth_clip_enable: Bool32 = .false,
};
pub const PipelineRasterizationDepthClipStateCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_rasterization_depth_clip_state_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: PipelineRasterizationDepthClipStateCreateFlagsEXT = .none,
    depth_clip_enable: Bool32 = .false,
};
pub const PhysicalDeviceMemoryBudgetPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_memory_budget_properties_ext,
    p_next: ?*anyopaque = null,
    heap_budget: [max_memory_heaps]DeviceSize = [_]DeviceSize{0} ** max_memory_heaps,
    heap_usage: [max_memory_heaps]DeviceSize = [_]DeviceSize{0} ** max_memory_heaps,
};
pub const PhysicalDeviceMemoryPriorityFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_memory_priority_features_ext,
    p_next: ?*anyopaque = null,
    memory_priority: Bool32 = .false,
};
pub const MemoryPriorityAllocateInfoEXT = extern struct {
    s_type: StructureType = .memory_priority_allocate_info_ext,
    p_next: ?*const anyopaque = null,
    priority: f32 = 0,
};
pub const PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_pageable_device_local_memory_features_ext,
    p_next: ?*anyopaque = null,
    pageable_device_local_memory: Bool32 = .false,
};
pub const PhysicalDeviceBufferDeviceAddressFeatures = extern struct {
    s_type: StructureType = .physical_device_buffer_device_address_features,
    p_next: ?*anyopaque = null,
    buffer_device_address: Bool32 = .false,
    buffer_device_address_capture_replay: Bool32 = .false,
    buffer_device_address_multi_device: Bool32 = .false,
};
pub const PhysicalDeviceBufferDeviceAddressFeaturesKHR = PhysicalDeviceBufferDeviceAddressFeatures;
pub const PhysicalDeviceBufferDeviceAddressFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_buffer_device_address_features_ext,
    p_next: ?*anyopaque = null,
    buffer_device_address: Bool32 = .false,
    buffer_device_address_capture_replay: Bool32 = .false,
    buffer_device_address_multi_device: Bool32 = .false,
};
pub const PhysicalDeviceBufferAddressFeaturesEXT = PhysicalDeviceBufferDeviceAddressFeaturesEXT;
pub const BufferDeviceAddressInfo = extern struct {
    s_type: StructureType = .buffer_device_address_info,
    p_next: ?*const anyopaque = null,
    buffer: Buffer = .null_handle,
};
pub const BufferDeviceAddressInfoKHR = BufferDeviceAddressInfo;
pub const BufferDeviceAddressInfoEXT = BufferDeviceAddressInfo;
pub const BufferOpaqueCaptureAddressCreateInfo = extern struct {
    s_type: StructureType = .buffer_opaque_capture_address_create_info,
    p_next: ?*const anyopaque = null,
    opaque_capture_address: u64 = 0,
};
pub const BufferOpaqueCaptureAddressCreateInfoKHR = BufferOpaqueCaptureAddressCreateInfo;
pub const BufferDeviceAddressCreateInfoEXT = extern struct {
    s_type: StructureType = .buffer_device_address_create_info_ext,
    p_next: ?*const anyopaque = null,
    device_address: DeviceAddress = 0,
};
pub const PhysicalDeviceImageViewImageFormatInfoEXT = extern struct {
    s_type: StructureType = .physical_device_image_view_image_format_info_ext,
    p_next: ?*anyopaque = null,
    image_view_type: ImageViewType = @enumFromInt(0),
};
pub const FilterCubicImageViewImageFormatPropertiesEXT = extern struct {
    s_type: StructureType = .filter_cubic_image_view_image_format_properties_ext,
    p_next: ?*anyopaque = null,
    filter_cubic: Bool32 = .false,
    filter_cubic_minmax: Bool32 = .false,
};
pub const PhysicalDeviceImagelessFramebufferFeatures = extern struct {
    s_type: StructureType = .physical_device_imageless_framebuffer_features,
    p_next: ?*anyopaque = null,
    imageless_framebuffer: Bool32 = .false,
};
pub const PhysicalDeviceImagelessFramebufferFeaturesKHR = PhysicalDeviceImagelessFramebufferFeatures;
pub const FramebufferAttachmentsCreateInfo = extern struct {
    s_type: StructureType = .framebuffer_attachments_create_info,
    p_next: ?*const anyopaque = null,
    attachment_image_info_count: u32 = 0,
    p_attachment_image_infos: ?[*]const FramebufferAttachmentImageInfo = null,
};
pub const FramebufferAttachmentsCreateInfoKHR = FramebufferAttachmentsCreateInfo;
pub const FramebufferAttachmentImageInfo = extern struct {
    s_type: StructureType = .framebuffer_attachment_image_info,
    p_next: ?*const anyopaque = null,
    flags: ImageCreateFlags = .none,
    usage: ImageUsageFlags = .none,
    width: u32 = 0,
    height: u32 = 0,
    layer_count: u32 = 0,
    view_format_count: u32 = 0,
    p_view_formats: ?[*]const Format = null,
};
pub const FramebufferAttachmentImageInfoKHR = FramebufferAttachmentImageInfo;
pub const RenderPassAttachmentBeginInfo = extern struct {
    s_type: StructureType = .render_pass_attachment_begin_info,
    p_next: ?*const anyopaque = null,
    attachment_count: u32 = 0,
    p_attachments: ?[*]const ImageView = null,
};
pub const RenderPassAttachmentBeginInfoKHR = RenderPassAttachmentBeginInfo;
pub const PhysicalDeviceTextureCompressionASTCHDRFeatures = extern struct {
    s_type: StructureType = .physical_device_texture_compression_astc_hdr_features,
    p_next: ?*anyopaque = null,
    texture_compression_astc_hdr: Bool32 = .false,
};
pub const PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = PhysicalDeviceTextureCompressionASTCHDRFeatures;
pub const PhysicalDeviceCooperativeMatrixFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_cooperative_matrix_features_nv,
    p_next: ?*anyopaque = null,
    cooperative_matrix: Bool32 = .false,
    cooperative_matrix_robust_buffer_access: Bool32 = .false,
};
pub const PhysicalDeviceCooperativeMatrixPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_cooperative_matrix_properties_nv,
    p_next: ?*anyopaque = null,
    cooperative_matrix_supported_stages: ShaderStageFlags = .none,
};
pub const CooperativeMatrixPropertiesNV = extern struct {
    s_type: StructureType = .cooperative_matrix_properties_nv,
    p_next: ?*anyopaque = null,
    m_size: u32 = 0,
    n_size: u32 = 0,
    k_size: u32 = 0,
    a_type: ComponentTypeNV = @enumFromInt(0),
    b_type: ComponentTypeNV = @enumFromInt(0),
    c_type: ComponentTypeNV = @enumFromInt(0),
    d_type: ComponentTypeNV = @enumFromInt(0),
    scope: ScopeNV = @enumFromInt(0),
};
pub const PhysicalDeviceYcbcrImageArraysFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_ycbcr_image_arrays_features_ext,
    p_next: ?*anyopaque = null,
    ycbcr_image_arrays: Bool32 = .false,
};
pub const ImageViewHandleInfoNVX = extern struct {
    s_type: StructureType = .image_view_handle_info_nvx,
    p_next: ?*const anyopaque = null,
    image_view: ImageView = .null_handle,
    descriptor_type: DescriptorType = @enumFromInt(0),
    sampler: Sampler = .null_handle,
};
pub const ImageViewAddressPropertiesNVX = extern struct {
    s_type: StructureType = .image_view_address_properties_nvx,
    p_next: ?*anyopaque = null,
    device_address: DeviceAddress = 0,
    size: DeviceSize = 0,
};
pub const PipelineCreationFeedback = extern struct {
    flags: PipelineCreationFeedbackFlags = .none,
    duration: u64 = 0,
};
pub const PipelineCreationFeedbackEXT = PipelineCreationFeedback;
pub const PipelineCreationFeedbackCreateInfo = extern struct {
    s_type: StructureType = .pipeline_creation_feedback_create_info,
    p_next: ?*const anyopaque = null,
    p_pipeline_creation_feedback: ?*PipelineCreationFeedback = null,
    pipeline_stage_creation_feedback_count: u32 = 0,
    p_pipeline_stage_creation_feedbacks: ?[*]PipelineCreationFeedback = null,
};
pub const PipelineCreationFeedbackCreateInfoEXT = PipelineCreationFeedbackCreateInfo;
pub const SurfaceFullScreenExclusiveInfoEXT = extern struct {
    s_type: StructureType = .surface_full_screen_exclusive_info_ext,
    p_next: ?*anyopaque = null,
    full_screen_exclusive: FullScreenExclusiveEXT = @enumFromInt(0),
};
pub const SurfaceFullScreenExclusiveWin32InfoEXT = extern struct {
    s_type: StructureType = .surface_full_screen_exclusive_win32_info_ext,
    p_next: ?*const anyopaque = null,
    hmonitor: HMONITOR = null,
};
pub const SurfaceCapabilitiesFullScreenExclusiveEXT = extern struct {
    s_type: StructureType = .surface_capabilities_full_screen_exclusive_ext,
    p_next: ?*anyopaque = null,
    full_screen_exclusive_supported: Bool32 = .false,
};
pub const PhysicalDevicePresentBarrierFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_present_barrier_features_nv,
    p_next: ?*anyopaque = null,
    present_barrier: Bool32 = .false,
};
pub const SurfaceCapabilitiesPresentBarrierNV = extern struct {
    s_type: StructureType = .surface_capabilities_present_barrier_nv,
    p_next: ?*anyopaque = null,
    present_barrier_supported: Bool32 = .false,
};
pub const SwapchainPresentBarrierCreateInfoNV = extern struct {
    s_type: StructureType = .swapchain_present_barrier_create_info_nv,
    p_next: ?*anyopaque = null,
    present_barrier_enable: Bool32 = .false,
};
pub const PhysicalDevicePerformanceQueryFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_performance_query_features_khr,
    p_next: ?*anyopaque = null,
    performance_counter_query_pools: Bool32 = .false,
    performance_counter_multiple_query_pools: Bool32 = .false,
};
pub const PhysicalDevicePerformanceQueryPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_performance_query_properties_khr,
    p_next: ?*anyopaque = null,
    allow_command_buffer_query_copies: Bool32 = .false,
};
pub const PerformanceCounterKHR = extern struct {
    s_type: StructureType = .performance_counter_khr,
    p_next: ?*anyopaque = null,
    unit: PerformanceCounterUnitKHR = @enumFromInt(0),
    scope: PerformanceCounterScopeKHR = @enumFromInt(0),
    storage: PerformanceCounterStorageKHR = @enumFromInt(0),
    uuid: [uuid_size]u8 = [_]u8{0} ** uuid_size,
};
pub const PerformanceCounterDescriptionKHR = extern struct {
    s_type: StructureType = .performance_counter_description_khr,
    p_next: ?*anyopaque = null,
    flags: PerformanceCounterDescriptionFlagsKHR = .none,
    name: [max_description_size - 1:0]u8 = [_:0]u8{0} ** (max_description_size - 1),
    category: [max_description_size - 1:0]u8 = [_:0]u8{0} ** (max_description_size - 1),
    description: [max_description_size - 1:0]u8 = [_:0]u8{0} ** (max_description_size - 1),
};
pub const QueryPoolPerformanceCreateInfoKHR = extern struct {
    s_type: StructureType = .query_pool_performance_create_info_khr,
    p_next: ?*const anyopaque = null,
    queue_family_index: u32 = 0,
    counter_index_count: u32 = 0,
    p_counter_indices: ?[*]const u32 = null,
};
pub const PerformanceCounterResultKHR = extern union {
    int32: i32,
    int64: i64,
    uint32: u32,
    uint64: u64,
    float32: f32,
    float64: f64,
};
pub const AcquireProfilingLockInfoKHR = extern struct {
    s_type: StructureType = .acquire_profiling_lock_info_khr,
    p_next: ?*const anyopaque = null,
    flags: AcquireProfilingLockFlagsKHR = .none,
    timeout: u64 = 0,
};
pub const PerformanceQuerySubmitInfoKHR = extern struct {
    s_type: StructureType = .performance_query_submit_info_khr,
    p_next: ?*const anyopaque = null,
    counter_pass_index: u32 = 0,
};
pub const HeadlessSurfaceCreateInfoEXT = extern struct {
    s_type: StructureType = .headless_surface_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: HeadlessSurfaceCreateFlagsEXT = .none,
};
pub const PhysicalDeviceCoverageReductionModeFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_coverage_reduction_mode_features_nv,
    p_next: ?*anyopaque = null,
    coverage_reduction_mode: Bool32 = .false,
};
pub const PipelineCoverageReductionStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_coverage_reduction_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    flags: PipelineCoverageReductionStateCreateFlagsNV = .none,
    coverage_reduction_mode: CoverageReductionModeNV = @enumFromInt(0),
};
pub const FramebufferMixedSamplesCombinationNV = extern struct {
    s_type: StructureType = .framebuffer_mixed_samples_combination_nv,
    p_next: ?*anyopaque = null,
    coverage_reduction_mode: CoverageReductionModeNV = @enumFromInt(0),
    rasterization_samples: SampleCountFlags = .none,
    depth_stencil_samples: SampleCountFlags = .none,
    color_samples: SampleCountFlags = .none,
};
pub const PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = extern struct {
    s_type: StructureType = .physical_device_shader_integer_functions_2_features_intel,
    p_next: ?*anyopaque = null,
    shader_integer_functions2: Bool32 = .false,
};
pub const PerformanceValueDataINTEL = extern union {
    value32: u32,
    value64: u64,
    value_float: f32,
    value_bool: Bool32,
    value_string: ?[*:0]const u8,
};
pub const PerformanceValueINTEL = extern struct {
    type: PerformanceValueTypeINTEL = @enumFromInt(0),
    data: PerformanceValueDataINTEL = .{ .value32 = 0 },
};
pub const InitializePerformanceApiInfoINTEL = extern struct {
    s_type: StructureType = .initialize_performance_api_info_intel,
    p_next: ?*const anyopaque = null,
    p_user_data: ?*anyopaque = null,
};
pub const QueryPoolPerformanceQueryCreateInfoINTEL = extern struct {
    s_type: StructureType = .query_pool_performance_query_create_info_intel,
    p_next: ?*const anyopaque = null,
    performance_counters_sampling: QueryPoolSamplingModeINTEL = @enumFromInt(0),
};
pub const QueryPoolCreateInfoINTEL = QueryPoolPerformanceQueryCreateInfoINTEL;
pub const PerformanceMarkerInfoINTEL = extern struct {
    s_type: StructureType = .performance_marker_info_intel,
    p_next: ?*const anyopaque = null,
    marker: u64 = 0,
};
pub const PerformanceStreamMarkerInfoINTEL = extern struct {
    s_type: StructureType = .performance_stream_marker_info_intel,
    p_next: ?*const anyopaque = null,
    marker: u32 = 0,
};
pub const PerformanceOverrideInfoINTEL = extern struct {
    s_type: StructureType = .performance_override_info_intel,
    p_next: ?*const anyopaque = null,
    type: PerformanceOverrideTypeINTEL = @enumFromInt(0),
    enable: Bool32 = .false,
    parameter: u64 = 0,
};
pub const PerformanceConfigurationAcquireInfoINTEL = extern struct {
    s_type: StructureType = .performance_configuration_acquire_info_intel,
    p_next: ?*const anyopaque = null,
    type: PerformanceConfigurationTypeINTEL = @enumFromInt(0),
};
pub const PhysicalDeviceShaderClockFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_shader_clock_features_khr,
    p_next: ?*anyopaque = null,
    shader_subgroup_clock: Bool32 = .false,
    shader_device_clock: Bool32 = .false,
};
pub const PhysicalDeviceIndexTypeUint8Features = extern struct {
    s_type: StructureType = .physical_device_index_type_uint8_features,
    p_next: ?*anyopaque = null,
    index_type_uint8: Bool32 = .false,
};
pub const PhysicalDeviceIndexTypeUint8FeaturesKHR = PhysicalDeviceIndexTypeUint8Features;
pub const PhysicalDeviceIndexTypeUint8FeaturesEXT = PhysicalDeviceIndexTypeUint8Features;
pub const PhysicalDeviceShaderSMBuiltinsPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_shader_sm_builtins_properties_nv,
    p_next: ?*anyopaque = null,
    shader_sm_count: u32 = 0,
    shader_warps_per_sm: u32 = 0,
};
pub const PhysicalDeviceShaderSMBuiltinsFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_shader_sm_builtins_features_nv,
    p_next: ?*anyopaque = null,
    shader_sm_builtins: Bool32 = .false,
};
pub const PhysicalDeviceFragmentShaderInterlockFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_fragment_shader_interlock_features_ext,
    p_next: ?*anyopaque = null,
    fragment_shader_sample_interlock: Bool32 = .false,
    fragment_shader_pixel_interlock: Bool32 = .false,
    fragment_shader_shading_rate_interlock: Bool32 = .false,
};
pub const PhysicalDeviceSeparateDepthStencilLayoutsFeatures = extern struct {
    s_type: StructureType = .physical_device_separate_depth_stencil_layouts_features,
    p_next: ?*anyopaque = null,
    separate_depth_stencil_layouts: Bool32 = .false,
};
pub const PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
pub const AttachmentReferenceStencilLayout = extern struct {
    s_type: StructureType = .attachment_reference_stencil_layout,
    p_next: ?*anyopaque = null,
    stencil_layout: ImageLayout = @enumFromInt(0),
};
pub const PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_primitive_topology_list_restart_features_ext,
    p_next: ?*anyopaque = null,
    primitive_topology_list_restart: Bool32 = .false,
    primitive_topology_patch_list_restart: Bool32 = .false,
};
pub const AttachmentReferenceStencilLayoutKHR = AttachmentReferenceStencilLayout;
pub const AttachmentDescriptionStencilLayout = extern struct {
    s_type: StructureType = .attachment_description_stencil_layout,
    p_next: ?*anyopaque = null,
    stencil_initial_layout: ImageLayout = @enumFromInt(0),
    stencil_final_layout: ImageLayout = @enumFromInt(0),
};
pub const AttachmentDescriptionStencilLayoutKHR = AttachmentDescriptionStencilLayout;
pub const PhysicalDevicePipelineExecutablePropertiesFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_pipeline_executable_properties_features_khr,
    p_next: ?*anyopaque = null,
    pipeline_executable_info: Bool32 = .false,
};
pub const PipelineInfoKHR = extern struct {
    s_type: StructureType = .pipeline_info_khr,
    p_next: ?*const anyopaque = null,
    pipeline: Pipeline = .null_handle,
};
pub const PipelineInfoEXT = PipelineInfoKHR;
pub const PipelineExecutablePropertiesKHR = extern struct {
    s_type: StructureType = .pipeline_executable_properties_khr,
    p_next: ?*anyopaque = null,
    stages: ShaderStageFlags = .none,
    name: [max_description_size - 1:0]u8 = [_:0]u8{0} ** (max_description_size - 1),
    description: [max_description_size - 1:0]u8 = [_:0]u8{0} ** (max_description_size - 1),
    subgroup_size: u32 = 0,
};
pub const PipelineExecutableInfoKHR = extern struct {
    s_type: StructureType = .pipeline_executable_info_khr,
    p_next: ?*const anyopaque = null,
    pipeline: Pipeline = .null_handle,
    executable_index: u32 = 0,
};
pub const PipelineExecutableStatisticValueKHR = extern union {
    b32: Bool32,
    i64: i64,
    u64: u64,
    f64: f64,
};
pub const PipelineExecutableStatisticKHR = extern struct {
    s_type: StructureType = .pipeline_executable_statistic_khr,
    p_next: ?*anyopaque = null,
    name: [max_description_size - 1:0]u8 = [_:0]u8{0} ** (max_description_size - 1),
    description: [max_description_size - 1:0]u8 = [_:0]u8{0} ** (max_description_size - 1),
    format: PipelineExecutableStatisticFormatKHR = @enumFromInt(0),
    value: PipelineExecutableStatisticValueKHR = .{ .b32 = .false },
};
pub const PipelineExecutableInternalRepresentationKHR = extern struct {
    s_type: StructureType = .pipeline_executable_internal_representation_khr,
    p_next: ?*anyopaque = null,
    name: [max_description_size - 1:0]u8 = [_:0]u8{0} ** (max_description_size - 1),
    description: [max_description_size - 1:0]u8 = [_:0]u8{0} ** (max_description_size - 1),
    is_text: Bool32 = .false,
    data_size: usize = 0,
    p_data: ?*anyopaque = null,
};
pub const PhysicalDeviceShaderDemoteToHelperInvocationFeatures = extern struct {
    s_type: StructureType = .physical_device_shader_demote_to_helper_invocation_features,
    p_next: ?*anyopaque = null,
    shader_demote_to_helper_invocation: Bool32 = .false,
};
pub const PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = PhysicalDeviceShaderDemoteToHelperInvocationFeatures;
pub const PhysicalDeviceTexelBufferAlignmentFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_texel_buffer_alignment_features_ext,
    p_next: ?*anyopaque = null,
    texel_buffer_alignment: Bool32 = .false,
};
pub const PhysicalDeviceTexelBufferAlignmentProperties = extern struct {
    s_type: StructureType = .physical_device_texel_buffer_alignment_properties,
    p_next: ?*anyopaque = null,
    storage_texel_buffer_offset_alignment_bytes: DeviceSize = 0,
    storage_texel_buffer_offset_single_texel_alignment: Bool32 = .false,
    uniform_texel_buffer_offset_alignment_bytes: DeviceSize = 0,
    uniform_texel_buffer_offset_single_texel_alignment: Bool32 = .false,
};
pub const PhysicalDeviceTexelBufferAlignmentPropertiesEXT = PhysicalDeviceTexelBufferAlignmentProperties;
pub const PhysicalDeviceSubgroupSizeControlFeatures = extern struct {
    s_type: StructureType = .physical_device_subgroup_size_control_features,
    p_next: ?*anyopaque = null,
    subgroup_size_control: Bool32 = .false,
    compute_full_subgroups: Bool32 = .false,
};
pub const PhysicalDeviceSubgroupSizeControlFeaturesEXT = PhysicalDeviceSubgroupSizeControlFeatures;
pub const PhysicalDeviceSubgroupSizeControlProperties = extern struct {
    s_type: StructureType = .physical_device_subgroup_size_control_properties,
    p_next: ?*anyopaque = null,
    min_subgroup_size: u32 = 0,
    max_subgroup_size: u32 = 0,
    max_compute_workgroup_subgroups: u32 = 0,
    required_subgroup_size_stages: ShaderStageFlags = .none,
};
pub const PhysicalDeviceSubgroupSizeControlPropertiesEXT = PhysicalDeviceSubgroupSizeControlProperties;
pub const PipelineShaderStageRequiredSubgroupSizeCreateInfo = extern struct {
    s_type: StructureType = .pipeline_shader_stage_required_subgroup_size_create_info,
    p_next: ?*const anyopaque = null,
    required_subgroup_size: u32 = 0,
};
pub const PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = PipelineShaderStageRequiredSubgroupSizeCreateInfo;
pub const ShaderRequiredSubgroupSizeCreateInfoEXT = PipelineShaderStageRequiredSubgroupSizeCreateInfo;
pub const SubpassShadingPipelineCreateInfoHUAWEI = extern struct {
    s_type: StructureType = .subpass_shading_pipeline_create_info_huawei,
    p_next: ?*anyopaque = null,
    render_pass: RenderPass = .null_handle,
    subpass: u32 = 0,
};
pub const PhysicalDeviceSubpassShadingPropertiesHUAWEI = extern struct {
    s_type: StructureType = .physical_device_subpass_shading_properties_huawei,
    p_next: ?*anyopaque = null,
    max_subpass_shading_workgroup_size_aspect_ratio: u32 = 0,
};
pub const PhysicalDeviceClusterCullingShaderPropertiesHUAWEI = extern struct {
    s_type: StructureType = .physical_device_cluster_culling_shader_properties_huawei,
    p_next: ?*anyopaque = null,
    max_work_group_count: [3]u32 = [_]u32{0} ** 3,
    max_work_group_size: [3]u32 = [_]u32{0} ** 3,
    max_output_cluster_count: u32 = 0,
    indirect_buffer_offset_alignment: DeviceSize = 0,
};
pub const MemoryOpaqueCaptureAddressAllocateInfo = extern struct {
    s_type: StructureType = .memory_opaque_capture_address_allocate_info,
    p_next: ?*const anyopaque = null,
    opaque_capture_address: u64 = 0,
};
pub const MemoryOpaqueCaptureAddressAllocateInfoKHR = MemoryOpaqueCaptureAddressAllocateInfo;
pub const DeviceMemoryOpaqueCaptureAddressInfo = extern struct {
    s_type: StructureType = .device_memory_opaque_capture_address_info,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory = .null_handle,
};
pub const DeviceMemoryOpaqueCaptureAddressInfoKHR = DeviceMemoryOpaqueCaptureAddressInfo;
pub const PhysicalDeviceLineRasterizationFeatures = extern struct {
    s_type: StructureType = .physical_device_line_rasterization_features,
    p_next: ?*anyopaque = null,
    rectangular_lines: Bool32 = .false,
    bresenham_lines: Bool32 = .false,
    smooth_lines: Bool32 = .false,
    stippled_rectangular_lines: Bool32 = .false,
    stippled_bresenham_lines: Bool32 = .false,
    stippled_smooth_lines: Bool32 = .false,
};
pub const PhysicalDeviceLineRasterizationFeaturesKHR = PhysicalDeviceLineRasterizationFeatures;
pub const PhysicalDeviceLineRasterizationFeaturesEXT = PhysicalDeviceLineRasterizationFeatures;
pub const PhysicalDeviceLineRasterizationProperties = extern struct {
    s_type: StructureType = .physical_device_line_rasterization_properties,
    p_next: ?*anyopaque = null,
    line_sub_pixel_precision_bits: u32 = 0,
};
pub const PhysicalDeviceLineRasterizationPropertiesKHR = PhysicalDeviceLineRasterizationProperties;
pub const PhysicalDeviceLineRasterizationPropertiesEXT = PhysicalDeviceLineRasterizationProperties;
pub const PipelineRasterizationLineStateCreateInfo = extern struct {
    s_type: StructureType = .pipeline_rasterization_line_state_create_info,
    p_next: ?*const anyopaque = null,
    line_rasterization_mode: LineRasterizationMode = @enumFromInt(0),
    stippled_line_enable: Bool32 = .false,
    line_stipple_factor: u32 = 0,
    line_stipple_pattern: u16 = 0,
};
pub const PipelineRasterizationLineStateCreateInfoKHR = PipelineRasterizationLineStateCreateInfo;
pub const PipelineRasterizationLineStateCreateInfoEXT = PipelineRasterizationLineStateCreateInfo;
pub const PhysicalDevicePipelineCreationCacheControlFeatures = extern struct {
    s_type: StructureType = .physical_device_pipeline_creation_cache_control_features,
    p_next: ?*anyopaque = null,
    pipeline_creation_cache_control: Bool32 = .false,
};
pub const PhysicalDevicePipelineCreationCacheControlFeaturesEXT = PhysicalDevicePipelineCreationCacheControlFeatures;
pub const PhysicalDeviceVulkan11Features = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_1_features,
    p_next: ?*anyopaque = null,
    storage_buffer16_bit_access: Bool32 = .false,
    uniform_and_storage_buffer16_bit_access: Bool32 = .false,
    storage_push_constant16: Bool32 = .false,
    storage_input_output16: Bool32 = .false,
    multiview: Bool32 = .false,
    multiview_geometry_shader: Bool32 = .false,
    multiview_tessellation_shader: Bool32 = .false,
    variable_pointers_storage_buffer: Bool32 = .false,
    variable_pointers: Bool32 = .false,
    protected_memory: Bool32 = .false,
    sampler_ycbcr_conversion: Bool32 = .false,
    shader_draw_parameters: Bool32 = .false,
};
pub const PhysicalDeviceVulkan11Properties = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_1_properties,
    p_next: ?*anyopaque = null,
    device_uuid: [uuid_size]u8 = [_]u8{0} ** uuid_size,
    driver_uuid: [uuid_size]u8 = [_]u8{0} ** uuid_size,
    device_luid: [luid_size]u8 = [_]u8{0} ** luid_size,
    device_node_mask: u32 = 0,
    device_luid_valid: Bool32 = .false,
    subgroup_size: u32 = 0,
    subgroup_supported_stages: ShaderStageFlags = .none,
    subgroup_supported_operations: SubgroupFeatureFlags = .none,
    subgroup_quad_operations_in_all_stages: Bool32 = .false,
    point_clipping_behavior: PointClippingBehavior = @enumFromInt(0),
    max_multiview_view_count: u32 = 0,
    max_multiview_instance_index: u32 = 0,
    protected_no_fault: Bool32 = .false,
    max_per_set_descriptors: u32 = 0,
    max_memory_allocation_size: DeviceSize = 0,
};
pub const PhysicalDeviceVulkan12Features = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_2_features,
    p_next: ?*anyopaque = null,
    sampler_mirror_clamp_to_edge: Bool32 = .false,
    draw_indirect_count: Bool32 = .false,
    storage_buffer8_bit_access: Bool32 = .false,
    uniform_and_storage_buffer8_bit_access: Bool32 = .false,
    storage_push_constant8: Bool32 = .false,
    shader_buffer_int64_atomics: Bool32 = .false,
    shader_shared_int64_atomics: Bool32 = .false,
    shader_float16: Bool32 = .false,
    shader_int8: Bool32 = .false,
    descriptor_indexing: Bool32 = .false,
    shader_input_attachment_array_dynamic_indexing: Bool32 = .false,
    shader_uniform_texel_buffer_array_dynamic_indexing: Bool32 = .false,
    shader_storage_texel_buffer_array_dynamic_indexing: Bool32 = .false,
    shader_uniform_buffer_array_non_uniform_indexing: Bool32 = .false,
    shader_sampled_image_array_non_uniform_indexing: Bool32 = .false,
    shader_storage_buffer_array_non_uniform_indexing: Bool32 = .false,
    shader_storage_image_array_non_uniform_indexing: Bool32 = .false,
    shader_input_attachment_array_non_uniform_indexing: Bool32 = .false,
    shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32 = .false,
    shader_storage_texel_buffer_array_non_uniform_indexing: Bool32 = .false,
    descriptor_binding_uniform_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_sampled_image_update_after_bind: Bool32 = .false,
    descriptor_binding_storage_image_update_after_bind: Bool32 = .false,
    descriptor_binding_storage_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_storage_texel_buffer_update_after_bind: Bool32 = .false,
    descriptor_binding_update_unused_while_pending: Bool32 = .false,
    descriptor_binding_partially_bound: Bool32 = .false,
    descriptor_binding_variable_descriptor_count: Bool32 = .false,
    runtime_descriptor_array: Bool32 = .false,
    sampler_filter_minmax: Bool32 = .false,
    scalar_block_layout: Bool32 = .false,
    imageless_framebuffer: Bool32 = .false,
    uniform_buffer_standard_layout: Bool32 = .false,
    shader_subgroup_extended_types: Bool32 = .false,
    separate_depth_stencil_layouts: Bool32 = .false,
    host_query_reset: Bool32 = .false,
    timeline_semaphore: Bool32 = .false,
    buffer_device_address: Bool32 = .false,
    buffer_device_address_capture_replay: Bool32 = .false,
    buffer_device_address_multi_device: Bool32 = .false,
    vulkan_memory_model: Bool32 = .false,
    vulkan_memory_model_device_scope: Bool32 = .false,
    vulkan_memory_model_availability_visibility_chains: Bool32 = .false,
    shader_output_viewport_index: Bool32 = .false,
    shader_output_layer: Bool32 = .false,
    subgroup_broadcast_dynamic_id: Bool32 = .false,
};
pub const PhysicalDeviceVulkan12Properties = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_2_properties,
    p_next: ?*anyopaque = null,
    driver_id: DriverId = @enumFromInt(0),
    driver_name: [max_driver_name_size - 1:0]u8 = [_:0]u8{0} ** (max_driver_name_size - 1),
    driver_info: [max_driver_info_size - 1:0]u8 = [_:0]u8{0} ** (max_driver_info_size - 1),
    conformance_version: ConformanceVersion = .{},
    denorm_behavior_independence: ShaderFloatControlsIndependence = @enumFromInt(0),
    rounding_mode_independence: ShaderFloatControlsIndependence = @enumFromInt(0),
    shader_signed_zero_inf_nan_preserve_float16: Bool32 = .false,
    shader_signed_zero_inf_nan_preserve_float32: Bool32 = .false,
    shader_signed_zero_inf_nan_preserve_float64: Bool32 = .false,
    shader_denorm_preserve_float16: Bool32 = .false,
    shader_denorm_preserve_float32: Bool32 = .false,
    shader_denorm_preserve_float64: Bool32 = .false,
    shader_denorm_flush_to_zero_float16: Bool32 = .false,
    shader_denorm_flush_to_zero_float32: Bool32 = .false,
    shader_denorm_flush_to_zero_float64: Bool32 = .false,
    shader_rounding_mode_rte_float16: Bool32 = .false,
    shader_rounding_mode_rte_float32: Bool32 = .false,
    shader_rounding_mode_rte_float64: Bool32 = .false,
    shader_rounding_mode_rtz_float16: Bool32 = .false,
    shader_rounding_mode_rtz_float32: Bool32 = .false,
    shader_rounding_mode_rtz_float64: Bool32 = .false,
    max_update_after_bind_descriptors_in_all_pools: u32 = 0,
    shader_uniform_buffer_array_non_uniform_indexing_native: Bool32 = .false,
    shader_sampled_image_array_non_uniform_indexing_native: Bool32 = .false,
    shader_storage_buffer_array_non_uniform_indexing_native: Bool32 = .false,
    shader_storage_image_array_non_uniform_indexing_native: Bool32 = .false,
    shader_input_attachment_array_non_uniform_indexing_native: Bool32 = .false,
    robust_buffer_access_update_after_bind: Bool32 = .false,
    quad_divergent_implicit_lod: Bool32 = .false,
    max_per_stage_descriptor_update_after_bind_samplers: u32 = 0,
    max_per_stage_descriptor_update_after_bind_uniform_buffers: u32 = 0,
    max_per_stage_descriptor_update_after_bind_storage_buffers: u32 = 0,
    max_per_stage_descriptor_update_after_bind_sampled_images: u32 = 0,
    max_per_stage_descriptor_update_after_bind_storage_images: u32 = 0,
    max_per_stage_descriptor_update_after_bind_input_attachments: u32 = 0,
    max_per_stage_update_after_bind_resources: u32 = 0,
    max_descriptor_set_update_after_bind_samplers: u32 = 0,
    max_descriptor_set_update_after_bind_uniform_buffers: u32 = 0,
    max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32 = 0,
    max_descriptor_set_update_after_bind_storage_buffers: u32 = 0,
    max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32 = 0,
    max_descriptor_set_update_after_bind_sampled_images: u32 = 0,
    max_descriptor_set_update_after_bind_storage_images: u32 = 0,
    max_descriptor_set_update_after_bind_input_attachments: u32 = 0,
    supported_depth_resolve_modes: ResolveModeFlags = .none,
    supported_stencil_resolve_modes: ResolveModeFlags = .none,
    independent_resolve_none: Bool32 = .false,
    independent_resolve: Bool32 = .false,
    filter_minmax_single_component_formats: Bool32 = .false,
    filter_minmax_image_component_mapping: Bool32 = .false,
    max_timeline_semaphore_value_difference: u64 = 0,
    framebuffer_integer_color_sample_counts: SampleCountFlags = .none,
};
pub const PhysicalDeviceVulkan13Features = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_3_features,
    p_next: ?*anyopaque = null,
    robust_image_access: Bool32 = .false,
    inline_uniform_block: Bool32 = .false,
    descriptor_binding_inline_uniform_block_update_after_bind: Bool32 = .false,
    pipeline_creation_cache_control: Bool32 = .false,
    private_data: Bool32 = .false,
    shader_demote_to_helper_invocation: Bool32 = .false,
    shader_terminate_invocation: Bool32 = .false,
    subgroup_size_control: Bool32 = .false,
    compute_full_subgroups: Bool32 = .false,
    synchronization2: Bool32 = .false,
    texture_compression_astc_hdr: Bool32 = .false,
    shader_zero_initialize_workgroup_memory: Bool32 = .false,
    dynamic_rendering: Bool32 = .false,
    shader_integer_dot_product: Bool32 = .false,
    maintenance4: Bool32 = .false,
};
pub const PhysicalDeviceVulkan13Properties = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_3_properties,
    p_next: ?*anyopaque = null,
    min_subgroup_size: u32 = 0,
    max_subgroup_size: u32 = 0,
    max_compute_workgroup_subgroups: u32 = 0,
    required_subgroup_size_stages: ShaderStageFlags = .none,
    max_inline_uniform_block_size: u32 = 0,
    max_per_stage_descriptor_inline_uniform_blocks: u32 = 0,
    max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32 = 0,
    max_descriptor_set_inline_uniform_blocks: u32 = 0,
    max_descriptor_set_update_after_bind_inline_uniform_blocks: u32 = 0,
    max_inline_uniform_total_size: u32 = 0,
    integer_dot_product8_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product8_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product8_bit_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product4x8_bit_packed_unsigned_accelerated: Bool32 = .false,
    integer_dot_product4x8_bit_packed_signed_accelerated: Bool32 = .false,
    integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product16_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product16_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product16_bit_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product32_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product32_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product32_bit_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product64_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product64_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product64_bit_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Bool32 = .false,
    storage_texel_buffer_offset_alignment_bytes: DeviceSize = 0,
    storage_texel_buffer_offset_single_texel_alignment: Bool32 = .false,
    uniform_texel_buffer_offset_alignment_bytes: DeviceSize = 0,
    uniform_texel_buffer_offset_single_texel_alignment: Bool32 = .false,
    max_buffer_size: DeviceSize = 0,
};
pub const PhysicalDeviceVulkan14Features = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_4_features,
    p_next: ?*anyopaque = null,
    global_priority_query: Bool32 = .false,
    shader_subgroup_rotate: Bool32 = .false,
    shader_subgroup_rotate_clustered: Bool32 = .false,
    shader_float_controls2: Bool32 = .false,
    shader_expect_assume: Bool32 = .false,
    rectangular_lines: Bool32 = .false,
    bresenham_lines: Bool32 = .false,
    smooth_lines: Bool32 = .false,
    stippled_rectangular_lines: Bool32 = .false,
    stippled_bresenham_lines: Bool32 = .false,
    stippled_smooth_lines: Bool32 = .false,
    vertex_attribute_instance_rate_divisor: Bool32 = .false,
    vertex_attribute_instance_rate_zero_divisor: Bool32 = .false,
    index_type_uint8: Bool32 = .false,
    dynamic_rendering_local_read: Bool32 = .false,
    maintenance5: Bool32 = .false,
    maintenance6: Bool32 = .false,
    pipeline_protected_access: Bool32 = .false,
    pipeline_robustness: Bool32 = .false,
    host_image_copy: Bool32 = .false,
    push_descriptor: Bool32 = .false,
};
pub const PhysicalDeviceVulkan14Properties = extern struct {
    s_type: StructureType = .physical_device_vulkan_1_4_properties,
    p_next: ?*anyopaque = null,
    line_sub_pixel_precision_bits: u32 = 0,
    max_vertex_attrib_divisor: u32 = 0,
    supports_non_zero_first_instance: Bool32 = .false,
    max_push_descriptors: u32 = 0,
    dynamic_rendering_local_read_depth_stencil_attachments: Bool32 = .false,
    dynamic_rendering_local_read_multisampled_attachments: Bool32 = .false,
    early_fragment_multisample_coverage_after_sample_counting: Bool32 = .false,
    early_fragment_sample_mask_test_before_sample_counting: Bool32 = .false,
    depth_stencil_swizzle_one_support: Bool32 = .false,
    polygon_mode_point_size: Bool32 = .false,
    non_strict_single_pixel_wide_lines_use_parallelogram: Bool32 = .false,
    non_strict_wide_lines_use_parallelogram: Bool32 = .false,
    block_texel_view_compatible_multiple_layers: Bool32 = .false,
    max_combined_image_sampler_descriptor_count: u32 = 0,
    fragment_shading_rate_clamp_combiner_inputs: Bool32 = .false,
    default_robustness_storage_buffers: PipelineRobustnessBufferBehavior = @enumFromInt(0),
    default_robustness_uniform_buffers: PipelineRobustnessBufferBehavior = @enumFromInt(0),
    default_robustness_vertex_inputs: PipelineRobustnessBufferBehavior = @enumFromInt(0),
    default_robustness_images: PipelineRobustnessImageBehavior = @enumFromInt(0),
    copy_src_layout_count: u32 = 0,
    p_copy_src_layouts: ?[*]ImageLayout = null,
    copy_dst_layout_count: u32 = 0,
    p_copy_dst_layouts: ?[*]ImageLayout = null,
    optimal_tiling_layout_uuid: [uuid_size]u8 = [_]u8{0} ** uuid_size,
    identical_memory_type_requirements: Bool32 = .false,
};
pub const PipelineCompilerControlCreateInfoAMD = extern struct {
    s_type: StructureType = .pipeline_compiler_control_create_info_amd,
    p_next: ?*const anyopaque = null,
    compiler_control_flags: PipelineCompilerControlFlagsAMD = .none,
};
pub const PhysicalDeviceCoherentMemoryFeaturesAMD = extern struct {
    s_type: StructureType = .physical_device_coherent_memory_features_amd,
    p_next: ?*anyopaque = null,
    device_coherent_memory: Bool32 = .false,
};
pub const PhysicalDeviceToolProperties = extern struct {
    s_type: StructureType = .physical_device_tool_properties,
    p_next: ?*anyopaque = null,
    name: [max_extension_name_size - 1:0]u8 = [_:0]u8{0} ** (max_extension_name_size - 1),
    version: [max_extension_name_size - 1:0]u8 = [_:0]u8{0} ** (max_extension_name_size - 1),
    purposes: ToolPurposeFlags = .none,
    description: [max_description_size - 1:0]u8 = [_:0]u8{0} ** (max_description_size - 1),
    layer: [max_extension_name_size - 1:0]u8 = [_:0]u8{0} ** (max_extension_name_size - 1),
};
pub const PhysicalDeviceToolPropertiesEXT = PhysicalDeviceToolProperties;
pub const SamplerCustomBorderColorCreateInfoEXT = extern struct {
    s_type: StructureType = .sampler_custom_border_color_create_info_ext,
    p_next: ?*const anyopaque = null,
    custom_border_color: ClearColorValue = .{ .float32 = [_]f32{0} ** 4 },
    format: Format = @enumFromInt(0),
};
pub const PhysicalDeviceCustomBorderColorPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_custom_border_color_properties_ext,
    p_next: ?*anyopaque = null,
    max_custom_border_color_samplers: u32 = 0,
};
pub const PhysicalDeviceCustomBorderColorFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_custom_border_color_features_ext,
    p_next: ?*anyopaque = null,
    custom_border_colors: Bool32 = .false,
    custom_border_color_without_format: Bool32 = .false,
};
pub const SamplerBorderColorComponentMappingCreateInfoEXT = extern struct {
    s_type: StructureType = .sampler_border_color_component_mapping_create_info_ext,
    p_next: ?*const anyopaque = null,
    components: ComponentMapping = .{},
    srgb: Bool32 = .false,
};
pub const PhysicalDeviceBorderColorSwizzleFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_border_color_swizzle_features_ext,
    p_next: ?*anyopaque = null,
    border_color_swizzle: Bool32 = .false,
    border_color_swizzle_from_image: Bool32 = .false,
};
pub const DeviceOrHostAddressKHR = extern union {
    device_address: DeviceAddress,
    host_address: ?*anyopaque,
};
pub const DeviceOrHostAddressConstKHR = extern union {
    device_address: DeviceAddress,
    host_address: ?*const anyopaque,
};
pub const DeviceOrHostAddressConstAMDX = extern union {
    device_address: DeviceAddress,
    host_address: ?*const anyopaque,
};
pub const AccelerationStructureGeometryTrianglesDataKHR = extern struct {
    s_type: StructureType = .acceleration_structure_geometry_triangles_data_khr,
    p_next: ?*const anyopaque = null,
    vertex_format: Format = @enumFromInt(0),
    vertex_data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    vertex_stride: DeviceSize = 0,
    max_vertex: u32 = 0,
    index_type: IndexType = @enumFromInt(0),
    index_data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    transform_data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *AccelerationStructureGeometryMotionTrianglesDataNV,
            *AccelerationStructureTrianglesOpacityMicromapEXT,
            *AccelerationStructureTrianglesDisplacementMicromapNV,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const AccelerationStructureGeometryAabbsDataKHR = extern struct {
    s_type: StructureType = .acceleration_structure_geometry_aabbs_data_khr,
    p_next: ?*const anyopaque = null,
    data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    stride: DeviceSize = 0,
};
pub const AccelerationStructureGeometryInstancesDataKHR = extern struct {
    s_type: StructureType = .acceleration_structure_geometry_instances_data_khr,
    p_next: ?*const anyopaque = null,
    array_of_pointers: Bool32 = .false,
    data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
};
pub const AccelerationStructureGeometryLinearSweptSpheresDataNV = extern struct {
    s_type: StructureType = .acceleration_structure_geometry_linear_swept_spheres_data_nv,
    p_next: ?*const anyopaque = null,
    vertex_format: Format = @enumFromInt(0),
    vertex_data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    vertex_stride: DeviceSize = 0,
    radius_format: Format = @enumFromInt(0),
    radius_data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    radius_stride: DeviceSize = 0,
    index_type: IndexType = @enumFromInt(0),
    index_data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    index_stride: DeviceSize = 0,
    indexing_mode: RayTracingLssIndexingModeNV = @enumFromInt(0),
    end_caps_mode: RayTracingLssPrimitiveEndCapsModeNV = @enumFromInt(0),
};
pub const AccelerationStructureGeometrySpheresDataNV = extern struct {
    s_type: StructureType = .acceleration_structure_geometry_spheres_data_nv,
    p_next: ?*const anyopaque = null,
    vertex_format: Format = @enumFromInt(0),
    vertex_data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    vertex_stride: DeviceSize = 0,
    radius_format: Format = @enumFromInt(0),
    radius_data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    radius_stride: DeviceSize = 0,
    index_type: IndexType = @enumFromInt(0),
    index_data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    index_stride: DeviceSize = 0,
};
pub const AccelerationStructureGeometryDataKHR = extern union {
    triangles: AccelerationStructureGeometryTrianglesDataKHR,
    aabbs: AccelerationStructureGeometryAabbsDataKHR,
    instances: AccelerationStructureGeometryInstancesDataKHR,
};
pub const AccelerationStructureGeometryKHR = extern struct {
    s_type: StructureType = .acceleration_structure_geometry_khr,
    p_next: ?*const anyopaque = null,
    geometry_type: GeometryTypeKHR = @enumFromInt(0),
    geometry: AccelerationStructureGeometryDataKHR = .{ .triangles = .{} },
    flags: GeometryFlagsKHR = .none,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *AccelerationStructureGeometryLinearSweptSpheresDataNV,
            *AccelerationStructureGeometrySpheresDataNV,
            *AccelerationStructureDenseGeometryFormatTrianglesDataAMDX,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const AccelerationStructureBuildGeometryInfoKHR = extern struct {
    s_type: StructureType = .acceleration_structure_build_geometry_info_khr,
    p_next: ?*const anyopaque = null,
    type: AccelerationStructureTypeKHR = @enumFromInt(0),
    flags: BuildAccelerationStructureFlagsKHR = .none,
    mode: BuildAccelerationStructureModeKHR = @enumFromInt(0),
    src_acceleration_structure: AccelerationStructureKHR = .null_handle,
    dst_acceleration_structure: AccelerationStructureKHR = .null_handle,
    geometry_count: u32 = 0,
    p_geometries: ?[*]const AccelerationStructureGeometryKHR = null,
    pp_geometries: ?[*]const ?*const AccelerationStructureGeometryKHR = null,
    scratch_data: DeviceOrHostAddressKHR = .{ .device_address = 0 },
};
pub const AccelerationStructureBuildRangeInfoKHR = extern struct {
    primitive_count: u32 = 0,
    primitive_offset: u32 = 0,
    first_vertex: u32 = 0,
    transform_offset: u32 = 0,
};
pub const AccelerationStructureCreateInfoKHR = extern struct {
    s_type: StructureType = .acceleration_structure_create_info_khr,
    p_next: ?*const anyopaque = null,
    create_flags: AccelerationStructureCreateFlagsKHR = .none,
    buffer: Buffer = .null_handle,
    offset: DeviceSize = 0,
    size: DeviceSize = 0,
    type: AccelerationStructureTypeKHR = @enumFromInt(0),
    device_address: DeviceAddress = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *OpaqueCaptureDescriptorDataCreateInfoEXT,
            *AccelerationStructureMotionInfoNV,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const AabbPositionsKHR = extern struct {
    min_x: f32 = 0,
    min_y: f32 = 0,
    min_z: f32 = 0,
    max_x: f32 = 0,
    max_y: f32 = 0,
    max_z: f32 = 0,
};
pub const AabbPositionsNV = AabbPositionsKHR;
pub const TransformMatrixKHR = extern struct {
    matrix: [12]f32 = [_]f32{0} ** 12,
};
pub const TransformMatrixNV = TransformMatrixKHR;
pub const AccelerationStructureInstanceKHR = extern struct {
    transform: TransformMatrixKHR = .{},
    instance_custom_index_and_mask: u32 = 0,
    instance_shader_binding_table_record_offset_and_flags: u32 = 0,
    acceleration_structure_reference: u64 = 0,
};
pub const AccelerationStructureInstanceNV = AccelerationStructureInstanceKHR;
pub const AccelerationStructureDeviceAddressInfoKHR = extern struct {
    s_type: StructureType = .acceleration_structure_device_address_info_khr,
    p_next: ?*const anyopaque = null,
    acceleration_structure: AccelerationStructureKHR = .null_handle,
};
pub const AccelerationStructureVersionInfoKHR = extern struct {
    s_type: StructureType = .acceleration_structure_version_info_khr,
    p_next: ?*const anyopaque = null,
    p_version_data: ?[*]const u8 = null,
};
pub const CopyAccelerationStructureInfoKHR = extern struct {
    s_type: StructureType = .copy_acceleration_structure_info_khr,
    p_next: ?*const anyopaque = null,
    src: AccelerationStructureKHR = .null_handle,
    dst: AccelerationStructureKHR = .null_handle,
    mode: CopyAccelerationStructureModeKHR = @enumFromInt(0),
};
pub const CopyAccelerationStructureToMemoryInfoKHR = extern struct {
    s_type: StructureType = .copy_acceleration_structure_to_memory_info_khr,
    p_next: ?*const anyopaque = null,
    src: AccelerationStructureKHR = .null_handle,
    dst: DeviceOrHostAddressKHR = .{ .device_address = 0 },
    mode: CopyAccelerationStructureModeKHR = @enumFromInt(0),
};
pub const CopyMemoryToAccelerationStructureInfoKHR = extern struct {
    s_type: StructureType = .copy_memory_to_acceleration_structure_info_khr,
    p_next: ?*const anyopaque = null,
    src: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    dst: AccelerationStructureKHR = .null_handle,
    mode: CopyAccelerationStructureModeKHR = @enumFromInt(0),
};
pub const RayTracingPipelineInterfaceCreateInfoKHR = extern struct {
    s_type: StructureType = .ray_tracing_pipeline_interface_create_info_khr,
    p_next: ?*const anyopaque = null,
    max_pipeline_ray_payload_size: u32 = 0,
    max_pipeline_ray_hit_attribute_size: u32 = 0,
};
pub const PipelineLibraryCreateInfoKHR = extern struct {
    s_type: StructureType = .pipeline_library_create_info_khr,
    p_next: ?*const anyopaque = null,
    library_count: u32 = 0,
    p_libraries: ?[*]const Pipeline = null,
};
pub const PhysicalDeviceExtendedDynamicStateFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_extended_dynamic_state_features_ext,
    p_next: ?*anyopaque = null,
    extended_dynamic_state: Bool32 = .false,
};
pub const PhysicalDeviceExtendedDynamicState2FeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_extended_dynamic_state_2_features_ext,
    p_next: ?*anyopaque = null,
    extended_dynamic_state2: Bool32 = .false,
    extended_dynamic_state2_logic_op: Bool32 = .false,
    extended_dynamic_state2_patch_control_points: Bool32 = .false,
};
pub const PhysicalDeviceExtendedDynamicState3FeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_extended_dynamic_state_3_features_ext,
    p_next: ?*anyopaque = null,
    extended_dynamic_state3_tessellation_domain_origin: Bool32 = .false,
    extended_dynamic_state3_depth_clamp_enable: Bool32 = .false,
    extended_dynamic_state3_polygon_mode: Bool32 = .false,
    extended_dynamic_state3_rasterization_samples: Bool32 = .false,
    extended_dynamic_state3_sample_mask: Bool32 = .false,
    extended_dynamic_state3_alpha_to_coverage_enable: Bool32 = .false,
    extended_dynamic_state3_alpha_to_one_enable: Bool32 = .false,
    extended_dynamic_state3_logic_op_enable: Bool32 = .false,
    extended_dynamic_state3_color_blend_enable: Bool32 = .false,
    extended_dynamic_state3_color_blend_equation: Bool32 = .false,
    extended_dynamic_state3_color_write_mask: Bool32 = .false,
    extended_dynamic_state3_rasterization_stream: Bool32 = .false,
    extended_dynamic_state3_conservative_rasterization_mode: Bool32 = .false,
    extended_dynamic_state3_extra_primitive_overestimation_size: Bool32 = .false,
    extended_dynamic_state3_depth_clip_enable: Bool32 = .false,
    extended_dynamic_state3_sample_locations_enable: Bool32 = .false,
    extended_dynamic_state3_color_blend_advanced: Bool32 = .false,
    extended_dynamic_state3_provoking_vertex_mode: Bool32 = .false,
    extended_dynamic_state3_line_rasterization_mode: Bool32 = .false,
    extended_dynamic_state3_line_stipple_enable: Bool32 = .false,
    extended_dynamic_state3_depth_clip_negative_one_to_one: Bool32 = .false,
    extended_dynamic_state3_viewport_w_scaling_enable: Bool32 = .false,
    extended_dynamic_state3_viewport_swizzle: Bool32 = .false,
    extended_dynamic_state3_coverage_to_color_enable: Bool32 = .false,
    extended_dynamic_state3_coverage_to_color_location: Bool32 = .false,
    extended_dynamic_state3_coverage_modulation_mode: Bool32 = .false,
    extended_dynamic_state3_coverage_modulation_table_enable: Bool32 = .false,
    extended_dynamic_state3_coverage_modulation_table: Bool32 = .false,
    extended_dynamic_state3_coverage_reduction_mode: Bool32 = .false,
    extended_dynamic_state3_representative_fragment_test_enable: Bool32 = .false,
    extended_dynamic_state3_shading_rate_image_enable: Bool32 = .false,
};
pub const PhysicalDeviceExtendedDynamicState3PropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_extended_dynamic_state_3_properties_ext,
    p_next: ?*anyopaque = null,
    dynamic_primitive_topology_unrestricted: Bool32 = .false,
};
pub const ColorBlendEquationEXT = extern struct {
    src_color_blend_factor: BlendFactor = @enumFromInt(0),
    dst_color_blend_factor: BlendFactor = @enumFromInt(0),
    color_blend_op: BlendOp = @enumFromInt(0),
    src_alpha_blend_factor: BlendFactor = @enumFromInt(0),
    dst_alpha_blend_factor: BlendFactor = @enumFromInt(0),
    alpha_blend_op: BlendOp = @enumFromInt(0),
};
pub const ColorBlendAdvancedEXT = extern struct {
    advanced_blend_op: BlendOp = @enumFromInt(0),
    src_premultiplied: Bool32 = .false,
    dst_premultiplied: Bool32 = .false,
    blend_overlap: BlendOverlapEXT = @enumFromInt(0),
    clamp_results: Bool32 = .false,
};
pub const RenderPassTransformBeginInfoQCOM = extern struct {
    s_type: StructureType = .render_pass_transform_begin_info_qcom,
    p_next: ?*const anyopaque = null,
    transform: SurfaceTransformFlagsKHR = .none,
};
pub const CopyCommandTransformInfoQCOM = extern struct {
    s_type: StructureType = .copy_command_transform_info_qcom,
    p_next: ?*const anyopaque = null,
    transform: SurfaceTransformFlagsKHR = .none,
};
pub const CommandBufferInheritanceRenderPassTransformInfoQCOM = extern struct {
    s_type: StructureType = .command_buffer_inheritance_render_pass_transform_info_qcom,
    p_next: ?*const anyopaque = null,
    transform: SurfaceTransformFlagsKHR = .none,
    render_area: Rect2D = .{},
};
pub const PhysicalDevicePartitionedAccelerationStructureFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_partitioned_acceleration_structure_features_nv,
    p_next: ?*anyopaque = null,
    partitioned_acceleration_structure: Bool32 = .false,
};
pub const PhysicalDevicePartitionedAccelerationStructurePropertiesNV = extern struct {
    s_type: StructureType = .physical_device_partitioned_acceleration_structure_properties_nv,
    p_next: ?*anyopaque = null,
    max_partition_count: u32 = 0,
};
pub const BuildPartitionedAccelerationStructureIndirectCommandNV = extern struct {
    op_type: PartitionedAccelerationStructureOpTypeNV = @enumFromInt(0),
    arg_count: u32 = 0,
    arg_data: StridedDeviceAddressNV = .{},
};
pub const PartitionedAccelerationStructureFlagsNV = extern struct {
    s_type: StructureType = .partitioned_acceleration_structure_flags_nv,
    p_next: ?*anyopaque = null,
    enable_partition_translation: Bool32 = .false,
};
pub const PartitionedAccelerationStructureWriteInstanceDataNV = extern struct {
    transform: TransformMatrixKHR = .{},
    explicit_aabb: [6]f32 = [_]f32{0} ** 6,
    instance_id: u32 = 0,
    instance_mask: u32 = 0,
    instance_contribution_to_hit_group_index: u32 = 0,
    instance_flags: PartitionedAccelerationStructureInstanceFlagsNV = .none,
    instance_index: u32 = 0,
    partition_index: u32 = 0,
    acceleration_structure: DeviceAddress = 0,
};
pub const PartitionedAccelerationStructureUpdateInstanceDataNV = extern struct {
    instance_index: u32 = 0,
    instance_contribution_to_hit_group_index: u32 = 0,
    acceleration_structure: DeviceAddress = 0,
};
pub const PartitionedAccelerationStructureWritePartitionTranslationDataNV = extern struct {
    partition_index: u32 = 0,
    partition_translation: [3]f32 = [_]f32{0} ** 3,
};
pub const WriteDescriptorSetPartitionedAccelerationStructureNV = extern struct {
    s_type: StructureType = .write_descriptor_set_partitioned_acceleration_structure_nv,
    p_next: ?*anyopaque = null,
    acceleration_structure_count: u32 = 0,
    p_acceleration_structures: ?[*]const DeviceAddress = null,
};
pub const PartitionedAccelerationStructureInstancesInputNV = extern struct {
    s_type: StructureType = .partitioned_acceleration_structure_instances_input_nv,
    p_next: ?*anyopaque = null,
    flags: BuildAccelerationStructureFlagsKHR = .none,
    instance_count: u32 = 0,
    max_instance_per_partition_count: u32 = 0,
    partition_count: u32 = 0,
    max_instance_in_global_partition_count: u32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PartitionedAccelerationStructureFlagsNV,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const BuildPartitionedAccelerationStructureInfoNV = extern struct {
    s_type: StructureType = .build_partitioned_acceleration_structure_info_nv,
    p_next: ?*anyopaque = null,
    input: PartitionedAccelerationStructureInstancesInputNV = .{},
    src_acceleration_structure_data: DeviceAddress = 0,
    dst_acceleration_structure_data: DeviceAddress = 0,
    scratch_data: DeviceAddress = 0,
    src_infos: DeviceAddress = 0,
    src_infos_count: DeviceAddress = 0,
};
pub const PhysicalDeviceDiagnosticsConfigFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_diagnostics_config_features_nv,
    p_next: ?*anyopaque = null,
    diagnostics_config: Bool32 = .false,
};
pub const DeviceDiagnosticsConfigCreateInfoNV = extern struct {
    s_type: StructureType = .device_diagnostics_config_create_info_nv,
    p_next: ?*const anyopaque = null,
    flags: DeviceDiagnosticsConfigFlagsNV = .none,
};
pub const PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = extern struct {
    s_type: StructureType = .physical_device_zero_initialize_workgroup_memory_features,
    p_next: ?*anyopaque = null,
    shader_zero_initialize_workgroup_memory: Bool32 = .false,
};
pub const PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
pub const PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_shader_subgroup_uniform_control_flow_features_khr,
    p_next: ?*anyopaque = null,
    shader_subgroup_uniform_control_flow: Bool32 = .false,
};
pub const PhysicalDeviceRobustness2FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_robustness_2_features_khr,
    p_next: ?*anyopaque = null,
    robust_buffer_access2: Bool32 = .false,
    robust_image_access2: Bool32 = .false,
    null_descriptor: Bool32 = .false,
};
pub const PhysicalDeviceRobustness2FeaturesEXT = PhysicalDeviceRobustness2FeaturesKHR;
pub const PhysicalDeviceRobustness2PropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_robustness_2_properties_khr,
    p_next: ?*anyopaque = null,
    robust_storage_buffer_access_size_alignment: DeviceSize = 0,
    robust_uniform_buffer_access_size_alignment: DeviceSize = 0,
};
pub const PhysicalDeviceRobustness2PropertiesEXT = PhysicalDeviceRobustness2PropertiesKHR;
pub const PhysicalDeviceImageRobustnessFeatures = extern struct {
    s_type: StructureType = .physical_device_image_robustness_features,
    p_next: ?*anyopaque = null,
    robust_image_access: Bool32 = .false,
};
pub const PhysicalDeviceImageRobustnessFeaturesEXT = PhysicalDeviceImageRobustnessFeatures;
pub const PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_workgroup_memory_explicit_layout_features_khr,
    p_next: ?*anyopaque = null,
    workgroup_memory_explicit_layout: Bool32 = .false,
    workgroup_memory_explicit_layout_scalar_block_layout: Bool32 = .false,
    workgroup_memory_explicit_layout8_bit_access: Bool32 = .false,
    workgroup_memory_explicit_layout16_bit_access: Bool32 = .false,
};
pub const PhysicalDevicePortabilitySubsetFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_portability_subset_features_khr,
    p_next: ?*anyopaque = null,
    constant_alpha_color_blend_factors: Bool32 = .false,
    events: Bool32 = .false,
    image_view_format_reinterpretation: Bool32 = .false,
    image_view_format_swizzle: Bool32 = .false,
    image_view_2d_on_3d_image: Bool32 = .false,
    multisample_array_image: Bool32 = .false,
    mutable_comparison_samplers: Bool32 = .false,
    point_polygons: Bool32 = .false,
    sampler_mip_lod_bias: Bool32 = .false,
    separate_stencil_mask_ref: Bool32 = .false,
    shader_sample_rate_interpolation_functions: Bool32 = .false,
    tessellation_isolines: Bool32 = .false,
    tessellation_point_mode: Bool32 = .false,
    triangle_fans: Bool32 = .false,
    vertex_attribute_access_beyond_stride: Bool32 = .false,
};
pub const PhysicalDevicePortabilitySubsetPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_portability_subset_properties_khr,
    p_next: ?*anyopaque = null,
    min_vertex_input_binding_stride_alignment: u32 = 0,
};
pub const PhysicalDevice4444FormatsFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_4444_formats_features_ext,
    p_next: ?*anyopaque = null,
    format_a4r4g4b4: Bool32 = .false,
    format_a4b4g4r4: Bool32 = .false,
};
pub const PhysicalDeviceSubpassShadingFeaturesHUAWEI = extern struct {
    s_type: StructureType = .physical_device_subpass_shading_features_huawei,
    p_next: ?*anyopaque = null,
    subpass_shading: Bool32 = .false,
};
pub const PhysicalDeviceClusterCullingShaderFeaturesHUAWEI = extern struct {
    s_type: StructureType = .physical_device_cluster_culling_shader_features_huawei,
    p_next: ?*anyopaque = null,
    clusterculling_shader: Bool32 = .false,
    multiview_cluster_culling_shader: Bool32 = .false,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI = extern struct {
    s_type: StructureType = .physical_device_cluster_culling_shader_vrs_features_huawei,
    p_next: ?*anyopaque = null,
    cluster_shading_rate: Bool32 = .false,
};
pub const BufferCopy2 = extern struct {
    s_type: StructureType = .buffer_copy_2,
    p_next: ?*const anyopaque = null,
    src_offset: DeviceSize = 0,
    dst_offset: DeviceSize = 0,
    size: DeviceSize = 0,
};
pub const BufferCopy2KHR = BufferCopy2;
pub const ImageCopy2 = extern struct {
    s_type: StructureType = .image_copy_2,
    p_next: ?*const anyopaque = null,
    src_subresource: ImageSubresourceLayers = .{},
    src_offset: Offset3D = .{},
    dst_subresource: ImageSubresourceLayers = .{},
    dst_offset: Offset3D = .{},
    extent: Extent3D = .{},
};
pub const ImageCopy2KHR = ImageCopy2;
pub const ImageBlit2 = extern struct {
    s_type: StructureType = .image_blit_2,
    p_next: ?*const anyopaque = null,
    src_subresource: ImageSubresourceLayers = .{},
    src_offsets: [2]Offset3D = [_]Offset3D{.{}} ** 2,
    dst_subresource: ImageSubresourceLayers = .{},
    dst_offsets: [2]Offset3D = [_]Offset3D{.{}} ** 2,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *CopyCommandTransformInfoQCOM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const ImageBlit2KHR = ImageBlit2;
pub const BufferImageCopy2 = extern struct {
    s_type: StructureType = .buffer_image_copy_2,
    p_next: ?*const anyopaque = null,
    buffer_offset: DeviceSize = 0,
    buffer_row_length: u32 = 0,
    buffer_image_height: u32 = 0,
    image_subresource: ImageSubresourceLayers = .{},
    image_offset: Offset3D = .{},
    image_extent: Extent3D = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *CopyCommandTransformInfoQCOM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const BufferImageCopy2KHR = BufferImageCopy2;
pub const ImageResolve2 = extern struct {
    s_type: StructureType = .image_resolve_2,
    p_next: ?*const anyopaque = null,
    src_subresource: ImageSubresourceLayers = .{},
    src_offset: Offset3D = .{},
    dst_subresource: ImageSubresourceLayers = .{},
    dst_offset: Offset3D = .{},
    extent: Extent3D = .{},
};
pub const ImageResolve2KHR = ImageResolve2;
pub const CopyBufferInfo2 = extern struct {
    s_type: StructureType = .copy_buffer_info_2,
    p_next: ?*const anyopaque = null,
    src_buffer: Buffer = .null_handle,
    dst_buffer: Buffer = .null_handle,
    region_count: u32 = 0,
    p_regions: ?[*]const BufferCopy2 = null,
};
pub const CopyBufferInfo2KHR = CopyBufferInfo2;
pub const CopyImageInfo2 = extern struct {
    s_type: StructureType = .copy_image_info_2,
    p_next: ?*const anyopaque = null,
    src_image: Image = .null_handle,
    src_image_layout: ImageLayout = @enumFromInt(0),
    dst_image: Image = .null_handle,
    dst_image_layout: ImageLayout = @enumFromInt(0),
    region_count: u32 = 0,
    p_regions: ?[*]const ImageCopy2 = null,
};
pub const CopyImageInfo2KHR = CopyImageInfo2;
pub const BlitImageInfo2 = extern struct {
    s_type: StructureType = .blit_image_info_2,
    p_next: ?*const anyopaque = null,
    src_image: Image = .null_handle,
    src_image_layout: ImageLayout = @enumFromInt(0),
    dst_image: Image = .null_handle,
    dst_image_layout: ImageLayout = @enumFromInt(0),
    region_count: u32 = 0,
    p_regions: ?[*]const ImageBlit2 = null,
    filter: Filter = @enumFromInt(0),
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *BlitImageCubicWeightsInfoQCOM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const BlitImageInfo2KHR = BlitImageInfo2;
pub const CopyBufferToImageInfo2 = extern struct {
    s_type: StructureType = .copy_buffer_to_image_info_2,
    p_next: ?*const anyopaque = null,
    src_buffer: Buffer = .null_handle,
    dst_image: Image = .null_handle,
    dst_image_layout: ImageLayout = @enumFromInt(0),
    region_count: u32 = 0,
    p_regions: ?[*]const BufferImageCopy2 = null,
};
pub const CopyBufferToImageInfo2KHR = CopyBufferToImageInfo2;
pub const CopyImageToBufferInfo2 = extern struct {
    s_type: StructureType = .copy_image_to_buffer_info_2,
    p_next: ?*const anyopaque = null,
    src_image: Image = .null_handle,
    src_image_layout: ImageLayout = @enumFromInt(0),
    dst_buffer: Buffer = .null_handle,
    region_count: u32 = 0,
    p_regions: ?[*]const BufferImageCopy2 = null,
};
pub const CopyImageToBufferInfo2KHR = CopyImageToBufferInfo2;
pub const ResolveImageInfo2 = extern struct {
    s_type: StructureType = .resolve_image_info_2,
    p_next: ?*const anyopaque = null,
    src_image: Image = .null_handle,
    src_image_layout: ImageLayout = @enumFromInt(0),
    dst_image: Image = .null_handle,
    dst_image_layout: ImageLayout = @enumFromInt(0),
    region_count: u32 = 0,
    p_regions: ?[*]const ImageResolve2 = null,
};
pub const ResolveImageInfo2KHR = ResolveImageInfo2;
pub const PhysicalDeviceShaderImageAtomicInt64FeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_image_atomic_int64_features_ext,
    p_next: ?*anyopaque = null,
    shader_image_int64_atomics: Bool32 = .false,
    sparse_image_int64_atomics: Bool32 = .false,
};
pub const FragmentShadingRateAttachmentInfoKHR = extern struct {
    s_type: StructureType = .fragment_shading_rate_attachment_info_khr,
    p_next: ?*const anyopaque = null,
    p_fragment_shading_rate_attachment: ?*const AttachmentReference2 = null,
    shading_rate_attachment_texel_size: Extent2D = .{},
};
pub const PipelineFragmentShadingRateStateCreateInfoKHR = extern struct {
    s_type: StructureType = .pipeline_fragment_shading_rate_state_create_info_khr,
    p_next: ?*const anyopaque = null,
    fragment_size: Extent2D = .{},
    combiner_ops: [2]FragmentShadingRateCombinerOpKHR = [_]FragmentShadingRateCombinerOpKHR{@enumFromInt(0)} ** 2,
};
pub const PhysicalDeviceFragmentShadingRateFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_fragment_shading_rate_features_khr,
    p_next: ?*anyopaque = null,
    pipeline_fragment_shading_rate: Bool32 = .false,
    primitive_fragment_shading_rate: Bool32 = .false,
    attachment_fragment_shading_rate: Bool32 = .false,
};
pub const PhysicalDeviceFragmentShadingRatePropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_fragment_shading_rate_properties_khr,
    p_next: ?*anyopaque = null,
    min_fragment_shading_rate_attachment_texel_size: Extent2D = .{},
    max_fragment_shading_rate_attachment_texel_size: Extent2D = .{},
    max_fragment_shading_rate_attachment_texel_size_aspect_ratio: u32 = 0,
    primitive_fragment_shading_rate_with_multiple_viewports: Bool32 = .false,
    layered_shading_rate_attachments: Bool32 = .false,
    fragment_shading_rate_non_trivial_combiner_ops: Bool32 = .false,
    max_fragment_size: Extent2D = .{},
    max_fragment_size_aspect_ratio: u32 = 0,
    max_fragment_shading_rate_coverage_samples: u32 = 0,
    max_fragment_shading_rate_rasterization_samples: SampleCountFlags = .none,
    fragment_shading_rate_with_shader_depth_stencil_writes: Bool32 = .false,
    fragment_shading_rate_with_sample_mask: Bool32 = .false,
    fragment_shading_rate_with_shader_sample_mask: Bool32 = .false,
    fragment_shading_rate_with_conservative_rasterization: Bool32 = .false,
    fragment_shading_rate_with_fragment_shader_interlock: Bool32 = .false,
    fragment_shading_rate_with_custom_sample_locations: Bool32 = .false,
    fragment_shading_rate_strict_multiply_combiner: Bool32 = .false,
};
pub const PhysicalDeviceFragmentShadingRateKHR = extern struct {
    s_type: StructureType = .physical_device_fragment_shading_rate_khr,
    p_next: ?*anyopaque = null,
    sample_counts: SampleCountFlags = .none,
    fragment_size: Extent2D = .{},
};
pub const PhysicalDeviceShaderTerminateInvocationFeatures = extern struct {
    s_type: StructureType = .physical_device_shader_terminate_invocation_features,
    p_next: ?*anyopaque = null,
    shader_terminate_invocation: Bool32 = .false,
};
pub const PhysicalDeviceShaderTerminateInvocationFeaturesKHR = PhysicalDeviceShaderTerminateInvocationFeatures;
pub const PhysicalDeviceFragmentShadingRateEnumsFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_fragment_shading_rate_enums_features_nv,
    p_next: ?*anyopaque = null,
    fragment_shading_rate_enums: Bool32 = .false,
    supersample_fragment_shading_rates: Bool32 = .false,
    no_invocation_fragment_shading_rates: Bool32 = .false,
};
pub const PhysicalDeviceFragmentShadingRateEnumsPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_fragment_shading_rate_enums_properties_nv,
    p_next: ?*anyopaque = null,
    max_fragment_shading_rate_invocation_count: SampleCountFlags = .none,
};
pub const PipelineFragmentShadingRateEnumStateCreateInfoNV = extern struct {
    s_type: StructureType = .pipeline_fragment_shading_rate_enum_state_create_info_nv,
    p_next: ?*const anyopaque = null,
    shading_rate_type: FragmentShadingRateTypeNV = @enumFromInt(0),
    shading_rate: FragmentShadingRateNV = @enumFromInt(0),
    combiner_ops: [2]FragmentShadingRateCombinerOpKHR = [_]FragmentShadingRateCombinerOpKHR{@enumFromInt(0)} ** 2,
};
pub const AccelerationStructureBuildSizesInfoKHR = extern struct {
    s_type: StructureType = .acceleration_structure_build_sizes_info_khr,
    p_next: ?*const anyopaque = null,
    acceleration_structure_size: DeviceSize = 0,
    update_scratch_size: DeviceSize = 0,
    build_scratch_size: DeviceSize = 0,
};
pub const PhysicalDeviceImage2DViewOf3DFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_image_2d_view_of_3d_features_ext,
    p_next: ?*anyopaque = null,
    image_2d_view_of_3d: Bool32 = .false,
    sampler_2d_view_of_3d: Bool32 = .false,
};
pub const PhysicalDeviceImageSlicedViewOf3DFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_image_sliced_view_of_3d_features_ext,
    p_next: ?*anyopaque = null,
    image_sliced_view_of_3d: Bool32 = .false,
};
pub const PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_attachment_feedback_loop_dynamic_state_features_ext,
    p_next: ?*anyopaque = null,
    attachment_feedback_loop_dynamic_state: Bool32 = .false,
};
pub const PhysicalDeviceLegacyVertexAttributesFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_legacy_vertex_attributes_features_ext,
    p_next: ?*anyopaque = null,
    legacy_vertex_attributes: Bool32 = .false,
};
pub const PhysicalDeviceLegacyVertexAttributesPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_legacy_vertex_attributes_properties_ext,
    p_next: ?*anyopaque = null,
    native_unaligned_performance: Bool32 = .false,
};
pub const PhysicalDeviceMutableDescriptorTypeFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_mutable_descriptor_type_features_ext,
    p_next: ?*anyopaque = null,
    mutable_descriptor_type: Bool32 = .false,
};
pub const PhysicalDeviceMutableDescriptorTypeFeaturesVALVE = PhysicalDeviceMutableDescriptorTypeFeaturesEXT;
pub const MutableDescriptorTypeListEXT = extern struct {
    descriptor_type_count: u32 = 0,
    p_descriptor_types: ?[*]const DescriptorType = null,
};
pub const MutableDescriptorTypeListVALVE = MutableDescriptorTypeListEXT;
pub const MutableDescriptorTypeCreateInfoEXT = extern struct {
    s_type: StructureType = .mutable_descriptor_type_create_info_ext,
    p_next: ?*const anyopaque = null,
    mutable_descriptor_type_list_count: u32 = 0,
    p_mutable_descriptor_type_lists: ?[*]const MutableDescriptorTypeListEXT = null,
};
pub const MutableDescriptorTypeCreateInfoVALVE = MutableDescriptorTypeCreateInfoEXT;
pub const PhysicalDeviceDepthClipControlFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_depth_clip_control_features_ext,
    p_next: ?*anyopaque = null,
    depth_clip_control: Bool32 = .false,
};
pub const PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_zero_initialize_device_memory_features_ext,
    p_next: ?*anyopaque = null,
    zero_initialize_device_memory: Bool32 = .false,
};
pub const PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_device_generated_commands_features_ext,
    p_next: ?*anyopaque = null,
    device_generated_commands: Bool32 = .false,
    dynamic_generated_pipeline_layout: Bool32 = .false,
};
pub const PhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_device_generated_commands_properties_ext,
    p_next: ?*anyopaque = null,
    max_indirect_pipeline_count: u32 = 0,
    max_indirect_shader_object_count: u32 = 0,
    max_indirect_sequence_count: u32 = 0,
    max_indirect_commands_token_count: u32 = 0,
    max_indirect_commands_token_offset: u32 = 0,
    max_indirect_commands_indirect_stride: u32 = 0,
    supported_indirect_commands_input_modes: IndirectCommandsInputModeFlagsEXT = .none,
    supported_indirect_commands_shader_stages: ShaderStageFlags = .none,
    supported_indirect_commands_shader_stages_pipeline_binding: ShaderStageFlags = .none,
    supported_indirect_commands_shader_stages_shader_binding: ShaderStageFlags = .none,
    device_generated_commands_transform_feedback: Bool32 = .false,
    device_generated_commands_multi_draw_indirect_count: Bool32 = .false,
};
pub const GeneratedCommandsPipelineInfoEXT = extern struct {
    s_type: StructureType = .generated_commands_pipeline_info_ext,
    p_next: ?*anyopaque = null,
    pipeline: Pipeline = .null_handle,
};
pub const GeneratedCommandsShaderInfoEXT = extern struct {
    s_type: StructureType = .generated_commands_shader_info_ext,
    p_next: ?*anyopaque = null,
    shader_count: u32 = 0,
    p_shaders: ?[*]const ShaderEXT = null,
};
pub const GeneratedCommandsMemoryRequirementsInfoEXT = extern struct {
    s_type: StructureType = .generated_commands_memory_requirements_info_ext,
    p_next: ?*const anyopaque = null,
    indirect_execution_set: IndirectExecutionSetEXT = .null_handle,
    indirect_commands_layout: IndirectCommandsLayoutEXT = .null_handle,
    max_sequence_count: u32 = 0,
    max_draw_count: u32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *GeneratedCommandsPipelineInfoEXT,
            *GeneratedCommandsShaderInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const IndirectExecutionSetPipelineInfoEXT = extern struct {
    s_type: StructureType = .indirect_execution_set_pipeline_info_ext,
    p_next: ?*const anyopaque = null,
    initial_pipeline: Pipeline = .null_handle,
    max_pipeline_count: u32 = 0,
};
pub const IndirectExecutionSetShaderLayoutInfoEXT = extern struct {
    s_type: StructureType = .indirect_execution_set_shader_layout_info_ext,
    p_next: ?*const anyopaque = null,
    set_layout_count: u32 = 0,
    p_set_layouts: ?[*]const DescriptorSetLayout = null,
};
pub const IndirectExecutionSetShaderInfoEXT = extern struct {
    s_type: StructureType = .indirect_execution_set_shader_info_ext,
    p_next: ?*const anyopaque = null,
    shader_count: u32 = 0,
    p_initial_shaders: ?[*]const ShaderEXT = null,
    p_set_layout_infos: ?[*]const IndirectExecutionSetShaderLayoutInfoEXT = null,
    max_shader_count: u32 = 0,
    push_constant_range_count: u32 = 0,
    p_push_constant_ranges: ?[*]const PushConstantRange = null,
};
pub const IndirectExecutionSetInfoEXT = extern union {
    p_pipeline_info: ?*const IndirectExecutionSetPipelineInfoEXT,
    p_shader_info: ?*const IndirectExecutionSetShaderInfoEXT,
};
pub const IndirectExecutionSetCreateInfoEXT = extern struct {
    s_type: StructureType = .indirect_execution_set_create_info_ext,
    p_next: ?*const anyopaque = null,
    type: IndirectExecutionSetInfoTypeEXT = @enumFromInt(0),
    info: IndirectExecutionSetInfoEXT = .{ .p_pipeline_info = null },
};
pub const GeneratedCommandsInfoEXT = extern struct {
    s_type: StructureType = .generated_commands_info_ext,
    p_next: ?*const anyopaque = null,
    shader_stages: ShaderStageFlags = .none,
    indirect_execution_set: IndirectExecutionSetEXT = .null_handle,
    indirect_commands_layout: IndirectCommandsLayoutEXT = .null_handle,
    indirect_address: DeviceAddress = 0,
    indirect_address_size: DeviceSize = 0,
    preprocess_address: DeviceAddress = 0,
    preprocess_size: DeviceSize = 0,
    max_sequence_count: u32 = 0,
    sequence_count_address: DeviceAddress = 0,
    max_draw_count: u32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *GeneratedCommandsPipelineInfoEXT,
            *GeneratedCommandsShaderInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const WriteIndirectExecutionSetPipelineEXT = extern struct {
    s_type: StructureType = .write_indirect_execution_set_pipeline_ext,
    p_next: ?*const anyopaque = null,
    index: u32 = 0,
    pipeline: Pipeline = .null_handle,
};
pub const WriteIndirectExecutionSetShaderEXT = extern struct {
    s_type: StructureType = .write_indirect_execution_set_shader_ext,
    p_next: ?*const anyopaque = null,
    index: u32 = 0,
    shader: ShaderEXT = .null_handle,
};
pub const IndirectCommandsLayoutCreateInfoEXT = extern struct {
    s_type: StructureType = .indirect_commands_layout_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: IndirectCommandsLayoutUsageFlagsEXT = .none,
    shader_stages: ShaderStageFlags = .none,
    indirect_stride: u32 = 0,
    pipeline_layout: PipelineLayout = .null_handle,
    token_count: u32 = 0,
    p_tokens: ?[*]const IndirectCommandsLayoutTokenEXT = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineLayoutCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const IndirectCommandsLayoutTokenEXT = extern struct {
    s_type: StructureType = .indirect_commands_layout_token_ext,
    p_next: ?*const anyopaque = null,
    type: IndirectCommandsTokenTypeEXT = @enumFromInt(0),
    data: IndirectCommandsTokenDataEXT = .{ .p_push_constant = null },
    offset: u32 = 0,
};
pub const DrawIndirectCountIndirectCommandEXT = extern struct {
    buffer_address: DeviceAddress = 0,
    stride: u32 = 0,
    command_count: u32 = 0,
};
pub const IndirectCommandsVertexBufferTokenEXT = extern struct {
    vertex_binding_unit: u32 = 0,
};
pub const BindVertexBufferIndirectCommandEXT = extern struct {
    buffer_address: DeviceAddress = 0,
    size: u32 = 0,
    stride: u32 = 0,
};
pub const IndirectCommandsIndexBufferTokenEXT = extern struct {
    mode: IndirectCommandsInputModeFlagsEXT = .none,
};
pub const BindIndexBufferIndirectCommandEXT = extern struct {
    buffer_address: DeviceAddress = 0,
    size: u32 = 0,
    index_type: IndexType = @enumFromInt(0),
};
pub const IndirectCommandsPushConstantTokenEXT = extern struct {
    update_range: PushConstantRange = .{},
};
pub const IndirectCommandsExecutionSetTokenEXT = extern struct {
    type: IndirectExecutionSetInfoTypeEXT = @enumFromInt(0),
    shader_stages: ShaderStageFlags = .none,
};
pub const IndirectCommandsTokenDataEXT = extern union {
    p_push_constant: ?*const IndirectCommandsPushConstantTokenEXT,
    p_vertex_buffer: ?*const IndirectCommandsVertexBufferTokenEXT,
    p_index_buffer: ?*const IndirectCommandsIndexBufferTokenEXT,
    p_execution_set: ?*const IndirectCommandsExecutionSetTokenEXT,
};
pub const PipelineViewportDepthClipControlCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_viewport_depth_clip_control_create_info_ext,
    p_next: ?*const anyopaque = null,
    negative_one_to_one: Bool32 = .false,
};
pub const PhysicalDeviceDepthClampControlFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_depth_clamp_control_features_ext,
    p_next: ?*anyopaque = null,
    depth_clamp_control: Bool32 = .false,
};
pub const PipelineViewportDepthClampControlCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_viewport_depth_clamp_control_create_info_ext,
    p_next: ?*const anyopaque = null,
    depth_clamp_mode: DepthClampModeEXT = @enumFromInt(0),
    p_depth_clamp_range: ?*const DepthClampRangeEXT = null,
};
pub const PhysicalDeviceVertexInputDynamicStateFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_vertex_input_dynamic_state_features_ext,
    p_next: ?*anyopaque = null,
    vertex_input_dynamic_state: Bool32 = .false,
};
pub const PhysicalDeviceExternalMemoryRDMAFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_external_memory_rdma_features_nv,
    p_next: ?*anyopaque = null,
    external_memory_rdma: Bool32 = .false,
};
pub const PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_shader_relaxed_extended_instruction_features_khr,
    p_next: ?*anyopaque = null,
    shader_relaxed_extended_instruction: Bool32 = .false,
};
pub const VertexInputBindingDescription2EXT = extern struct {
    s_type: StructureType = .vertex_input_binding_description_2_ext,
    p_next: ?*anyopaque = null,
    binding: u32 = 0,
    stride: u32 = 0,
    input_rate: VertexInputRate = @enumFromInt(0),
    divisor: u32 = 0,
};
pub const VertexInputAttributeDescription2EXT = extern struct {
    s_type: StructureType = .vertex_input_attribute_description_2_ext,
    p_next: ?*anyopaque = null,
    location: u32 = 0,
    binding: u32 = 0,
    format: Format = @enumFromInt(0),
    offset: u32 = 0,
};
pub const PhysicalDeviceColorWriteEnableFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_color_write_enable_features_ext,
    p_next: ?*anyopaque = null,
    color_write_enable: Bool32 = .false,
};
pub const PipelineColorWriteCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_color_write_create_info_ext,
    p_next: ?*const anyopaque = null,
    attachment_count: u32 = 0,
    p_color_write_enables: ?[*]const Bool32 = null,
};
pub const MemoryBarrier2 = extern struct {
    s_type: StructureType = .memory_barrier_2,
    p_next: ?*const anyopaque = null,
    src_stage_mask: PipelineStageFlags2 = .none,
    src_access_mask: AccessFlags2 = .none,
    dst_stage_mask: PipelineStageFlags2 = .none,
    dst_access_mask: AccessFlags2 = .none,
};
pub const MemoryBarrier2KHR = MemoryBarrier2;
pub const ImageMemoryBarrier2 = extern struct {
    s_type: StructureType = .image_memory_barrier_2,
    p_next: ?*const anyopaque = null,
    src_stage_mask: PipelineStageFlags2 = .none,
    src_access_mask: AccessFlags2 = .none,
    dst_stage_mask: PipelineStageFlags2 = .none,
    dst_access_mask: AccessFlags2 = .none,
    old_layout: ImageLayout = @enumFromInt(0),
    new_layout: ImageLayout = @enumFromInt(0),
    src_queue_family_index: u32 = 0,
    dst_queue_family_index: u32 = 0,
    image: Image = .null_handle,
    subresource_range: ImageSubresourceRange = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *SampleLocationsInfoEXT,
            *MemoryBarrierAccessFlags3KHR,
            *ExternalMemoryAcquireUnmodifiedEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const ImageMemoryBarrier2KHR = ImageMemoryBarrier2;
pub const BufferMemoryBarrier2 = extern struct {
    s_type: StructureType = .buffer_memory_barrier_2,
    p_next: ?*const anyopaque = null,
    src_stage_mask: PipelineStageFlags2 = .none,
    src_access_mask: AccessFlags2 = .none,
    dst_stage_mask: PipelineStageFlags2 = .none,
    dst_access_mask: AccessFlags2 = .none,
    src_queue_family_index: u32 = 0,
    dst_queue_family_index: u32 = 0,
    buffer: Buffer = .null_handle,
    offset: DeviceSize = 0,
    size: DeviceSize = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *MemoryBarrierAccessFlags3KHR,
            *ExternalMemoryAcquireUnmodifiedEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const BufferMemoryBarrier2KHR = BufferMemoryBarrier2;
pub const MemoryBarrierAccessFlags3KHR = extern struct {
    s_type: StructureType = .memory_barrier_access_flags_3_khr,
    p_next: ?*const anyopaque = null,
    src_access_mask3: AccessFlags3KHR = .none,
    dst_access_mask3: AccessFlags3KHR = .none,
};
pub const DependencyInfo = extern struct {
    s_type: StructureType = .dependency_info,
    p_next: ?*const anyopaque = null,
    dependency_flags: DependencyFlags = .none,
    memory_barrier_count: u32 = 0,
    p_memory_barriers: ?[*]const MemoryBarrier2 = null,
    buffer_memory_barrier_count: u32 = 0,
    p_buffer_memory_barriers: ?[*]const BufferMemoryBarrier2 = null,
    image_memory_barrier_count: u32 = 0,
    p_image_memory_barriers: ?[*]const ImageMemoryBarrier2 = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *TensorMemoryBarrierARM,
            *TensorDependencyInfoARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DependencyInfoKHR = DependencyInfo;
pub const SemaphoreSubmitInfo = extern struct {
    s_type: StructureType = .semaphore_submit_info,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore = .null_handle,
    value: u64 = 0,
    stage_mask: PipelineStageFlags2 = .none,
    device_index: u32 = 0,
};
pub const SemaphoreSubmitInfoKHR = SemaphoreSubmitInfo;
pub const CommandBufferSubmitInfo = extern struct {
    s_type: StructureType = .command_buffer_submit_info,
    p_next: ?*const anyopaque = null,
    command_buffer: CommandBuffer = .null_handle,
    device_mask: u32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *RenderPassStripeSubmitInfoARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const CommandBufferSubmitInfoKHR = CommandBufferSubmitInfo;
pub const SubmitInfo2 = extern struct {
    s_type: StructureType = .submit_info_2,
    p_next: ?*const anyopaque = null,
    flags: SubmitFlags = .none,
    wait_semaphore_info_count: u32 = 0,
    p_wait_semaphore_infos: ?[*]const SemaphoreSubmitInfo = null,
    command_buffer_info_count: u32 = 0,
    p_command_buffer_infos: ?[*]const CommandBufferSubmitInfo = null,
    signal_semaphore_info_count: u32 = 0,
    p_signal_semaphore_infos: ?[*]const SemaphoreSubmitInfo = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *Win32KeyedMutexAcquireReleaseInfoNV,
            *Win32KeyedMutexAcquireReleaseInfoKHR,
            *PerformanceQuerySubmitInfoKHR,
            *FrameBoundaryEXT,
            *LatencySubmissionPresentIdNV,
            *FrameBoundaryTensorsARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const SubmitInfo2KHR = SubmitInfo2;
pub const QueueFamilyCheckpointProperties2NV = extern struct {
    s_type: StructureType = .queue_family_checkpoint_properties_2_nv,
    p_next: ?*anyopaque = null,
    checkpoint_execution_stage_mask: PipelineStageFlags2 = .none,
};
pub const CheckpointData2NV = extern struct {
    s_type: StructureType = .checkpoint_data_2_nv,
    p_next: ?*anyopaque = null,
    stage: PipelineStageFlags2 = .none,
    p_checkpoint_marker: ?*anyopaque = null,
};
pub const PhysicalDeviceSynchronization2Features = extern struct {
    s_type: StructureType = .physical_device_synchronization_2_features,
    p_next: ?*anyopaque = null,
    synchronization2: Bool32 = .false,
};
pub const PhysicalDeviceSynchronization2FeaturesKHR = PhysicalDeviceSynchronization2Features;
pub const PhysicalDeviceUnifiedImageLayoutsFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_unified_image_layouts_features_khr,
    p_next: ?*anyopaque = null,
    unified_image_layouts: Bool32 = .false,
    unified_image_layouts_video: Bool32 = .false,
};
pub const PhysicalDeviceHostImageCopyFeatures = extern struct {
    s_type: StructureType = .physical_device_host_image_copy_features,
    p_next: ?*anyopaque = null,
    host_image_copy: Bool32 = .false,
};
pub const PhysicalDeviceHostImageCopyFeaturesEXT = PhysicalDeviceHostImageCopyFeatures;
pub const PhysicalDeviceHostImageCopyProperties = extern struct {
    s_type: StructureType = .physical_device_host_image_copy_properties,
    p_next: ?*anyopaque = null,
    copy_src_layout_count: u32 = 0,
    p_copy_src_layouts: ?[*]ImageLayout = null,
    copy_dst_layout_count: u32 = 0,
    p_copy_dst_layouts: ?[*]ImageLayout = null,
    optimal_tiling_layout_uuid: [uuid_size]u8 = [_]u8{0} ** uuid_size,
    identical_memory_type_requirements: Bool32 = .false,
};
pub const PhysicalDeviceHostImageCopyPropertiesEXT = PhysicalDeviceHostImageCopyProperties;
pub const MemoryToImageCopy = extern struct {
    s_type: StructureType = .memory_to_image_copy,
    p_next: ?*const anyopaque = null,
    p_host_pointer: ?*const anyopaque = null,
    memory_row_length: u32 = 0,
    memory_image_height: u32 = 0,
    image_subresource: ImageSubresourceLayers = .{},
    image_offset: Offset3D = .{},
    image_extent: Extent3D = .{},
};
pub const MemoryToImageCopyEXT = MemoryToImageCopy;
pub const ImageToMemoryCopy = extern struct {
    s_type: StructureType = .image_to_memory_copy,
    p_next: ?*const anyopaque = null,
    p_host_pointer: ?*anyopaque = null,
    memory_row_length: u32 = 0,
    memory_image_height: u32 = 0,
    image_subresource: ImageSubresourceLayers = .{},
    image_offset: Offset3D = .{},
    image_extent: Extent3D = .{},
};
pub const ImageToMemoryCopyEXT = ImageToMemoryCopy;
pub const CopyMemoryToImageInfo = extern struct {
    s_type: StructureType = .copy_memory_to_image_info,
    p_next: ?*const anyopaque = null,
    flags: HostImageCopyFlags = .none,
    dst_image: Image = .null_handle,
    dst_image_layout: ImageLayout = @enumFromInt(0),
    region_count: u32 = 0,
    p_regions: ?[*]const MemoryToImageCopy = null,
};
pub const CopyMemoryToImageInfoEXT = CopyMemoryToImageInfo;
pub const CopyImageToMemoryInfo = extern struct {
    s_type: StructureType = .copy_image_to_memory_info,
    p_next: ?*const anyopaque = null,
    flags: HostImageCopyFlags = .none,
    src_image: Image = .null_handle,
    src_image_layout: ImageLayout = @enumFromInt(0),
    region_count: u32 = 0,
    p_regions: ?[*]const ImageToMemoryCopy = null,
};
pub const CopyImageToMemoryInfoEXT = CopyImageToMemoryInfo;
pub const CopyImageToImageInfo = extern struct {
    s_type: StructureType = .copy_image_to_image_info,
    p_next: ?*const anyopaque = null,
    flags: HostImageCopyFlags = .none,
    src_image: Image = .null_handle,
    src_image_layout: ImageLayout = @enumFromInt(0),
    dst_image: Image = .null_handle,
    dst_image_layout: ImageLayout = @enumFromInt(0),
    region_count: u32 = 0,
    p_regions: ?[*]const ImageCopy2 = null,
};
pub const CopyImageToImageInfoEXT = CopyImageToImageInfo;
pub const HostImageLayoutTransitionInfo = extern struct {
    s_type: StructureType = .host_image_layout_transition_info,
    p_next: ?*const anyopaque = null,
    image: Image = .null_handle,
    old_layout: ImageLayout = @enumFromInt(0),
    new_layout: ImageLayout = @enumFromInt(0),
    subresource_range: ImageSubresourceRange = .{},
};
pub const HostImageLayoutTransitionInfoEXT = HostImageLayoutTransitionInfo;
pub const SubresourceHostMemcpySize = extern struct {
    s_type: StructureType = .subresource_host_memcpy_size,
    p_next: ?*anyopaque = null,
    size: DeviceSize = 0,
};
pub const SubresourceHostMemcpySizeEXT = SubresourceHostMemcpySize;
pub const HostImageCopyDevicePerformanceQuery = extern struct {
    s_type: StructureType = .host_image_copy_device_performance_query,
    p_next: ?*anyopaque = null,
    optimal_device_access: Bool32 = .false,
    identical_memory_layout: Bool32 = .false,
};
pub const HostImageCopyDevicePerformanceQueryEXT = HostImageCopyDevicePerformanceQuery;
pub const PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_primitives_generated_query_features_ext,
    p_next: ?*anyopaque = null,
    primitives_generated_query: Bool32 = .false,
    primitives_generated_query_with_rasterizer_discard: Bool32 = .false,
    primitives_generated_query_with_non_zero_streams: Bool32 = .false,
};
pub const PhysicalDeviceLegacyDitheringFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_legacy_dithering_features_ext,
    p_next: ?*anyopaque = null,
    legacy_dithering: Bool32 = .false,
};
pub const PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_multisampled_render_to_single_sampled_features_ext,
    p_next: ?*anyopaque = null,
    multisampled_render_to_single_sampled: Bool32 = .false,
};
pub const SurfaceCapabilitiesPresentId2KHR = extern struct {
    s_type: StructureType = .surface_capabilities_present_id_2_khr,
    p_next: ?*anyopaque = null,
    present_id2_supported: Bool32 = .false,
};
pub const SurfaceCapabilitiesPresentWait2KHR = extern struct {
    s_type: StructureType = .surface_capabilities_present_wait_2_khr,
    p_next: ?*anyopaque = null,
    present_wait2_supported: Bool32 = .false,
};
pub const SubpassResolvePerformanceQueryEXT = extern struct {
    s_type: StructureType = .subpass_resolve_performance_query_ext,
    p_next: ?*anyopaque = null,
    optimal: Bool32 = .false,
};
pub const MultisampledRenderToSingleSampledInfoEXT = extern struct {
    s_type: StructureType = .multisampled_render_to_single_sampled_info_ext,
    p_next: ?*const anyopaque = null,
    multisampled_render_to_single_sampled_enable: Bool32 = .false,
    rasterization_samples: SampleCountFlags = .none,
};
pub const PhysicalDevicePipelineProtectedAccessFeatures = extern struct {
    s_type: StructureType = .physical_device_pipeline_protected_access_features,
    p_next: ?*anyopaque = null,
    pipeline_protected_access: Bool32 = .false,
};
pub const PhysicalDevicePipelineProtectedAccessFeaturesEXT = PhysicalDevicePipelineProtectedAccessFeatures;
pub const PhysicalDeviceInheritedViewportScissorFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_inherited_viewport_scissor_features_nv,
    p_next: ?*anyopaque = null,
    inherited_viewport_scissor_2d: Bool32 = .false,
};
pub const CommandBufferInheritanceViewportScissorInfoNV = extern struct {
    s_type: StructureType = .command_buffer_inheritance_viewport_scissor_info_nv,
    p_next: ?*const anyopaque = null,
    viewport_scissor_2d: Bool32 = .false,
    viewport_depth_count: u32 = 0,
    p_viewport_depths: ?*const Viewport = null,
};
pub const PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_ycbcr_2_plane_444_formats_features_ext,
    p_next: ?*anyopaque = null,
    ycbcr2plane444_formats: Bool32 = .false,
};
pub const PhysicalDeviceProvokingVertexFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_provoking_vertex_features_ext,
    p_next: ?*anyopaque = null,
    provoking_vertex_last: Bool32 = .false,
    transform_feedback_preserves_provoking_vertex: Bool32 = .false,
};
pub const PhysicalDeviceProvokingVertexPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_provoking_vertex_properties_ext,
    p_next: ?*anyopaque = null,
    provoking_vertex_mode_per_pipeline: Bool32 = .false,
    transform_feedback_preserves_triangle_fan_provoking_vertex: Bool32 = .false,
};
pub const PipelineRasterizationProvokingVertexStateCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_rasterization_provoking_vertex_state_create_info_ext,
    p_next: ?*const anyopaque = null,
    provoking_vertex_mode: ProvokingVertexModeEXT = @enumFromInt(0),
};
pub const CuModuleCreateInfoNVX = extern struct {
    s_type: StructureType = .cu_module_create_info_nvx,
    p_next: ?*const anyopaque = null,
    data_size: usize = 0,
    p_data: ?*const anyopaque = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *CuModuleTexturingModeCreateInfoNVX,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const CuModuleTexturingModeCreateInfoNVX = extern struct {
    s_type: StructureType = .cu_module_texturing_mode_create_info_nvx,
    p_next: ?*const anyopaque = null,
    use64bit_texturing: Bool32 = .false,
};
pub const CuFunctionCreateInfoNVX = extern struct {
    s_type: StructureType = .cu_function_create_info_nvx,
    p_next: ?*const anyopaque = null,
    module: CuModuleNVX = .null_handle,
    p_name: ?[*:0]const u8 = null,
};
pub const CuLaunchInfoNVX = extern struct {
    s_type: StructureType = .cu_launch_info_nvx,
    p_next: ?*const anyopaque = null,
    function: CuFunctionNVX = .null_handle,
    grid_dim_x: u32 = 0,
    grid_dim_y: u32 = 0,
    grid_dim_z: u32 = 0,
    block_dim_x: u32 = 0,
    block_dim_y: u32 = 0,
    block_dim_z: u32 = 0,
    shared_mem_bytes: u32 = 0,
    param_count: usize = 0,
    p_params: ?[*]const ?*const anyopaque = null,
    extra_count: usize = 0,
    p_extras: ?[*]const ?*const anyopaque = null,
};
pub const PhysicalDeviceDescriptorBufferFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_descriptor_buffer_features_ext,
    p_next: ?*anyopaque = null,
    descriptor_buffer: Bool32 = .false,
    descriptor_buffer_capture_replay: Bool32 = .false,
    descriptor_buffer_image_layout_ignored: Bool32 = .false,
    descriptor_buffer_push_descriptors: Bool32 = .false,
};
pub const PhysicalDeviceDescriptorBufferPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_descriptor_buffer_properties_ext,
    p_next: ?*anyopaque = null,
    combined_image_sampler_descriptor_single_array: Bool32 = .false,
    bufferless_push_descriptors: Bool32 = .false,
    allow_sampler_image_view_post_submit_creation: Bool32 = .false,
    descriptor_buffer_offset_alignment: DeviceSize = 0,
    max_descriptor_buffer_bindings: u32 = 0,
    max_resource_descriptor_buffer_bindings: u32 = 0,
    max_sampler_descriptor_buffer_bindings: u32 = 0,
    max_embedded_immutable_sampler_bindings: u32 = 0,
    max_embedded_immutable_samplers: u32 = 0,
    buffer_capture_replay_descriptor_data_size: usize = 0,
    image_capture_replay_descriptor_data_size: usize = 0,
    image_view_capture_replay_descriptor_data_size: usize = 0,
    sampler_capture_replay_descriptor_data_size: usize = 0,
    acceleration_structure_capture_replay_descriptor_data_size: usize = 0,
    sampler_descriptor_size: usize = 0,
    combined_image_sampler_descriptor_size: usize = 0,
    sampled_image_descriptor_size: usize = 0,
    storage_image_descriptor_size: usize = 0,
    uniform_texel_buffer_descriptor_size: usize = 0,
    robust_uniform_texel_buffer_descriptor_size: usize = 0,
    storage_texel_buffer_descriptor_size: usize = 0,
    robust_storage_texel_buffer_descriptor_size: usize = 0,
    uniform_buffer_descriptor_size: usize = 0,
    robust_uniform_buffer_descriptor_size: usize = 0,
    storage_buffer_descriptor_size: usize = 0,
    robust_storage_buffer_descriptor_size: usize = 0,
    input_attachment_descriptor_size: usize = 0,
    acceleration_structure_descriptor_size: usize = 0,
    max_sampler_descriptor_buffer_range: DeviceSize = 0,
    max_resource_descriptor_buffer_range: DeviceSize = 0,
    sampler_descriptor_buffer_address_space_size: DeviceSize = 0,
    resource_descriptor_buffer_address_space_size: DeviceSize = 0,
    descriptor_buffer_address_space_size: DeviceSize = 0,
};
pub const PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_descriptor_buffer_density_map_properties_ext,
    p_next: ?*anyopaque = null,
    combined_image_sampler_density_map_descriptor_size: usize = 0,
};
pub const DescriptorAddressInfoEXT = extern struct {
    s_type: StructureType = .descriptor_address_info_ext,
    p_next: ?*anyopaque = null,
    address: DeviceAddress = 0,
    range: DeviceSize = 0,
    format: Format = @enumFromInt(0),
};
pub const DescriptorBufferBindingInfoEXT = extern struct {
    s_type: StructureType = .descriptor_buffer_binding_info_ext,
    p_next: ?*const anyopaque = null,
    address: DeviceAddress = 0,
    usage: BufferUsageFlags = .none,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *BufferUsageFlags2CreateInfo,
            *DescriptorBufferBindingPushDescriptorBufferHandleEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DescriptorBufferBindingPushDescriptorBufferHandleEXT = extern struct {
    s_type: StructureType = .descriptor_buffer_binding_push_descriptor_buffer_handle_ext,
    p_next: ?*const anyopaque = null,
    buffer: Buffer = .null_handle,
};
pub const DescriptorDataEXT = extern union {
    p_sampler: ?*const Sampler,
    p_combined_image_sampler: ?*const DescriptorImageInfo,
    p_input_attachment_image: ?*const DescriptorImageInfo,
    p_sampled_image: ?*const DescriptorImageInfo,
    p_storage_image: ?*const DescriptorImageInfo,
    p_uniform_texel_buffer: ?*const DescriptorAddressInfoEXT,
    p_storage_texel_buffer: ?*const DescriptorAddressInfoEXT,
    p_uniform_buffer: ?*const DescriptorAddressInfoEXT,
    p_storage_buffer: ?*const DescriptorAddressInfoEXT,
    acceleration_structure: DeviceAddress,
};
pub const DescriptorGetInfoEXT = extern struct {
    s_type: StructureType = .descriptor_get_info_ext,
    p_next: ?*const anyopaque = null,
    type: DescriptorType = @enumFromInt(0),
    data: DescriptorDataEXT = .{ .p_sampler = null },
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DescriptorGetTensorInfoARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const BufferCaptureDescriptorDataInfoEXT = extern struct {
    s_type: StructureType = .buffer_capture_descriptor_data_info_ext,
    p_next: ?*const anyopaque = null,
    buffer: Buffer = .null_handle,
};
pub const ImageCaptureDescriptorDataInfoEXT = extern struct {
    s_type: StructureType = .image_capture_descriptor_data_info_ext,
    p_next: ?*const anyopaque = null,
    image: Image = .null_handle,
};
pub const ImageViewCaptureDescriptorDataInfoEXT = extern struct {
    s_type: StructureType = .image_view_capture_descriptor_data_info_ext,
    p_next: ?*const anyopaque = null,
    image_view: ImageView = .null_handle,
};
pub const SamplerCaptureDescriptorDataInfoEXT = extern struct {
    s_type: StructureType = .sampler_capture_descriptor_data_info_ext,
    p_next: ?*const anyopaque = null,
    sampler: Sampler = .null_handle,
};
pub const AccelerationStructureCaptureDescriptorDataInfoEXT = extern struct {
    s_type: StructureType = .acceleration_structure_capture_descriptor_data_info_ext,
    p_next: ?*const anyopaque = null,
    acceleration_structure: AccelerationStructureKHR = .null_handle,
    acceleration_structure_nv: AccelerationStructureNV = .null_handle,
};
pub const OpaqueCaptureDescriptorDataCreateInfoEXT = extern struct {
    s_type: StructureType = .opaque_capture_descriptor_data_create_info_ext,
    p_next: ?*const anyopaque = null,
    opaque_capture_descriptor_data: ?*const anyopaque = null,
};
pub const PhysicalDeviceShaderIntegerDotProductFeatures = extern struct {
    s_type: StructureType = .physical_device_shader_integer_dot_product_features,
    p_next: ?*anyopaque = null,
    shader_integer_dot_product: Bool32 = .false,
};
pub const PhysicalDeviceShaderIntegerDotProductFeaturesKHR = PhysicalDeviceShaderIntegerDotProductFeatures;
pub const PhysicalDeviceShaderIntegerDotProductProperties = extern struct {
    s_type: StructureType = .physical_device_shader_integer_dot_product_properties,
    p_next: ?*anyopaque = null,
    integer_dot_product8_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product8_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product8_bit_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product4x8_bit_packed_unsigned_accelerated: Bool32 = .false,
    integer_dot_product4x8_bit_packed_signed_accelerated: Bool32 = .false,
    integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product16_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product16_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product16_bit_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product32_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product32_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product32_bit_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product64_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product64_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product64_bit_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Bool32 = .false,
    integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Bool32 = .false,
};
pub const PhysicalDeviceShaderIntegerDotProductPropertiesKHR = PhysicalDeviceShaderIntegerDotProductProperties;
pub const PhysicalDeviceDrmPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_drm_properties_ext,
    p_next: ?*anyopaque = null,
    has_primary: Bool32 = .false,
    has_render: Bool32 = .false,
    primary_major: i64 = 0,
    primary_minor: i64 = 0,
    render_major: i64 = 0,
    render_minor: i64 = 0,
};
pub const PhysicalDeviceFragmentShaderBarycentricFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_fragment_shader_barycentric_features_khr,
    p_next: ?*anyopaque = null,
    fragment_shader_barycentric: Bool32 = .false,
};
pub const PhysicalDeviceFragmentShaderBarycentricPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_fragment_shader_barycentric_properties_khr,
    p_next: ?*anyopaque = null,
    tri_strip_vertex_order_independent_of_provoking_vertex: Bool32 = .false,
};
pub const PhysicalDeviceRayTracingMotionBlurFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_motion_blur_features_nv,
    p_next: ?*anyopaque = null,
    ray_tracing_motion_blur: Bool32 = .false,
    ray_tracing_motion_blur_pipeline_trace_rays_indirect: Bool32 = .false,
};
pub const PhysicalDeviceRayTracingValidationFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_validation_features_nv,
    p_next: ?*anyopaque = null,
    ray_tracing_validation: Bool32 = .false,
};
pub const PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_linear_swept_spheres_features_nv,
    p_next: ?*anyopaque = null,
    spheres: Bool32 = .false,
    linear_swept_spheres: Bool32 = .false,
};
pub const AccelerationStructureMotionInstanceTypeNV = enum(i32) {
    static = 0,
    matrix_motion = 1,
    srt_motion = 2,
    _,
};
pub const AccelerationStructureGeometryMotionTrianglesDataNV = extern struct {
    s_type: StructureType = .acceleration_structure_geometry_motion_triangles_data_nv,
    p_next: ?*const anyopaque = null,
    vertex_data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
};
pub const AccelerationStructureMotionInfoNV = extern struct {
    s_type: StructureType = .acceleration_structure_motion_info_nv,
    p_next: ?*const anyopaque = null,
    max_instances: u32 = 0,
    flags: AccelerationStructureMotionInfoFlagsNV = .none,
};
pub const SRTDataNV = extern struct {
    sx: f32 = 0,
    a: f32 = 0,
    b: f32 = 0,
    pvx: f32 = 0,
    sy: f32 = 0,
    c: f32 = 0,
    pvy: f32 = 0,
    sz: f32 = 0,
    pvz: f32 = 0,
    qx: f32 = 0,
    qy: f32 = 0,
    qz: f32 = 0,
    qw: f32 = 0,
    tx: f32 = 0,
    ty: f32 = 0,
    tz: f32 = 0,
};
pub const AccelerationStructureSRTMotionInstanceNV = extern struct {
    transform_t0: SRTDataNV = .{},
    transform_t1: SRTDataNV = .{},
    instance_custom_index_and_mask: u32 = 0,
    instance_shader_binding_table_record_offset_and_flags: u32 = 0,
    acceleration_structure_reference: u64 = 0,
};
pub const AccelerationStructureMatrixMotionInstanceNV = extern struct {
    transform_t0: TransformMatrixKHR = .{},
    transform_t1: TransformMatrixKHR = .{},
    instance_custom_index_and_mask: u32 = 0,
    instance_shader_binding_table_record_offset_and_flags: u32 = 0,
    acceleration_structure_reference: u64 = 0,
};
pub const AccelerationStructureMotionInstanceDataNV = extern union {
    static_instance: AccelerationStructureInstanceKHR,
    matrix_motion_instance: AccelerationStructureMatrixMotionInstanceNV,
    srt_motion_instance: AccelerationStructureSRTMotionInstanceNV,
};
pub const AccelerationStructureMotionInstanceNV = extern struct {
    type: AccelerationStructureMotionInstanceTypeNV = @enumFromInt(0),
    flags: AccelerationStructureMotionInstanceFlagsNV = .none,
    data: AccelerationStructureMotionInstanceDataNV = .{ .static_instance = .{} },
};
pub const RemoteAddressNV = ?*anyopaque;
pub const MemoryGetRemoteAddressInfoNV = extern struct {
    s_type: StructureType = .memory_get_remote_address_info_nv,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory = .null_handle,
    handle_type: ExternalMemoryHandleTypeFlags = .none,
};
pub const ImportMemoryBufferCollectionFUCHSIA = extern struct {
    s_type: StructureType = .import_memory_buffer_collection_fuchsia,
    p_next: ?*const anyopaque = null,
    collection: BufferCollectionFUCHSIA = .null_handle,
    index: u32 = 0,
};
pub const BufferCollectionImageCreateInfoFUCHSIA = extern struct {
    s_type: StructureType = .buffer_collection_image_create_info_fuchsia,
    p_next: ?*const anyopaque = null,
    collection: BufferCollectionFUCHSIA = .null_handle,
    index: u32 = 0,
};
pub const BufferCollectionBufferCreateInfoFUCHSIA = extern struct {
    s_type: StructureType = .buffer_collection_buffer_create_info_fuchsia,
    p_next: ?*const anyopaque = null,
    collection: BufferCollectionFUCHSIA = .null_handle,
    index: u32 = 0,
};
pub const BufferCollectionCreateInfoFUCHSIA = extern struct {
    s_type: StructureType = .buffer_collection_create_info_fuchsia,
    p_next: ?*const anyopaque = null,
    collection_token: zx_handle_t = 0,
};
pub const BufferCollectionPropertiesFUCHSIA = extern struct {
    s_type: StructureType = .buffer_collection_properties_fuchsia,
    p_next: ?*anyopaque = null,
    memory_type_bits: u32 = 0,
    buffer_count: u32 = 0,
    create_info_index: u32 = 0,
    sysmem_pixel_format: u64 = 0,
    format_features: FormatFeatureFlags = .none,
    sysmem_color_space_index: SysmemColorSpaceFUCHSIA = .{},
    sampler_ycbcr_conversion_components: ComponentMapping = .{},
    suggested_ycbcr_model: SamplerYcbcrModelConversion = @enumFromInt(0),
    suggested_ycbcr_range: SamplerYcbcrRange = @enumFromInt(0),
    suggested_x_chroma_offset: ChromaLocation = @enumFromInt(0),
    suggested_y_chroma_offset: ChromaLocation = @enumFromInt(0),
};
pub const BufferConstraintsInfoFUCHSIA = extern struct {
    s_type: StructureType = .buffer_constraints_info_fuchsia,
    p_next: ?*const anyopaque = null,
    create_info: BufferCreateInfo = .{},
    required_format_features: FormatFeatureFlags = .none,
    buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA = .{},
};
pub const SysmemColorSpaceFUCHSIA = extern struct {
    s_type: StructureType = .sysmem_color_space_fuchsia,
    p_next: ?*const anyopaque = null,
    color_space: u32 = 0,
};
pub const ImageFormatConstraintsInfoFUCHSIA = extern struct {
    s_type: StructureType = .image_format_constraints_info_fuchsia,
    p_next: ?*const anyopaque = null,
    image_create_info: ImageCreateInfo = .{},
    required_format_features: FormatFeatureFlags = .none,
    flags: ImageFormatConstraintsFlagsFUCHSIA = .none,
    sysmem_pixel_format: u64 = 0,
    color_space_count: u32 = 0,
    p_color_spaces: ?[*]const SysmemColorSpaceFUCHSIA = null,
};
pub const ImageConstraintsInfoFUCHSIA = extern struct {
    s_type: StructureType = .image_constraints_info_fuchsia,
    p_next: ?*const anyopaque = null,
    format_constraints_count: u32 = 0,
    p_format_constraints: ?[*]const ImageFormatConstraintsInfoFUCHSIA = null,
    buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA = .{},
    flags: ImageConstraintsInfoFlagsFUCHSIA = .none,
};
pub const BufferCollectionConstraintsInfoFUCHSIA = extern struct {
    s_type: StructureType = .buffer_collection_constraints_info_fuchsia,
    p_next: ?*const anyopaque = null,
    min_buffer_count: u32 = 0,
    max_buffer_count: u32 = 0,
    min_buffer_count_for_camping: u32 = 0,
    min_buffer_count_for_dedicated_slack: u32 = 0,
    min_buffer_count_for_shared_slack: u32 = 0,
};
pub const CudaModuleNV = enum(u64) { null_handle = 0, _ };
pub const CudaFunctionNV = enum(u64) { null_handle = 0, _ };
pub const CudaModuleCreateInfoNV = extern struct {
    s_type: StructureType = .cuda_module_create_info_nv,
    p_next: ?*const anyopaque = null,
    data_size: usize = 0,
    p_data: ?*const anyopaque = null,
};
pub const CudaFunctionCreateInfoNV = extern struct {
    s_type: StructureType = .cuda_function_create_info_nv,
    p_next: ?*const anyopaque = null,
    module: CudaModuleNV = .null_handle,
    p_name: ?[*:0]const u8 = null,
};
pub const CudaLaunchInfoNV = extern struct {
    s_type: StructureType = .cuda_launch_info_nv,
    p_next: ?*const anyopaque = null,
    function: CudaFunctionNV = .null_handle,
    grid_dim_x: u32 = 0,
    grid_dim_y: u32 = 0,
    grid_dim_z: u32 = 0,
    block_dim_x: u32 = 0,
    block_dim_y: u32 = 0,
    block_dim_z: u32 = 0,
    shared_mem_bytes: u32 = 0,
    param_count: usize = 0,
    p_params: ?[*]const ?*const anyopaque = null,
    extra_count: usize = 0,
    p_extras: ?[*]const ?*const anyopaque = null,
};
pub const PhysicalDeviceRGBA10X6FormatsFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_rgba10x6_formats_features_ext,
    p_next: ?*anyopaque = null,
    format_rgba10x6_without_y_cb_cr_sampler: Bool32 = .false,
};
pub const FormatProperties3 = extern struct {
    s_type: StructureType = .format_properties_3,
    p_next: ?*anyopaque = null,
    linear_tiling_features: FormatFeatureFlags2 = .none,
    optimal_tiling_features: FormatFeatureFlags2 = .none,
    buffer_features: FormatFeatureFlags2 = .none,
};
pub const FormatProperties3KHR = FormatProperties3;
pub const DrmFormatModifierPropertiesList2EXT = extern struct {
    s_type: StructureType = .drm_format_modifier_properties_list_2_ext,
    p_next: ?*anyopaque = null,
    drm_format_modifier_count: u32 = 0,
    p_drm_format_modifier_properties: ?[*]DrmFormatModifierProperties2EXT = null,
};
pub const DrmFormatModifierProperties2EXT = extern struct {
    drm_format_modifier: u64 = 0,
    drm_format_modifier_plane_count: u32 = 0,
    drm_format_modifier_tiling_features: FormatFeatureFlags2 = .none,
};
pub const AndroidHardwareBufferFormatProperties2ANDROID = extern struct {
    s_type: StructureType = .android_hardware_buffer_format_properties_2_android,
    p_next: ?*anyopaque = null,
    format: Format = @enumFromInt(0),
    external_format: u64 = 0,
    format_features: FormatFeatureFlags2 = .none,
    sampler_ycbcr_conversion_components: ComponentMapping = .{},
    suggested_ycbcr_model: SamplerYcbcrModelConversion = @enumFromInt(0),
    suggested_ycbcr_range: SamplerYcbcrRange = @enumFromInt(0),
    suggested_x_chroma_offset: ChromaLocation = @enumFromInt(0),
    suggested_y_chroma_offset: ChromaLocation = @enumFromInt(0),
};
pub const PipelineRenderingCreateInfo = extern struct {
    s_type: StructureType = .pipeline_rendering_create_info,
    p_next: ?*const anyopaque = null,
    view_mask: u32 = 0,
    color_attachment_count: u32 = 0,
    p_color_attachment_formats: ?[*]const Format = null,
    depth_attachment_format: Format = @enumFromInt(0),
    stencil_attachment_format: Format = @enumFromInt(0),
};
pub const PipelineRenderingCreateInfoKHR = PipelineRenderingCreateInfo;
pub const RenderingInfo = extern struct {
    s_type: StructureType = .rendering_info,
    p_next: ?*const anyopaque = null,
    flags: RenderingFlags = .none,
    render_area: Rect2D = .{},
    layer_count: u32 = 0,
    view_mask: u32 = 0,
    color_attachment_count: u32 = 0,
    p_color_attachments: ?[*]const RenderingAttachmentInfo = null,
    p_depth_attachment: ?*const RenderingAttachmentInfo = null,
    p_stencil_attachment: ?*const RenderingAttachmentInfo = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DeviceGroupRenderPassBeginInfo,
            *MultisampledRenderToSingleSampledInfoEXT,
            *RenderingFragmentShadingRateAttachmentInfoKHR,
            *RenderingFragmentDensityMapAttachmentInfoEXT,
            *MultiviewPerViewAttributesInfoNVX,
            *MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM,
            *TileMemorySizeInfoQCOM,
            *RenderPassStripeBeginInfoARM,
            *RenderPassTileShadingCreateInfoQCOM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const RenderingInfoKHR = RenderingInfo;
pub const RenderingEndInfoEXT = extern struct {
    s_type: StructureType = .rendering_end_info_ext,
    p_next: ?*const anyopaque = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *RenderPassFragmentDensityMapOffsetEndInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const RenderingAttachmentInfo = extern struct {
    s_type: StructureType = .rendering_attachment_info,
    p_next: ?*const anyopaque = null,
    image_view: ImageView = .null_handle,
    image_layout: ImageLayout = @enumFromInt(0),
    resolve_mode: ResolveModeFlags = .none,
    resolve_image_view: ImageView = .null_handle,
    resolve_image_layout: ImageLayout = @enumFromInt(0),
    load_op: AttachmentLoadOp = @enumFromInt(0),
    store_op: AttachmentStoreOp = @enumFromInt(0),
    clear_value: ClearValue = .{ .color = .{ .float32 = [_]f32{0} ** 4 } },
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *AttachmentFeedbackLoopInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const RenderingAttachmentInfoKHR = RenderingAttachmentInfo;
pub const RenderingFragmentShadingRateAttachmentInfoKHR = extern struct {
    s_type: StructureType = .rendering_fragment_shading_rate_attachment_info_khr,
    p_next: ?*const anyopaque = null,
    image_view: ImageView = .null_handle,
    image_layout: ImageLayout = @enumFromInt(0),
    shading_rate_attachment_texel_size: Extent2D = .{},
};
pub const RenderingFragmentDensityMapAttachmentInfoEXT = extern struct {
    s_type: StructureType = .rendering_fragment_density_map_attachment_info_ext,
    p_next: ?*const anyopaque = null,
    image_view: ImageView = .null_handle,
    image_layout: ImageLayout = @enumFromInt(0),
};
pub const PhysicalDeviceDynamicRenderingFeatures = extern struct {
    s_type: StructureType = .physical_device_dynamic_rendering_features,
    p_next: ?*anyopaque = null,
    dynamic_rendering: Bool32 = .false,
};
pub const PhysicalDeviceDynamicRenderingFeaturesKHR = PhysicalDeviceDynamicRenderingFeatures;
pub const CommandBufferInheritanceRenderingInfo = extern struct {
    s_type: StructureType = .command_buffer_inheritance_rendering_info,
    p_next: ?*const anyopaque = null,
    flags: RenderingFlags = .none,
    view_mask: u32 = 0,
    color_attachment_count: u32 = 0,
    p_color_attachment_formats: ?[*]const Format = null,
    depth_attachment_format: Format = @enumFromInt(0),
    stencil_attachment_format: Format = @enumFromInt(0),
    rasterization_samples: SampleCountFlags = .none,
};
pub const CommandBufferInheritanceRenderingInfoKHR = CommandBufferInheritanceRenderingInfo;
pub const AttachmentSampleCountInfoAMD = extern struct {
    s_type: StructureType = .attachment_sample_count_info_amd,
    p_next: ?*const anyopaque = null,
    color_attachment_count: u32 = 0,
    p_color_attachment_samples: ?[*]const SampleCountFlags = null,
    depth_stencil_attachment_samples: SampleCountFlags = .none,
};
pub const AttachmentSampleCountInfoNV = AttachmentSampleCountInfoAMD;
pub const MultiviewPerViewAttributesInfoNVX = extern struct {
    s_type: StructureType = .multiview_per_view_attributes_info_nvx,
    p_next: ?*const anyopaque = null,
    per_view_attributes: Bool32 = .false,
    per_view_attributes_position_x_only: Bool32 = .false,
};
pub const PhysicalDeviceImageViewMinLodFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_image_view_min_lod_features_ext,
    p_next: ?*anyopaque = null,
    min_lod: Bool32 = .false,
};
pub const ImageViewMinLodCreateInfoEXT = extern struct {
    s_type: StructureType = .image_view_min_lod_create_info_ext,
    p_next: ?*const anyopaque = null,
    min_lod: f32 = 0,
};
pub const PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_rasterization_order_attachment_access_features_ext,
    p_next: ?*anyopaque = null,
    rasterization_order_color_attachment_access: Bool32 = .false,
    rasterization_order_depth_attachment_access: Bool32 = .false,
    rasterization_order_stencil_attachment_access: Bool32 = .false,
};
pub const PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
pub const PhysicalDeviceLinearColorAttachmentFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_linear_color_attachment_features_nv,
    p_next: ?*anyopaque = null,
    linear_color_attachment: Bool32 = .false,
};
pub const PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_graphics_pipeline_library_features_ext,
    p_next: ?*anyopaque = null,
    graphics_pipeline_library: Bool32 = .false,
};
pub const PhysicalDevicePipelineBinaryFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_pipeline_binary_features_khr,
    p_next: ?*anyopaque = null,
    pipeline_binaries: Bool32 = .false,
};
pub const DevicePipelineBinaryInternalCacheControlKHR = extern struct {
    s_type: StructureType = .device_pipeline_binary_internal_cache_control_khr,
    p_next: ?*const anyopaque = null,
    disable_internal_cache: Bool32 = .false,
};
pub const PhysicalDevicePipelineBinaryPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_pipeline_binary_properties_khr,
    p_next: ?*anyopaque = null,
    pipeline_binary_internal_cache: Bool32 = .false,
    pipeline_binary_internal_cache_control: Bool32 = .false,
    pipeline_binary_prefers_internal_cache: Bool32 = .false,
    pipeline_binary_precompiled_internal_cache: Bool32 = .false,
    pipeline_binary_compressed_data: Bool32 = .false,
};
pub const PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_graphics_pipeline_library_properties_ext,
    p_next: ?*anyopaque = null,
    graphics_pipeline_library_fast_linking: Bool32 = .false,
    graphics_pipeline_library_independent_interpolation_decoration: Bool32 = .false,
};
pub const GraphicsPipelineLibraryCreateInfoEXT = extern struct {
    s_type: StructureType = .graphics_pipeline_library_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: GraphicsPipelineLibraryFlagsEXT = .none,
};
pub const PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = extern struct {
    s_type: StructureType = .physical_device_descriptor_set_host_mapping_features_valve,
    p_next: ?*anyopaque = null,
    descriptor_set_host_mapping: Bool32 = .false,
};
pub const DescriptorSetBindingReferenceVALVE = extern struct {
    s_type: StructureType = .descriptor_set_binding_reference_valve,
    p_next: ?*const anyopaque = null,
    descriptor_set_layout: DescriptorSetLayout = .null_handle,
    binding: u32 = 0,
};
pub const DescriptorSetLayoutHostMappingInfoVALVE = extern struct {
    s_type: StructureType = .descriptor_set_layout_host_mapping_info_valve,
    p_next: ?*anyopaque = null,
    descriptor_offset: usize = 0,
    descriptor_size: u32 = 0,
};
pub const PhysicalDeviceNestedCommandBufferFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_nested_command_buffer_features_ext,
    p_next: ?*anyopaque = null,
    nested_command_buffer: Bool32 = .false,
    nested_command_buffer_rendering: Bool32 = .false,
    nested_command_buffer_simultaneous_use: Bool32 = .false,
};
pub const PhysicalDeviceNestedCommandBufferPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_nested_command_buffer_properties_ext,
    p_next: ?*anyopaque = null,
    max_command_buffer_nesting_level: u32 = 0,
};
pub const PhysicalDeviceShaderModuleIdentifierFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_module_identifier_features_ext,
    p_next: ?*anyopaque = null,
    shader_module_identifier: Bool32 = .false,
};
pub const PhysicalDeviceShaderModuleIdentifierPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_module_identifier_properties_ext,
    p_next: ?*anyopaque = null,
    shader_module_identifier_algorithm_uuid: [uuid_size]u8 = [_]u8{0} ** uuid_size,
};
pub const PipelineShaderStageModuleIdentifierCreateInfoEXT = extern struct {
    s_type: StructureType = .pipeline_shader_stage_module_identifier_create_info_ext,
    p_next: ?*const anyopaque = null,
    identifier_size: u32 = 0,
    p_identifier: ?[*]const u8 = null,
};
pub const ShaderModuleIdentifierEXT = extern struct {
    s_type: StructureType = .shader_module_identifier_ext,
    p_next: ?*anyopaque = null,
    identifier_size: u32 = 0,
    identifier: [max_shader_module_identifier_size_ext]u8 = [_]u8{0} ** max_shader_module_identifier_size_ext,
};
pub const ImageCompressionControlEXT = extern struct {
    s_type: StructureType = .image_compression_control_ext,
    p_next: ?*const anyopaque = null,
    flags: ImageCompressionFlagsEXT = .none,
    compression_control_plane_count: u32 = 0,
    p_fixed_rate_flags: ?[*]ImageCompressionFixedRateFlagsEXT = null,
};
pub const PhysicalDeviceImageCompressionControlFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_image_compression_control_features_ext,
    p_next: ?*anyopaque = null,
    image_compression_control: Bool32 = .false,
};
pub const ImageCompressionPropertiesEXT = extern struct {
    s_type: StructureType = .image_compression_properties_ext,
    p_next: ?*anyopaque = null,
    image_compression_flags: ImageCompressionFlagsEXT = .none,
    image_compression_fixed_rate_flags: ImageCompressionFixedRateFlagsEXT = .none,
};
pub const PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_image_compression_control_swapchain_features_ext,
    p_next: ?*anyopaque = null,
    image_compression_control_swapchain: Bool32 = .false,
};
pub const ImageSubresource2 = extern struct {
    s_type: StructureType = .image_subresource_2,
    p_next: ?*anyopaque = null,
    image_subresource: ImageSubresource = .{},
};
pub const ImageSubresource2KHR = ImageSubresource2;
pub const ImageSubresource2EXT = ImageSubresource2;
pub const SubresourceLayout2 = extern struct {
    s_type: StructureType = .subresource_layout_2,
    p_next: ?*anyopaque = null,
    subresource_layout: SubresourceLayout = .{},
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *SubresourceHostMemcpySize,
            *ImageCompressionPropertiesEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const SubresourceLayout2KHR = SubresourceLayout2;
pub const SubresourceLayout2EXT = SubresourceLayout2;
pub const RenderPassCreationControlEXT = extern struct {
    s_type: StructureType = .render_pass_creation_control_ext,
    p_next: ?*const anyopaque = null,
    disallow_merging: Bool32 = .false,
};
pub const RenderPassCreationFeedbackInfoEXT = extern struct {
    post_merge_subpass_count: u32 = 0,
};
pub const RenderPassCreationFeedbackCreateInfoEXT = extern struct {
    s_type: StructureType = .render_pass_creation_feedback_create_info_ext,
    p_next: ?*const anyopaque = null,
    p_render_pass_feedback: ?*RenderPassCreationFeedbackInfoEXT = null,
};
pub const RenderPassSubpassFeedbackInfoEXT = extern struct {
    subpass_merge_status: SubpassMergeStatusEXT = @enumFromInt(0),
    description: [max_description_size - 1:0]u8 = [_:0]u8{0} ** (max_description_size - 1),
    post_merge_index: u32 = 0,
};
pub const RenderPassSubpassFeedbackCreateInfoEXT = extern struct {
    s_type: StructureType = .render_pass_subpass_feedback_create_info_ext,
    p_next: ?*const anyopaque = null,
    p_subpass_feedback: ?*RenderPassSubpassFeedbackInfoEXT = null,
};
pub const PhysicalDeviceSubpassMergeFeedbackFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_subpass_merge_feedback_features_ext,
    p_next: ?*anyopaque = null,
    subpass_merge_feedback: Bool32 = .false,
};
pub const MicromapBuildInfoEXT = extern struct {
    s_type: StructureType = .micromap_build_info_ext,
    p_next: ?*const anyopaque = null,
    type: MicromapTypeEXT = @enumFromInt(0),
    flags: BuildMicromapFlagsEXT = .none,
    mode: BuildMicromapModeEXT = @enumFromInt(0),
    dst_micromap: MicromapEXT = .null_handle,
    usage_counts_count: u32 = 0,
    p_usage_counts: ?[*]const MicromapUsageEXT = null,
    pp_usage_counts: ?[*]const ?*const MicromapUsageEXT = null,
    data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    scratch_data: DeviceOrHostAddressKHR = .{ .device_address = 0 },
    triangle_array: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    triangle_array_stride: DeviceSize = 0,
};
pub const MicromapCreateInfoEXT = extern struct {
    s_type: StructureType = .micromap_create_info_ext,
    p_next: ?*const anyopaque = null,
    create_flags: MicromapCreateFlagsEXT = .none,
    buffer: Buffer = .null_handle,
    offset: DeviceSize = 0,
    size: DeviceSize = 0,
    type: MicromapTypeEXT = @enumFromInt(0),
    device_address: DeviceAddress = 0,
};
pub const MicromapVersionInfoEXT = extern struct {
    s_type: StructureType = .micromap_version_info_ext,
    p_next: ?*const anyopaque = null,
    p_version_data: ?[*]const u8 = null,
};
pub const CopyMicromapInfoEXT = extern struct {
    s_type: StructureType = .copy_micromap_info_ext,
    p_next: ?*const anyopaque = null,
    src: MicromapEXT = .null_handle,
    dst: MicromapEXT = .null_handle,
    mode: CopyMicromapModeEXT = @enumFromInt(0),
};
pub const CopyMicromapToMemoryInfoEXT = extern struct {
    s_type: StructureType = .copy_micromap_to_memory_info_ext,
    p_next: ?*const anyopaque = null,
    src: MicromapEXT = .null_handle,
    dst: DeviceOrHostAddressKHR = .{ .device_address = 0 },
    mode: CopyMicromapModeEXT = @enumFromInt(0),
};
pub const CopyMemoryToMicromapInfoEXT = extern struct {
    s_type: StructureType = .copy_memory_to_micromap_info_ext,
    p_next: ?*const anyopaque = null,
    src: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    dst: MicromapEXT = .null_handle,
    mode: CopyMicromapModeEXT = @enumFromInt(0),
};
pub const MicromapBuildSizesInfoEXT = extern struct {
    s_type: StructureType = .micromap_build_sizes_info_ext,
    p_next: ?*const anyopaque = null,
    micromap_size: DeviceSize = 0,
    build_scratch_size: DeviceSize = 0,
    discardable: Bool32 = .false,
};
pub const MicromapUsageEXT = extern struct {
    count: u32 = 0,
    subdivision_level: u32 = 0,
    format: u32 = 0,
};
pub const MicromapTriangleEXT = extern struct {
    data_offset: u32 = 0,
    subdivision_level: u16 = 0,
    format: u16 = 0,
};
pub const PhysicalDeviceOpacityMicromapFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_opacity_micromap_features_ext,
    p_next: ?*anyopaque = null,
    micromap: Bool32 = .false,
    micromap_capture_replay: Bool32 = .false,
    micromap_host_commands: Bool32 = .false,
};
pub const PhysicalDeviceOpacityMicromapPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_opacity_micromap_properties_ext,
    p_next: ?*anyopaque = null,
    max_opacity2_state_subdivision_level: u32 = 0,
    max_opacity4_state_subdivision_level: u32 = 0,
};
pub const AccelerationStructureTrianglesOpacityMicromapEXT = extern struct {
    s_type: StructureType = .acceleration_structure_triangles_opacity_micromap_ext,
    p_next: ?*anyopaque = null,
    index_type: IndexType = @enumFromInt(0),
    index_buffer: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    index_stride: DeviceSize = 0,
    base_triangle: u32 = 0,
    usage_counts_count: u32 = 0,
    p_usage_counts: ?[*]const MicromapUsageEXT = null,
    pp_usage_counts: ?[*]const ?*const MicromapUsageEXT = null,
    micromap: MicromapEXT = .null_handle,
};
pub const PhysicalDeviceDisplacementMicromapFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_displacement_micromap_features_nv,
    p_next: ?*anyopaque = null,
    displacement_micromap: Bool32 = .false,
};
pub const PhysicalDeviceDisplacementMicromapPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_displacement_micromap_properties_nv,
    p_next: ?*anyopaque = null,
    max_displacement_micromap_subdivision_level: u32 = 0,
};
pub const AccelerationStructureTrianglesDisplacementMicromapNV = extern struct {
    s_type: StructureType = .acceleration_structure_triangles_displacement_micromap_nv,
    p_next: ?*anyopaque = null,
    displacement_bias_and_scale_format: Format = @enumFromInt(0),
    displacement_vector_format: Format = @enumFromInt(0),
    displacement_bias_and_scale_buffer: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    displacement_bias_and_scale_stride: DeviceSize = 0,
    displacement_vector_buffer: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    displacement_vector_stride: DeviceSize = 0,
    displaced_micromap_primitive_flags: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    displaced_micromap_primitive_flags_stride: DeviceSize = 0,
    index_type: IndexType = @enumFromInt(0),
    index_buffer: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    index_stride: DeviceSize = 0,
    base_triangle: u32 = 0,
    usage_counts_count: u32 = 0,
    p_usage_counts: ?[*]const MicromapUsageEXT = null,
    pp_usage_counts: ?[*]const ?*const MicromapUsageEXT = null,
    micromap: MicromapEXT = .null_handle,
};
pub const PipelinePropertiesIdentifierEXT = extern struct {
    s_type: StructureType = .pipeline_properties_identifier_ext,
    p_next: ?*anyopaque = null,
    pipeline_identifier: [uuid_size]u8 = [_]u8{0} ** uuid_size,
};
pub const PhysicalDevicePipelinePropertiesFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_pipeline_properties_features_ext,
    p_next: ?*anyopaque = null,
    pipeline_properties_identifier: Bool32 = .false,
};
pub const PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = extern struct {
    s_type: StructureType = .physical_device_shader_early_and_late_fragment_tests_features_amd,
    p_next: ?*anyopaque = null,
    shader_early_and_late_fragment_tests: Bool32 = .false,
};
pub const ExternalMemoryAcquireUnmodifiedEXT = extern struct {
    s_type: StructureType = .external_memory_acquire_unmodified_ext,
    p_next: ?*const anyopaque = null,
    acquire_unmodified_memory: Bool32 = .false,
};
pub const ExportMetalObjectCreateInfoEXT = extern struct {
    s_type: StructureType = .export_metal_object_create_info_ext,
    p_next: ?*const anyopaque = null,
    export_object_type: ExportMetalObjectTypeFlagsEXT = .none,
};
pub const ExportMetalObjectsInfoEXT = extern struct {
    s_type: StructureType = .export_metal_objects_info_ext,
    p_next: ?*const anyopaque = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ExportMetalDeviceInfoEXT,
            *ExportMetalCommandQueueInfoEXT,
            *ExportMetalBufferInfoEXT,
            *ExportMetalTextureInfoEXT,
            *ExportMetalIOSurfaceInfoEXT,
            *ExportMetalSharedEventInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const ExportMetalDeviceInfoEXT = extern struct {
    s_type: StructureType = .export_metal_device_info_ext,
    p_next: ?*const anyopaque = null,
    mtl_device: MTLDevice_id = null,
};
pub const ExportMetalCommandQueueInfoEXT = extern struct {
    s_type: StructureType = .export_metal_command_queue_info_ext,
    p_next: ?*const anyopaque = null,
    queue: Queue = .null_handle,
    mtl_command_queue: MTLCommandQueue_id = null,
};
pub const ExportMetalBufferInfoEXT = extern struct {
    s_type: StructureType = .export_metal_buffer_info_ext,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory = .null_handle,
    mtl_buffer: MTLBuffer_id = null,
};
pub const ImportMetalBufferInfoEXT = extern struct {
    s_type: StructureType = .import_metal_buffer_info_ext,
    p_next: ?*const anyopaque = null,
    mtl_buffer: MTLBuffer_id = null,
};
pub const ExportMetalTextureInfoEXT = extern struct {
    s_type: StructureType = .export_metal_texture_info_ext,
    p_next: ?*const anyopaque = null,
    image: Image = .null_handle,
    image_view: ImageView = .null_handle,
    buffer_view: BufferView = .null_handle,
    plane: ImageAspectFlags = .none,
    mtl_texture: MTLTexture_id = null,
};
pub const ImportMetalTextureInfoEXT = extern struct {
    s_type: StructureType = .import_metal_texture_info_ext,
    p_next: ?*const anyopaque = null,
    plane: ImageAspectFlags = .none,
    mtl_texture: MTLTexture_id = null,
};
pub const ExportMetalIOSurfaceInfoEXT = extern struct {
    s_type: StructureType = .export_metal_io_surface_info_ext,
    p_next: ?*const anyopaque = null,
    image: Image = .null_handle,
    io_surface: IOSurfaceRef = null,
};
pub const ImportMetalIOSurfaceInfoEXT = extern struct {
    s_type: StructureType = .import_metal_io_surface_info_ext,
    p_next: ?*const anyopaque = null,
    io_surface: IOSurfaceRef = null,
};
pub const ExportMetalSharedEventInfoEXT = extern struct {
    s_type: StructureType = .export_metal_shared_event_info_ext,
    p_next: ?*const anyopaque = null,
    semaphore: Semaphore = .null_handle,
    event: Event = .null_handle,
    mtl_shared_event: MTLSharedEvent_id = null,
};
pub const ImportMetalSharedEventInfoEXT = extern struct {
    s_type: StructureType = .import_metal_shared_event_info_ext,
    p_next: ?*const anyopaque = null,
    mtl_shared_event: MTLSharedEvent_id = null,
};
pub const PhysicalDeviceNonSeamlessCubeMapFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_non_seamless_cube_map_features_ext,
    p_next: ?*anyopaque = null,
    non_seamless_cube_map: Bool32 = .false,
};
pub const PhysicalDevicePipelineRobustnessFeatures = extern struct {
    s_type: StructureType = .physical_device_pipeline_robustness_features,
    p_next: ?*anyopaque = null,
    pipeline_robustness: Bool32 = .false,
};
pub const PhysicalDevicePipelineRobustnessFeaturesEXT = PhysicalDevicePipelineRobustnessFeatures;
pub const PipelineRobustnessCreateInfo = extern struct {
    s_type: StructureType = .pipeline_robustness_create_info,
    p_next: ?*const anyopaque = null,
    storage_buffers: PipelineRobustnessBufferBehavior = @enumFromInt(0),
    uniform_buffers: PipelineRobustnessBufferBehavior = @enumFromInt(0),
    vertex_inputs: PipelineRobustnessBufferBehavior = @enumFromInt(0),
    images: PipelineRobustnessImageBehavior = @enumFromInt(0),
};
pub const PipelineRobustnessCreateInfoEXT = PipelineRobustnessCreateInfo;
pub const PhysicalDevicePipelineRobustnessProperties = extern struct {
    s_type: StructureType = .physical_device_pipeline_robustness_properties,
    p_next: ?*anyopaque = null,
    default_robustness_storage_buffers: PipelineRobustnessBufferBehavior = @enumFromInt(0),
    default_robustness_uniform_buffers: PipelineRobustnessBufferBehavior = @enumFromInt(0),
    default_robustness_vertex_inputs: PipelineRobustnessBufferBehavior = @enumFromInt(0),
    default_robustness_images: PipelineRobustnessImageBehavior = @enumFromInt(0),
};
pub const PhysicalDevicePipelineRobustnessPropertiesEXT = PhysicalDevicePipelineRobustnessProperties;
pub const ImageViewSampleWeightCreateInfoQCOM = extern struct {
    s_type: StructureType = .image_view_sample_weight_create_info_qcom,
    p_next: ?*const anyopaque = null,
    filter_center: Offset2D = .{},
    filter_size: Extent2D = .{},
    num_phases: u32 = 0,
};
pub const PhysicalDeviceImageProcessingFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_image_processing_features_qcom,
    p_next: ?*anyopaque = null,
    texture_sample_weighted: Bool32 = .false,
    texture_box_filter: Bool32 = .false,
    texture_block_match: Bool32 = .false,
};
pub const PhysicalDeviceImageProcessingPropertiesQCOM = extern struct {
    s_type: StructureType = .physical_device_image_processing_properties_qcom,
    p_next: ?*anyopaque = null,
    max_weight_filter_phases: u32 = 0,
    max_weight_filter_dimension: Extent2D = .{},
    max_block_match_region: Extent2D = .{},
    max_box_filter_block_size: Extent2D = .{},
};
pub const PhysicalDeviceTilePropertiesFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_tile_properties_features_qcom,
    p_next: ?*anyopaque = null,
    tile_properties: Bool32 = .false,
};
pub const TilePropertiesQCOM = extern struct {
    s_type: StructureType = .tile_properties_qcom,
    p_next: ?*anyopaque = null,
    tile_size: Extent3D = .{},
    apron_size: Extent2D = .{},
    origin: Offset2D = .{},
};
pub const TileMemoryBindInfoQCOM = extern struct {
    s_type: StructureType = .tile_memory_bind_info_qcom,
    p_next: ?*const anyopaque = null,
    memory: DeviceMemory = .null_handle,
};
pub const PhysicalDeviceAmigoProfilingFeaturesSEC = extern struct {
    s_type: StructureType = .physical_device_amigo_profiling_features_sec,
    p_next: ?*anyopaque = null,
    amigo_profiling: Bool32 = .false,
};
pub const AmigoProfilingSubmitInfoSEC = extern struct {
    s_type: StructureType = .amigo_profiling_submit_info_sec,
    p_next: ?*const anyopaque = null,
    first_draw_timestamp: u64 = 0,
    swap_buffer_timestamp: u64 = 0,
};
pub const PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_attachment_feedback_loop_layout_features_ext,
    p_next: ?*anyopaque = null,
    attachment_feedback_loop_layout: Bool32 = .false,
};
pub const PhysicalDeviceDepthClampZeroOneFeaturesEXT = PhysicalDeviceDepthClampZeroOneFeaturesKHR;
pub const AttachmentFeedbackLoopInfoEXT = extern struct {
    s_type: StructureType = .attachment_feedback_loop_info_ext,
    p_next: ?*const anyopaque = null,
    feedback_loop_enable: Bool32 = .false,
};
pub const PhysicalDeviceAddressBindingReportFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_address_binding_report_features_ext,
    p_next: ?*anyopaque = null,
    report_address_binding: Bool32 = .false,
};
pub const DeviceAddressBindingCallbackDataEXT = extern struct {
    s_type: StructureType = .device_address_binding_callback_data_ext,
    p_next: ?*anyopaque = null,
    flags: DeviceAddressBindingFlagsEXT = .none,
    base_address: DeviceAddress = 0,
    size: DeviceSize = 0,
    binding_type: DeviceAddressBindingTypeEXT = @enumFromInt(0),
};
pub const PhysicalDeviceOpticalFlowFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_optical_flow_features_nv,
    p_next: ?*anyopaque = null,
    optical_flow: Bool32 = .false,
};
pub const PhysicalDeviceOpticalFlowPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_optical_flow_properties_nv,
    p_next: ?*anyopaque = null,
    supported_output_grid_sizes: OpticalFlowGridSizeFlagsNV = .none,
    supported_hint_grid_sizes: OpticalFlowGridSizeFlagsNV = .none,
    hint_supported: Bool32 = .false,
    cost_supported: Bool32 = .false,
    bidirectional_flow_supported: Bool32 = .false,
    global_flow_supported: Bool32 = .false,
    min_width: u32 = 0,
    min_height: u32 = 0,
    max_width: u32 = 0,
    max_height: u32 = 0,
    max_num_regions_of_interest: u32 = 0,
};
pub const OpticalFlowImageFormatInfoNV = extern struct {
    s_type: StructureType = .optical_flow_image_format_info_nv,
    p_next: ?*const anyopaque = null,
    usage: OpticalFlowUsageFlagsNV = .none,
};
pub const OpticalFlowImageFormatPropertiesNV = extern struct {
    s_type: StructureType = .optical_flow_image_format_properties_nv,
    p_next: ?*const anyopaque = null,
    format: Format = @enumFromInt(0),
};
pub const OpticalFlowSessionCreateInfoNV = extern struct {
    s_type: StructureType = .optical_flow_session_create_info_nv,
    p_next: ?*anyopaque = null,
    width: u32 = 0,
    height: u32 = 0,
    image_format: Format = @enumFromInt(0),
    flow_vector_format: Format = @enumFromInt(0),
    cost_format: Format = @enumFromInt(0),
    output_grid_size: OpticalFlowGridSizeFlagsNV = .none,
    hint_grid_size: OpticalFlowGridSizeFlagsNV = .none,
    performance_level: OpticalFlowPerformanceLevelNV = @enumFromInt(0),
    flags: OpticalFlowSessionCreateFlagsNV = .none,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *OpticalFlowSessionCreatePrivateDataInfoNV,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const OpticalFlowSessionCreatePrivateDataInfoNV = extern struct {
    s_type: StructureType = .optical_flow_session_create_private_data_info_nv,
    p_next: ?*anyopaque = null,
    id: u32 = 0,
    size: u32 = 0,
    p_private_data: ?*const anyopaque = null,
};
pub const OpticalFlowExecuteInfoNV = extern struct {
    s_type: StructureType = .optical_flow_execute_info_nv,
    p_next: ?*anyopaque = null,
    flags: OpticalFlowExecuteFlagsNV = .none,
    region_count: u32 = 0,
    p_regions: ?[*]const Rect2D = null,
};
pub const PhysicalDeviceFaultFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_fault_features_ext,
    p_next: ?*anyopaque = null,
    device_fault: Bool32 = .false,
    device_fault_vendor_binary: Bool32 = .false,
};
pub const DeviceFaultAddressInfoEXT = extern struct {
    address_type: DeviceFaultAddressTypeEXT = @enumFromInt(0),
    reported_address: DeviceAddress = 0,
    address_precision: DeviceSize = 0,
};
pub const DeviceFaultVendorInfoEXT = extern struct {
    description: [max_description_size - 1:0]u8 = [_:0]u8{0} ** (max_description_size - 1),
    vendor_fault_code: u64 = 0,
    vendor_fault_data: u64 = 0,
};
pub const DeviceFaultCountsEXT = extern struct {
    s_type: StructureType = .device_fault_counts_ext,
    p_next: ?*anyopaque = null,
    address_info_count: u32 = 0,
    vendor_info_count: u32 = 0,
    vendor_binary_size: DeviceSize = 0,
};
pub const DeviceFaultInfoEXT = extern struct {
    s_type: StructureType = .device_fault_info_ext,
    p_next: ?*anyopaque = null,
    description: [max_description_size - 1:0]u8 = [_:0]u8{0} ** (max_description_size - 1),
    p_address_infos: ?*DeviceFaultAddressInfoEXT = null,
    p_vendor_infos: ?*DeviceFaultVendorInfoEXT = null,
    p_vendor_binary_data: ?*anyopaque = null,
};
pub const DeviceFaultVendorBinaryHeaderVersionOneEXT = extern struct {
    header_size: u32 = 0,
    header_version: DeviceFaultVendorBinaryHeaderVersionEXT = @enumFromInt(0),
    vendor_id: u32 = 0,
    device_id: u32 = 0,
    driver_version: u32 = 0,
    pipeline_cache_uuid: [uuid_size]u8 = [_]u8{0} ** uuid_size,
    application_name_offset: u32 = 0,
    application_version: u32 = 0,
    engine_name_offset: u32 = 0,
    engine_version: u32 = 0,
    api_version: Version = Version.from_int(0),
};
pub const PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_pipeline_library_group_handles_features_ext,
    p_next: ?*anyopaque = null,
    pipeline_library_group_handles: Bool32 = .false,
};
pub const DepthBiasInfoEXT = extern struct {
    s_type: StructureType = .depth_bias_info_ext,
    p_next: ?*const anyopaque = null,
    depth_bias_constant_factor: f32 = 0,
    depth_bias_clamp: f32 = 0,
    depth_bias_slope_factor: f32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *DepthBiasRepresentationInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DepthBiasRepresentationInfoEXT = extern struct {
    s_type: StructureType = .depth_bias_representation_info_ext,
    p_next: ?*const anyopaque = null,
    depth_bias_representation: DepthBiasRepresentationEXT = @enumFromInt(0),
    depth_bias_exact: Bool32 = .false,
};
pub const DecompressMemoryRegionNV = extern struct {
    src_address: DeviceAddress = 0,
    dst_address: DeviceAddress = 0,
    compressed_size: DeviceSize = 0,
    decompressed_size: DeviceSize = 0,
    decompression_method: MemoryDecompressionMethodFlagsNV = .none,
};
pub const PhysicalDeviceShaderCoreBuiltinsPropertiesARM = extern struct {
    s_type: StructureType = .physical_device_shader_core_builtins_properties_arm,
    p_next: ?*anyopaque = null,
    shader_core_mask: u64 = 0,
    shader_core_count: u32 = 0,
    shader_warps_per_core: u32 = 0,
};
pub const PhysicalDeviceShaderCoreBuiltinsFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_shader_core_builtins_features_arm,
    p_next: ?*anyopaque = null,
    shader_core_builtins: Bool32 = .false,
};
pub const FrameBoundaryEXT = extern struct {
    s_type: StructureType = .frame_boundary_ext,
    p_next: ?*const anyopaque = null,
    flags: FrameBoundaryFlagsEXT = .none,
    frame_id: u64 = 0,
    image_count: u32 = 0,
    p_images: ?[*]const Image = null,
    buffer_count: u32 = 0,
    p_buffers: ?[*]const Buffer = null,
    tag_name: u64 = 0,
    tag_size: usize = 0,
    p_tag: ?*const anyopaque = null,
};
pub const PhysicalDeviceFrameBoundaryFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_frame_boundary_features_ext,
    p_next: ?*anyopaque = null,
    frame_boundary: Bool32 = .false,
};
pub const PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_dynamic_rendering_unused_attachments_features_ext,
    p_next: ?*anyopaque = null,
    dynamic_rendering_unused_attachments: Bool32 = .false,
};
pub const SurfacePresentModeKHR = extern struct {
    s_type: StructureType = .surface_present_mode_khr,
    p_next: ?*anyopaque = null,
    present_mode: PresentModeKHR = @enumFromInt(0),
};
pub const SurfacePresentModeEXT = SurfacePresentModeKHR;
pub const SurfacePresentScalingCapabilitiesKHR = extern struct {
    s_type: StructureType = .surface_present_scaling_capabilities_khr,
    p_next: ?*anyopaque = null,
    supported_present_scaling: PresentScalingFlagsKHR = .none,
    supported_present_gravity_x: PresentGravityFlagsKHR = .none,
    supported_present_gravity_y: PresentGravityFlagsKHR = .none,
    min_scaled_image_extent: Extent2D = .{},
    max_scaled_image_extent: Extent2D = .{},
};
pub const SurfacePresentScalingCapabilitiesEXT = SurfacePresentScalingCapabilitiesKHR;
pub const SurfacePresentModeCompatibilityKHR = extern struct {
    s_type: StructureType = .surface_present_mode_compatibility_khr,
    p_next: ?*anyopaque = null,
    present_mode_count: u32 = 0,
    p_present_modes: ?[*]PresentModeKHR = null,
};
pub const SurfacePresentModeCompatibilityEXT = SurfacePresentModeCompatibilityKHR;
pub const PhysicalDeviceSwapchainMaintenance1FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_swapchain_maintenance_1_features_khr,
    p_next: ?*anyopaque = null,
    swapchain_maintenance1: Bool32 = .false,
};
pub const PhysicalDeviceSwapchainMaintenance1FeaturesEXT = PhysicalDeviceSwapchainMaintenance1FeaturesKHR;
pub const SwapchainPresentFenceInfoKHR = extern struct {
    s_type: StructureType = .swapchain_present_fence_info_khr,
    p_next: ?*const anyopaque = null,
    swapchain_count: u32 = 0,
    p_fences: ?[*]const Fence = null,
};
pub const SwapchainPresentFenceInfoEXT = SwapchainPresentFenceInfoKHR;
pub const SwapchainPresentModesCreateInfoKHR = extern struct {
    s_type: StructureType = .swapchain_present_modes_create_info_khr,
    p_next: ?*const anyopaque = null,
    present_mode_count: u32 = 0,
    p_present_modes: ?[*]const PresentModeKHR = null,
};
pub const SwapchainPresentModesCreateInfoEXT = SwapchainPresentModesCreateInfoKHR;
pub const SwapchainPresentModeInfoKHR = extern struct {
    s_type: StructureType = .swapchain_present_mode_info_khr,
    p_next: ?*const anyopaque = null,
    swapchain_count: u32 = 0,
    p_present_modes: ?[*]const PresentModeKHR = null,
};
pub const SwapchainPresentModeInfoEXT = SwapchainPresentModeInfoKHR;
pub const SwapchainPresentScalingCreateInfoKHR = extern struct {
    s_type: StructureType = .swapchain_present_scaling_create_info_khr,
    p_next: ?*const anyopaque = null,
    scaling_behavior: PresentScalingFlagsKHR = .none,
    present_gravity_x: PresentGravityFlagsKHR = .none,
    present_gravity_y: PresentGravityFlagsKHR = .none,
};
pub const SwapchainPresentScalingCreateInfoEXT = SwapchainPresentScalingCreateInfoKHR;
pub const ReleaseSwapchainImagesInfoKHR = extern struct {
    s_type: StructureType = .release_swapchain_images_info_khr,
    p_next: ?*const anyopaque = null,
    swapchain: SwapchainKHR = .null_handle,
    image_index_count: u32 = 0,
    p_image_indices: ?[*]const u32 = null,
};
pub const ReleaseSwapchainImagesInfoEXT = ReleaseSwapchainImagesInfoKHR;
pub const PhysicalDeviceDepthBiasControlFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_depth_bias_control_features_ext,
    p_next: ?*anyopaque = null,
    depth_bias_control: Bool32 = .false,
    least_representable_value_force_unorm_representation: Bool32 = .false,
    float_representation: Bool32 = .false,
    depth_bias_exact: Bool32 = .false,
};
pub const PhysicalDeviceRayTracingInvocationReorderFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_invocation_reorder_features_nv,
    p_next: ?*anyopaque = null,
    ray_tracing_invocation_reorder: Bool32 = .false,
};
pub const PhysicalDeviceRayTracingInvocationReorderPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_invocation_reorder_properties_nv,
    p_next: ?*anyopaque = null,
    ray_tracing_invocation_reorder_reordering_hint: RayTracingInvocationReorderModeNV = @enumFromInt(0),
};
pub const PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_extended_sparse_address_space_features_nv,
    p_next: ?*anyopaque = null,
    extended_sparse_address_space: Bool32 = .false,
};
pub const PhysicalDeviceExtendedSparseAddressSpacePropertiesNV = extern struct {
    s_type: StructureType = .physical_device_extended_sparse_address_space_properties_nv,
    p_next: ?*anyopaque = null,
    extended_sparse_address_space_size: DeviceSize = 0,
    extended_sparse_image_usage_flags: ImageUsageFlags = .none,
    extended_sparse_buffer_usage_flags: BufferUsageFlags = .none,
};
pub const DirectDriverLoadingInfoLUNARG = extern struct {
    s_type: StructureType = .direct_driver_loading_info_lunarg,
    p_next: ?*anyopaque = null,
    flags: DirectDriverLoadingFlagsLUNARG = .none,
    pfn_get_instance_proc_addr: ?FpGetInstanceProcAddrLUNARG = null,
};
pub const DirectDriverLoadingListLUNARG = extern struct {
    s_type: StructureType = .direct_driver_loading_list_lunarg,
    p_next: ?*const anyopaque = null,
    mode: DirectDriverLoadingModeLUNARG = @enumFromInt(0),
    driver_count: u32 = 0,
    p_drivers: ?[*]const DirectDriverLoadingInfoLUNARG = null,
};
pub const PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_multiview_per_view_viewports_features_qcom,
    p_next: ?*anyopaque = null,
    multiview_per_view_viewports: Bool32 = .false,
};
pub const PhysicalDeviceRayTracingPositionFetchFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_ray_tracing_position_fetch_features_khr,
    p_next: ?*anyopaque = null,
    ray_tracing_position_fetch: Bool32 = .false,
};
pub const DeviceImageSubresourceInfo = extern struct {
    s_type: StructureType = .device_image_subresource_info,
    p_next: ?*const anyopaque = null,
    p_create_info: ?*const ImageCreateInfo = null,
    p_subresource: ?*const ImageSubresource2 = null,
};
pub const DeviceImageSubresourceInfoKHR = DeviceImageSubresourceInfo;
pub const PhysicalDeviceShaderCorePropertiesARM = extern struct {
    s_type: StructureType = .physical_device_shader_core_properties_arm,
    p_next: ?*anyopaque = null,
    pixel_rate: u32 = 0,
    texel_rate: u32 = 0,
    fma_rate: u32 = 0,
};
pub const PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_multiview_per_view_render_areas_features_qcom,
    p_next: ?*anyopaque = null,
    multiview_per_view_render_areas: Bool32 = .false,
};
pub const MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = extern struct {
    s_type: StructureType = .multiview_per_view_render_areas_render_pass_begin_info_qcom,
    p_next: ?*const anyopaque = null,
    per_view_render_area_count: u32 = 0,
    p_per_view_render_areas: ?[*]const Rect2D = null,
};
pub const QueryLowLatencySupportNV = extern struct {
    s_type: StructureType = .query_low_latency_support_nv,
    p_next: ?*const anyopaque = null,
    p_queried_low_latency_data: ?*anyopaque = null,
};
pub const MemoryMapInfo = extern struct {
    s_type: StructureType = .memory_map_info,
    p_next: ?*const anyopaque = null,
    flags: MemoryMapFlags = .none,
    memory: DeviceMemory = .null_handle,
    offset: DeviceSize = 0,
    size: DeviceSize = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *MemoryMapPlacedInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const MemoryMapInfoKHR = MemoryMapInfo;
pub const MemoryUnmapInfo = extern struct {
    s_type: StructureType = .memory_unmap_info,
    p_next: ?*const anyopaque = null,
    flags: MemoryUnmapFlags = .none,
    memory: DeviceMemory = .null_handle,
};
pub const MemoryUnmapInfoKHR = MemoryUnmapInfo;
pub const PhysicalDeviceShaderObjectFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_object_features_ext,
    p_next: ?*anyopaque = null,
    shader_object: Bool32 = .false,
};
pub const PhysicalDeviceShaderObjectPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_object_properties_ext,
    p_next: ?*anyopaque = null,
    shader_binary_uuid: [uuid_size]u8 = [_]u8{0} ** uuid_size,
    shader_binary_version: u32 = 0,
};
pub const ShaderCreateInfoEXT = extern struct {
    s_type: StructureType = .shader_create_info_ext,
    p_next: ?*const anyopaque = null,
    flags: ShaderCreateFlagsEXT = .none,
    stage: ShaderStageFlags = .none,
    next_stage: ShaderStageFlags = .none,
    code_type: ShaderCodeTypeEXT = @enumFromInt(0),
    code_size: usize = 0,
    p_code: ?*const anyopaque = null,
    p_name: ?[*:0]const u8 = null,
    set_layout_count: u32 = 0,
    p_set_layouts: ?[*]const DescriptorSetLayout = null,
    push_constant_range_count: u32 = 0,
    p_push_constant_ranges: ?[*]const PushConstantRange = null,
    p_specialization_info: ?*const SpecializationInfo = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ValidationFeaturesEXT,
            *PipelineShaderStageRequiredSubgroupSizeCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PhysicalDeviceShaderTileImageFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_tile_image_features_ext,
    p_next: ?*anyopaque = null,
    shader_tile_image_color_read_access: Bool32 = .false,
    shader_tile_image_depth_read_access: Bool32 = .false,
    shader_tile_image_stencil_read_access: Bool32 = .false,
};
pub const PhysicalDeviceShaderTileImagePropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_tile_image_properties_ext,
    p_next: ?*anyopaque = null,
    shader_tile_image_coherent_read_accelerated: Bool32 = .false,
    shader_tile_image_read_sample_from_pixel_rate_invocation: Bool32 = .false,
    shader_tile_image_read_from_helper_invocation: Bool32 = .false,
};
pub const PhysicalDeviceCooperativeMatrixFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_cooperative_matrix_features_khr,
    p_next: ?*anyopaque = null,
    cooperative_matrix: Bool32 = .false,
    cooperative_matrix_robust_buffer_access: Bool32 = .false,
};
pub const CooperativeMatrixPropertiesKHR = extern struct {
    s_type: StructureType = .cooperative_matrix_properties_khr,
    p_next: ?*anyopaque = null,
    m_size: u32 = 0,
    n_size: u32 = 0,
    k_size: u32 = 0,
    a_type: ComponentTypeKHR = @enumFromInt(0),
    b_type: ComponentTypeKHR = @enumFromInt(0),
    c_type: ComponentTypeKHR = @enumFromInt(0),
    result_type: ComponentTypeKHR = @enumFromInt(0),
    saturating_accumulation: Bool32 = .false,
    scope: ScopeKHR = @enumFromInt(0),
};
pub const PhysicalDeviceCooperativeMatrixPropertiesKHR = extern struct {
    s_type: StructureType = .physical_device_cooperative_matrix_properties_khr,
    p_next: ?*anyopaque = null,
    cooperative_matrix_supported_stages: ShaderStageFlags = .none,
};
pub const PhysicalDeviceShaderEnqueuePropertiesAMDX = extern struct {
    s_type: StructureType = .physical_device_shader_enqueue_properties_amdx,
    p_next: ?*anyopaque = null,
    max_execution_graph_depth: u32 = 0,
    max_execution_graph_shader_output_nodes: u32 = 0,
    max_execution_graph_shader_payload_size: u32 = 0,
    max_execution_graph_shader_payload_count: u32 = 0,
    execution_graph_dispatch_address_alignment: u32 = 0,
    max_execution_graph_workgroup_count: [3]u32 = [_]u32{0} ** 3,
    max_execution_graph_workgroups: u32 = 0,
};
pub const PhysicalDeviceShaderEnqueueFeaturesAMDX = extern struct {
    s_type: StructureType = .physical_device_shader_enqueue_features_amdx,
    p_next: ?*anyopaque = null,
    shader_enqueue: Bool32 = .false,
    shader_mesh_enqueue: Bool32 = .false,
};
pub const ExecutionGraphPipelineCreateInfoAMDX = extern struct {
    s_type: StructureType = .execution_graph_pipeline_create_info_amdx,
    p_next: ?*const anyopaque = null,
    flags: PipelineCreateFlags = .none,
    stage_count: u32 = 0,
    p_stages: ?[*]const PipelineShaderStageCreateInfo = null,
    p_library_info: ?*const PipelineLibraryCreateInfoKHR = null,
    layout: PipelineLayout = .null_handle,
    base_pipeline_handle: Pipeline = .null_handle,
    base_pipeline_index: i32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineCreationFeedbackCreateInfo,
            *PipelineCompilerControlCreateInfoAMD,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PipelineShaderStageNodeCreateInfoAMDX = extern struct {
    s_type: StructureType = .pipeline_shader_stage_node_create_info_amdx,
    p_next: ?*const anyopaque = null,
    p_name: ?[*:0]const u8 = null,
    index: u32 = 0,
};
pub const ExecutionGraphPipelineScratchSizeAMDX = extern struct {
    s_type: StructureType = .execution_graph_pipeline_scratch_size_amdx,
    p_next: ?*anyopaque = null,
    min_size: DeviceSize = 0,
    max_size: DeviceSize = 0,
    size_granularity: DeviceSize = 0,
};
pub const DispatchGraphInfoAMDX = extern struct {
    node_index: u32 = 0,
    payload_count: u32 = 0,
    payloads: DeviceOrHostAddressConstAMDX = .{ .device_address = 0 },
    payload_stride: u64 = 0,
};
pub const DispatchGraphCountInfoAMDX = extern struct {
    count: u32 = 0,
    infos: DeviceOrHostAddressConstAMDX = .{ .device_address = 0 },
    stride: u64 = 0,
};
pub const PhysicalDeviceAntiLagFeaturesAMD = extern struct {
    s_type: StructureType = .physical_device_anti_lag_features_amd,
    p_next: ?*anyopaque = null,
    anti_lag: Bool32 = .false,
};
pub const AntiLagDataAMD = extern struct {
    s_type: StructureType = .anti_lag_data_amd,
    p_next: ?*const anyopaque = null,
    mode: AntiLagModeAMD = @enumFromInt(0),
    max_fps: u32 = 0,
    p_presentation_info: ?*const AntiLagPresentationInfoAMD = null,
};
pub const AntiLagPresentationInfoAMD = extern struct {
    s_type: StructureType = .anti_lag_presentation_info_amd,
    p_next: ?*anyopaque = null,
    stage: AntiLagStageAMD = @enumFromInt(0),
    frame_index: u64 = 0,
};
pub const BindMemoryStatus = extern struct {
    s_type: StructureType = .bind_memory_status,
    p_next: ?*const anyopaque = null,
    p_result: ?*Result = null,
};
pub const PhysicalDeviceTileMemoryHeapFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_tile_memory_heap_features_qcom,
    p_next: ?*anyopaque = null,
    tile_memory_heap: Bool32 = .false,
};
pub const PhysicalDeviceTileMemoryHeapPropertiesQCOM = extern struct {
    s_type: StructureType = .physical_device_tile_memory_heap_properties_qcom,
    p_next: ?*anyopaque = null,
    queue_submit_boundary: Bool32 = .false,
    tile_buffer_transfers: Bool32 = .false,
};
pub const TileMemorySizeInfoQCOM = extern struct {
    s_type: StructureType = .tile_memory_size_info_qcom,
    p_next: ?*const anyopaque = null,
    size: DeviceSize = 0,
};
pub const TileMemoryRequirementsQCOM = extern struct {
    s_type: StructureType = .tile_memory_requirements_qcom,
    p_next: ?*anyopaque = null,
    size: DeviceSize = 0,
    alignment: DeviceSize = 0,
};
pub const BindMemoryStatusKHR = BindMemoryStatus;
pub const BindDescriptorSetsInfo = extern struct {
    s_type: StructureType = .bind_descriptor_sets_info,
    p_next: ?*const anyopaque = null,
    stage_flags: ShaderStageFlags = .none,
    layout: PipelineLayout = .null_handle,
    first_set: u32 = 0,
    descriptor_set_count: u32 = 0,
    p_descriptor_sets: ?[*]const DescriptorSet = null,
    dynamic_offset_count: u32 = 0,
    p_dynamic_offsets: ?[*]const u32 = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineLayoutCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const BindDescriptorSetsInfoKHR = BindDescriptorSetsInfo;
pub const PushConstantsInfo = extern struct {
    s_type: StructureType = .push_constants_info,
    p_next: ?*const anyopaque = null,
    layout: PipelineLayout = .null_handle,
    stage_flags: ShaderStageFlags = .none,
    offset: u32 = 0,
    size: u32 = 0,
    p_values: ?*const anyopaque = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineLayoutCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PushConstantsInfoKHR = PushConstantsInfo;
pub const PushDescriptorSetInfo = extern struct {
    s_type: StructureType = .push_descriptor_set_info,
    p_next: ?*const anyopaque = null,
    stage_flags: ShaderStageFlags = .none,
    layout: PipelineLayout = .null_handle,
    set: u32 = 0,
    descriptor_write_count: u32 = 0,
    p_descriptor_writes: ?[*]const WriteDescriptorSet = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineLayoutCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PushDescriptorSetInfoKHR = PushDescriptorSetInfo;
pub const PushDescriptorSetWithTemplateInfo = extern struct {
    s_type: StructureType = .push_descriptor_set_with_template_info,
    p_next: ?*const anyopaque = null,
    descriptor_update_template: DescriptorUpdateTemplate = .null_handle,
    layout: PipelineLayout = .null_handle,
    set: u32 = 0,
    p_data: ?*const anyopaque = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineLayoutCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PushDescriptorSetWithTemplateInfoKHR = PushDescriptorSetWithTemplateInfo;
pub const SetDescriptorBufferOffsetsInfoEXT = extern struct {
    s_type: StructureType = .set_descriptor_buffer_offsets_info_ext,
    p_next: ?*const anyopaque = null,
    stage_flags: ShaderStageFlags = .none,
    layout: PipelineLayout = .null_handle,
    first_set: u32 = 0,
    set_count: u32 = 0,
    p_buffer_indices: ?[*]const u32 = null,
    p_offsets: ?[*]const DeviceSize = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineLayoutCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const BindDescriptorBufferEmbeddedSamplersInfoEXT = extern struct {
    s_type: StructureType = .bind_descriptor_buffer_embedded_samplers_info_ext,
    p_next: ?*const anyopaque = null,
    stage_flags: ShaderStageFlags = .none,
    layout: PipelineLayout = .null_handle,
    set: u32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *PipelineLayoutCreateInfo,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PhysicalDeviceCubicClampFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_cubic_clamp_features_qcom,
    p_next: ?*anyopaque = null,
    cubic_range_clamp: Bool32 = .false,
};
pub const PhysicalDeviceYcbcrDegammaFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_ycbcr_degamma_features_qcom,
    p_next: ?*anyopaque = null,
    ycbcr_degamma: Bool32 = .false,
};
pub const SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = extern struct {
    s_type: StructureType = .sampler_ycbcr_conversion_ycbcr_degamma_create_info_qcom,
    p_next: ?*anyopaque = null,
    enable_y_degamma: Bool32 = .false,
    enable_cb_cr_degamma: Bool32 = .false,
};
pub const PhysicalDeviceCubicWeightsFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_cubic_weights_features_qcom,
    p_next: ?*anyopaque = null,
    selectable_cubic_weights: Bool32 = .false,
};
pub const SamplerCubicWeightsCreateInfoQCOM = extern struct {
    s_type: StructureType = .sampler_cubic_weights_create_info_qcom,
    p_next: ?*const anyopaque = null,
    cubic_weights: CubicFilterWeightsQCOM = @enumFromInt(0),
};
pub const BlitImageCubicWeightsInfoQCOM = extern struct {
    s_type: StructureType = .blit_image_cubic_weights_info_qcom,
    p_next: ?*const anyopaque = null,
    cubic_weights: CubicFilterWeightsQCOM = @enumFromInt(0),
};
pub const PhysicalDeviceImageProcessing2FeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_image_processing_2_features_qcom,
    p_next: ?*anyopaque = null,
    texture_block_match2: Bool32 = .false,
};
pub const PhysicalDeviceImageProcessing2PropertiesQCOM = extern struct {
    s_type: StructureType = .physical_device_image_processing_2_properties_qcom,
    p_next: ?*anyopaque = null,
    max_block_match_window: Extent2D = .{},
};
pub const SamplerBlockMatchWindowCreateInfoQCOM = extern struct {
    s_type: StructureType = .sampler_block_match_window_create_info_qcom,
    p_next: ?*const anyopaque = null,
    window_extent: Extent2D = .{},
    window_compare_mode: BlockMatchWindowCompareModeQCOM = @enumFromInt(0),
};
pub const PhysicalDeviceDescriptorPoolOverallocationFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_descriptor_pool_overallocation_features_nv,
    p_next: ?*anyopaque = null,
    descriptor_pool_overallocation: Bool32 = .false,
};
pub const PhysicalDeviceLayeredDriverPropertiesMSFT = extern struct {
    s_type: StructureType = .physical_device_layered_driver_properties_msft,
    p_next: ?*anyopaque = null,
    underlying_api: LayeredDriverUnderlyingApiMSFT = @enumFromInt(0),
};
pub const PhysicalDevicePerStageDescriptorSetFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_per_stage_descriptor_set_features_nv,
    p_next: ?*anyopaque = null,
    per_stage_descriptor_set: Bool32 = .false,
    dynamic_pipeline_layout: Bool32 = .false,
};
pub const PhysicalDeviceExternalFormatResolveFeaturesANDROID = extern struct {
    s_type: StructureType = .physical_device_external_format_resolve_features_android,
    p_next: ?*anyopaque = null,
    external_format_resolve: Bool32 = .false,
};
pub const PhysicalDeviceExternalFormatResolvePropertiesANDROID = extern struct {
    s_type: StructureType = .physical_device_external_format_resolve_properties_android,
    p_next: ?*anyopaque = null,
    null_color_attachment_with_external_format_resolve: Bool32 = .false,
    external_format_resolve_chroma_offset_x: ChromaLocation = @enumFromInt(0),
    external_format_resolve_chroma_offset_y: ChromaLocation = @enumFromInt(0),
};
pub const AndroidHardwareBufferFormatResolvePropertiesANDROID = extern struct {
    s_type: StructureType = .android_hardware_buffer_format_resolve_properties_android,
    p_next: ?*anyopaque = null,
    color_attachment_format: Format = @enumFromInt(0),
};
pub const LatencySleepModeInfoNV = extern struct {
    s_type: StructureType = .latency_sleep_mode_info_nv,
    p_next: ?*const anyopaque = null,
    low_latency_mode: Bool32 = .false,
    low_latency_boost: Bool32 = .false,
    minimum_interval_us: u32 = 0,
};
pub const LatencySleepInfoNV = extern struct {
    s_type: StructureType = .latency_sleep_info_nv,
    p_next: ?*const anyopaque = null,
    signal_semaphore: Semaphore = .null_handle,
    value: u64 = 0,
};
pub const SetLatencyMarkerInfoNV = extern struct {
    s_type: StructureType = .set_latency_marker_info_nv,
    p_next: ?*const anyopaque = null,
    present_id: u64 = 0,
    marker: LatencyMarkerNV = @enumFromInt(0),
};
pub const GetLatencyMarkerInfoNV = extern struct {
    s_type: StructureType = .get_latency_marker_info_nv,
    p_next: ?*const anyopaque = null,
    timing_count: u32 = 0,
    p_timings: ?[*]LatencyTimingsFrameReportNV = null,
};
pub const LatencyTimingsFrameReportNV = extern struct {
    s_type: StructureType = .latency_timings_frame_report_nv,
    p_next: ?*const anyopaque = null,
    present_id: u64 = 0,
    input_sample_time_us: u64 = 0,
    sim_start_time_us: u64 = 0,
    sim_end_time_us: u64 = 0,
    render_submit_start_time_us: u64 = 0,
    render_submit_end_time_us: u64 = 0,
    present_start_time_us: u64 = 0,
    present_end_time_us: u64 = 0,
    driver_start_time_us: u64 = 0,
    driver_end_time_us: u64 = 0,
    os_render_queue_start_time_us: u64 = 0,
    os_render_queue_end_time_us: u64 = 0,
    gpu_render_start_time_us: u64 = 0,
    gpu_render_end_time_us: u64 = 0,
};
pub const OutOfBandQueueTypeInfoNV = extern struct {
    s_type: StructureType = .out_of_band_queue_type_info_nv,
    p_next: ?*const anyopaque = null,
    queue_type: OutOfBandQueueTypeNV = @enumFromInt(0),
};
pub const LatencySubmissionPresentIdNV = extern struct {
    s_type: StructureType = .latency_submission_present_id_nv,
    p_next: ?*const anyopaque = null,
    present_id: u64 = 0,
};
pub const SwapchainLatencyCreateInfoNV = extern struct {
    s_type: StructureType = .swapchain_latency_create_info_nv,
    p_next: ?*const anyopaque = null,
    latency_mode_enable: Bool32 = .false,
};
pub const LatencySurfaceCapabilitiesNV = extern struct {
    s_type: StructureType = .latency_surface_capabilities_nv,
    p_next: ?*const anyopaque = null,
    present_mode_count: u32 = 0,
    p_present_modes: ?[*]PresentModeKHR = null,
};
pub const PhysicalDeviceCudaKernelLaunchFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_cuda_kernel_launch_features_nv,
    p_next: ?*anyopaque = null,
    cuda_kernel_launch_features: Bool32 = .false,
};
pub const PhysicalDeviceCudaKernelLaunchPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_cuda_kernel_launch_properties_nv,
    p_next: ?*anyopaque = null,
    compute_capability_minor: u32 = 0,
    compute_capability_major: u32 = 0,
};
pub const DeviceQueueShaderCoreControlCreateInfoARM = extern struct {
    s_type: StructureType = .device_queue_shader_core_control_create_info_arm,
    p_next: ?*anyopaque = null,
    shader_core_count: u32 = 0,
};
pub const PhysicalDeviceSchedulingControlsFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_scheduling_controls_features_arm,
    p_next: ?*anyopaque = null,
    scheduling_controls: Bool32 = .false,
};
pub const PhysicalDeviceSchedulingControlsPropertiesARM = extern struct {
    s_type: StructureType = .physical_device_scheduling_controls_properties_arm,
    p_next: ?*anyopaque = null,
    scheduling_controls_flags: PhysicalDeviceSchedulingControlsFlagsARM = .none,
};
pub const PhysicalDeviceRelaxedLineRasterizationFeaturesIMG = extern struct {
    s_type: StructureType = .physical_device_relaxed_line_rasterization_features_img,
    p_next: ?*anyopaque = null,
    relaxed_line_rasterization: Bool32 = .false,
};
pub const PhysicalDeviceRenderPassStripedFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_render_pass_striped_features_arm,
    p_next: ?*anyopaque = null,
    render_pass_striped: Bool32 = .false,
};
pub const PhysicalDeviceRenderPassStripedPropertiesARM = extern struct {
    s_type: StructureType = .physical_device_render_pass_striped_properties_arm,
    p_next: ?*anyopaque = null,
    render_pass_stripe_granularity: Extent2D = .{},
    max_render_pass_stripes: u32 = 0,
};
pub const RenderPassStripeInfoARM = extern struct {
    s_type: StructureType = .render_pass_stripe_info_arm,
    p_next: ?*const anyopaque = null,
    stripe_area: Rect2D = .{},
};
pub const RenderPassStripeBeginInfoARM = extern struct {
    s_type: StructureType = .render_pass_stripe_begin_info_arm,
    p_next: ?*const anyopaque = null,
    stripe_info_count: u32 = 0,
    p_stripe_infos: ?[*]const RenderPassStripeInfoARM = null,
};
pub const RenderPassStripeSubmitInfoARM = extern struct {
    s_type: StructureType = .render_pass_stripe_submit_info_arm,
    p_next: ?*const anyopaque = null,
    stripe_semaphore_info_count: u32 = 0,
    p_stripe_semaphore_infos: ?[*]const SemaphoreSubmitInfo = null,
};
pub const PhysicalDevicePipelineOpacityMicromapFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_pipeline_opacity_micromap_features_arm,
    p_next: ?*anyopaque = null,
    pipeline_opacity_micromap: Bool32 = .false,
};
pub const PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_shader_maximal_reconvergence_features_khr,
    p_next: ?*anyopaque = null,
    shader_maximal_reconvergence: Bool32 = .false,
};
pub const PhysicalDeviceShaderSubgroupRotateFeatures = extern struct {
    s_type: StructureType = .physical_device_shader_subgroup_rotate_features,
    p_next: ?*anyopaque = null,
    shader_subgroup_rotate: Bool32 = .false,
    shader_subgroup_rotate_clustered: Bool32 = .false,
};
pub const PhysicalDeviceShaderSubgroupRotateFeaturesKHR = PhysicalDeviceShaderSubgroupRotateFeatures;
pub const PhysicalDeviceShaderExpectAssumeFeatures = extern struct {
    s_type: StructureType = .physical_device_shader_expect_assume_features,
    p_next: ?*anyopaque = null,
    shader_expect_assume: Bool32 = .false,
};
pub const PhysicalDeviceShaderExpectAssumeFeaturesKHR = PhysicalDeviceShaderExpectAssumeFeatures;
pub const PhysicalDeviceShaderFloatControls2Features = extern struct {
    s_type: StructureType = .physical_device_shader_float_controls_2_features,
    p_next: ?*anyopaque = null,
    shader_float_controls2: Bool32 = .false,
};
pub const PhysicalDeviceShaderFloatControls2FeaturesKHR = PhysicalDeviceShaderFloatControls2Features;
pub const PhysicalDeviceDynamicRenderingLocalReadFeatures = extern struct {
    s_type: StructureType = .physical_device_dynamic_rendering_local_read_features,
    p_next: ?*anyopaque = null,
    dynamic_rendering_local_read: Bool32 = .false,
};
pub const PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = PhysicalDeviceDynamicRenderingLocalReadFeatures;
pub const RenderingAttachmentLocationInfo = extern struct {
    s_type: StructureType = .rendering_attachment_location_info,
    p_next: ?*const anyopaque = null,
    color_attachment_count: u32 = 0,
    p_color_attachment_locations: ?[*]const u32 = null,
};
pub const RenderingAttachmentLocationInfoKHR = RenderingAttachmentLocationInfo;
pub const RenderingInputAttachmentIndexInfo = extern struct {
    s_type: StructureType = .rendering_input_attachment_index_info,
    p_next: ?*const anyopaque = null,
    color_attachment_count: u32 = 0,
    p_color_attachment_input_indices: ?[*]const u32 = null,
    p_depth_input_attachment_index: ?*const u32 = null,
    p_stencil_input_attachment_index: ?*const u32 = null,
};
pub const RenderingInputAttachmentIndexInfoKHR = RenderingInputAttachmentIndexInfo;
pub const PhysicalDeviceShaderQuadControlFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_shader_quad_control_features_khr,
    p_next: ?*anyopaque = null,
    shader_quad_control: Bool32 = .false,
};
pub const PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_shader_atomic_float16_vector_features_nv,
    p_next: ?*anyopaque = null,
    shader_float16_vector_atomics: Bool32 = .false,
};
pub const PhysicalDeviceMapMemoryPlacedFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_map_memory_placed_features_ext,
    p_next: ?*anyopaque = null,
    memory_map_placed: Bool32 = .false,
    memory_map_range_placed: Bool32 = .false,
    memory_unmap_reserve: Bool32 = .false,
};
pub const PhysicalDeviceMapMemoryPlacedPropertiesEXT = extern struct {
    s_type: StructureType = .physical_device_map_memory_placed_properties_ext,
    p_next: ?*anyopaque = null,
    min_placed_memory_map_alignment: DeviceSize = 0,
};
pub const MemoryMapPlacedInfoEXT = extern struct {
    s_type: StructureType = .memory_map_placed_info_ext,
    p_next: ?*const anyopaque = null,
    p_placed_address: ?*anyopaque = null,
};
pub const PhysicalDeviceShaderBfloat16FeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_shader_bfloat16_features_khr,
    p_next: ?*anyopaque = null,
    shader_b_float16_type: Bool32 = .false,
    shader_b_float16_dot_product: Bool32 = .false,
    shader_b_float16_cooperative_matrix: Bool32 = .false,
};
pub const PhysicalDeviceRawAccessChainsFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_raw_access_chains_features_nv,
    p_next: ?*anyopaque = null,
    shader_raw_access_chains: Bool32 = .false,
};
pub const PhysicalDeviceCommandBufferInheritanceFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_command_buffer_inheritance_features_nv,
    p_next: ?*anyopaque = null,
    command_buffer_inheritance: Bool32 = .false,
};
pub const PhysicalDeviceImageAlignmentControlFeaturesMESA = extern struct {
    s_type: StructureType = .physical_device_image_alignment_control_features_mesa,
    p_next: ?*anyopaque = null,
    image_alignment_control: Bool32 = .false,
};
pub const PhysicalDeviceImageAlignmentControlPropertiesMESA = extern struct {
    s_type: StructureType = .physical_device_image_alignment_control_properties_mesa,
    p_next: ?*anyopaque = null,
    supported_image_alignment_mask: u32 = 0,
};
pub const ImageAlignmentControlCreateInfoMESA = extern struct {
    s_type: StructureType = .image_alignment_control_create_info_mesa,
    p_next: ?*const anyopaque = null,
    maximum_requested_alignment: u32 = 0,
};
pub const PhysicalDeviceShaderReplicatedCompositesFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_replicated_composites_features_ext,
    p_next: ?*anyopaque = null,
    shader_replicated_composites: Bool32 = .false,
};
pub const PhysicalDevicePresentModeFifoLatestReadyFeaturesEXT = PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR;
pub const PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_present_mode_fifo_latest_ready_features_khr,
    p_next: ?*anyopaque = null,
    present_mode_fifo_latest_ready: Bool32 = .false,
};
pub const DepthClampRangeEXT = extern struct {
    min_depth_clamp: f32 = 0,
    max_depth_clamp: f32 = 0,
};
pub const PhysicalDeviceCooperativeMatrix2FeaturesNV = extern struct {
    s_type: StructureType = .physical_device_cooperative_matrix_2_features_nv,
    p_next: ?*anyopaque = null,
    cooperative_matrix_workgroup_scope: Bool32 = .false,
    cooperative_matrix_flexible_dimensions: Bool32 = .false,
    cooperative_matrix_reductions: Bool32 = .false,
    cooperative_matrix_conversions: Bool32 = .false,
    cooperative_matrix_per_element_operations: Bool32 = .false,
    cooperative_matrix_tensor_addressing: Bool32 = .false,
    cooperative_matrix_block_loads: Bool32 = .false,
};
pub const PhysicalDeviceCooperativeMatrix2PropertiesNV = extern struct {
    s_type: StructureType = .physical_device_cooperative_matrix_2_properties_nv,
    p_next: ?*anyopaque = null,
    cooperative_matrix_workgroup_scope_max_workgroup_size: u32 = 0,
    cooperative_matrix_flexible_dimensions_max_dimension: u32 = 0,
    cooperative_matrix_workgroup_scope_reserved_shared_memory: u32 = 0,
};
pub const CooperativeMatrixFlexibleDimensionsPropertiesNV = extern struct {
    s_type: StructureType = .cooperative_matrix_flexible_dimensions_properties_nv,
    p_next: ?*anyopaque = null,
    m_granularity: u32 = 0,
    n_granularity: u32 = 0,
    k_granularity: u32 = 0,
    a_type: ComponentTypeKHR = @enumFromInt(0),
    b_type: ComponentTypeKHR = @enumFromInt(0),
    c_type: ComponentTypeKHR = @enumFromInt(0),
    result_type: ComponentTypeKHR = @enumFromInt(0),
    saturating_accumulation: Bool32 = .false,
    scope: ScopeKHR = @enumFromInt(0),
    workgroup_invocations: u32 = 0,
};
pub const PhysicalDeviceHdrVividFeaturesHUAWEI = extern struct {
    s_type: StructureType = .physical_device_hdr_vivid_features_huawei,
    p_next: ?*anyopaque = null,
    hdr_vivid: Bool32 = .false,
};
pub const PhysicalDeviceVertexAttributeRobustnessFeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_vertex_attribute_robustness_features_ext,
    p_next: ?*anyopaque = null,
    vertex_attribute_robustness: Bool32 = .false,
};
pub const PhysicalDeviceDenseGeometryFormatFeaturesAMDX = extern struct {
    s_type: StructureType = .physical_device_dense_geometry_format_features_amdx,
    p_next: ?*anyopaque = null,
    dense_geometry_format: Bool32 = .false,
};
pub const AccelerationStructureDenseGeometryFormatTrianglesDataAMDX = extern struct {
    s_type: StructureType = .acceleration_structure_dense_geometry_format_triangles_data_amdx,
    p_next: ?*const anyopaque = null,
    compressed_data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    data_size: DeviceSize = 0,
    num_triangles: u32 = 0,
    num_vertices: u32 = 0,
    max_primitive_index: u32 = 0,
    max_geometry_index: u32 = 0,
    format: CompressedTriangleFormatAMDX = @enumFromInt(0),
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *AccelerationStructureTrianglesOpacityMicromapEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const PhysicalDeviceDepthClampZeroOneFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_depth_clamp_zero_one_features_khr,
    p_next: ?*anyopaque = null,
    depth_clamp_zero_one: Bool32 = .false,
};
pub const PhysicalDeviceCooperativeVectorFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_cooperative_vector_features_nv,
    p_next: ?*anyopaque = null,
    cooperative_vector: Bool32 = .false,
    cooperative_vector_training: Bool32 = .false,
};
pub const CooperativeVectorPropertiesNV = extern struct {
    s_type: StructureType = .cooperative_vector_properties_nv,
    p_next: ?*anyopaque = null,
    input_type: ComponentTypeKHR = @enumFromInt(0),
    input_interpretation: ComponentTypeKHR = @enumFromInt(0),
    matrix_interpretation: ComponentTypeKHR = @enumFromInt(0),
    bias_interpretation: ComponentTypeKHR = @enumFromInt(0),
    result_type: ComponentTypeKHR = @enumFromInt(0),
    transpose: Bool32 = .false,
};
pub const PhysicalDeviceCooperativeVectorPropertiesNV = extern struct {
    s_type: StructureType = .physical_device_cooperative_vector_properties_nv,
    p_next: ?*anyopaque = null,
    cooperative_vector_supported_stages: ShaderStageFlags = .none,
    cooperative_vector_training_float16_accumulation: Bool32 = .false,
    cooperative_vector_training_float32_accumulation: Bool32 = .false,
    max_cooperative_vector_components: u32 = 0,
};
pub const ConvertCooperativeVectorMatrixInfoNV = extern struct {
    s_type: StructureType = .convert_cooperative_vector_matrix_info_nv,
    p_next: ?*const anyopaque = null,
    src_size: usize = 0,
    src_data: DeviceOrHostAddressConstKHR = .{ .device_address = 0 },
    p_dst_size: ?*usize = null,
    dst_data: DeviceOrHostAddressKHR = .{ .device_address = 0 },
    src_component_type: ComponentTypeKHR = @enumFromInt(0),
    dst_component_type: ComponentTypeKHR = @enumFromInt(0),
    num_rows: u32 = 0,
    num_columns: u32 = 0,
    src_layout: CooperativeVectorMatrixLayoutNV = @enumFromInt(0),
    src_stride: usize = 0,
    dst_layout: CooperativeVectorMatrixLayoutNV = @enumFromInt(0),
    dst_stride: usize = 0,
};
pub const PhysicalDeviceTileShadingFeaturesQCOM = extern struct {
    s_type: StructureType = .physical_device_tile_shading_features_qcom,
    p_next: ?*anyopaque = null,
    tile_shading: Bool32 = .false,
    tile_shading_fragment_stage: Bool32 = .false,
    tile_shading_color_attachments: Bool32 = .false,
    tile_shading_depth_attachments: Bool32 = .false,
    tile_shading_stencil_attachments: Bool32 = .false,
    tile_shading_input_attachments: Bool32 = .false,
    tile_shading_sampled_attachments: Bool32 = .false,
    tile_shading_per_tile_draw: Bool32 = .false,
    tile_shading_per_tile_dispatch: Bool32 = .false,
    tile_shading_dispatch_tile: Bool32 = .false,
    tile_shading_apron: Bool32 = .false,
    tile_shading_anisotropic_apron: Bool32 = .false,
    tile_shading_atomic_ops: Bool32 = .false,
    tile_shading_image_processing: Bool32 = .false,
};
pub const PhysicalDeviceTileShadingPropertiesQCOM = extern struct {
    s_type: StructureType = .physical_device_tile_shading_properties_qcom,
    p_next: ?*anyopaque = null,
    max_apron_size: u32 = 0,
    prefer_non_coherent: Bool32 = .false,
    tile_granularity: Extent2D = .{},
    max_tile_shading_rate: Extent2D = .{},
};
pub const RenderPassTileShadingCreateInfoQCOM = extern struct {
    s_type: StructureType = .render_pass_tile_shading_create_info_qcom,
    p_next: ?*const anyopaque = null,
    flags: TileShadingRenderPassFlagsQCOM = .none,
    tile_apron_size: Extent2D = .{},
};
pub const PerTileBeginInfoQCOM = extern struct {
    s_type: StructureType = .per_tile_begin_info_qcom,
    p_next: ?*const anyopaque = null,
};
pub const PerTileEndInfoQCOM = extern struct {
    s_type: StructureType = .per_tile_end_info_qcom,
    p_next: ?*const anyopaque = null,
};
pub const DispatchTileInfoQCOM = extern struct {
    s_type: StructureType = .dispatch_tile_info_qcom,
    p_next: ?*const anyopaque = null,
};
pub const PhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_layered_properties_valve,
    p_next: ?*anyopaque = null,
    max_fragment_density_map_layers: u32 = 0,
};
pub const PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = extern struct {
    s_type: StructureType = .physical_device_fragment_density_map_layered_features_valve,
    p_next: ?*anyopaque = null,
    fragment_density_map_layered: Bool32 = .false,
};
pub const PipelineFragmentDensityMapLayeredCreateInfoVALVE = extern struct {
    s_type: StructureType = .pipeline_fragment_density_map_layered_create_info_valve,
    p_next: ?*const anyopaque = null,
    max_fragment_density_map_layers: u32 = 0,
};
pub const SetPresentConfigNV = extern struct {
    s_type: StructureType = .set_present_config_nv,
    p_next: ?*const anyopaque = null,
    num_frames_per_batch: u32 = 0,
    present_config_feedback: u32 = 0,
};
pub const PhysicalDevicePresentMeteringFeaturesNV = extern struct {
    s_type: StructureType = .physical_device_present_metering_features_nv,
    p_next: ?*anyopaque = null,
    present_metering: Bool32 = .false,
};
pub const ExternalComputeQueueDeviceCreateInfoNV = extern struct {
    s_type: StructureType = .external_compute_queue_device_create_info_nv,
    p_next: ?*const anyopaque = null,
    reserved_external_queues: u32 = 0,
};
pub const ExternalComputeQueueCreateInfoNV = extern struct {
    s_type: StructureType = .external_compute_queue_create_info_nv,
    p_next: ?*const anyopaque = null,
    preferred_queue: Queue = .null_handle,
};
pub const ExternalComputeQueueDataParamsNV = extern struct {
    s_type: StructureType = .external_compute_queue_data_params_nv,
    p_next: ?*const anyopaque = null,
    device_index: u32 = 0,
};
pub const PhysicalDeviceExternalComputeQueuePropertiesNV = extern struct {
    s_type: StructureType = .physical_device_external_compute_queue_properties_nv,
    p_next: ?*anyopaque = null,
    external_data_size: u32 = 0,
    max_external_queues: u32 = 0,
};
pub const ExternalComputeQueueNV = enum(usize) { null_handle = 0, _ };
pub const PhysicalDeviceFormatPackFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_format_pack_features_arm,
    p_next: ?*anyopaque = null,
    format_pack: Bool32 = .false,
};
pub const TensorDescriptionARM = extern struct {
    s_type: StructureType = .tensor_description_arm,
    p_next: ?*const anyopaque = null,
    tiling: TensorTilingARM = @enumFromInt(0),
    format: Format = @enumFromInt(0),
    dimension_count: u32 = 0,
    p_dimensions: ?[*]const i64 = null,
    p_strides: ?[*]const i64 = null,
    usage: TensorUsageFlagsARM = .none,
};
pub const TensorCreateInfoARM = extern struct {
    s_type: StructureType = .tensor_create_info_arm,
    p_next: ?*const anyopaque = null,
    flags: TensorCreateFlagsARM = .none,
    p_description: ?*const TensorDescriptionARM = null,
    sharing_mode: SharingMode = @enumFromInt(0),
    queue_family_index_count: u32 = 0,
    p_queue_family_indices: ?[*]const u32 = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *OpaqueCaptureDescriptorDataCreateInfoEXT,
            *ExternalMemoryTensorCreateInfoARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const TensorViewCreateInfoARM = extern struct {
    s_type: StructureType = .tensor_view_create_info_arm,
    p_next: ?*const anyopaque = null,
    flags: TensorViewCreateFlagsARM = .none,
    tensor: TensorARM = .null_handle,
    format: Format = @enumFromInt(0),
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *OpaqueCaptureDescriptorDataCreateInfoEXT,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const TensorMemoryRequirementsInfoARM = extern struct {
    s_type: StructureType = .tensor_memory_requirements_info_arm,
    p_next: ?*const anyopaque = null,
    tensor: TensorARM = .null_handle,
};
pub const BindTensorMemoryInfoARM = extern struct {
    s_type: StructureType = .bind_tensor_memory_info_arm,
    p_next: ?*const anyopaque = null,
    tensor: TensorARM = .null_handle,
    memory: DeviceMemory = .null_handle,
    memory_offset: DeviceSize = 0,
};
pub const WriteDescriptorSetTensorARM = extern struct {
    s_type: StructureType = .write_descriptor_set_tensor_arm,
    p_next: ?*const anyopaque = null,
    tensor_view_count: u32 = 0,
    p_tensor_views: ?[*]const TensorViewARM = null,
};
pub const TensorFormatPropertiesARM = extern struct {
    s_type: StructureType = .tensor_format_properties_arm,
    p_next: ?*const anyopaque = null,
    optimal_tiling_tensor_features: FormatFeatureFlags2 = .none,
    linear_tiling_tensor_features: FormatFeatureFlags2 = .none,
};
pub const PhysicalDeviceTensorPropertiesARM = extern struct {
    s_type: StructureType = .physical_device_tensor_properties_arm,
    p_next: ?*anyopaque = null,
    max_tensor_dimension_count: u32 = 0,
    max_tensor_elements: u64 = 0,
    max_per_dimension_tensor_elements: u64 = 0,
    max_tensor_stride: i64 = 0,
    max_tensor_size: u64 = 0,
    max_tensor_shader_access_array_length: u32 = 0,
    max_tensor_shader_access_size: u32 = 0,
    max_descriptor_set_storage_tensors: u32 = 0,
    max_per_stage_descriptor_set_storage_tensors: u32 = 0,
    max_descriptor_set_update_after_bind_storage_tensors: u32 = 0,
    max_per_stage_descriptor_update_after_bind_storage_tensors: u32 = 0,
    shader_storage_tensor_array_non_uniform_indexing_native: Bool32 = .false,
    shader_tensor_supported_stages: ShaderStageFlags = .none,
};
pub const TensorMemoryBarrierARM = extern struct {
    s_type: StructureType = .tensor_memory_barrier_arm,
    p_next: ?*const anyopaque = null,
    src_stage_mask: PipelineStageFlags2 = .none,
    src_access_mask: AccessFlags2 = .none,
    dst_stage_mask: PipelineStageFlags2 = .none,
    dst_access_mask: AccessFlags2 = .none,
    src_queue_family_index: u32 = 0,
    dst_queue_family_index: u32 = 0,
    tensor: TensorARM = .null_handle,
};
pub const TensorDependencyInfoARM = extern struct {
    s_type: StructureType = .tensor_dependency_info_arm,
    p_next: ?*const anyopaque = null,
    tensor_memory_barrier_count: u32 = 0,
    p_tensor_memory_barriers: ?*const TensorMemoryBarrierARM = null,
};
pub const PhysicalDeviceTensorFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_tensor_features_arm,
    p_next: ?*anyopaque = null,
    tensor_non_packed: Bool32 = .false,
    shader_tensor_access: Bool32 = .false,
    shader_storage_tensor_array_dynamic_indexing: Bool32 = .false,
    shader_storage_tensor_array_non_uniform_indexing: Bool32 = .false,
    descriptor_binding_storage_tensor_update_after_bind: Bool32 = .false,
    tensors: Bool32 = .false,
};
pub const DeviceTensorMemoryRequirementsARM = extern struct {
    s_type: StructureType = .device_tensor_memory_requirements_arm,
    p_next: ?*const anyopaque = null,
    p_create_info: ?*const TensorCreateInfoARM = null,
};
pub const CopyTensorInfoARM = extern struct {
    s_type: StructureType = .copy_tensor_info_arm,
    p_next: ?*const anyopaque = null,
    src_tensor: TensorARM = .null_handle,
    dst_tensor: TensorARM = .null_handle,
    region_count: u32 = 0,
    p_regions: ?[*]const TensorCopyARM = null,
};
pub const TensorCopyARM = extern struct {
    s_type: StructureType = .tensor_copy_arm,
    p_next: ?*const anyopaque = null,
    dimension_count: u32 = 0,
    p_src_offset: ?[*]const u64 = null,
    p_dst_offset: ?[*]const u64 = null,
    p_extent: ?[*]const u64 = null,
};
pub const MemoryDedicatedAllocateInfoTensorARM = extern struct {
    s_type: StructureType = .memory_dedicated_allocate_info_tensor_arm,
    p_next: ?*const anyopaque = null,
    tensor: TensorARM = .null_handle,
};
pub const PhysicalDeviceDescriptorBufferTensorPropertiesARM = extern struct {
    s_type: StructureType = .physical_device_descriptor_buffer_tensor_properties_arm,
    p_next: ?*anyopaque = null,
    tensor_capture_replay_descriptor_data_size: usize = 0,
    tensor_view_capture_replay_descriptor_data_size: usize = 0,
    tensor_descriptor_size: usize = 0,
};
pub const PhysicalDeviceDescriptorBufferTensorFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_descriptor_buffer_tensor_features_arm,
    p_next: ?*anyopaque = null,
    descriptor_buffer_tensor_descriptors: Bool32 = .false,
};
pub const TensorCaptureDescriptorDataInfoARM = extern struct {
    s_type: StructureType = .tensor_capture_descriptor_data_info_arm,
    p_next: ?*const anyopaque = null,
    tensor: TensorARM = .null_handle,
};
pub const TensorViewCaptureDescriptorDataInfoARM = extern struct {
    s_type: StructureType = .tensor_view_capture_descriptor_data_info_arm,
    p_next: ?*const anyopaque = null,
    tensor_view: TensorViewARM = .null_handle,
};
pub const DescriptorGetTensorInfoARM = extern struct {
    s_type: StructureType = .descriptor_get_tensor_info_arm,
    p_next: ?*const anyopaque = null,
    tensor_view: TensorViewARM = .null_handle,
};
pub const FrameBoundaryTensorsARM = extern struct {
    s_type: StructureType = .frame_boundary_tensors_arm,
    p_next: ?*const anyopaque = null,
    tensor_count: u32 = 0,
    p_tensors: ?[*]const TensorARM = null,
};
pub const PhysicalDeviceExternalTensorInfoARM = extern struct {
    s_type: StructureType = .physical_device_external_tensor_info_arm,
    p_next: ?*const anyopaque = null,
    flags: TensorCreateFlagsARM = .none,
    p_description: ?*const TensorDescriptionARM = null,
    handle_type: ExternalMemoryHandleTypeFlags = .none,
};
pub const ExternalTensorPropertiesARM = extern struct {
    s_type: StructureType = .external_tensor_properties_arm,
    p_next: ?*const anyopaque = null,
    external_memory_properties: ExternalMemoryProperties = .{},
};
pub const ExternalMemoryTensorCreateInfoARM = extern struct {
    s_type: StructureType = .external_memory_tensor_create_info_arm,
    p_next: ?*const anyopaque = null,
    handle_types: ExternalMemoryHandleTypeFlags = .none,
};
pub const PhysicalDeviceShaderFloat8FeaturesEXT = extern struct {
    s_type: StructureType = .physical_device_shader_float8_features_ext,
    p_next: ?*anyopaque = null,
    shader_float8: Bool32 = .false,
    shader_float8_cooperative_matrix: Bool32 = .false,
};
pub const SurfaceCreateInfoOHOS = extern struct {
    s_type: StructureType = .surface_create_info_ohos,
    p_next: ?*const anyopaque = null,
    flags: SurfaceCreateFlagsOHOS = .none,
    window: ?*OHNativeWindow = null,
};
pub const PhysicalDeviceDataGraphFeaturesARM = extern struct {
    s_type: StructureType = .physical_device_data_graph_features_arm,
    p_next: ?*anyopaque = null,
    data_graph: Bool32 = .false,
    data_graph_update_after_bind: Bool32 = .false,
    data_graph_specialization_constants: Bool32 = .false,
    data_graph_descriptor_buffer: Bool32 = .false,
    data_graph_shader_module: Bool32 = .false,
};
pub const DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_constant_tensor_semi_structured_sparsity_info_arm,
    p_next: ?*const anyopaque = null,
    dimension: u32 = 0,
    zero_count: u32 = 0,
    group_size: u32 = 0,
};
pub const DataGraphPipelineConstantARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_constant_arm,
    p_next: ?*const anyopaque = null,
    id: u32 = 0,
    p_constant_data: ?*const anyopaque = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *TensorDescriptionARM,
            *DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DataGraphPipelineResourceInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_resource_info_arm,
    p_next: ?*const anyopaque = null,
    descriptor_set: u32 = 0,
    binding: u32 = 0,
    array_element: u32 = 0,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *TensorDescriptionARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DataGraphPipelineCompilerControlCreateInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_compiler_control_create_info_arm,
    p_next: ?*const anyopaque = null,
    p_vendor_options: ?[*:0]const u8 = null,
};
pub const DataGraphPipelineCreateInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_create_info_arm,
    p_next: ?*const anyopaque = null,
    flags: PipelineCreateFlags2KHR = .none,
    layout: PipelineLayout = .null_handle,
    resource_info_count: u32 = 0,
    p_resource_infos: ?[*]const DataGraphPipelineResourceInfoARM = null,
    const Self = @This();
    pub fn insert_next(self: *Self, next: anytype) void {
        switch (@TypeOf(next)) {
            inline *ShaderModuleCreateInfo,
            *PipelineCreationFeedbackCreateInfo,
            *DataGraphPipelineCompilerControlCreateInfoARM,
            *DataGraphPipelineShaderModuleCreateInfoARM,
            *DataGraphPipelineIdentifierCreateInfoARM,
            *DataGraphProcessingEngineCreateInfoARM,
            => {
                next.p_next = @constCast(self.p_next);
                self.p_next = next;
            },
            else => @compileError("invalid extension struct type"),
        }
    }
};
pub const DataGraphPipelineShaderModuleCreateInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_shader_module_create_info_arm,
    p_next: ?*const anyopaque = null,
    module: ShaderModule = .null_handle,
    p_name: ?[*:0]const u8 = null,
    p_specialization_info: ?*const SpecializationInfo = null,
    constant_count: u32 = 0,
    p_constants: ?[*]const DataGraphPipelineConstantARM = null,
};
pub const DataGraphPipelineSessionCreateInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_session_create_info_arm,
    p_next: ?*const anyopaque = null,
    flags: DataGraphPipelineSessionCreateFlagsARM = .none,
    data_graph_pipeline: Pipeline = .null_handle,
};
pub const DataGraphPipelineSessionBindPointRequirementsInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_session_bind_point_requirements_info_arm,
    p_next: ?*const anyopaque = null,
    session: DataGraphPipelineSessionARM = .null_handle,
};
pub const DataGraphPipelineSessionBindPointRequirementARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_session_bind_point_requirement_arm,
    p_next: ?*const anyopaque = null,
    bind_point: DataGraphPipelineSessionBindPointARM = @enumFromInt(0),
    bind_point_type: DataGraphPipelineSessionBindPointTypeARM = @enumFromInt(0),
    num_objects: u32 = 0,
};
pub const DataGraphPipelineSessionMemoryRequirementsInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_session_memory_requirements_info_arm,
    p_next: ?*const anyopaque = null,
    session: DataGraphPipelineSessionARM = .null_handle,
    bind_point: DataGraphPipelineSessionBindPointARM = @enumFromInt(0),
    object_index: u32 = 0,
};
pub const BindDataGraphPipelineSessionMemoryInfoARM = extern struct {
    s_type: StructureType = .bind_data_graph_pipeline_session_memory_info_arm,
    p_next: ?*const anyopaque = null,
    session: DataGraphPipelineSessionARM = .null_handle,
    bind_point: DataGraphPipelineSessionBindPointARM = @enumFromInt(0),
    object_index: u32 = 0,
    memory: DeviceMemory = .null_handle,
    memory_offset: DeviceSize = 0,
};
pub const DataGraphPipelineInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_info_arm,
    p_next: ?*const anyopaque = null,
    data_graph_pipeline: Pipeline = .null_handle,
};
pub const DataGraphPipelinePropertyQueryResultARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_property_query_result_arm,
    p_next: ?*const anyopaque = null,
    property: DataGraphPipelinePropertyARM = @enumFromInt(0),
    is_text: Bool32 = .false,
    data_size: usize = 0,
    p_data: ?*anyopaque = null,
};
pub const DataGraphPipelineIdentifierCreateInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_identifier_create_info_arm,
    p_next: ?*const anyopaque = null,
    identifier_size: u32 = 0,
    p_identifier: ?[*]const u8 = null,
};
pub const DataGraphPipelineDispatchInfoARM = extern struct {
    s_type: StructureType = .data_graph_pipeline_dispatch_info_arm,
    p_next: ?*anyopaque = null,
    flags: DataGraphPipelineDispatchFlagsARM = .none,
};
pub const PhysicalDeviceDataGraphProcessingEngineARM = extern struct {
    type: PhysicalDeviceDataGraphProcessingEngineTypeARM = @enumFromInt(0),
    is_foreign: Bool32 = .false,
};
pub const PhysicalDeviceDataGraphOperationSupportARM = extern struct {
    operation_type: PhysicalDeviceDataGraphOperationTypeARM = @enumFromInt(0),
    name: [max_physical_device_data_graph_operation_set_name_size_arm - 1:0]u8 = [_:0]u8{0} ** (max_physical_device_data_graph_operation_set_name_size_arm - 1),
    version: u32 = 0,
};
pub const QueueFamilyDataGraphPropertiesARM = extern struct {
    s_type: StructureType = .queue_family_data_graph_properties_arm,
    p_next: ?*const anyopaque = null,
    engine: PhysicalDeviceDataGraphProcessingEngineARM = .{},
    operation: PhysicalDeviceDataGraphOperationSupportARM = .{},
};
pub const PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = extern struct {
    s_type: StructureType = .physical_device_queue_family_data_graph_processing_engine_info_arm,
    p_next: ?*const anyopaque = null,
    queue_family_index: u32 = 0,
    engine_type: PhysicalDeviceDataGraphProcessingEngineTypeARM = @enumFromInt(0),
};
pub const QueueFamilyDataGraphProcessingEnginePropertiesARM = extern struct {
    s_type: StructureType = .queue_family_data_graph_processing_engine_properties_arm,
    p_next: ?*const anyopaque = null,
    foreign_semaphore_handle_types: ExternalSemaphoreHandleTypeFlags = .none,
    foreign_memory_handle_types: ExternalMemoryHandleTypeFlags = .none,
};
pub const DataGraphProcessingEngineCreateInfoARM = extern struct {
    s_type: StructureType = .data_graph_processing_engine_create_info_arm,
    p_next: ?*const anyopaque = null,
    processing_engine_count: u32 = 0,
    p_processing_engines: ?[*]PhysicalDeviceDataGraphProcessingEngineARM = null,
};
pub const PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = extern struct {
    s_type: StructureType = .physical_device_pipeline_cache_incremental_mode_features_sec,
    p_next: ?*anyopaque = null,
    pipeline_cache_incremental_mode: Bool32 = .false,
};
pub const PhysicalDeviceShaderUntypedPointersFeaturesKHR = extern struct {
    s_type: StructureType = .physical_device_shader_untyped_pointers_features_khr,
    p_next: ?*anyopaque = null,
    shader_untyped_pointers: Bool32 = .false,
};
pub const FpCreateInstance = *const fn ([*c]const InstanceCreateInfo, [*c]const AllocationCallbacks, [*c]Instance) callconv(.c) Result;
pub const FpDestroyInstance = *const fn (Instance, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpEnumeratePhysicalDevices = *const fn (Instance, [*c]u32, [*c]PhysicalDevice) callconv(.c) Result;
pub const FpGetDeviceProcAddr = *const fn (Device, [*c]const u8) callconv(.c) ?FpVoidFunction;
pub const FpGetInstanceProcAddr = *const fn (Instance, [*c]const u8) callconv(.c) ?FpVoidFunction;
pub const FpGetPhysicalDeviceProperties = *const fn (PhysicalDevice, [*c]PhysicalDeviceProperties) callconv(.c) void;
pub const FpGetPhysicalDeviceQueueFamilyProperties = *const fn (PhysicalDevice, [*c]u32, [*c]QueueFamilyProperties) callconv(.c) void;
pub const FpGetPhysicalDeviceMemoryProperties = *const fn (PhysicalDevice, [*c]PhysicalDeviceMemoryProperties) callconv(.c) void;
pub const FpGetPhysicalDeviceFeatures = *const fn (PhysicalDevice, [*c]PhysicalDeviceFeatures) callconv(.c) void;
pub const FpGetPhysicalDeviceFormatProperties = *const fn (PhysicalDevice, Format, [*c]FormatProperties) callconv(.c) void;
pub const FpGetPhysicalDeviceImageFormatProperties = *const fn (PhysicalDevice, Format, ImageType, ImageTiling, ImageUsageFlags, ImageCreateFlags, [*c]ImageFormatProperties) callconv(.c) Result;
pub const FpCreateDevice = *const fn (PhysicalDevice, [*c]const DeviceCreateInfo, [*c]const AllocationCallbacks, [*c]Device) callconv(.c) Result;
pub const FpDestroyDevice = *const fn (Device, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpEnumerateInstanceVersion = *const fn ([*c]Version) callconv(.c) Result;
pub const FpEnumerateInstanceLayerProperties = *const fn ([*c]u32, [*c]LayerProperties) callconv(.c) Result;
pub const FpEnumerateInstanceExtensionProperties = *const fn ([*c]const u8, [*c]u32, [*c]ExtensionProperties) callconv(.c) Result;
pub const FpEnumerateDeviceLayerProperties = *const fn (PhysicalDevice, [*c]u32, [*c]LayerProperties) callconv(.c) Result;
pub const FpEnumerateDeviceExtensionProperties = *const fn (PhysicalDevice, [*c]const u8, [*c]u32, [*c]ExtensionProperties) callconv(.c) Result;
pub const FpGetDeviceQueue = *const fn (Device, u32, u32, [*c]Queue) callconv(.c) void;
pub const FpQueueSubmit = *const fn (Queue, u32, [*c]const SubmitInfo, Fence) callconv(.c) Result;
pub const FpQueueWaitIdle = *const fn (Queue) callconv(.c) Result;
pub const FpDeviceWaitIdle = *const fn (Device) callconv(.c) Result;
pub const FpAllocateMemory = *const fn (Device, [*c]const MemoryAllocateInfo, [*c]const AllocationCallbacks, [*c]DeviceMemory) callconv(.c) Result;
pub const FpFreeMemory = *const fn (Device, DeviceMemory, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpMapMemory = *const fn (Device, DeviceMemory, DeviceSize, DeviceSize, MemoryMapFlags, [*c]?*anyopaque) callconv(.c) Result;
pub const FpUnmapMemory = *const fn (Device, DeviceMemory) callconv(.c) void;
pub const FpFlushMappedMemoryRanges = *const fn (Device, u32, [*c]const MappedMemoryRange) callconv(.c) Result;
pub const FpInvalidateMappedMemoryRanges = *const fn (Device, u32, [*c]const MappedMemoryRange) callconv(.c) Result;
pub const FpGetDeviceMemoryCommitment = *const fn (Device, DeviceMemory, [*c]DeviceSize) callconv(.c) void;
pub const FpGetBufferMemoryRequirements = *const fn (Device, Buffer, [*c]MemoryRequirements) callconv(.c) void;
pub const FpBindBufferMemory = *const fn (Device, Buffer, DeviceMemory, DeviceSize) callconv(.c) Result;
pub const FpGetImageMemoryRequirements = *const fn (Device, Image, [*c]MemoryRequirements) callconv(.c) void;
pub const FpBindImageMemory = *const fn (Device, Image, DeviceMemory, DeviceSize) callconv(.c) Result;
pub const FpGetImageSparseMemoryRequirements = *const fn (Device, Image, [*c]u32, [*c]SparseImageMemoryRequirements) callconv(.c) void;
pub const FpGetPhysicalDeviceSparseImageFormatProperties = *const fn (PhysicalDevice, Format, ImageType, SampleCountFlags, ImageUsageFlags, ImageTiling, [*c]u32, [*c]SparseImageFormatProperties) callconv(.c) void;
pub const FpQueueBindSparse = *const fn (Queue, u32, [*c]const BindSparseInfo, Fence) callconv(.c) Result;
pub const FpCreateFence = *const fn (Device, [*c]const FenceCreateInfo, [*c]const AllocationCallbacks, [*c]Fence) callconv(.c) Result;
pub const FpDestroyFence = *const fn (Device, Fence, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpResetFences = *const fn (Device, u32, [*c]const Fence) callconv(.c) Result;
pub const FpGetFenceStatus = *const fn (Device, Fence) callconv(.c) Result;
pub const FpWaitForFences = *const fn (Device, u32, [*c]const Fence, Bool32, u64) callconv(.c) Result;
pub const FpCreateSemaphore = *const fn (Device, [*c]const SemaphoreCreateInfo, [*c]const AllocationCallbacks, [*c]Semaphore) callconv(.c) Result;
pub const FpDestroySemaphore = *const fn (Device, Semaphore, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCreateEvent = *const fn (Device, [*c]const EventCreateInfo, [*c]const AllocationCallbacks, [*c]Event) callconv(.c) Result;
pub const FpDestroyEvent = *const fn (Device, Event, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetEventStatus = *const fn (Device, Event) callconv(.c) Result;
pub const FpSetEvent = *const fn (Device, Event) callconv(.c) Result;
pub const FpResetEvent = *const fn (Device, Event) callconv(.c) Result;
pub const FpCreateQueryPool = *const fn (Device, [*c]const QueryPoolCreateInfo, [*c]const AllocationCallbacks, [*c]QueryPool) callconv(.c) Result;
pub const FpDestroyQueryPool = *const fn (Device, QueryPool, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetQueryPoolResults = *const fn (Device, QueryPool, u32, u32, usize, ?*anyopaque, DeviceSize, QueryResultFlags) callconv(.c) Result;
pub const FpResetQueryPool = *const fn (Device, QueryPool, u32, u32) callconv(.c) void;
pub const FpCreateBuffer = *const fn (Device, [*c]const BufferCreateInfo, [*c]const AllocationCallbacks, [*c]Buffer) callconv(.c) Result;
pub const FpDestroyBuffer = *const fn (Device, Buffer, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCreateBufferView = *const fn (Device, [*c]const BufferViewCreateInfo, [*c]const AllocationCallbacks, [*c]BufferView) callconv(.c) Result;
pub const FpDestroyBufferView = *const fn (Device, BufferView, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCreateImage = *const fn (Device, [*c]const ImageCreateInfo, [*c]const AllocationCallbacks, [*c]Image) callconv(.c) Result;
pub const FpDestroyImage = *const fn (Device, Image, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetImageSubresourceLayout = *const fn (Device, Image, [*c]const ImageSubresource, [*c]SubresourceLayout) callconv(.c) void;
pub const FpCreateImageView = *const fn (Device, [*c]const ImageViewCreateInfo, [*c]const AllocationCallbacks, [*c]ImageView) callconv(.c) Result;
pub const FpDestroyImageView = *const fn (Device, ImageView, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCreateShaderModule = *const fn (Device, [*c]const ShaderModuleCreateInfo, [*c]const AllocationCallbacks, [*c]ShaderModule) callconv(.c) Result;
pub const FpDestroyShaderModule = *const fn (Device, ShaderModule, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCreatePipelineCache = *const fn (Device, [*c]const PipelineCacheCreateInfo, [*c]const AllocationCallbacks, [*c]PipelineCache) callconv(.c) Result;
pub const FpDestroyPipelineCache = *const fn (Device, PipelineCache, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetPipelineCacheData = *const fn (Device, PipelineCache, [*c]usize, ?*anyopaque) callconv(.c) Result;
pub const FpMergePipelineCaches = *const fn (Device, PipelineCache, u32, [*c]const PipelineCache) callconv(.c) Result;
pub const FpCreatePipelineBinariesKHR = *const fn (Device, [*c]const PipelineBinaryCreateInfoKHR, [*c]const AllocationCallbacks, [*c]PipelineBinaryHandlesInfoKHR) callconv(.c) Result;
pub const FpDestroyPipelineBinaryKHR = *const fn (Device, PipelineBinaryKHR, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetPipelineKeyKHR = *const fn (Device, [*c]const PipelineCreateInfoKHR, [*c]PipelineBinaryKeyKHR) callconv(.c) Result;
pub const FpGetPipelineBinaryDataKHR = *const fn (Device, [*c]const PipelineBinaryDataInfoKHR, [*c]PipelineBinaryKeyKHR, [*c]usize, ?*anyopaque) callconv(.c) Result;
pub const FpReleaseCapturedPipelineDataKHR = *const fn (Device, [*c]const ReleaseCapturedPipelineDataInfoKHR, [*c]const AllocationCallbacks) callconv(.c) Result;
pub const FpCreateGraphicsPipelines = *const fn (Device, PipelineCache, u32, [*c]const GraphicsPipelineCreateInfo, [*c]const AllocationCallbacks, [*c]Pipeline) callconv(.c) Result;
pub const FpCreateComputePipelines = *const fn (Device, PipelineCache, u32, [*c]const ComputePipelineCreateInfo, [*c]const AllocationCallbacks, [*c]Pipeline) callconv(.c) Result;
pub const FpGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = *const fn (Device, RenderPass, [*c]Extent2D) callconv(.c) Result;
pub const FpDestroyPipeline = *const fn (Device, Pipeline, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCreatePipelineLayout = *const fn (Device, [*c]const PipelineLayoutCreateInfo, [*c]const AllocationCallbacks, [*c]PipelineLayout) callconv(.c) Result;
pub const FpDestroyPipelineLayout = *const fn (Device, PipelineLayout, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCreateSampler = *const fn (Device, [*c]const SamplerCreateInfo, [*c]const AllocationCallbacks, [*c]Sampler) callconv(.c) Result;
pub const FpDestroySampler = *const fn (Device, Sampler, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCreateDescriptorSetLayout = *const fn (Device, [*c]const DescriptorSetLayoutCreateInfo, [*c]const AllocationCallbacks, [*c]DescriptorSetLayout) callconv(.c) Result;
pub const FpDestroyDescriptorSetLayout = *const fn (Device, DescriptorSetLayout, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCreateDescriptorPool = *const fn (Device, [*c]const DescriptorPoolCreateInfo, [*c]const AllocationCallbacks, [*c]DescriptorPool) callconv(.c) Result;
pub const FpDestroyDescriptorPool = *const fn (Device, DescriptorPool, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpResetDescriptorPool = *const fn (Device, DescriptorPool, DescriptorPoolResetFlags) callconv(.c) Result;
pub const FpAllocateDescriptorSets = *const fn (Device, [*c]const DescriptorSetAllocateInfo, [*c]DescriptorSet) callconv(.c) Result;
pub const FpFreeDescriptorSets = *const fn (Device, DescriptorPool, u32, [*c]const DescriptorSet) callconv(.c) Result;
pub const FpUpdateDescriptorSets = *const fn (Device, u32, [*c]const WriteDescriptorSet, u32, [*c]const CopyDescriptorSet) callconv(.c) void;
pub const FpCreateFramebuffer = *const fn (Device, [*c]const FramebufferCreateInfo, [*c]const AllocationCallbacks, [*c]Framebuffer) callconv(.c) Result;
pub const FpDestroyFramebuffer = *const fn (Device, Framebuffer, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCreateRenderPass = *const fn (Device, [*c]const RenderPassCreateInfo, [*c]const AllocationCallbacks, [*c]RenderPass) callconv(.c) Result;
pub const FpDestroyRenderPass = *const fn (Device, RenderPass, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetRenderAreaGranularity = *const fn (Device, RenderPass, [*c]Extent2D) callconv(.c) void;
pub const FpGetRenderingAreaGranularity = *const fn (Device, [*c]const RenderingAreaInfo, [*c]Extent2D) callconv(.c) void;
pub const FpCreateCommandPool = *const fn (Device, [*c]const CommandPoolCreateInfo, [*c]const AllocationCallbacks, [*c]CommandPool) callconv(.c) Result;
pub const FpDestroyCommandPool = *const fn (Device, CommandPool, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpResetCommandPool = *const fn (Device, CommandPool, CommandPoolResetFlags) callconv(.c) Result;
pub const FpAllocateCommandBuffers = *const fn (Device, [*c]const CommandBufferAllocateInfo, [*c]CommandBuffer) callconv(.c) Result;
pub const FpFreeCommandBuffers = *const fn (Device, CommandPool, u32, [*c]const CommandBuffer) callconv(.c) void;
pub const FpBeginCommandBuffer = *const fn (CommandBuffer, [*c]const CommandBufferBeginInfo) callconv(.c) Result;
pub const FpEndCommandBuffer = *const fn (CommandBuffer) callconv(.c) Result;
pub const FpResetCommandBuffer = *const fn (CommandBuffer, CommandBufferResetFlags) callconv(.c) Result;
pub const FpCmdBindPipeline = *const fn (CommandBuffer, PipelineBindPoint, Pipeline) callconv(.c) void;
pub const FpCmdSetAttachmentFeedbackLoopEnableEXT = *const fn (CommandBuffer, ImageAspectFlags) callconv(.c) void;
pub const FpCmdSetViewport = *const fn (CommandBuffer, u32, u32, [*c]const Viewport) callconv(.c) void;
pub const FpCmdSetScissor = *const fn (CommandBuffer, u32, u32, [*c]const Rect2D) callconv(.c) void;
pub const FpCmdSetLineWidth = *const fn (CommandBuffer, f32) callconv(.c) void;
pub const FpCmdSetDepthBias = *const fn (CommandBuffer, f32, f32, f32) callconv(.c) void;
pub const FpCmdSetBlendConstants = *const fn (CommandBuffer, [*c]const f32) callconv(.c) void;
pub const FpCmdSetDepthBounds = *const fn (CommandBuffer, f32, f32) callconv(.c) void;
pub const FpCmdSetStencilCompareMask = *const fn (CommandBuffer, StencilFaceFlags, u32) callconv(.c) void;
pub const FpCmdSetStencilWriteMask = *const fn (CommandBuffer, StencilFaceFlags, u32) callconv(.c) void;
pub const FpCmdSetStencilReference = *const fn (CommandBuffer, StencilFaceFlags, u32) callconv(.c) void;
pub const FpCmdBindDescriptorSets = *const fn (CommandBuffer, PipelineBindPoint, PipelineLayout, u32, u32, [*c]const DescriptorSet, u32, [*c]const u32) callconv(.c) void;
pub const FpCmdBindIndexBuffer = *const fn (CommandBuffer, Buffer, DeviceSize, IndexType) callconv(.c) void;
pub const FpCmdBindVertexBuffers = *const fn (CommandBuffer, u32, u32, [*c]const Buffer, [*c]const DeviceSize) callconv(.c) void;
pub const FpCmdDraw = *const fn (CommandBuffer, u32, u32, u32, u32) callconv(.c) void;
pub const FpCmdDrawIndexed = *const fn (CommandBuffer, u32, u32, u32, i32, u32) callconv(.c) void;
pub const FpCmdDrawMultiEXT = *const fn (CommandBuffer, u32, [*c]const MultiDrawInfoEXT, u32, u32, u32) callconv(.c) void;
pub const FpCmdDrawMultiIndexedEXT = *const fn (CommandBuffer, u32, [*c]const MultiDrawIndexedInfoEXT, u32, u32, u32, [*c]const i32) callconv(.c) void;
pub const FpCmdDrawIndirect = *const fn (CommandBuffer, Buffer, DeviceSize, u32, u32) callconv(.c) void;
pub const FpCmdDrawIndexedIndirect = *const fn (CommandBuffer, Buffer, DeviceSize, u32, u32) callconv(.c) void;
pub const FpCmdDispatch = *const fn (CommandBuffer, u32, u32, u32) callconv(.c) void;
pub const FpCmdDispatchIndirect = *const fn (CommandBuffer, Buffer, DeviceSize) callconv(.c) void;
pub const FpCmdSubpassShadingHUAWEI = *const fn (CommandBuffer) callconv(.c) void;
pub const FpCmdDrawClusterHUAWEI = *const fn (CommandBuffer, u32, u32, u32) callconv(.c) void;
pub const FpCmdDrawClusterIndirectHUAWEI = *const fn (CommandBuffer, Buffer, DeviceSize) callconv(.c) void;
pub const FpCmdUpdatePipelineIndirectBufferNV = *const fn (CommandBuffer, PipelineBindPoint, Pipeline) callconv(.c) void;
pub const FpCmdCopyBuffer = *const fn (CommandBuffer, Buffer, Buffer, u32, [*c]const BufferCopy) callconv(.c) void;
pub const FpCmdCopyImage = *const fn (CommandBuffer, Image, ImageLayout, Image, ImageLayout, u32, [*c]const ImageCopy) callconv(.c) void;
pub const FpCmdBlitImage = *const fn (CommandBuffer, Image, ImageLayout, Image, ImageLayout, u32, [*c]const ImageBlit, Filter) callconv(.c) void;
pub const FpCmdCopyBufferToImage = *const fn (CommandBuffer, Buffer, Image, ImageLayout, u32, [*c]const BufferImageCopy) callconv(.c) void;
pub const FpCmdCopyImageToBuffer = *const fn (CommandBuffer, Image, ImageLayout, Buffer, u32, [*c]const BufferImageCopy) callconv(.c) void;
pub const FpCmdCopyMemoryIndirectNV = *const fn (CommandBuffer, DeviceAddress, u32, u32) callconv(.c) void;
pub const FpCmdCopyMemoryToImageIndirectNV = *const fn (CommandBuffer, DeviceAddress, u32, u32, Image, ImageLayout, [*c]const ImageSubresourceLayers) callconv(.c) void;
pub const FpCmdUpdateBuffer = *const fn (CommandBuffer, Buffer, DeviceSize, DeviceSize, ?*const anyopaque) callconv(.c) void;
pub const FpCmdFillBuffer = *const fn (CommandBuffer, Buffer, DeviceSize, DeviceSize, u32) callconv(.c) void;
pub const FpCmdClearColorImage = *const fn (CommandBuffer, Image, ImageLayout, [*c]const ClearColorValue, u32, [*c]const ImageSubresourceRange) callconv(.c) void;
pub const FpCmdClearDepthStencilImage = *const fn (CommandBuffer, Image, ImageLayout, [*c]const ClearDepthStencilValue, u32, [*c]const ImageSubresourceRange) callconv(.c) void;
pub const FpCmdClearAttachments = *const fn (CommandBuffer, u32, [*c]const ClearAttachment, u32, [*c]const ClearRect) callconv(.c) void;
pub const FpCmdResolveImage = *const fn (CommandBuffer, Image, ImageLayout, Image, ImageLayout, u32, [*c]const ImageResolve) callconv(.c) void;
pub const FpCmdSetEvent = *const fn (CommandBuffer, Event, PipelineStageFlags) callconv(.c) void;
pub const FpCmdResetEvent = *const fn (CommandBuffer, Event, PipelineStageFlags) callconv(.c) void;
pub const FpCmdWaitEvents = *const fn (CommandBuffer, u32, [*c]const Event, PipelineStageFlags, PipelineStageFlags, u32, [*c]const MemoryBarrier, u32, [*c]const BufferMemoryBarrier, u32, [*c]const ImageMemoryBarrier) callconv(.c) void;
pub const FpCmdPipelineBarrier = *const fn (CommandBuffer, PipelineStageFlags, PipelineStageFlags, DependencyFlags, u32, [*c]const MemoryBarrier, u32, [*c]const BufferMemoryBarrier, u32, [*c]const ImageMemoryBarrier) callconv(.c) void;
pub const FpCmdBeginQuery = *const fn (CommandBuffer, QueryPool, u32, QueryControlFlags) callconv(.c) void;
pub const FpCmdEndQuery = *const fn (CommandBuffer, QueryPool, u32) callconv(.c) void;
pub const FpCmdBeginConditionalRenderingEXT = *const fn (CommandBuffer, [*c]const ConditionalRenderingBeginInfoEXT) callconv(.c) void;
pub const FpCmdEndConditionalRenderingEXT = *const fn (CommandBuffer) callconv(.c) void;
pub const FpCmdResetQueryPool = *const fn (CommandBuffer, QueryPool, u32, u32) callconv(.c) void;
pub const FpCmdWriteTimestamp = *const fn (CommandBuffer, PipelineStageFlags, QueryPool, u32) callconv(.c) void;
pub const FpCmdCopyQueryPoolResults = *const fn (CommandBuffer, QueryPool, u32, u32, Buffer, DeviceSize, DeviceSize, QueryResultFlags) callconv(.c) void;
pub const FpCmdPushConstants = *const fn (CommandBuffer, PipelineLayout, ShaderStageFlags, u32, u32, ?*const anyopaque) callconv(.c) void;
pub const FpCmdBeginRenderPass = *const fn (CommandBuffer, [*c]const RenderPassBeginInfo, SubpassContents) callconv(.c) void;
pub const FpCmdNextSubpass = *const fn (CommandBuffer, SubpassContents) callconv(.c) void;
pub const FpCmdEndRenderPass = *const fn (CommandBuffer) callconv(.c) void;
pub const FpCmdExecuteCommands = *const fn (CommandBuffer, u32, [*c]const CommandBuffer) callconv(.c) void;
pub const FpCreateAndroidSurfaceKHR = *const fn (Instance, [*c]const AndroidSurfaceCreateInfoKHR, [*c]const AllocationCallbacks, [*c]SurfaceKHR) callconv(.c) Result;
pub const FpCreateSurfaceOHOS = *const fn (Instance, [*c]const SurfaceCreateInfoOHOS, [*c]const AllocationCallbacks, [*c]SurfaceKHR) callconv(.c) Result;
pub const FpGetPhysicalDeviceDisplayPropertiesKHR = *const fn (PhysicalDevice, [*c]u32, [*c]DisplayPropertiesKHR) callconv(.c) Result;
pub const FpGetPhysicalDeviceDisplayPlanePropertiesKHR = *const fn (PhysicalDevice, [*c]u32, [*c]DisplayPlanePropertiesKHR) callconv(.c) Result;
pub const FpGetDisplayPlaneSupportedDisplaysKHR = *const fn (PhysicalDevice, u32, [*c]u32, [*c]DisplayKHR) callconv(.c) Result;
pub const FpGetDisplayModePropertiesKHR = *const fn (PhysicalDevice, DisplayKHR, [*c]u32, [*c]DisplayModePropertiesKHR) callconv(.c) Result;
pub const FpCreateDisplayModeKHR = *const fn (PhysicalDevice, DisplayKHR, [*c]const DisplayModeCreateInfoKHR, [*c]const AllocationCallbacks, [*c]DisplayModeKHR) callconv(.c) Result;
pub const FpGetDisplayPlaneCapabilitiesKHR = *const fn (PhysicalDevice, DisplayModeKHR, u32, [*c]DisplayPlaneCapabilitiesKHR) callconv(.c) Result;
pub const FpCreateDisplayPlaneSurfaceKHR = *const fn (Instance, [*c]const DisplaySurfaceCreateInfoKHR, [*c]const AllocationCallbacks, [*c]SurfaceKHR) callconv(.c) Result;
pub const FpCreateSharedSwapchainsKHR = *const fn (Device, u32, [*c]const SwapchainCreateInfoKHR, [*c]const AllocationCallbacks, [*c]SwapchainKHR) callconv(.c) Result;
pub const FpDestroySurfaceKHR = *const fn (Instance, SurfaceKHR, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetPhysicalDeviceSurfaceSupportKHR = *const fn (PhysicalDevice, u32, SurfaceKHR, [*c]Bool32) callconv(.c) Result;
pub const FpGetPhysicalDeviceSurfaceCapabilitiesKHR = *const fn (PhysicalDevice, SurfaceKHR, [*c]SurfaceCapabilitiesKHR) callconv(.c) Result;
pub const FpGetPhysicalDeviceSurfaceFormatsKHR = *const fn (PhysicalDevice, SurfaceKHR, [*c]u32, [*c]SurfaceFormatKHR) callconv(.c) Result;
pub const FpGetPhysicalDeviceSurfacePresentModesKHR = *const fn (PhysicalDevice, SurfaceKHR, [*c]u32, [*c]PresentModeKHR) callconv(.c) Result;
pub const FpCreateSwapchainKHR = *const fn (Device, [*c]const SwapchainCreateInfoKHR, [*c]const AllocationCallbacks, [*c]SwapchainKHR) callconv(.c) Result;
pub const FpDestroySwapchainKHR = *const fn (Device, SwapchainKHR, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetSwapchainImagesKHR = *const fn (Device, SwapchainKHR, [*c]u32, [*c]Image) callconv(.c) Result;
pub const FpAcquireNextImageKHR = *const fn (Device, SwapchainKHR, u64, Semaphore, Fence, [*c]u32) callconv(.c) Result;
pub const FpQueuePresentKHR = *const fn (Queue, [*c]const PresentInfoKHR) callconv(.c) Result;
pub const FpCreateViSurfaceNN = *const fn (Instance, [*c]const ViSurfaceCreateInfoNN, [*c]const AllocationCallbacks, [*c]SurfaceKHR) callconv(.c) Result;
pub const FpCreateWaylandSurfaceKHR = *const fn (Instance, [*c]const WaylandSurfaceCreateInfoKHR, [*c]const AllocationCallbacks, [*c]SurfaceKHR) callconv(.c) Result;
pub const FpGetPhysicalDeviceWaylandPresentationSupportKHR = *const fn (PhysicalDevice, u32, ?*wl_display) callconv(.c) Bool32;
pub const FpCreateWin32SurfaceKHR = *const fn (Instance, [*c]const Win32SurfaceCreateInfoKHR, [*c]const AllocationCallbacks, [*c]SurfaceKHR) callconv(.c) Result;
pub const FpGetPhysicalDeviceWin32PresentationSupportKHR = *const fn (PhysicalDevice, u32) callconv(.c) Bool32;
pub const FpCreateXlibSurfaceKHR = *const fn (Instance, [*c]const XlibSurfaceCreateInfoKHR, [*c]const AllocationCallbacks, [*c]SurfaceKHR) callconv(.c) Result;
pub const FpGetPhysicalDeviceXlibPresentationSupportKHR = *const fn (PhysicalDevice, u32, ?*Display, VisualID) callconv(.c) Bool32;
pub const FpCreateXcbSurfaceKHR = *const fn (Instance, [*c]const XcbSurfaceCreateInfoKHR, [*c]const AllocationCallbacks, [*c]SurfaceKHR) callconv(.c) Result;
pub const FpGetPhysicalDeviceXcbPresentationSupportKHR = *const fn (PhysicalDevice, u32, ?*xcb_connection_t, xcb_visualid_t) callconv(.c) Bool32;
pub const FpCreateDirectFBSurfaceEXT = *const fn (Instance, [*c]const DirectFBSurfaceCreateInfoEXT, [*c]const AllocationCallbacks, [*c]SurfaceKHR) callconv(.c) Result;
pub const FpGetPhysicalDeviceDirectFBPresentationSupportEXT = *const fn (PhysicalDevice, u32, ?*IDirectFB) callconv(.c) Bool32;
pub const FpCreateImagePipeSurfaceFUCHSIA = *const fn (Instance, [*c]const ImagePipeSurfaceCreateInfoFUCHSIA, [*c]const AllocationCallbacks, [*c]SurfaceKHR) callconv(.c) Result;
pub const FpCreateDebugReportCallbackEXT = *const fn (Instance, [*c]const DebugReportCallbackCreateInfoEXT, [*c]const AllocationCallbacks, [*c]DebugReportCallbackEXT) callconv(.c) Result;
pub const FpDestroyDebugReportCallbackEXT = *const fn (Instance, DebugReportCallbackEXT, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpDebugReportMessageEXT = *const fn (Instance, DebugReportFlagsEXT, DebugReportObjectTypeEXT, u64, usize, i32, [*c]const u8, [*c]const u8) callconv(.c) void;
pub const FpDebugMarkerSetObjectNameEXT = *const fn (Device, [*c]const DebugMarkerObjectNameInfoEXT) callconv(.c) Result;
pub const FpDebugMarkerSetObjectTagEXT = *const fn (Device, [*c]const DebugMarkerObjectTagInfoEXT) callconv(.c) Result;
pub const FpCmdDebugMarkerBeginEXT = *const fn (CommandBuffer, [*c]const DebugMarkerMarkerInfoEXT) callconv(.c) void;
pub const FpCmdDebugMarkerEndEXT = *const fn (CommandBuffer) callconv(.c) void;
pub const FpCmdDebugMarkerInsertEXT = *const fn (CommandBuffer, [*c]const DebugMarkerMarkerInfoEXT) callconv(.c) void;
pub const FpGetPhysicalDeviceExternalImageFormatPropertiesNV = *const fn (PhysicalDevice, Format, ImageType, ImageTiling, ImageUsageFlags, ImageCreateFlags, ExternalMemoryHandleTypeFlagsNV, [*c]ExternalImageFormatPropertiesNV) callconv(.c) Result;
pub const FpGetMemoryWin32HandleNV = *const fn (Device, DeviceMemory, ExternalMemoryHandleTypeFlagsNV, [*c]HANDLE) callconv(.c) Result;
pub const FpCmdExecuteGeneratedCommandsNV = *const fn (CommandBuffer, Bool32, [*c]const GeneratedCommandsInfoNV) callconv(.c) void;
pub const FpCmdPreprocessGeneratedCommandsNV = *const fn (CommandBuffer, [*c]const GeneratedCommandsInfoNV) callconv(.c) void;
pub const FpCmdBindPipelineShaderGroupNV = *const fn (CommandBuffer, PipelineBindPoint, Pipeline, u32) callconv(.c) void;
pub const FpGetGeneratedCommandsMemoryRequirementsNV = *const fn (Device, [*c]const GeneratedCommandsMemoryRequirementsInfoNV, [*c]MemoryRequirements2) callconv(.c) void;
pub const FpCreateIndirectCommandsLayoutNV = *const fn (Device, [*c]const IndirectCommandsLayoutCreateInfoNV, [*c]const AllocationCallbacks, [*c]IndirectCommandsLayoutNV) callconv(.c) Result;
pub const FpDestroyIndirectCommandsLayoutNV = *const fn (Device, IndirectCommandsLayoutNV, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCmdExecuteGeneratedCommandsEXT = *const fn (CommandBuffer, Bool32, [*c]const GeneratedCommandsInfoEXT) callconv(.c) void;
pub const FpCmdPreprocessGeneratedCommandsEXT = *const fn (CommandBuffer, [*c]const GeneratedCommandsInfoEXT, CommandBuffer) callconv(.c) void;
pub const FpGetGeneratedCommandsMemoryRequirementsEXT = *const fn (Device, [*c]const GeneratedCommandsMemoryRequirementsInfoEXT, [*c]MemoryRequirements2) callconv(.c) void;
pub const FpCreateIndirectCommandsLayoutEXT = *const fn (Device, [*c]const IndirectCommandsLayoutCreateInfoEXT, [*c]const AllocationCallbacks, [*c]IndirectCommandsLayoutEXT) callconv(.c) Result;
pub const FpDestroyIndirectCommandsLayoutEXT = *const fn (Device, IndirectCommandsLayoutEXT, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCreateIndirectExecutionSetEXT = *const fn (Device, [*c]const IndirectExecutionSetCreateInfoEXT, [*c]const AllocationCallbacks, [*c]IndirectExecutionSetEXT) callconv(.c) Result;
pub const FpDestroyIndirectExecutionSetEXT = *const fn (Device, IndirectExecutionSetEXT, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpUpdateIndirectExecutionSetPipelineEXT = *const fn (Device, IndirectExecutionSetEXT, u32, [*c]const WriteIndirectExecutionSetPipelineEXT) callconv(.c) void;
pub const FpUpdateIndirectExecutionSetShaderEXT = *const fn (Device, IndirectExecutionSetEXT, u32, [*c]const WriteIndirectExecutionSetShaderEXT) callconv(.c) void;
pub const FpGetPhysicalDeviceFeatures2 = *const fn (PhysicalDevice, [*c]PhysicalDeviceFeatures2) callconv(.c) void;
pub const FpGetPhysicalDeviceProperties2 = *const fn (PhysicalDevice, [*c]PhysicalDeviceProperties2) callconv(.c) void;
pub const FpGetPhysicalDeviceFormatProperties2 = *const fn (PhysicalDevice, Format, [*c]FormatProperties2) callconv(.c) void;
pub const FpGetPhysicalDeviceImageFormatProperties2 = *const fn (PhysicalDevice, [*c]const PhysicalDeviceImageFormatInfo2, [*c]ImageFormatProperties2) callconv(.c) Result;
pub const FpGetPhysicalDeviceQueueFamilyProperties2 = *const fn (PhysicalDevice, [*c]u32, [*c]QueueFamilyProperties2) callconv(.c) void;
pub const FpGetPhysicalDeviceMemoryProperties2 = *const fn (PhysicalDevice, [*c]PhysicalDeviceMemoryProperties2) callconv(.c) void;
pub const FpGetPhysicalDeviceSparseImageFormatProperties2 = *const fn (PhysicalDevice, [*c]const PhysicalDeviceSparseImageFormatInfo2, [*c]u32, [*c]SparseImageFormatProperties2) callconv(.c) void;
pub const FpCmdPushDescriptorSet = *const fn (CommandBuffer, PipelineBindPoint, PipelineLayout, u32, u32, [*c]const WriteDescriptorSet) callconv(.c) void;
pub const FpTrimCommandPool = *const fn (Device, CommandPool, CommandPoolTrimFlags) callconv(.c) void;
pub const FpGetPhysicalDeviceExternalBufferProperties = *const fn (PhysicalDevice, [*c]const PhysicalDeviceExternalBufferInfo, [*c]ExternalBufferProperties) callconv(.c) void;
pub const FpGetMemoryWin32HandleKHR = *const fn (Device, [*c]const MemoryGetWin32HandleInfoKHR, [*c]HANDLE) callconv(.c) Result;
pub const FpGetMemoryWin32HandlePropertiesKHR = *const fn (Device, ExternalMemoryHandleTypeFlags, HANDLE, [*c]MemoryWin32HandlePropertiesKHR) callconv(.c) Result;
pub const FpGetMemoryFdKHR = *const fn (Device, [*c]const MemoryGetFdInfoKHR, [*c]c_int) callconv(.c) Result;
pub const FpGetMemoryFdPropertiesKHR = *const fn (Device, ExternalMemoryHandleTypeFlags, c_int, [*c]MemoryFdPropertiesKHR) callconv(.c) Result;
pub const FpGetMemoryZirconHandleFUCHSIA = *const fn (Device, [*c]const MemoryGetZirconHandleInfoFUCHSIA, [*c]zx_handle_t) callconv(.c) Result;
pub const FpGetMemoryZirconHandlePropertiesFUCHSIA = *const fn (Device, ExternalMemoryHandleTypeFlags, zx_handle_t, [*c]MemoryZirconHandlePropertiesFUCHSIA) callconv(.c) Result;
pub const FpGetMemoryRemoteAddressNV = *const fn (Device, [*c]const MemoryGetRemoteAddressInfoNV, [*c]RemoteAddressNV) callconv(.c) Result;
pub const FpGetPhysicalDeviceExternalSemaphoreProperties = *const fn (PhysicalDevice, [*c]const PhysicalDeviceExternalSemaphoreInfo, [*c]ExternalSemaphoreProperties) callconv(.c) void;
pub const FpGetSemaphoreWin32HandleKHR = *const fn (Device, [*c]const SemaphoreGetWin32HandleInfoKHR, [*c]HANDLE) callconv(.c) Result;
pub const FpImportSemaphoreWin32HandleKHR = *const fn (Device, [*c]const ImportSemaphoreWin32HandleInfoKHR) callconv(.c) Result;
pub const FpGetSemaphoreFdKHR = *const fn (Device, [*c]const SemaphoreGetFdInfoKHR, [*c]c_int) callconv(.c) Result;
pub const FpImportSemaphoreFdKHR = *const fn (Device, [*c]const ImportSemaphoreFdInfoKHR) callconv(.c) Result;
pub const FpGetSemaphoreZirconHandleFUCHSIA = *const fn (Device, [*c]const SemaphoreGetZirconHandleInfoFUCHSIA, [*c]zx_handle_t) callconv(.c) Result;
pub const FpImportSemaphoreZirconHandleFUCHSIA = *const fn (Device, [*c]const ImportSemaphoreZirconHandleInfoFUCHSIA) callconv(.c) Result;
pub const FpGetPhysicalDeviceExternalFenceProperties = *const fn (PhysicalDevice, [*c]const PhysicalDeviceExternalFenceInfo, [*c]ExternalFenceProperties) callconv(.c) void;
pub const FpGetFenceWin32HandleKHR = *const fn (Device, [*c]const FenceGetWin32HandleInfoKHR, [*c]HANDLE) callconv(.c) Result;
pub const FpImportFenceWin32HandleKHR = *const fn (Device, [*c]const ImportFenceWin32HandleInfoKHR) callconv(.c) Result;
pub const FpGetFenceFdKHR = *const fn (Device, [*c]const FenceGetFdInfoKHR, [*c]c_int) callconv(.c) Result;
pub const FpImportFenceFdKHR = *const fn (Device, [*c]const ImportFenceFdInfoKHR) callconv(.c) Result;
pub const FpReleaseDisplayEXT = *const fn (PhysicalDevice, DisplayKHR) callconv(.c) Result;
pub const FpAcquireXlibDisplayEXT = *const fn (PhysicalDevice, ?*Display, DisplayKHR) callconv(.c) Result;
pub const FpGetRandROutputDisplayEXT = *const fn (PhysicalDevice, ?*Display, RROutput, [*c]DisplayKHR) callconv(.c) Result;
pub const FpAcquireWinrtDisplayNV = *const fn (PhysicalDevice, DisplayKHR) callconv(.c) Result;
pub const FpGetWinrtDisplayNV = *const fn (PhysicalDevice, u32, [*c]DisplayKHR) callconv(.c) Result;
pub const FpDisplayPowerControlEXT = *const fn (Device, DisplayKHR, [*c]const DisplayPowerInfoEXT) callconv(.c) Result;
pub const FpRegisterDeviceEventEXT = *const fn (Device, [*c]const DeviceEventInfoEXT, [*c]const AllocationCallbacks, [*c]Fence) callconv(.c) Result;
pub const FpRegisterDisplayEventEXT = *const fn (Device, DisplayKHR, [*c]const DisplayEventInfoEXT, [*c]const AllocationCallbacks, [*c]Fence) callconv(.c) Result;
pub const FpGetSwapchainCounterEXT = *const fn (Device, SwapchainKHR, SurfaceCounterFlagsEXT, [*c]u64) callconv(.c) Result;
pub const FpGetPhysicalDeviceSurfaceCapabilities2EXT = *const fn (PhysicalDevice, SurfaceKHR, [*c]SurfaceCapabilities2EXT) callconv(.c) Result;
pub const FpEnumeratePhysicalDeviceGroups = *const fn (Instance, [*c]u32, [*c]PhysicalDeviceGroupProperties) callconv(.c) Result;
pub const FpGetDeviceGroupPeerMemoryFeatures = *const fn (Device, u32, u32, u32, [*c]PeerMemoryFeatureFlags) callconv(.c) void;
pub const FpBindBufferMemory2 = *const fn (Device, u32, [*c]const BindBufferMemoryInfo) callconv(.c) Result;
pub const FpBindImageMemory2 = *const fn (Device, u32, [*c]const BindImageMemoryInfo) callconv(.c) Result;
pub const FpCmdSetDeviceMask = *const fn (CommandBuffer, u32) callconv(.c) void;
pub const FpGetDeviceGroupPresentCapabilitiesKHR = *const fn (Device, [*c]DeviceGroupPresentCapabilitiesKHR) callconv(.c) Result;
pub const FpGetDeviceGroupSurfacePresentModesKHR = *const fn (Device, SurfaceKHR, [*c]DeviceGroupPresentModeFlagsKHR) callconv(.c) Result;
pub const FpAcquireNextImage2KHR = *const fn (Device, [*c]const AcquireNextImageInfoKHR, [*c]u32) callconv(.c) Result;
pub const FpCmdDispatchBase = *const fn (CommandBuffer, u32, u32, u32, u32, u32, u32) callconv(.c) void;
pub const FpGetPhysicalDevicePresentRectanglesKHR = *const fn (PhysicalDevice, SurfaceKHR, [*c]u32, [*c]Rect2D) callconv(.c) Result;
pub const FpCreateDescriptorUpdateTemplate = *const fn (Device, [*c]const DescriptorUpdateTemplateCreateInfo, [*c]const AllocationCallbacks, [*c]DescriptorUpdateTemplate) callconv(.c) Result;
pub const FpDestroyDescriptorUpdateTemplate = *const fn (Device, DescriptorUpdateTemplate, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpUpdateDescriptorSetWithTemplate = *const fn (Device, DescriptorSet, DescriptorUpdateTemplate, ?*const anyopaque) callconv(.c) void;
pub const FpCmdPushDescriptorSetWithTemplate = *const fn (CommandBuffer, DescriptorUpdateTemplate, PipelineLayout, u32, ?*const anyopaque) callconv(.c) void;
pub const FpSetHdrMetadataEXT = *const fn (Device, u32, [*c]const SwapchainKHR, [*c]const HdrMetadataEXT) callconv(.c) void;
pub const FpGetSwapchainStatusKHR = *const fn (Device, SwapchainKHR) callconv(.c) Result;
pub const FpGetRefreshCycleDurationGOOGLE = *const fn (Device, SwapchainKHR, [*c]RefreshCycleDurationGOOGLE) callconv(.c) Result;
pub const FpGetPastPresentationTimingGOOGLE = *const fn (Device, SwapchainKHR, [*c]u32, [*c]PastPresentationTimingGOOGLE) callconv(.c) Result;
pub const FpCreateIOSSurfaceMVK = *const fn (Instance, [*c]const IOSSurfaceCreateInfoMVK, [*c]const AllocationCallbacks, [*c]SurfaceKHR) callconv(.c) Result;
pub const FpCreateMacOSSurfaceMVK = *const fn (Instance, [*c]const MacOSSurfaceCreateInfoMVK, [*c]const AllocationCallbacks, [*c]SurfaceKHR) callconv(.c) Result;
pub const FpCreateMetalSurfaceEXT = *const fn (Instance, [*c]const MetalSurfaceCreateInfoEXT, [*c]const AllocationCallbacks, [*c]SurfaceKHR) callconv(.c) Result;
pub const FpCmdSetViewportWScalingNV = *const fn (CommandBuffer, u32, u32, [*c]const ViewportWScalingNV) callconv(.c) void;
pub const FpCmdSetDiscardRectangleEXT = *const fn (CommandBuffer, u32, u32, [*c]const Rect2D) callconv(.c) void;
pub const FpCmdSetDiscardRectangleEnableEXT = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetDiscardRectangleModeEXT = *const fn (CommandBuffer, DiscardRectangleModeEXT) callconv(.c) void;
pub const FpCmdSetSampleLocationsEXT = *const fn (CommandBuffer, [*c]const SampleLocationsInfoEXT) callconv(.c) void;
pub const FpGetPhysicalDeviceMultisamplePropertiesEXT = *const fn (PhysicalDevice, SampleCountFlags, [*c]MultisamplePropertiesEXT) callconv(.c) void;
pub const FpGetPhysicalDeviceSurfaceCapabilities2KHR = *const fn (PhysicalDevice, [*c]const PhysicalDeviceSurfaceInfo2KHR, [*c]SurfaceCapabilities2KHR) callconv(.c) Result;
pub const FpGetPhysicalDeviceSurfaceFormats2KHR = *const fn (PhysicalDevice, [*c]const PhysicalDeviceSurfaceInfo2KHR, [*c]u32, [*c]SurfaceFormat2KHR) callconv(.c) Result;
pub const FpGetPhysicalDeviceDisplayProperties2KHR = *const fn (PhysicalDevice, [*c]u32, [*c]DisplayProperties2KHR) callconv(.c) Result;
pub const FpGetPhysicalDeviceDisplayPlaneProperties2KHR = *const fn (PhysicalDevice, [*c]u32, [*c]DisplayPlaneProperties2KHR) callconv(.c) Result;
pub const FpGetDisplayModeProperties2KHR = *const fn (PhysicalDevice, DisplayKHR, [*c]u32, [*c]DisplayModeProperties2KHR) callconv(.c) Result;
pub const FpGetDisplayPlaneCapabilities2KHR = *const fn (PhysicalDevice, [*c]const DisplayPlaneInfo2KHR, [*c]DisplayPlaneCapabilities2KHR) callconv(.c) Result;
pub const FpGetBufferMemoryRequirements2 = *const fn (Device, [*c]const BufferMemoryRequirementsInfo2, [*c]MemoryRequirements2) callconv(.c) void;
pub const FpGetImageMemoryRequirements2 = *const fn (Device, [*c]const ImageMemoryRequirementsInfo2, [*c]MemoryRequirements2) callconv(.c) void;
pub const FpGetImageSparseMemoryRequirements2 = *const fn (Device, [*c]const ImageSparseMemoryRequirementsInfo2, [*c]u32, [*c]SparseImageMemoryRequirements2) callconv(.c) void;
pub const FpGetDeviceBufferMemoryRequirements = *const fn (Device, [*c]const DeviceBufferMemoryRequirements, [*c]MemoryRequirements2) callconv(.c) void;
pub const FpGetDeviceImageMemoryRequirements = *const fn (Device, [*c]const DeviceImageMemoryRequirements, [*c]MemoryRequirements2) callconv(.c) void;
pub const FpGetDeviceImageSparseMemoryRequirements = *const fn (Device, [*c]const DeviceImageMemoryRequirements, [*c]u32, [*c]SparseImageMemoryRequirements2) callconv(.c) void;
pub const FpCreateSamplerYcbcrConversion = *const fn (Device, [*c]const SamplerYcbcrConversionCreateInfo, [*c]const AllocationCallbacks, [*c]SamplerYcbcrConversion) callconv(.c) Result;
pub const FpDestroySamplerYcbcrConversion = *const fn (Device, SamplerYcbcrConversion, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetDeviceQueue2 = *const fn (Device, [*c]const DeviceQueueInfo2, [*c]Queue) callconv(.c) void;
pub const FpCreateValidationCacheEXT = *const fn (Device, [*c]const ValidationCacheCreateInfoEXT, [*c]const AllocationCallbacks, [*c]ValidationCacheEXT) callconv(.c) Result;
pub const FpDestroyValidationCacheEXT = *const fn (Device, ValidationCacheEXT, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetValidationCacheDataEXT = *const fn (Device, ValidationCacheEXT, [*c]usize, ?*anyopaque) callconv(.c) Result;
pub const FpMergeValidationCachesEXT = *const fn (Device, ValidationCacheEXT, u32, [*c]const ValidationCacheEXT) callconv(.c) Result;
pub const FpGetDescriptorSetLayoutSupport = *const fn (Device, [*c]const DescriptorSetLayoutCreateInfo, [*c]DescriptorSetLayoutSupport) callconv(.c) void;
pub const FpGetShaderInfoAMD = *const fn (Device, Pipeline, ShaderStageFlags, ShaderInfoTypeAMD, [*c]usize, ?*anyopaque) callconv(.c) Result;
pub const FpSetLocalDimmingAMD = *const fn (Device, SwapchainKHR, Bool32) callconv(.c) void;
pub const FpGetPhysicalDeviceCalibrateableTimeDomainsKHR = *const fn (PhysicalDevice, [*c]u32, [*c]TimeDomainKHR) callconv(.c) Result;
pub const FpGetCalibratedTimestampsKHR = *const fn (Device, u32, [*c]const CalibratedTimestampInfoKHR, [*c]u64, [*c]u64) callconv(.c) Result;
pub const FpSetDebugUtilsObjectNameEXT = *const fn (Device, [*c]const DebugUtilsObjectNameInfoEXT) callconv(.c) Result;
pub const FpSetDebugUtilsObjectTagEXT = *const fn (Device, [*c]const DebugUtilsObjectTagInfoEXT) callconv(.c) Result;
pub const FpQueueBeginDebugUtilsLabelEXT = *const fn (Queue, [*c]const DebugUtilsLabelEXT) callconv(.c) void;
pub const FpQueueEndDebugUtilsLabelEXT = *const fn (Queue) callconv(.c) void;
pub const FpQueueInsertDebugUtilsLabelEXT = *const fn (Queue, [*c]const DebugUtilsLabelEXT) callconv(.c) void;
pub const FpCmdBeginDebugUtilsLabelEXT = *const fn (CommandBuffer, [*c]const DebugUtilsLabelEXT) callconv(.c) void;
pub const FpCmdEndDebugUtilsLabelEXT = *const fn (CommandBuffer) callconv(.c) void;
pub const FpCmdInsertDebugUtilsLabelEXT = *const fn (CommandBuffer, [*c]const DebugUtilsLabelEXT) callconv(.c) void;
pub const FpCreateDebugUtilsMessengerEXT = *const fn (Instance, [*c]const DebugUtilsMessengerCreateInfoEXT, [*c]const AllocationCallbacks, [*c]DebugUtilsMessengerEXT) callconv(.c) Result;
pub const FpDestroyDebugUtilsMessengerEXT = *const fn (Instance, DebugUtilsMessengerEXT, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpSubmitDebugUtilsMessageEXT = *const fn (Instance, DebugUtilsMessageSeverityFlagsEXT, DebugUtilsMessageTypeFlagsEXT, [*c]const DebugUtilsMessengerCallbackDataEXT) callconv(.c) void;
pub const FpGetMemoryHostPointerPropertiesEXT = *const fn (Device, ExternalMemoryHandleTypeFlags, ?*const anyopaque, [*c]MemoryHostPointerPropertiesEXT) callconv(.c) Result;
pub const FpCmdWriteBufferMarkerAMD = *const fn (CommandBuffer, PipelineStageFlags, Buffer, DeviceSize, u32) callconv(.c) void;
pub const FpCreateRenderPass2 = *const fn (Device, [*c]const RenderPassCreateInfo2, [*c]const AllocationCallbacks, [*c]RenderPass) callconv(.c) Result;
pub const FpCmdBeginRenderPass2 = *const fn (CommandBuffer, [*c]const RenderPassBeginInfo, [*c]const SubpassBeginInfo) callconv(.c) void;
pub const FpCmdNextSubpass2 = *const fn (CommandBuffer, [*c]const SubpassBeginInfo, [*c]const SubpassEndInfo) callconv(.c) void;
pub const FpCmdEndRenderPass2 = *const fn (CommandBuffer, [*c]const SubpassEndInfo) callconv(.c) void;
pub const FpGetSemaphoreCounterValue = *const fn (Device, Semaphore, [*c]u64) callconv(.c) Result;
pub const FpWaitSemaphores = *const fn (Device, [*c]const SemaphoreWaitInfo, u64) callconv(.c) Result;
pub const FpSignalSemaphore = *const fn (Device, [*c]const SemaphoreSignalInfo) callconv(.c) Result;
pub const FpGetAndroidHardwareBufferPropertiesANDROID = *const fn (Device, ?*const AHardwareBuffer, [*c]AndroidHardwareBufferPropertiesANDROID) callconv(.c) Result;
pub const FpGetMemoryAndroidHardwareBufferANDROID = *const fn (Device, [*c]const MemoryGetAndroidHardwareBufferInfoANDROID, [*c]?*AHardwareBuffer) callconv(.c) Result;
pub const FpCmdDrawIndirectCount = *const fn (CommandBuffer, Buffer, DeviceSize, Buffer, DeviceSize, u32, u32) callconv(.c) void;
pub const FpCmdDrawIndexedIndirectCount = *const fn (CommandBuffer, Buffer, DeviceSize, Buffer, DeviceSize, u32, u32) callconv(.c) void;
pub const FpCmdSetCheckpointNV = *const fn (CommandBuffer, ?*const anyopaque) callconv(.c) void;
pub const FpGetQueueCheckpointDataNV = *const fn (Queue, [*c]u32, [*c]CheckpointDataNV) callconv(.c) void;
pub const FpCmdBindTransformFeedbackBuffersEXT = *const fn (CommandBuffer, u32, u32, [*c]const Buffer, [*c]const DeviceSize, [*c]const DeviceSize) callconv(.c) void;
pub const FpCmdBeginTransformFeedbackEXT = *const fn (CommandBuffer, u32, u32, [*c]const Buffer, [*c]const DeviceSize) callconv(.c) void;
pub const FpCmdEndTransformFeedbackEXT = *const fn (CommandBuffer, u32, u32, [*c]const Buffer, [*c]const DeviceSize) callconv(.c) void;
pub const FpCmdBeginQueryIndexedEXT = *const fn (CommandBuffer, QueryPool, u32, QueryControlFlags, u32) callconv(.c) void;
pub const FpCmdEndQueryIndexedEXT = *const fn (CommandBuffer, QueryPool, u32, u32) callconv(.c) void;
pub const FpCmdDrawIndirectByteCountEXT = *const fn (CommandBuffer, u32, u32, Buffer, DeviceSize, u32, u32) callconv(.c) void;
pub const FpCmdSetExclusiveScissorNV = *const fn (CommandBuffer, u32, u32, [*c]const Rect2D) callconv(.c) void;
pub const FpCmdSetExclusiveScissorEnableNV = *const fn (CommandBuffer, u32, u32, [*c]const Bool32) callconv(.c) void;
pub const FpCmdBindShadingRateImageNV = *const fn (CommandBuffer, ImageView, ImageLayout) callconv(.c) void;
pub const FpCmdSetViewportShadingRatePaletteNV = *const fn (CommandBuffer, u32, u32, [*c]const ShadingRatePaletteNV) callconv(.c) void;
pub const FpCmdSetCoarseSampleOrderNV = *const fn (CommandBuffer, CoarseSampleOrderTypeNV, u32, [*c]const CoarseSampleOrderCustomNV) callconv(.c) void;
pub const FpCmdDrawMeshTasksNV = *const fn (CommandBuffer, u32, u32) callconv(.c) void;
pub const FpCmdDrawMeshTasksIndirectNV = *const fn (CommandBuffer, Buffer, DeviceSize, u32, u32) callconv(.c) void;
pub const FpCmdDrawMeshTasksIndirectCountNV = *const fn (CommandBuffer, Buffer, DeviceSize, Buffer, DeviceSize, u32, u32) callconv(.c) void;
pub const FpCmdDrawMeshTasksEXT = *const fn (CommandBuffer, u32, u32, u32) callconv(.c) void;
pub const FpCmdDrawMeshTasksIndirectEXT = *const fn (CommandBuffer, Buffer, DeviceSize, u32, u32) callconv(.c) void;
pub const FpCmdDrawMeshTasksIndirectCountEXT = *const fn (CommandBuffer, Buffer, DeviceSize, Buffer, DeviceSize, u32, u32) callconv(.c) void;
pub const FpCompileDeferredNV = *const fn (Device, Pipeline, u32) callconv(.c) Result;
pub const FpCreateAccelerationStructureNV = *const fn (Device, [*c]const AccelerationStructureCreateInfoNV, [*c]const AllocationCallbacks, [*c]AccelerationStructureNV) callconv(.c) Result;
pub const FpCmdBindInvocationMaskHUAWEI = *const fn (CommandBuffer, ImageView, ImageLayout) callconv(.c) void;
pub const FpDestroyAccelerationStructureKHR = *const fn (Device, AccelerationStructureKHR, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpDestroyAccelerationStructureNV = *const fn (Device, AccelerationStructureNV, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetAccelerationStructureMemoryRequirementsNV = *const fn (Device, [*c]const AccelerationStructureMemoryRequirementsInfoNV, [*c]MemoryRequirements2KHR) callconv(.c) void;
pub const FpBindAccelerationStructureMemoryNV = *const fn (Device, u32, [*c]const BindAccelerationStructureMemoryInfoNV) callconv(.c) Result;
pub const FpCmdCopyAccelerationStructureNV = *const fn (CommandBuffer, AccelerationStructureNV, AccelerationStructureNV, CopyAccelerationStructureModeKHR) callconv(.c) void;
pub const FpCmdCopyAccelerationStructureKHR = *const fn (CommandBuffer, [*c]const CopyAccelerationStructureInfoKHR) callconv(.c) void;
pub const FpCopyAccelerationStructureKHR = *const fn (Device, DeferredOperationKHR, [*c]const CopyAccelerationStructureInfoKHR) callconv(.c) Result;
pub const FpCmdCopyAccelerationStructureToMemoryKHR = *const fn (CommandBuffer, [*c]const CopyAccelerationStructureToMemoryInfoKHR) callconv(.c) void;
pub const FpCopyAccelerationStructureToMemoryKHR = *const fn (Device, DeferredOperationKHR, [*c]const CopyAccelerationStructureToMemoryInfoKHR) callconv(.c) Result;
pub const FpCmdCopyMemoryToAccelerationStructureKHR = *const fn (CommandBuffer, [*c]const CopyMemoryToAccelerationStructureInfoKHR) callconv(.c) void;
pub const FpCopyMemoryToAccelerationStructureKHR = *const fn (Device, DeferredOperationKHR, [*c]const CopyMemoryToAccelerationStructureInfoKHR) callconv(.c) Result;
pub const FpCmdWriteAccelerationStructuresPropertiesKHR = *const fn (CommandBuffer, u32, [*c]const AccelerationStructureKHR, QueryType, QueryPool, u32) callconv(.c) void;
pub const FpCmdWriteAccelerationStructuresPropertiesNV = *const fn (CommandBuffer, u32, [*c]const AccelerationStructureNV, QueryType, QueryPool, u32) callconv(.c) void;
pub const FpCmdBuildAccelerationStructureNV = *const fn (CommandBuffer, [*c]const AccelerationStructureInfoNV, Buffer, DeviceSize, Bool32, AccelerationStructureNV, AccelerationStructureNV, Buffer, DeviceSize) callconv(.c) void;
pub const FpWriteAccelerationStructuresPropertiesKHR = *const fn (Device, u32, [*c]const AccelerationStructureKHR, QueryType, usize, ?*anyopaque, usize) callconv(.c) Result;
pub const FpCmdTraceRaysKHR = *const fn (CommandBuffer, [*c]const StridedDeviceAddressRegionKHR, [*c]const StridedDeviceAddressRegionKHR, [*c]const StridedDeviceAddressRegionKHR, [*c]const StridedDeviceAddressRegionKHR, u32, u32, u32) callconv(.c) void;
pub const FpCmdTraceRaysNV = *const fn (CommandBuffer, Buffer, DeviceSize, Buffer, DeviceSize, DeviceSize, Buffer, DeviceSize, DeviceSize, Buffer, DeviceSize, DeviceSize, u32, u32, u32) callconv(.c) void;
pub const FpGetRayTracingShaderGroupHandlesKHR = *const fn (Device, Pipeline, u32, u32, usize, ?*anyopaque) callconv(.c) Result;
pub const FpGetRayTracingCaptureReplayShaderGroupHandlesKHR = *const fn (Device, Pipeline, u32, u32, usize, ?*anyopaque) callconv(.c) Result;
pub const FpGetAccelerationStructureHandleNV = *const fn (Device, AccelerationStructureNV, usize, ?*anyopaque) callconv(.c) Result;
pub const FpCreateRayTracingPipelinesNV = *const fn (Device, PipelineCache, u32, [*c]const RayTracingPipelineCreateInfoNV, [*c]const AllocationCallbacks, [*c]Pipeline) callconv(.c) Result;
pub const FpCreateRayTracingPipelinesKHR = *const fn (Device, DeferredOperationKHR, PipelineCache, u32, [*c]const RayTracingPipelineCreateInfoKHR, [*c]const AllocationCallbacks, [*c]Pipeline) callconv(.c) Result;
pub const FpGetPhysicalDeviceCooperativeMatrixPropertiesNV = *const fn (PhysicalDevice, [*c]u32, [*c]CooperativeMatrixPropertiesNV) callconv(.c) Result;
pub const FpCmdTraceRaysIndirectKHR = *const fn (CommandBuffer, [*c]const StridedDeviceAddressRegionKHR, [*c]const StridedDeviceAddressRegionKHR, [*c]const StridedDeviceAddressRegionKHR, [*c]const StridedDeviceAddressRegionKHR, DeviceAddress) callconv(.c) void;
pub const FpCmdTraceRaysIndirect2KHR = *const fn (CommandBuffer, DeviceAddress) callconv(.c) void;
pub const FpGetClusterAccelerationStructureBuildSizesNV = *const fn (Device, [*c]const ClusterAccelerationStructureInputInfoNV, [*c]AccelerationStructureBuildSizesInfoKHR) callconv(.c) void;
pub const FpCmdBuildClusterAccelerationStructureIndirectNV = *const fn (CommandBuffer, [*c]const ClusterAccelerationStructureCommandsInfoNV) callconv(.c) void;
pub const FpGetDeviceAccelerationStructureCompatibilityKHR = *const fn (Device, [*c]const AccelerationStructureVersionInfoKHR, [*c]AccelerationStructureCompatibilityKHR) callconv(.c) void;
pub const FpGetRayTracingShaderGroupStackSizeKHR = *const fn (Device, Pipeline, u32, ShaderGroupShaderKHR) callconv(.c) DeviceSize;
pub const FpCmdSetRayTracingPipelineStackSizeKHR = *const fn (CommandBuffer, u32) callconv(.c) void;
pub const FpGetImageViewHandleNVX = *const fn (Device, [*c]const ImageViewHandleInfoNVX) callconv(.c) u32;
pub const FpGetImageViewHandle64NVX = *const fn (Device, [*c]const ImageViewHandleInfoNVX) callconv(.c) u64;
pub const FpGetImageViewAddressNVX = *const fn (Device, ImageView, [*c]ImageViewAddressPropertiesNVX) callconv(.c) Result;
pub const FpGetPhysicalDeviceSurfacePresentModes2EXT = *const fn (PhysicalDevice, [*c]const PhysicalDeviceSurfaceInfo2KHR, [*c]u32, [*c]PresentModeKHR) callconv(.c) Result;
pub const FpGetDeviceGroupSurfacePresentModes2EXT = *const fn (Device, [*c]const PhysicalDeviceSurfaceInfo2KHR, [*c]DeviceGroupPresentModeFlagsKHR) callconv(.c) Result;
pub const FpAcquireFullScreenExclusiveModeEXT = *const fn (Device, SwapchainKHR) callconv(.c) Result;
pub const FpReleaseFullScreenExclusiveModeEXT = *const fn (Device, SwapchainKHR) callconv(.c) Result;
pub const FpEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = *const fn (PhysicalDevice, u32, [*c]u32, [*c]PerformanceCounterKHR, [*c]PerformanceCounterDescriptionKHR) callconv(.c) Result;
pub const FpGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = *const fn (PhysicalDevice, [*c]const QueryPoolPerformanceCreateInfoKHR, [*c]u32) callconv(.c) void;
pub const FpAcquireProfilingLockKHR = *const fn (Device, [*c]const AcquireProfilingLockInfoKHR) callconv(.c) Result;
pub const FpReleaseProfilingLockKHR = *const fn (Device) callconv(.c) void;
pub const FpGetImageDrmFormatModifierPropertiesEXT = *const fn (Device, Image, [*c]ImageDrmFormatModifierPropertiesEXT) callconv(.c) Result;
pub const FpGetBufferOpaqueCaptureAddress = *const fn (Device, [*c]const BufferDeviceAddressInfo) callconv(.c) u64;
pub const FpGetBufferDeviceAddress = *const fn (Device, [*c]const BufferDeviceAddressInfo) callconv(.c) DeviceAddress;
pub const FpCreateHeadlessSurfaceEXT = *const fn (Instance, [*c]const HeadlessSurfaceCreateInfoEXT, [*c]const AllocationCallbacks, [*c]SurfaceKHR) callconv(.c) Result;
pub const FpGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = *const fn (PhysicalDevice, [*c]u32, [*c]FramebufferMixedSamplesCombinationNV) callconv(.c) Result;
pub const FpInitializePerformanceApiINTEL = *const fn (Device, [*c]const InitializePerformanceApiInfoINTEL) callconv(.c) Result;
pub const FpUninitializePerformanceApiINTEL = *const fn (Device) callconv(.c) void;
pub const FpCmdSetPerformanceMarkerINTEL = *const fn (CommandBuffer, [*c]const PerformanceMarkerInfoINTEL) callconv(.c) Result;
pub const FpCmdSetPerformanceStreamMarkerINTEL = *const fn (CommandBuffer, [*c]const PerformanceStreamMarkerInfoINTEL) callconv(.c) Result;
pub const FpCmdSetPerformanceOverrideINTEL = *const fn (CommandBuffer, [*c]const PerformanceOverrideInfoINTEL) callconv(.c) Result;
pub const FpAcquirePerformanceConfigurationINTEL = *const fn (Device, [*c]const PerformanceConfigurationAcquireInfoINTEL, [*c]PerformanceConfigurationINTEL) callconv(.c) Result;
pub const FpReleasePerformanceConfigurationINTEL = *const fn (Device, PerformanceConfigurationINTEL) callconv(.c) Result;
pub const FpQueueSetPerformanceConfigurationINTEL = *const fn (Queue, PerformanceConfigurationINTEL) callconv(.c) Result;
pub const FpGetPerformanceParameterINTEL = *const fn (Device, PerformanceParameterTypeINTEL, [*c]PerformanceValueINTEL) callconv(.c) Result;
pub const FpGetDeviceMemoryOpaqueCaptureAddress = *const fn (Device, [*c]const DeviceMemoryOpaqueCaptureAddressInfo) callconv(.c) u64;
pub const FpGetPipelineExecutablePropertiesKHR = *const fn (Device, [*c]const PipelineInfoKHR, [*c]u32, [*c]PipelineExecutablePropertiesKHR) callconv(.c) Result;
pub const FpGetPipelineExecutableStatisticsKHR = *const fn (Device, [*c]const PipelineExecutableInfoKHR, [*c]u32, [*c]PipelineExecutableStatisticKHR) callconv(.c) Result;
pub const FpGetPipelineExecutableInternalRepresentationsKHR = *const fn (Device, [*c]const PipelineExecutableInfoKHR, [*c]u32, [*c]PipelineExecutableInternalRepresentationKHR) callconv(.c) Result;
pub const FpCmdSetLineStipple = *const fn (CommandBuffer, u32, u16) callconv(.c) void;
pub const FpGetPhysicalDeviceToolProperties = *const fn (PhysicalDevice, [*c]u32, [*c]PhysicalDeviceToolProperties) callconv(.c) Result;
pub const FpCreateAccelerationStructureKHR = *const fn (Device, [*c]const AccelerationStructureCreateInfoKHR, [*c]const AllocationCallbacks, [*c]AccelerationStructureKHR) callconv(.c) Result;
pub const FpCmdBuildAccelerationStructuresKHR = *const fn (CommandBuffer, u32, [*c]const AccelerationStructureBuildGeometryInfoKHR, [*c]const [*c]const AccelerationStructureBuildRangeInfoKHR) callconv(.c) void;
pub const FpCmdBuildAccelerationStructuresIndirectKHR = *const fn (CommandBuffer, u32, [*c]const AccelerationStructureBuildGeometryInfoKHR, [*c]const DeviceAddress, [*c]const u32, [*c]const [*c]const u32) callconv(.c) void;
pub const FpBuildAccelerationStructuresKHR = *const fn (Device, DeferredOperationKHR, u32, [*c]const AccelerationStructureBuildGeometryInfoKHR, [*c]const [*c]const AccelerationStructureBuildRangeInfoKHR) callconv(.c) Result;
pub const FpGetAccelerationStructureDeviceAddressKHR = *const fn (Device, [*c]const AccelerationStructureDeviceAddressInfoKHR) callconv(.c) DeviceAddress;
pub const FpCreateDeferredOperationKHR = *const fn (Device, [*c]const AllocationCallbacks, [*c]DeferredOperationKHR) callconv(.c) Result;
pub const FpDestroyDeferredOperationKHR = *const fn (Device, DeferredOperationKHR, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetDeferredOperationMaxConcurrencyKHR = *const fn (Device, DeferredOperationKHR) callconv(.c) u32;
pub const FpGetDeferredOperationResultKHR = *const fn (Device, DeferredOperationKHR) callconv(.c) Result;
pub const FpDeferredOperationJoinKHR = *const fn (Device, DeferredOperationKHR) callconv(.c) Result;
pub const FpGetPipelineIndirectMemoryRequirementsNV = *const fn (Device, [*c]const ComputePipelineCreateInfo, [*c]MemoryRequirements2) callconv(.c) void;
pub const FpGetPipelineIndirectDeviceAddressNV = *const fn (Device, [*c]const PipelineIndirectDeviceAddressInfoNV) callconv(.c) DeviceAddress;
pub const FpAntiLagUpdateAMD = *const fn (Device, [*c]const AntiLagDataAMD) callconv(.c) void;
pub const FpCmdSetCullMode = *const fn (CommandBuffer, CullModeFlags) callconv(.c) void;
pub const FpCmdSetFrontFace = *const fn (CommandBuffer, FrontFace) callconv(.c) void;
pub const FpCmdSetPrimitiveTopology = *const fn (CommandBuffer, PrimitiveTopology) callconv(.c) void;
pub const FpCmdSetViewportWithCount = *const fn (CommandBuffer, u32, [*c]const Viewport) callconv(.c) void;
pub const FpCmdSetScissorWithCount = *const fn (CommandBuffer, u32, [*c]const Rect2D) callconv(.c) void;
pub const FpCmdBindIndexBuffer2 = *const fn (CommandBuffer, Buffer, DeviceSize, DeviceSize, IndexType) callconv(.c) void;
pub const FpCmdBindVertexBuffers2 = *const fn (CommandBuffer, u32, u32, [*c]const Buffer, [*c]const DeviceSize, [*c]const DeviceSize, [*c]const DeviceSize) callconv(.c) void;
pub const FpCmdSetDepthTestEnable = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetDepthWriteEnable = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetDepthCompareOp = *const fn (CommandBuffer, CompareOp) callconv(.c) void;
pub const FpCmdSetDepthBoundsTestEnable = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetStencilTestEnable = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetStencilOp = *const fn (CommandBuffer, StencilFaceFlags, StencilOp, StencilOp, StencilOp, CompareOp) callconv(.c) void;
pub const FpCmdSetPatchControlPointsEXT = *const fn (CommandBuffer, u32) callconv(.c) void;
pub const FpCmdSetRasterizerDiscardEnable = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetDepthBiasEnable = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetLogicOpEXT = *const fn (CommandBuffer, LogicOp) callconv(.c) void;
pub const FpCmdSetPrimitiveRestartEnable = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetTessellationDomainOriginEXT = *const fn (CommandBuffer, TessellationDomainOrigin) callconv(.c) void;
pub const FpCmdSetDepthClampEnableEXT = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetPolygonModeEXT = *const fn (CommandBuffer, PolygonMode) callconv(.c) void;
pub const FpCmdSetRasterizationSamplesEXT = *const fn (CommandBuffer, SampleCountFlags) callconv(.c) void;
pub const FpCmdSetSampleMaskEXT = *const fn (CommandBuffer, SampleCountFlags, [*c]const SampleMask) callconv(.c) void;
pub const FpCmdSetAlphaToCoverageEnableEXT = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetAlphaToOneEnableEXT = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetLogicOpEnableEXT = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetColorBlendEnableEXT = *const fn (CommandBuffer, u32, u32, [*c]const Bool32) callconv(.c) void;
pub const FpCmdSetColorBlendEquationEXT = *const fn (CommandBuffer, u32, u32, [*c]const ColorBlendEquationEXT) callconv(.c) void;
pub const FpCmdSetColorWriteMaskEXT = *const fn (CommandBuffer, u32, u32, [*c]const ColorComponentFlags) callconv(.c) void;
pub const FpCmdSetRasterizationStreamEXT = *const fn (CommandBuffer, u32) callconv(.c) void;
pub const FpCmdSetConservativeRasterizationModeEXT = *const fn (CommandBuffer, ConservativeRasterizationModeEXT) callconv(.c) void;
pub const FpCmdSetExtraPrimitiveOverestimationSizeEXT = *const fn (CommandBuffer, f32) callconv(.c) void;
pub const FpCmdSetDepthClipEnableEXT = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetSampleLocationsEnableEXT = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetColorBlendAdvancedEXT = *const fn (CommandBuffer, u32, u32, [*c]const ColorBlendAdvancedEXT) callconv(.c) void;
pub const FpCmdSetProvokingVertexModeEXT = *const fn (CommandBuffer, ProvokingVertexModeEXT) callconv(.c) void;
pub const FpCmdSetLineRasterizationModeEXT = *const fn (CommandBuffer, LineRasterizationModeEXT) callconv(.c) void;
pub const FpCmdSetLineStippleEnableEXT = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetDepthClipNegativeOneToOneEXT = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetViewportWScalingEnableNV = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetViewportSwizzleNV = *const fn (CommandBuffer, u32, u32, [*c]const ViewportSwizzleNV) callconv(.c) void;
pub const FpCmdSetCoverageToColorEnableNV = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetCoverageToColorLocationNV = *const fn (CommandBuffer, u32) callconv(.c) void;
pub const FpCmdSetCoverageModulationModeNV = *const fn (CommandBuffer, CoverageModulationModeNV) callconv(.c) void;
pub const FpCmdSetCoverageModulationTableEnableNV = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetCoverageModulationTableNV = *const fn (CommandBuffer, u32, [*c]const f32) callconv(.c) void;
pub const FpCmdSetShadingRateImageEnableNV = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCmdSetCoverageReductionModeNV = *const fn (CommandBuffer, CoverageReductionModeNV) callconv(.c) void;
pub const FpCmdSetRepresentativeFragmentTestEnableNV = *const fn (CommandBuffer, Bool32) callconv(.c) void;
pub const FpCreatePrivateDataSlot = *const fn (Device, [*c]const PrivateDataSlotCreateInfo, [*c]const AllocationCallbacks, [*c]PrivateDataSlot) callconv(.c) Result;
pub const FpDestroyPrivateDataSlot = *const fn (Device, PrivateDataSlot, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpSetPrivateData = *const fn (Device, ObjectType, u64, PrivateDataSlot, u64) callconv(.c) Result;
pub const FpGetPrivateData = *const fn (Device, ObjectType, u64, PrivateDataSlot, [*c]u64) callconv(.c) void;
pub const FpCmdCopyBuffer2 = *const fn (CommandBuffer, [*c]const CopyBufferInfo2) callconv(.c) void;
pub const FpCmdCopyImage2 = *const fn (CommandBuffer, [*c]const CopyImageInfo2) callconv(.c) void;
pub const FpCmdBlitImage2 = *const fn (CommandBuffer, [*c]const BlitImageInfo2) callconv(.c) void;
pub const FpCmdCopyBufferToImage2 = *const fn (CommandBuffer, [*c]const CopyBufferToImageInfo2) callconv(.c) void;
pub const FpCmdCopyImageToBuffer2 = *const fn (CommandBuffer, [*c]const CopyImageToBufferInfo2) callconv(.c) void;
pub const FpCmdResolveImage2 = *const fn (CommandBuffer, [*c]const ResolveImageInfo2) callconv(.c) void;
pub const FpCmdSetFragmentShadingRateKHR = *const fn (CommandBuffer, [*c]const Extent2D, [*c]const FragmentShadingRateCombinerOpKHR) callconv(.c) void;
pub const FpGetPhysicalDeviceFragmentShadingRatesKHR = *const fn (PhysicalDevice, [*c]u32, [*c]PhysicalDeviceFragmentShadingRateKHR) callconv(.c) Result;
pub const FpCmdSetFragmentShadingRateEnumNV = *const fn (CommandBuffer, FragmentShadingRateNV, [*c]const FragmentShadingRateCombinerOpKHR) callconv(.c) void;
pub const FpGetAccelerationStructureBuildSizesKHR = *const fn (Device, AccelerationStructureBuildTypeKHR, [*c]const AccelerationStructureBuildGeometryInfoKHR, [*c]const u32, [*c]AccelerationStructureBuildSizesInfoKHR) callconv(.c) void;
pub const FpCmdSetVertexInputEXT = *const fn (CommandBuffer, u32, [*c]const VertexInputBindingDescription2EXT, u32, [*c]const VertexInputAttributeDescription2EXT) callconv(.c) void;
pub const FpCmdSetColorWriteEnableEXT = *const fn (CommandBuffer, u32, [*c]const Bool32) callconv(.c) void;
pub const FpCmdSetEvent2 = *const fn (CommandBuffer, Event, [*c]const DependencyInfo) callconv(.c) void;
pub const FpCmdResetEvent2 = *const fn (CommandBuffer, Event, PipelineStageFlags2) callconv(.c) void;
pub const FpCmdWaitEvents2 = *const fn (CommandBuffer, u32, [*c]const Event, [*c]const DependencyInfo) callconv(.c) void;
pub const FpCmdPipelineBarrier2 = *const fn (CommandBuffer, [*c]const DependencyInfo) callconv(.c) void;
pub const FpQueueSubmit2 = *const fn (Queue, u32, [*c]const SubmitInfo2, Fence) callconv(.c) Result;
pub const FpCmdWriteTimestamp2 = *const fn (CommandBuffer, PipelineStageFlags2, QueryPool, u32) callconv(.c) void;
pub const FpCmdWriteBufferMarker2AMD = *const fn (CommandBuffer, PipelineStageFlags2, Buffer, DeviceSize, u32) callconv(.c) void;
pub const FpGetQueueCheckpointData2NV = *const fn (Queue, [*c]u32, [*c]CheckpointData2NV) callconv(.c) void;
pub const FpCopyMemoryToImage = *const fn (Device, [*c]const CopyMemoryToImageInfo) callconv(.c) Result;
pub const FpCopyImageToMemory = *const fn (Device, [*c]const CopyImageToMemoryInfo) callconv(.c) Result;
pub const FpCopyImageToImage = *const fn (Device, [*c]const CopyImageToImageInfo) callconv(.c) Result;
pub const FpTransitionImageLayout = *const fn (Device, u32, [*c]const HostImageLayoutTransitionInfo) callconv(.c) Result;
pub const FpCmdDecompressMemoryNV = *const fn (CommandBuffer, u32, [*c]const DecompressMemoryRegionNV) callconv(.c) void;
pub const FpCmdDecompressMemoryIndirectCountNV = *const fn (CommandBuffer, DeviceAddress, DeviceAddress, u32) callconv(.c) void;
pub const FpGetPartitionedAccelerationStructuresBuildSizesNV = *const fn (Device, [*c]const PartitionedAccelerationStructureInstancesInputNV, [*c]AccelerationStructureBuildSizesInfoKHR) callconv(.c) void;
pub const FpCmdBuildPartitionedAccelerationStructuresNV = *const fn (CommandBuffer, [*c]const BuildPartitionedAccelerationStructureInfoNV) callconv(.c) void;
pub const FpCreateCuModuleNVX = *const fn (Device, [*c]const CuModuleCreateInfoNVX, [*c]const AllocationCallbacks, [*c]CuModuleNVX) callconv(.c) Result;
pub const FpCreateCuFunctionNVX = *const fn (Device, [*c]const CuFunctionCreateInfoNVX, [*c]const AllocationCallbacks, [*c]CuFunctionNVX) callconv(.c) Result;
pub const FpDestroyCuModuleNVX = *const fn (Device, CuModuleNVX, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpDestroyCuFunctionNVX = *const fn (Device, CuFunctionNVX, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCmdCuLaunchKernelNVX = *const fn (CommandBuffer, [*c]const CuLaunchInfoNVX) callconv(.c) void;
pub const FpGetDescriptorSetLayoutSizeEXT = *const fn (Device, DescriptorSetLayout, [*c]DeviceSize) callconv(.c) void;
pub const FpGetDescriptorSetLayoutBindingOffsetEXT = *const fn (Device, DescriptorSetLayout, u32, [*c]DeviceSize) callconv(.c) void;
pub const FpGetDescriptorEXT = *const fn (Device, [*c]const DescriptorGetInfoEXT, usize, ?*anyopaque) callconv(.c) void;
pub const FpCmdBindDescriptorBuffersEXT = *const fn (CommandBuffer, u32, [*c]const DescriptorBufferBindingInfoEXT) callconv(.c) void;
pub const FpCmdSetDescriptorBufferOffsetsEXT = *const fn (CommandBuffer, PipelineBindPoint, PipelineLayout, u32, u32, [*c]const u32, [*c]const DeviceSize) callconv(.c) void;
pub const FpCmdBindDescriptorBufferEmbeddedSamplersEXT = *const fn (CommandBuffer, PipelineBindPoint, PipelineLayout, u32) callconv(.c) void;
pub const FpGetBufferOpaqueCaptureDescriptorDataEXT = *const fn (Device, [*c]const BufferCaptureDescriptorDataInfoEXT, ?*anyopaque) callconv(.c) Result;
pub const FpGetImageOpaqueCaptureDescriptorDataEXT = *const fn (Device, [*c]const ImageCaptureDescriptorDataInfoEXT, ?*anyopaque) callconv(.c) Result;
pub const FpGetImageViewOpaqueCaptureDescriptorDataEXT = *const fn (Device, [*c]const ImageViewCaptureDescriptorDataInfoEXT, ?*anyopaque) callconv(.c) Result;
pub const FpGetSamplerOpaqueCaptureDescriptorDataEXT = *const fn (Device, [*c]const SamplerCaptureDescriptorDataInfoEXT, ?*anyopaque) callconv(.c) Result;
pub const FpGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = *const fn (Device, [*c]const AccelerationStructureCaptureDescriptorDataInfoEXT, ?*anyopaque) callconv(.c) Result;
pub const FpSetDeviceMemoryPriorityEXT = *const fn (Device, DeviceMemory, f32) callconv(.c) void;
pub const FpAcquireDrmDisplayEXT = *const fn (PhysicalDevice, i32, DisplayKHR) callconv(.c) Result;
pub const FpGetDrmDisplayEXT = *const fn (PhysicalDevice, i32, u32, [*c]DisplayKHR) callconv(.c) Result;
pub const FpWaitForPresent2KHR = *const fn (Device, SwapchainKHR, [*c]const PresentWait2InfoKHR) callconv(.c) Result;
pub const FpWaitForPresentKHR = *const fn (Device, SwapchainKHR, u64, u64) callconv(.c) Result;
pub const FpCreateBufferCollectionFUCHSIA = *const fn (Device, [*c]const BufferCollectionCreateInfoFUCHSIA, [*c]const AllocationCallbacks, [*c]BufferCollectionFUCHSIA) callconv(.c) Result;
pub const FpSetBufferCollectionBufferConstraintsFUCHSIA = *const fn (Device, BufferCollectionFUCHSIA, [*c]const BufferConstraintsInfoFUCHSIA) callconv(.c) Result;
pub const FpSetBufferCollectionImageConstraintsFUCHSIA = *const fn (Device, BufferCollectionFUCHSIA, [*c]const ImageConstraintsInfoFUCHSIA) callconv(.c) Result;
pub const FpDestroyBufferCollectionFUCHSIA = *const fn (Device, BufferCollectionFUCHSIA, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetBufferCollectionPropertiesFUCHSIA = *const fn (Device, BufferCollectionFUCHSIA, [*c]BufferCollectionPropertiesFUCHSIA) callconv(.c) Result;
pub const FpCreateCudaModuleNV = *const fn (Device, [*c]const CudaModuleCreateInfoNV, [*c]const AllocationCallbacks, [*c]CudaModuleNV) callconv(.c) Result;
pub const FpGetCudaModuleCacheNV = *const fn (Device, CudaModuleNV, [*c]usize, ?*anyopaque) callconv(.c) Result;
pub const FpCreateCudaFunctionNV = *const fn (Device, [*c]const CudaFunctionCreateInfoNV, [*c]const AllocationCallbacks, [*c]CudaFunctionNV) callconv(.c) Result;
pub const FpDestroyCudaModuleNV = *const fn (Device, CudaModuleNV, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpDestroyCudaFunctionNV = *const fn (Device, CudaFunctionNV, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCmdCudaLaunchKernelNV = *const fn (CommandBuffer, [*c]const CudaLaunchInfoNV) callconv(.c) void;
pub const FpCmdBeginRendering = *const fn (CommandBuffer, [*c]const RenderingInfo) callconv(.c) void;
pub const FpCmdEndRendering = *const fn (CommandBuffer) callconv(.c) void;
pub const FpCmdEndRendering2EXT = *const fn (CommandBuffer, [*c]const RenderingEndInfoEXT) callconv(.c) void;
pub const FpGetDescriptorSetLayoutHostMappingInfoVALVE = *const fn (Device, [*c]const DescriptorSetBindingReferenceVALVE, [*c]DescriptorSetLayoutHostMappingInfoVALVE) callconv(.c) void;
pub const FpGetDescriptorSetHostMappingVALVE = *const fn (Device, DescriptorSet, [*c]?*anyopaque) callconv(.c) void;
pub const FpCreateMicromapEXT = *const fn (Device, [*c]const MicromapCreateInfoEXT, [*c]const AllocationCallbacks, [*c]MicromapEXT) callconv(.c) Result;
pub const FpCmdBuildMicromapsEXT = *const fn (CommandBuffer, u32, [*c]const MicromapBuildInfoEXT) callconv(.c) void;
pub const FpBuildMicromapsEXT = *const fn (Device, DeferredOperationKHR, u32, [*c]const MicromapBuildInfoEXT) callconv(.c) Result;
pub const FpDestroyMicromapEXT = *const fn (Device, MicromapEXT, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCmdCopyMicromapEXT = *const fn (CommandBuffer, [*c]const CopyMicromapInfoEXT) callconv(.c) void;
pub const FpCopyMicromapEXT = *const fn (Device, DeferredOperationKHR, [*c]const CopyMicromapInfoEXT) callconv(.c) Result;
pub const FpCmdCopyMicromapToMemoryEXT = *const fn (CommandBuffer, [*c]const CopyMicromapToMemoryInfoEXT) callconv(.c) void;
pub const FpCopyMicromapToMemoryEXT = *const fn (Device, DeferredOperationKHR, [*c]const CopyMicromapToMemoryInfoEXT) callconv(.c) Result;
pub const FpCmdCopyMemoryToMicromapEXT = *const fn (CommandBuffer, [*c]const CopyMemoryToMicromapInfoEXT) callconv(.c) void;
pub const FpCopyMemoryToMicromapEXT = *const fn (Device, DeferredOperationKHR, [*c]const CopyMemoryToMicromapInfoEXT) callconv(.c) Result;
pub const FpCmdWriteMicromapsPropertiesEXT = *const fn (CommandBuffer, u32, [*c]const MicromapEXT, QueryType, QueryPool, u32) callconv(.c) void;
pub const FpWriteMicromapsPropertiesEXT = *const fn (Device, u32, [*c]const MicromapEXT, QueryType, usize, ?*anyopaque, usize) callconv(.c) Result;
pub const FpGetDeviceMicromapCompatibilityEXT = *const fn (Device, [*c]const MicromapVersionInfoEXT, [*c]AccelerationStructureCompatibilityKHR) callconv(.c) void;
pub const FpGetMicromapBuildSizesEXT = *const fn (Device, AccelerationStructureBuildTypeKHR, [*c]const MicromapBuildInfoEXT, [*c]MicromapBuildSizesInfoEXT) callconv(.c) void;
pub const FpGetShaderModuleIdentifierEXT = *const fn (Device, ShaderModule, [*c]ShaderModuleIdentifierEXT) callconv(.c) void;
pub const FpGetShaderModuleCreateInfoIdentifierEXT = *const fn (Device, [*c]const ShaderModuleCreateInfo, [*c]ShaderModuleIdentifierEXT) callconv(.c) void;
pub const FpGetImageSubresourceLayout2 = *const fn (Device, Image, [*c]const ImageSubresource2, [*c]SubresourceLayout2) callconv(.c) void;
pub const FpGetPipelinePropertiesEXT = *const fn (Device, [*c]const PipelineInfoEXT, [*c]BaseOutStructure) callconv(.c) Result;
pub const FpExportMetalObjectsEXT = *const fn (Device, [*c]ExportMetalObjectsInfoEXT) callconv(.c) void;
pub const FpCmdBindTileMemoryQCOM = *const fn (CommandBuffer, [*c]const TileMemoryBindInfoQCOM) callconv(.c) void;
pub const FpGetFramebufferTilePropertiesQCOM = *const fn (Device, Framebuffer, [*c]u32, [*c]TilePropertiesQCOM) callconv(.c) Result;
pub const FpGetDynamicRenderingTilePropertiesQCOM = *const fn (Device, [*c]const RenderingInfo, [*c]TilePropertiesQCOM) callconv(.c) Result;
pub const FpGetPhysicalDeviceOpticalFlowImageFormatsNV = *const fn (PhysicalDevice, [*c]const OpticalFlowImageFormatInfoNV, [*c]u32, [*c]OpticalFlowImageFormatPropertiesNV) callconv(.c) Result;
pub const FpCreateOpticalFlowSessionNV = *const fn (Device, [*c]const OpticalFlowSessionCreateInfoNV, [*c]const AllocationCallbacks, [*c]OpticalFlowSessionNV) callconv(.c) Result;
pub const FpDestroyOpticalFlowSessionNV = *const fn (Device, OpticalFlowSessionNV, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpBindOpticalFlowSessionImageNV = *const fn (Device, OpticalFlowSessionNV, OpticalFlowSessionBindingPointNV, ImageView, ImageLayout) callconv(.c) Result;
pub const FpCmdOpticalFlowExecuteNV = *const fn (CommandBuffer, OpticalFlowSessionNV, [*c]const OpticalFlowExecuteInfoNV) callconv(.c) void;
pub const FpGetDeviceFaultInfoEXT = *const fn (Device, [*c]DeviceFaultCountsEXT, [*c]DeviceFaultInfoEXT) callconv(.c) Result;
pub const FpCmdSetDepthBias2EXT = *const fn (CommandBuffer, [*c]const DepthBiasInfoEXT) callconv(.c) void;
pub const FpReleaseSwapchainImagesKHR = *const fn (Device, [*c]const ReleaseSwapchainImagesInfoKHR) callconv(.c) Result;
pub const FpGetDeviceImageSubresourceLayout = *const fn (Device, [*c]const DeviceImageSubresourceInfo, [*c]SubresourceLayout2) callconv(.c) void;
pub const FpMapMemory2 = *const fn (Device, [*c]const MemoryMapInfo, [*c]?*anyopaque) callconv(.c) Result;
pub const FpUnmapMemory2 = *const fn (Device, [*c]const MemoryUnmapInfo) callconv(.c) Result;
pub const FpCreateShadersEXT = *const fn (Device, u32, [*c]const ShaderCreateInfoEXT, [*c]const AllocationCallbacks, [*c]ShaderEXT) callconv(.c) Result;
pub const FpDestroyShaderEXT = *const fn (Device, ShaderEXT, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetShaderBinaryDataEXT = *const fn (Device, ShaderEXT, [*c]usize, ?*anyopaque) callconv(.c) Result;
pub const FpCmdBindShadersEXT = *const fn (CommandBuffer, u32, [*c]const ShaderStageFlags, [*c]const ShaderEXT) callconv(.c) void;
pub const FpGetPhysicalDeviceCooperativeMatrixPropertiesKHR = *const fn (PhysicalDevice, [*c]u32, [*c]CooperativeMatrixPropertiesKHR) callconv(.c) Result;
pub const FpGetExecutionGraphPipelineScratchSizeAMDX = *const fn (Device, Pipeline, [*c]ExecutionGraphPipelineScratchSizeAMDX) callconv(.c) Result;
pub const FpGetExecutionGraphPipelineNodeIndexAMDX = *const fn (Device, Pipeline, [*c]const PipelineShaderStageNodeCreateInfoAMDX, [*c]u32) callconv(.c) Result;
pub const FpCreateExecutionGraphPipelinesAMDX = *const fn (Device, PipelineCache, u32, [*c]const ExecutionGraphPipelineCreateInfoAMDX, [*c]const AllocationCallbacks, [*c]Pipeline) callconv(.c) Result;
pub const FpCmdInitializeGraphScratchMemoryAMDX = *const fn (CommandBuffer, Pipeline, DeviceAddress, DeviceSize) callconv(.c) void;
pub const FpCmdDispatchGraphAMDX = *const fn (CommandBuffer, DeviceAddress, DeviceSize, [*c]const DispatchGraphCountInfoAMDX) callconv(.c) void;
pub const FpCmdDispatchGraphIndirectAMDX = *const fn (CommandBuffer, DeviceAddress, DeviceSize, [*c]const DispatchGraphCountInfoAMDX) callconv(.c) void;
pub const FpCmdDispatchGraphIndirectCountAMDX = *const fn (CommandBuffer, DeviceAddress, DeviceSize, DeviceAddress) callconv(.c) void;
pub const FpCmdBindDescriptorSets2 = *const fn (CommandBuffer, [*c]const BindDescriptorSetsInfo) callconv(.c) void;
pub const FpCmdPushConstants2 = *const fn (CommandBuffer, [*c]const PushConstantsInfo) callconv(.c) void;
pub const FpCmdPushDescriptorSet2 = *const fn (CommandBuffer, [*c]const PushDescriptorSetInfo) callconv(.c) void;
pub const FpCmdPushDescriptorSetWithTemplate2 = *const fn (CommandBuffer, [*c]const PushDescriptorSetWithTemplateInfo) callconv(.c) void;
pub const FpCmdSetDescriptorBufferOffsets2EXT = *const fn (CommandBuffer, [*c]const SetDescriptorBufferOffsetsInfoEXT) callconv(.c) void;
pub const FpCmdBindDescriptorBufferEmbeddedSamplers2EXT = *const fn (CommandBuffer, [*c]const BindDescriptorBufferEmbeddedSamplersInfoEXT) callconv(.c) void;
pub const FpSetLatencySleepModeNV = *const fn (Device, SwapchainKHR, [*c]const LatencySleepModeInfoNV) callconv(.c) Result;
pub const FpLatencySleepNV = *const fn (Device, SwapchainKHR, [*c]const LatencySleepInfoNV) callconv(.c) Result;
pub const FpSetLatencyMarkerNV = *const fn (Device, SwapchainKHR, [*c]const SetLatencyMarkerInfoNV) callconv(.c) void;
pub const FpGetLatencyTimingsNV = *const fn (Device, SwapchainKHR, [*c]GetLatencyMarkerInfoNV) callconv(.c) void;
pub const FpQueueNotifyOutOfBandNV = *const fn (Queue, [*c]const OutOfBandQueueTypeInfoNV) callconv(.c) void;
pub const FpCmdSetRenderingAttachmentLocations = *const fn (CommandBuffer, [*c]const RenderingAttachmentLocationInfo) callconv(.c) void;
pub const FpCmdSetRenderingInputAttachmentIndices = *const fn (CommandBuffer, [*c]const RenderingInputAttachmentIndexInfo) callconv(.c) void;
pub const FpCmdSetDepthClampRangeEXT = *const fn (CommandBuffer, DepthClampModeEXT, [*c]const DepthClampRangeEXT) callconv(.c) void;
pub const FpGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = *const fn (PhysicalDevice, [*c]u32, [*c]CooperativeMatrixFlexibleDimensionsPropertiesNV) callconv(.c) Result;
pub const FpGetMemoryMetalHandleEXT = *const fn (Device, [*c]const MemoryGetMetalHandleInfoEXT, [*c]?*anyopaque) callconv(.c) Result;
pub const FpGetMemoryMetalHandlePropertiesEXT = *const fn (Device, ExternalMemoryHandleTypeFlags, ?*const anyopaque, [*c]MemoryMetalHandlePropertiesEXT) callconv(.c) Result;
pub const FpGetPhysicalDeviceCooperativeVectorPropertiesNV = *const fn (PhysicalDevice, [*c]u32, [*c]CooperativeVectorPropertiesNV) callconv(.c) Result;
pub const FpConvertCooperativeVectorMatrixNV = *const fn (Device, [*c]const ConvertCooperativeVectorMatrixInfoNV) callconv(.c) Result;
pub const FpCmdConvertCooperativeVectorMatrixNV = *const fn (CommandBuffer, u32, [*c]const ConvertCooperativeVectorMatrixInfoNV) callconv(.c) void;
pub const FpCmdDispatchTileQCOM = *const fn (CommandBuffer, [*c]const DispatchTileInfoQCOM) callconv(.c) void;
pub const FpCmdBeginPerTileExecutionQCOM = *const fn (CommandBuffer, [*c]const PerTileBeginInfoQCOM) callconv(.c) void;
pub const FpCmdEndPerTileExecutionQCOM = *const fn (CommandBuffer, [*c]const PerTileEndInfoQCOM) callconv(.c) void;
pub const FpCreateExternalComputeQueueNV = *const fn (Device, [*c]const ExternalComputeQueueCreateInfoNV, [*c]const AllocationCallbacks, [*c]ExternalComputeQueueNV) callconv(.c) Result;
pub const FpDestroyExternalComputeQueueNV = *const fn (Device, ExternalComputeQueueNV, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetExternalComputeQueueDataNV = *const fn (ExternalComputeQueueNV, [*c]ExternalComputeQueueDataParamsNV, ?*anyopaque) callconv(.c) void;
pub const FpCreateTensorARM = *const fn (Device, [*c]const TensorCreateInfoARM, [*c]const AllocationCallbacks, [*c]TensorARM) callconv(.c) Result;
pub const FpDestroyTensorARM = *const fn (Device, TensorARM, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCreateTensorViewARM = *const fn (Device, [*c]const TensorViewCreateInfoARM, [*c]const AllocationCallbacks, [*c]TensorViewARM) callconv(.c) Result;
pub const FpDestroyTensorViewARM = *const fn (Device, TensorViewARM, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpGetTensorMemoryRequirementsARM = *const fn (Device, [*c]const TensorMemoryRequirementsInfoARM, [*c]MemoryRequirements2) callconv(.c) void;
pub const FpBindTensorMemoryARM = *const fn (Device, u32, [*c]const BindTensorMemoryInfoARM) callconv(.c) Result;
pub const FpGetDeviceTensorMemoryRequirementsARM = *const fn (Device, [*c]const DeviceTensorMemoryRequirementsARM, [*c]MemoryRequirements2) callconv(.c) void;
pub const FpCmdCopyTensorARM = *const fn (CommandBuffer, [*c]const CopyTensorInfoARM) callconv(.c) void;
pub const FpGetTensorOpaqueCaptureDescriptorDataARM = *const fn (Device, [*c]const TensorCaptureDescriptorDataInfoARM, ?*anyopaque) callconv(.c) Result;
pub const FpGetTensorViewOpaqueCaptureDescriptorDataARM = *const fn (Device, [*c]const TensorViewCaptureDescriptorDataInfoARM, ?*anyopaque) callconv(.c) Result;
pub const FpGetPhysicalDeviceExternalTensorPropertiesARM = *const fn (PhysicalDevice, [*c]const PhysicalDeviceExternalTensorInfoARM, [*c]ExternalTensorPropertiesARM) callconv(.c) void;
pub const FpCreateDataGraphPipelinesARM = *const fn (Device, DeferredOperationKHR, PipelineCache, u32, [*c]const DataGraphPipelineCreateInfoARM, [*c]const AllocationCallbacks, [*c]Pipeline) callconv(.c) Result;
pub const FpCreateDataGraphPipelineSessionARM = *const fn (Device, [*c]const DataGraphPipelineSessionCreateInfoARM, [*c]const AllocationCallbacks, [*c]DataGraphPipelineSessionARM) callconv(.c) Result;
pub const FpGetDataGraphPipelineSessionBindPointRequirementsARM = *const fn (Device, [*c]const DataGraphPipelineSessionBindPointRequirementsInfoARM, [*c]u32, [*c]DataGraphPipelineSessionBindPointRequirementARM) callconv(.c) Result;
pub const FpGetDataGraphPipelineSessionMemoryRequirementsARM = *const fn (Device, [*c]const DataGraphPipelineSessionMemoryRequirementsInfoARM, [*c]MemoryRequirements2) callconv(.c) void;
pub const FpBindDataGraphPipelineSessionMemoryARM = *const fn (Device, u32, [*c]const BindDataGraphPipelineSessionMemoryInfoARM) callconv(.c) Result;
pub const FpDestroyDataGraphPipelineSessionARM = *const fn (Device, DataGraphPipelineSessionARM, [*c]const AllocationCallbacks) callconv(.c) void;
pub const FpCmdDispatchDataGraphARM = *const fn (CommandBuffer, DataGraphPipelineSessionARM, [*c]const DataGraphPipelineDispatchInfoARM) callconv(.c) void;
pub const FpGetDataGraphPipelineAvailablePropertiesARM = *const fn (Device, [*c]const DataGraphPipelineInfoARM, [*c]u32, [*c]DataGraphPipelinePropertyARM) callconv(.c) Result;
pub const FpGetDataGraphPipelinePropertiesARM = *const fn (Device, [*c]const DataGraphPipelineInfoARM, u32, [*c]DataGraphPipelinePropertyQueryResultARM) callconv(.c) Result;
pub const FpGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = *const fn (PhysicalDevice, u32, [*c]u32, [*c]QueueFamilyDataGraphPropertiesARM) callconv(.c) Result;
pub const FpGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = *const fn (PhysicalDevice, [*c]const PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM, [*c]QueueFamilyDataGraphProcessingEnginePropertiesARM) callconv(.c) void;

const ExtensionNames = struct {
    const khr_surface = "VK_KHR_surface";
    const khr_swapchain = "VK_KHR_swapchain";
    const khr_display = "VK_KHR_display";
    const khr_display_swapchain = "VK_KHR_display_swapchain";
    const khr_xlib_surface = "VK_KHR_xlib_surface";
    const khr_xcb_surface = "VK_KHR_xcb_surface";
    const khr_wayland_surface = "VK_KHR_wayland_surface";
    const khr_android_surface = "VK_KHR_android_surface";
    const khr_win32_surface = "VK_KHR_win32_surface";
    const ext_debug_report = "VK_EXT_debug_report";
    const nv_glsl_shader = "VK_NV_glsl_shader";
    const ext_depth_range_unrestricted = "VK_EXT_depth_range_unrestricted";
    const khr_sampler_mirror_clamp_to_edge = "VK_KHR_sampler_mirror_clamp_to_edge";
    const img_filter_cubic = "VK_IMG_filter_cubic";
    const amd_rasterization_order = "VK_AMD_rasterization_order";
    const amd_shader_trinary_minmax = "VK_AMD_shader_trinary_minmax";
    const amd_shader_explicit_vertex_parameter = "VK_AMD_shader_explicit_vertex_parameter";
    const ext_debug_marker = "VK_EXT_debug_marker";
    const amd_gcn_shader = "VK_AMD_gcn_shader";
    const nv_dedicated_allocation = "VK_NV_dedicated_allocation";
    const ext_transform_feedback = "VK_EXT_transform_feedback";
    const nvx_binary_import = "VK_NVX_binary_import";
    const nvx_image_view_handle = "VK_NVX_image_view_handle";
    const amd_draw_indirect_count = "VK_AMD_draw_indirect_count";
    const amd_negative_viewport_height = "VK_AMD_negative_viewport_height";
    const amd_gpu_shader_half_float = "VK_AMD_gpu_shader_half_float";
    const amd_shader_ballot = "VK_AMD_shader_ballot";
    const amd_texture_gather_bias_lod = "VK_AMD_texture_gather_bias_lod";
    const amd_shader_info = "VK_AMD_shader_info";
    const khr_dynamic_rendering = "VK_KHR_dynamic_rendering";
    const amd_shader_image_load_store_lod = "VK_AMD_shader_image_load_store_lod";
    const nv_corner_sampled_image = "VK_NV_corner_sampled_image";
    const khr_multiview = "VK_KHR_multiview";
    const img_format_pvrtc = "VK_IMG_format_pvrtc";
    const nv_external_memory_capabilities = "VK_NV_external_memory_capabilities";
    const nv_external_memory = "VK_NV_external_memory";
    const nv_external_memory_win32 = "VK_NV_external_memory_win32";
    const nv_win32_keyed_mutex = "VK_NV_win32_keyed_mutex";
    const khr_get_physical_device_properties2 = "VK_KHR_get_physical_device_properties2";
    const khr_device_group = "VK_KHR_device_group";
    const ext_validation_flags = "VK_EXT_validation_flags";
    const nn_vi_surface = "VK_NN_vi_surface";
    const khr_shader_draw_parameters = "VK_KHR_shader_draw_parameters";
    const ext_shader_subgroup_ballot = "VK_EXT_shader_subgroup_ballot";
    const ext_shader_subgroup_vote = "VK_EXT_shader_subgroup_vote";
    const ext_texture_compression_astc_hdr = "VK_EXT_texture_compression_astc_hdr";
    const ext_astc_decode_mode = "VK_EXT_astc_decode_mode";
    const ext_pipeline_robustness = "VK_EXT_pipeline_robustness";
    const khr_maintenance1 = "VK_KHR_maintenance1";
    const khr_device_group_creation = "VK_KHR_device_group_creation";
    const khr_external_memory_capabilities = "VK_KHR_external_memory_capabilities";
    const khr_external_memory = "VK_KHR_external_memory";
    const khr_external_memory_win32 = "VK_KHR_external_memory_win32";
    const khr_external_memory_fd = "VK_KHR_external_memory_fd";
    const khr_win32_keyed_mutex = "VK_KHR_win32_keyed_mutex";
    const khr_external_semaphore_capabilities = "VK_KHR_external_semaphore_capabilities";
    const khr_external_semaphore = "VK_KHR_external_semaphore";
    const khr_external_semaphore_win32 = "VK_KHR_external_semaphore_win32";
    const khr_external_semaphore_fd = "VK_KHR_external_semaphore_fd";
    const khr_push_descriptor = "VK_KHR_push_descriptor";
    const ext_conditional_rendering = "VK_EXT_conditional_rendering";
    const khr_shader_float16_int8 = "VK_KHR_shader_float16_int8";
    const khr_16bit_storage = "VK_KHR_16bit_storage";
    const khr_incremental_present = "VK_KHR_incremental_present";
    const khr_descriptor_update_template = "VK_KHR_descriptor_update_template";
    const nv_clip_space_w_scaling = "VK_NV_clip_space_w_scaling";
    const ext_direct_mode_display = "VK_EXT_direct_mode_display";
    const ext_acquire_xlib_display = "VK_EXT_acquire_xlib_display";
    const ext_display_surface_counter = "VK_EXT_display_surface_counter";
    const ext_display_control = "VK_EXT_display_control";
    const google_display_timing = "VK_GOOGLE_display_timing";
    const nv_sample_mask_override_coverage = "VK_NV_sample_mask_override_coverage";
    const nv_geometry_shader_passthrough = "VK_NV_geometry_shader_passthrough";
    const nv_viewport_array2 = "VK_NV_viewport_array2";
    const nvx_multiview_per_view_attributes = "VK_NVX_multiview_per_view_attributes";
    const nv_viewport_swizzle = "VK_NV_viewport_swizzle";
    const ext_discard_rectangles = "VK_EXT_discard_rectangles";
    const ext_conservative_rasterization = "VK_EXT_conservative_rasterization";
    const ext_depth_clip_enable = "VK_EXT_depth_clip_enable";
    const ext_swapchain_colorspace = "VK_EXT_swapchain_colorspace";
    const ext_hdr_metadata = "VK_EXT_hdr_metadata";
    const khr_imageless_framebuffer = "VK_KHR_imageless_framebuffer";
    const khr_create_renderpass2 = "VK_KHR_create_renderpass2";
    const img_relaxed_line_rasterization = "VK_IMG_relaxed_line_rasterization";
    const khr_shared_presentable_image = "VK_KHR_shared_presentable_image";
    const khr_external_fence_capabilities = "VK_KHR_external_fence_capabilities";
    const khr_external_fence = "VK_KHR_external_fence";
    const khr_external_fence_win32 = "VK_KHR_external_fence_win32";
    const khr_external_fence_fd = "VK_KHR_external_fence_fd";
    const khr_performance_query = "VK_KHR_performance_query";
    const khr_maintenance2 = "VK_KHR_maintenance2";
    const khr_get_surface_capabilities2 = "VK_KHR_get_surface_capabilities2";
    const khr_variable_pointers = "VK_KHR_variable_pointers";
    const khr_get_display_properties2 = "VK_KHR_get_display_properties2";
    const mvk_ios_surface = "VK_MVK_ios_surface";
    const mvk_macos_surface = "VK_MVK_macos_surface";
    const ext_external_memory_dma_buf = "VK_EXT_external_memory_dma_buf";
    const ext_queue_family_foreign = "VK_EXT_queue_family_foreign";
    const khr_dedicated_allocation = "VK_KHR_dedicated_allocation";
    const ext_debug_utils = "VK_EXT_debug_utils";
    const android_external_memory_android_hardware_buffer = "VK_ANDROID_external_memory_android_hardware_buffer";
    const ext_sampler_filter_minmax = "VK_EXT_sampler_filter_minmax";
    const khr_storage_buffer_storage_class = "VK_KHR_storage_buffer_storage_class";
    const amd_gpu_shader_int16 = "VK_AMD_gpu_shader_int16";
    const amdx_shader_enqueue = "VK_AMDX_shader_enqueue";
    const amd_mixed_attachment_samples = "VK_AMD_mixed_attachment_samples";
    const amd_shader_fragment_mask = "VK_AMD_shader_fragment_mask";
    const ext_inline_uniform_block = "VK_EXT_inline_uniform_block";
    const ext_shader_stencil_export = "VK_EXT_shader_stencil_export";
    const khr_shader_bfloat16 = "VK_KHR_shader_bfloat16";
    const ext_sample_locations = "VK_EXT_sample_locations";
    const khr_relaxed_block_layout = "VK_KHR_relaxed_block_layout";
    const khr_get_memory_requirements2 = "VK_KHR_get_memory_requirements2";
    const khr_image_format_list = "VK_KHR_image_format_list";
    const ext_blend_operation_advanced = "VK_EXT_blend_operation_advanced";
    const nv_fragment_coverage_to_color = "VK_NV_fragment_coverage_to_color";
    const khr_acceleration_structure = "VK_KHR_acceleration_structure";
    const khr_ray_tracing_pipeline = "VK_KHR_ray_tracing_pipeline";
    const khr_ray_query = "VK_KHR_ray_query";
    const nv_framebuffer_mixed_samples = "VK_NV_framebuffer_mixed_samples";
    const nv_fill_rectangle = "VK_NV_fill_rectangle";
    const nv_shader_sm_builtins = "VK_NV_shader_sm_builtins";
    const ext_post_depth_coverage = "VK_EXT_post_depth_coverage";
    const khr_sampler_ycbcr_conversion = "VK_KHR_sampler_ycbcr_conversion";
    const khr_bind_memory2 = "VK_KHR_bind_memory2";
    const ext_image_drm_format_modifier = "VK_EXT_image_drm_format_modifier";
    const ext_validation_cache = "VK_EXT_validation_cache";
    const ext_descriptor_indexing = "VK_EXT_descriptor_indexing";
    const ext_shader_viewport_index_layer = "VK_EXT_shader_viewport_index_layer";
    const khr_portability_subset = "VK_KHR_portability_subset";
    const nv_shading_rate_image = "VK_NV_shading_rate_image";
    const nv_ray_tracing = "VK_NV_ray_tracing";
    const nv_representative_fragment_test = "VK_NV_representative_fragment_test";
    const khr_maintenance3 = "VK_KHR_maintenance3";
    const khr_draw_indirect_count = "VK_KHR_draw_indirect_count";
    const ext_filter_cubic = "VK_EXT_filter_cubic";
    const qcom_render_pass_shader_resolve = "VK_QCOM_render_pass_shader_resolve";
    const ext_global_priority = "VK_EXT_global_priority";
    const khr_shader_subgroup_extended_types = "VK_KHR_shader_subgroup_extended_types";
    const khr_8bit_storage = "VK_KHR_8bit_storage";
    const ext_external_memory_host = "VK_EXT_external_memory_host";
    const amd_buffer_marker = "VK_AMD_buffer_marker";
    const khr_shader_atomic_int64 = "VK_KHR_shader_atomic_int64";
    const khr_shader_clock = "VK_KHR_shader_clock";
    const amd_pipeline_compiler_control = "VK_AMD_pipeline_compiler_control";
    const ext_calibrated_timestamps = "VK_EXT_calibrated_timestamps";
    const amd_shader_core_properties = "VK_AMD_shader_core_properties";
    const khr_global_priority = "VK_KHR_global_priority";
    const amd_memory_overallocation_behavior = "VK_AMD_memory_overallocation_behavior";
    const ext_vertex_attribute_divisor = "VK_EXT_vertex_attribute_divisor";
    const ext_pipeline_creation_feedback = "VK_EXT_pipeline_creation_feedback";
    const khr_driver_properties = "VK_KHR_driver_properties";
    const khr_shader_float_controls = "VK_KHR_shader_float_controls";
    const nv_shader_subgroup_partitioned = "VK_NV_shader_subgroup_partitioned";
    const khr_depth_stencil_resolve = "VK_KHR_depth_stencil_resolve";
    const khr_swapchain_mutable_format = "VK_KHR_swapchain_mutable_format";
    const nv_compute_shader_derivatives = "VK_NV_compute_shader_derivatives";
    const nv_mesh_shader = "VK_NV_mesh_shader";
    const nv_fragment_shader_barycentric = "VK_NV_fragment_shader_barycentric";
    const nv_shader_image_footprint = "VK_NV_shader_image_footprint";
    const nv_scissor_exclusive = "VK_NV_scissor_exclusive";
    const nv_device_diagnostic_checkpoints = "VK_NV_device_diagnostic_checkpoints";
    const khr_timeline_semaphore = "VK_KHR_timeline_semaphore";
    const intel_shader_integer_functions2 = "VK_INTEL_shader_integer_functions2";
    const intel_performance_query = "VK_INTEL_performance_query";
    const khr_vulkan_memory_model = "VK_KHR_vulkan_memory_model";
    const ext_pci_bus_info = "VK_EXT_pci_bus_info";
    const amd_display_native_hdr = "VK_AMD_display_native_hdr";
    const fuchsia_imagepipe_surface = "VK_FUCHSIA_imagepipe_surface";
    const khr_shader_terminate_invocation = "VK_KHR_shader_terminate_invocation";
    const ext_metal_surface = "VK_EXT_metal_surface";
    const ext_fragment_density_map = "VK_EXT_fragment_density_map";
    const ext_scalar_block_layout = "VK_EXT_scalar_block_layout";
    const google_hlsl_functionality1 = "VK_GOOGLE_hlsl_functionality1";
    const google_decorate_string = "VK_GOOGLE_decorate_string";
    const ext_subgroup_size_control = "VK_EXT_subgroup_size_control";
    const khr_fragment_shading_rate = "VK_KHR_fragment_shading_rate";
    const amd_shader_core_properties2 = "VK_AMD_shader_core_properties2";
    const amd_device_coherent_memory = "VK_AMD_device_coherent_memory";
    const khr_dynamic_rendering_local_read = "VK_KHR_dynamic_rendering_local_read";
    const ext_shader_image_atomic_int64 = "VK_EXT_shader_image_atomic_int64";
    const khr_shader_quad_control = "VK_KHR_shader_quad_control";
    const khr_spirv_1_4 = "VK_KHR_spirv_1_4";
    const ext_memory_budget = "VK_EXT_memory_budget";
    const ext_memory_priority = "VK_EXT_memory_priority";
    const khr_surface_protected_capabilities = "VK_KHR_surface_protected_capabilities";
    const nv_dedicated_allocation_image_aliasing = "VK_NV_dedicated_allocation_image_aliasing";
    const khr_separate_depth_stencil_layouts = "VK_KHR_separate_depth_stencil_layouts";
    const ext_buffer_device_address = "VK_EXT_buffer_device_address";
    const ext_tooling_info = "VK_EXT_tooling_info";
    const ext_separate_stencil_usage = "VK_EXT_separate_stencil_usage";
    const ext_validation_features = "VK_EXT_validation_features";
    const khr_present_wait = "VK_KHR_present_wait";
    const nv_cooperative_matrix = "VK_NV_cooperative_matrix";
    const nv_coverage_reduction_mode = "VK_NV_coverage_reduction_mode";
    const ext_fragment_shader_interlock = "VK_EXT_fragment_shader_interlock";
    const ext_ycbcr_image_arrays = "VK_EXT_ycbcr_image_arrays";
    const khr_uniform_buffer_standard_layout = "VK_KHR_uniform_buffer_standard_layout";
    const ext_provoking_vertex = "VK_EXT_provoking_vertex";
    const ext_full_screen_exclusive = "VK_EXT_full_screen_exclusive";
    const ext_headless_surface = "VK_EXT_headless_surface";
    const khr_buffer_device_address = "VK_KHR_buffer_device_address";
    const ext_line_rasterization = "VK_EXT_line_rasterization";
    const ext_shader_atomic_float = "VK_EXT_shader_atomic_float";
    const ext_host_query_reset = "VK_EXT_host_query_reset";
    const ext_index_type_uint8 = "VK_EXT_index_type_uint8";
    const ext_extended_dynamic_state = "VK_EXT_extended_dynamic_state";
    const khr_deferred_host_operations = "VK_KHR_deferred_host_operations";
    const khr_pipeline_executable_properties = "VK_KHR_pipeline_executable_properties";
    const ext_host_image_copy = "VK_EXT_host_image_copy";
    const khr_map_memory2 = "VK_KHR_map_memory2";
    const ext_map_memory_placed = "VK_EXT_map_memory_placed";
    const ext_shader_atomic_float2 = "VK_EXT_shader_atomic_float2";
    const ext_surface_maintenance1 = "VK_EXT_surface_maintenance1";
    const ext_swapchain_maintenance1 = "VK_EXT_swapchain_maintenance1";
    const ext_shader_demote_to_helper_invocation = "VK_EXT_shader_demote_to_helper_invocation";
    const nv_device_generated_commands = "VK_NV_device_generated_commands";
    const nv_inherited_viewport_scissor = "VK_NV_inherited_viewport_scissor";
    const khr_shader_integer_dot_product = "VK_KHR_shader_integer_dot_product";
    const ext_texel_buffer_alignment = "VK_EXT_texel_buffer_alignment";
    const qcom_render_pass_transform = "VK_QCOM_render_pass_transform";
    const ext_depth_bias_control = "VK_EXT_depth_bias_control";
    const ext_device_memory_report = "VK_EXT_device_memory_report";
    const ext_acquire_drm_display = "VK_EXT_acquire_drm_display";
    const ext_robustness2 = "VK_EXT_robustness2";
    const ext_custom_border_color = "VK_EXT_custom_border_color";
    const google_user_type = "VK_GOOGLE_user_type";
    const khr_pipeline_library = "VK_KHR_pipeline_library";
    const nv_present_barrier = "VK_NV_present_barrier";
    const khr_shader_non_semantic_info = "VK_KHR_shader_non_semantic_info";
    const khr_present_id = "VK_KHR_present_id";
    const ext_private_data = "VK_EXT_private_data";
    const ext_pipeline_creation_cache_control = "VK_EXT_pipeline_creation_cache_control";
    const nv_device_diagnostics_config = "VK_NV_device_diagnostics_config";
    const qcom_render_pass_store_ops = "VK_QCOM_render_pass_store_ops";
    const nv_cuda_kernel_launch = "VK_NV_cuda_kernel_launch";
    const qcom_tile_shading = "VK_QCOM_tile_shading";
    const nv_low_latency = "VK_NV_low_latency";
    const ext_metal_objects = "VK_EXT_metal_objects";
    const khr_synchronization2 = "VK_KHR_synchronization2";
    const ext_descriptor_buffer = "VK_EXT_descriptor_buffer";
    const ext_graphics_pipeline_library = "VK_EXT_graphics_pipeline_library";
    const amd_shader_early_and_late_fragment_tests = "VK_AMD_shader_early_and_late_fragment_tests";
    const khr_fragment_shader_barycentric = "VK_KHR_fragment_shader_barycentric";
    const khr_shader_subgroup_uniform_control_flow = "VK_KHR_shader_subgroup_uniform_control_flow";
    const khr_zero_initialize_workgroup_memory = "VK_KHR_zero_initialize_workgroup_memory";
    const nv_fragment_shading_rate_enums = "VK_NV_fragment_shading_rate_enums";
    const nv_ray_tracing_motion_blur = "VK_NV_ray_tracing_motion_blur";
    const ext_mesh_shader = "VK_EXT_mesh_shader";
    const ext_ycbcr_2plane_444_formats = "VK_EXT_ycbcr_2plane_444_formats";
    const ext_fragment_density_map2 = "VK_EXT_fragment_density_map2";
    const qcom_rotated_copy_commands = "VK_QCOM_rotated_copy_commands";
    const ext_image_robustness = "VK_EXT_image_robustness";
    const khr_workgroup_memory_explicit_layout = "VK_KHR_workgroup_memory_explicit_layout";
    const khr_copy_commands2 = "VK_KHR_copy_commands2";
    const ext_image_compression_control = "VK_EXT_image_compression_control";
    const ext_attachment_feedback_loop_layout = "VK_EXT_attachment_feedback_loop_layout";
    const ext_4444_formats = "VK_EXT_4444_formats";
    const ext_device_fault = "VK_EXT_device_fault";
    const arm_rasterization_order_attachment_access = "VK_ARM_rasterization_order_attachment_access";
    const ext_rgba10x6_formats = "VK_EXT_rgba10x6_formats";
    const nv_acquire_winrt_display = "VK_NV_acquire_winrt_display";
    const ext_directfb_surface = "VK_EXT_directfb_surface";
    const valve_mutable_descriptor_type = "VK_VALVE_mutable_descriptor_type";
    const ext_vertex_input_dynamic_state = "VK_EXT_vertex_input_dynamic_state";
    const ext_physical_device_drm = "VK_EXT_physical_device_drm";
    const ext_device_address_binding_report = "VK_EXT_device_address_binding_report";
    const ext_depth_clip_control = "VK_EXT_depth_clip_control";
    const ext_primitive_topology_list_restart = "VK_EXT_primitive_topology_list_restart";
    const khr_format_feature_flags2 = "VK_KHR_format_feature_flags2";
    const ext_present_mode_fifo_latest_ready = "VK_EXT_present_mode_fifo_latest_ready";
    const fuchsia_external_memory = "VK_FUCHSIA_external_memory";
    const fuchsia_external_semaphore = "VK_FUCHSIA_external_semaphore";
    const fuchsia_buffer_collection = "VK_FUCHSIA_buffer_collection";
    const huawei_subpass_shading = "VK_HUAWEI_subpass_shading";
    const huawei_invocation_mask = "VK_HUAWEI_invocation_mask";
    const nv_external_memory_rdma = "VK_NV_external_memory_rdma";
    const ext_pipeline_properties = "VK_EXT_pipeline_properties";
    const ext_frame_boundary = "VK_EXT_frame_boundary";
    const ext_multisampled_render_to_single_sampled = "VK_EXT_multisampled_render_to_single_sampled";
    const ext_extended_dynamic_state2 = "VK_EXT_extended_dynamic_state2";
    const ext_color_write_enable = "VK_EXT_color_write_enable";
    const ext_primitives_generated_query = "VK_EXT_primitives_generated_query";
    const khr_ray_tracing_maintenance1 = "VK_KHR_ray_tracing_maintenance1";
    const khr_shader_untyped_pointers = "VK_KHR_shader_untyped_pointers";
    const ext_global_priority_query = "VK_EXT_global_priority_query";
    const ext_image_view_min_lod = "VK_EXT_image_view_min_lod";
    const ext_multi_draw = "VK_EXT_multi_draw";
    const ext_image_2d_view_of_3d = "VK_EXT_image_2d_view_of_3d";
    const khr_portability_enumeration = "VK_KHR_portability_enumeration";
    const ext_shader_tile_image = "VK_EXT_shader_tile_image";
    const ext_opacity_micromap = "VK_EXT_opacity_micromap";
    const nv_displacement_micromap = "VK_NV_displacement_micromap";
    const ext_load_store_op_none = "VK_EXT_load_store_op_none";
    const huawei_cluster_culling_shader = "VK_HUAWEI_cluster_culling_shader";
    const ext_border_color_swizzle = "VK_EXT_border_color_swizzle";
    const ext_pageable_device_local_memory = "VK_EXT_pageable_device_local_memory";
    const khr_maintenance4 = "VK_KHR_maintenance4";
    const arm_shader_core_properties = "VK_ARM_shader_core_properties";
    const khr_shader_subgroup_rotate = "VK_KHR_shader_subgroup_rotate";
    const arm_scheduling_controls = "VK_ARM_scheduling_controls";
    const ext_image_sliced_view_of_3d = "VK_EXT_image_sliced_view_of_3d";
    const valve_descriptor_set_host_mapping = "VK_VALVE_descriptor_set_host_mapping";
    const ext_depth_clamp_zero_one = "VK_EXT_depth_clamp_zero_one";
    const ext_non_seamless_cube_map = "VK_EXT_non_seamless_cube_map";
    const arm_render_pass_striped = "VK_ARM_render_pass_striped";
    const qcom_fragment_density_map_offset = "VK_QCOM_fragment_density_map_offset";
    const nv_copy_memory_indirect = "VK_NV_copy_memory_indirect";
    const nv_memory_decompression = "VK_NV_memory_decompression";
    const nv_device_generated_commands_compute = "VK_NV_device_generated_commands_compute";
    const nv_ray_tracing_linear_swept_spheres = "VK_NV_ray_tracing_linear_swept_spheres";
    const nv_linear_color_attachment = "VK_NV_linear_color_attachment";
    const google_surfaceless_query = "VK_GOOGLE_surfaceless_query";
    const khr_shader_maximal_reconvergence = "VK_KHR_shader_maximal_reconvergence";
    const ext_image_compression_control_swapchain = "VK_EXT_image_compression_control_swapchain";
    const qcom_image_processing = "VK_QCOM_image_processing";
    const ext_nested_command_buffer = "VK_EXT_nested_command_buffer";
    const ext_external_memory_acquire_unmodified = "VK_EXT_external_memory_acquire_unmodified";
    const ext_extended_dynamic_state3 = "VK_EXT_extended_dynamic_state3";
    const ext_subpass_merge_feedback = "VK_EXT_subpass_merge_feedback";
    const lunarg_direct_driver_loading = "VK_LUNARG_direct_driver_loading";
    const arm_tensors = "VK_ARM_tensors";
    const ext_shader_module_identifier = "VK_EXT_shader_module_identifier";
    const ext_rasterization_order_attachment_access = "VK_EXT_rasterization_order_attachment_access";
    const nv_optical_flow = "VK_NV_optical_flow";
    const ext_legacy_dithering = "VK_EXT_legacy_dithering";
    const ext_pipeline_protected_access = "VK_EXT_pipeline_protected_access";
    const android_external_format_resolve = "VK_ANDROID_external_format_resolve";
    const khr_maintenance5 = "VK_KHR_maintenance5";
    const amd_anti_lag = "VK_AMD_anti_lag";
    const amdx_dense_geometry_format = "VK_AMDX_dense_geometry_format";
    const khr_present_id2 = "VK_KHR_present_id2";
    const khr_present_wait2 = "VK_KHR_present_wait2";
    const khr_ray_tracing_position_fetch = "VK_KHR_ray_tracing_position_fetch";
    const ext_shader_object = "VK_EXT_shader_object";
    const khr_pipeline_binary = "VK_KHR_pipeline_binary";
    const qcom_tile_properties = "VK_QCOM_tile_properties";
    const sec_amigo_profiling = "VK_SEC_amigo_profiling";
    const khr_surface_maintenance1 = "VK_KHR_surface_maintenance1";
    const khr_swapchain_maintenance1 = "VK_KHR_swapchain_maintenance1";
    const qcom_multiview_per_view_viewports = "VK_QCOM_multiview_per_view_viewports";
    const nv_ray_tracing_invocation_reorder = "VK_NV_ray_tracing_invocation_reorder";
    const nv_cooperative_vector = "VK_NV_cooperative_vector";
    const nv_extended_sparse_address_space = "VK_NV_extended_sparse_address_space";
    const ext_mutable_descriptor_type = "VK_EXT_mutable_descriptor_type";
    const ext_legacy_vertex_attributes = "VK_EXT_legacy_vertex_attributes";
    const ext_layer_settings = "VK_EXT_layer_settings";
    const arm_shader_core_builtins = "VK_ARM_shader_core_builtins";
    const ext_pipeline_library_group_handles = "VK_EXT_pipeline_library_group_handles";
    const ext_dynamic_rendering_unused_attachments = "VK_EXT_dynamic_rendering_unused_attachments";
    const nv_low_latency2 = "VK_NV_low_latency2";
    const khr_cooperative_matrix = "VK_KHR_cooperative_matrix";
    const arm_data_graph = "VK_ARM_data_graph";
    const qcom_multiview_per_view_render_areas = "VK_QCOM_multiview_per_view_render_areas";
    const khr_compute_shader_derivatives = "VK_KHR_compute_shader_derivatives";
    const nv_per_stage_descriptor_set = "VK_NV_per_stage_descriptor_set";
    const qcom_image_processing2 = "VK_QCOM_image_processing2";
    const qcom_filter_cubic_weights = "VK_QCOM_filter_cubic_weights";
    const qcom_ycbcr_degamma = "VK_QCOM_ycbcr_degamma";
    const qcom_filter_cubic_clamp = "VK_QCOM_filter_cubic_clamp";
    const ext_attachment_feedback_loop_dynamic_state = "VK_EXT_attachment_feedback_loop_dynamic_state";
    const khr_vertex_attribute_divisor = "VK_KHR_vertex_attribute_divisor";
    const khr_load_store_op_none = "VK_KHR_load_store_op_none";
    const khr_unified_image_layouts = "VK_KHR_unified_image_layouts";
    const khr_shader_float_controls2 = "VK_KHR_shader_float_controls2";
    const msft_layered_driver = "VK_MSFT_layered_driver";
    const khr_index_type_uint8 = "VK_KHR_index_type_uint8";
    const khr_line_rasterization = "VK_KHR_line_rasterization";
    const khr_calibrated_timestamps = "VK_KHR_calibrated_timestamps";
    const khr_shader_expect_assume = "VK_KHR_shader_expect_assume";
    const khr_maintenance6 = "VK_KHR_maintenance6";
    const nv_descriptor_pool_overallocation = "VK_NV_descriptor_pool_overallocation";
    const qcom_tile_memory_heap = "VK_QCOM_tile_memory_heap";
    const nv_display_stereo = "VK_NV_display_stereo";
    const nv_raw_access_chains = "VK_NV_raw_access_chains";
    const nv_external_compute_queue = "VK_NV_external_compute_queue";
    const khr_shader_relaxed_extended_instruction = "VK_KHR_shader_relaxed_extended_instruction";
    const nv_command_buffer_inheritance = "VK_NV_command_buffer_inheritance";
    const khr_maintenance7 = "VK_KHR_maintenance7";
    const nv_shader_atomic_float16_vector = "VK_NV_shader_atomic_float16_vector";
    const ext_shader_replicated_composites = "VK_EXT_shader_replicated_composites";
    const ext_shader_float8 = "VK_EXT_shader_float8";
    const nv_ray_tracing_validation = "VK_NV_ray_tracing_validation";
    const nv_cluster_acceleration_structure = "VK_NV_cluster_acceleration_structure";
    const nv_partitioned_acceleration_structure = "VK_NV_partitioned_acceleration_structure";
    const ext_device_generated_commands = "VK_EXT_device_generated_commands";
    const khr_maintenance8 = "VK_KHR_maintenance8";
    const mesa_image_alignment_control = "VK_MESA_image_alignment_control";
    const ext_depth_clamp_control = "VK_EXT_depth_clamp_control";
    const khr_maintenance9 = "VK_KHR_maintenance9";
    const ohos_surface = "VK_OHOS_surface";
    const huawei_hdr_vivid = "VK_HUAWEI_hdr_vivid";
    const nv_cooperative_matrix2 = "VK_NV_cooperative_matrix2";
    const arm_pipeline_opacity_micromap = "VK_ARM_pipeline_opacity_micromap";
    const ext_external_memory_metal = "VK_EXT_external_memory_metal";
    const khr_depth_clamp_zero_one = "VK_KHR_depth_clamp_zero_one";
    const ext_vertex_attribute_robustness = "VK_EXT_vertex_attribute_robustness";
    const arm_format_pack = "VK_ARM_format_pack";
    const valve_fragment_density_map_layered = "VK_VALVE_fragment_density_map_layered";
    const khr_robustness2 = "VK_KHR_robustness2";
    const nv_present_metering = "VK_NV_present_metering";
    const ext_fragment_density_map_offset = "VK_EXT_fragment_density_map_offset";
    const ext_zero_initialize_device_memory = "VK_EXT_zero_initialize_device_memory";
    const khr_present_mode_fifo_latest_ready = "VK_KHR_present_mode_fifo_latest_ready";
    const sec_pipeline_cache_incremental_mode = "VK_SEC_pipeline_cache_incremental_mode";
};

pub const InstanceExtensions = packed struct {
    core_version: Version,
    khr_surface: bool = false,
    khr_display: bool = false,
    khr_xlib_surface: bool = false,
    khr_xcb_surface: bool = false,
    khr_wayland_surface: bool = false,
    khr_android_surface: bool = false,
    khr_win32_surface: bool = false,
    ext_debug_report: bool = false,
    nv_external_memory_capabilities: bool = false,
    khr_get_physical_device_properties2: bool = false,
    ext_validation_flags: bool = false,
    nn_vi_surface: bool = false,
    khr_device_group_creation: bool = false,
    khr_external_memory_capabilities: bool = false,
    khr_external_semaphore_capabilities: bool = false,
    ext_direct_mode_display: bool = false,
    ext_acquire_xlib_display: bool = false,
    ext_display_surface_counter: bool = false,
    ext_swapchain_colorspace: bool = false,
    khr_external_fence_capabilities: bool = false,
    khr_get_surface_capabilities2: bool = false,
    khr_get_display_properties2: bool = false,
    mvk_ios_surface: bool = false,
    mvk_macos_surface: bool = false,
    ext_debug_utils: bool = false,
    fuchsia_imagepipe_surface: bool = false,
    ext_metal_surface: bool = false,
    khr_surface_protected_capabilities: bool = false,
    ext_validation_features: bool = false,
    ext_headless_surface: bool = false,
    ext_surface_maintenance1: bool = false,
    ext_acquire_drm_display: bool = false,
    ext_directfb_surface: bool = false,
    khr_portability_enumeration: bool = false,
    google_surfaceless_query: bool = false,
    lunarg_direct_driver_loading: bool = false,
    khr_surface_maintenance1: bool = false,
    ext_layer_settings: bool = false,
    nv_display_stereo: bool = false,
    ohos_surface: bool = false,

    pub fn enable_by_name(self: *InstanceExtensions, maybe_name: ?[*:0]const u8) void {
        const name = maybe_name orelse return;
        if (std.mem.orderZ(u8, name, ExtensionNames.khr_surface) == .eq) {
            self.khr_surface = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_display) == .eq) {
            self.khr_display = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_xlib_surface) == .eq) {
            self.khr_xlib_surface = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_xcb_surface) == .eq) {
            self.khr_xcb_surface = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_wayland_surface) == .eq) {
            self.khr_wayland_surface = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_android_surface) == .eq) {
            self.khr_android_surface = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_win32_surface) == .eq) {
            self.khr_win32_surface = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_debug_report) == .eq) {
            self.ext_debug_report = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_external_memory_capabilities) == .eq) {
            self.nv_external_memory_capabilities = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_get_physical_device_properties2) == .eq) {
            self.khr_get_physical_device_properties2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_validation_flags) == .eq) {
            self.ext_validation_flags = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nn_vi_surface) == .eq) {
            self.nn_vi_surface = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_device_group_creation) == .eq) {
            self.khr_device_group_creation = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_external_memory_capabilities) == .eq) {
            self.khr_external_memory_capabilities = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_external_semaphore_capabilities) == .eq) {
            self.khr_external_semaphore_capabilities = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_direct_mode_display) == .eq) {
            self.ext_direct_mode_display = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_acquire_xlib_display) == .eq) {
            self.ext_acquire_xlib_display = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_display_surface_counter) == .eq) {
            self.ext_display_surface_counter = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_swapchain_colorspace) == .eq) {
            self.ext_swapchain_colorspace = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_external_fence_capabilities) == .eq) {
            self.khr_external_fence_capabilities = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_get_surface_capabilities2) == .eq) {
            self.khr_get_surface_capabilities2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_get_display_properties2) == .eq) {
            self.khr_get_display_properties2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.mvk_ios_surface) == .eq) {
            self.mvk_ios_surface = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.mvk_macos_surface) == .eq) {
            self.mvk_macos_surface = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_debug_utils) == .eq) {
            self.ext_debug_utils = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.fuchsia_imagepipe_surface) == .eq) {
            self.fuchsia_imagepipe_surface = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_metal_surface) == .eq) {
            self.ext_metal_surface = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_surface_protected_capabilities) == .eq) {
            self.khr_surface_protected_capabilities = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_validation_features) == .eq) {
            self.ext_validation_features = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_headless_surface) == .eq) {
            self.ext_headless_surface = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_surface_maintenance1) == .eq) {
            self.ext_surface_maintenance1 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_acquire_drm_display) == .eq) {
            self.ext_acquire_drm_display = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_directfb_surface) == .eq) {
            self.ext_directfb_surface = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_portability_enumeration) == .eq) {
            self.khr_portability_enumeration = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.google_surfaceless_query) == .eq) {
            self.google_surfaceless_query = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.lunarg_direct_driver_loading) == .eq) {
            self.lunarg_direct_driver_loading = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_surface_maintenance1) == .eq) {
            self.khr_surface_maintenance1 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_layer_settings) == .eq) {
            self.ext_layer_settings = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_display_stereo) == .eq) {
            self.nv_display_stereo = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ohos_surface) == .eq) {
            self.ohos_surface = true;
        }
    }

    pub fn from_properties(instance_version: Version, properties: []const ExtensionProperties) InstanceExtensions {
        var self: InstanceExtensions = .{
            .core_version = instance_version,
        };
        for (properties) |*prop| {
            self.enable_by_name(&prop.extension_name);
        }
        return self;
    }

    pub fn to_name_array(self: InstanceExtensions, allocator: Allocator) Allocator.Error![][*:0]const u8 {
        var names = std.ArrayListUnmanaged([*:0]const u8){};
        if (self.khr_surface) try names.append(allocator, ExtensionNames.khr_surface);
        if (self.khr_display) try names.append(allocator, ExtensionNames.khr_display);
        if (self.khr_xlib_surface) try names.append(allocator, ExtensionNames.khr_xlib_surface);
        if (self.khr_xcb_surface) try names.append(allocator, ExtensionNames.khr_xcb_surface);
        if (self.khr_wayland_surface) try names.append(allocator, ExtensionNames.khr_wayland_surface);
        if (self.khr_android_surface) try names.append(allocator, ExtensionNames.khr_android_surface);
        if (self.khr_win32_surface) try names.append(allocator, ExtensionNames.khr_win32_surface);
        if (self.ext_debug_report) try names.append(allocator, ExtensionNames.ext_debug_report);
        if (self.nv_external_memory_capabilities) try names.append(allocator, ExtensionNames.nv_external_memory_capabilities);
        if (self.khr_get_physical_device_properties2) try names.append(allocator, ExtensionNames.khr_get_physical_device_properties2);
        if (self.ext_validation_flags) try names.append(allocator, ExtensionNames.ext_validation_flags);
        if (self.nn_vi_surface) try names.append(allocator, ExtensionNames.nn_vi_surface);
        if (self.khr_device_group_creation) try names.append(allocator, ExtensionNames.khr_device_group_creation);
        if (self.khr_external_memory_capabilities) try names.append(allocator, ExtensionNames.khr_external_memory_capabilities);
        if (self.khr_external_semaphore_capabilities) try names.append(allocator, ExtensionNames.khr_external_semaphore_capabilities);
        if (self.ext_direct_mode_display) try names.append(allocator, ExtensionNames.ext_direct_mode_display);
        if (self.ext_acquire_xlib_display) try names.append(allocator, ExtensionNames.ext_acquire_xlib_display);
        if (self.ext_display_surface_counter) try names.append(allocator, ExtensionNames.ext_display_surface_counter);
        if (self.ext_swapchain_colorspace) try names.append(allocator, ExtensionNames.ext_swapchain_colorspace);
        if (self.khr_external_fence_capabilities) try names.append(allocator, ExtensionNames.khr_external_fence_capabilities);
        if (self.khr_get_surface_capabilities2) try names.append(allocator, ExtensionNames.khr_get_surface_capabilities2);
        if (self.khr_get_display_properties2) try names.append(allocator, ExtensionNames.khr_get_display_properties2);
        if (self.mvk_ios_surface) try names.append(allocator, ExtensionNames.mvk_ios_surface);
        if (self.mvk_macos_surface) try names.append(allocator, ExtensionNames.mvk_macos_surface);
        if (self.ext_debug_utils) try names.append(allocator, ExtensionNames.ext_debug_utils);
        if (self.fuchsia_imagepipe_surface) try names.append(allocator, ExtensionNames.fuchsia_imagepipe_surface);
        if (self.ext_metal_surface) try names.append(allocator, ExtensionNames.ext_metal_surface);
        if (self.khr_surface_protected_capabilities) try names.append(allocator, ExtensionNames.khr_surface_protected_capabilities);
        if (self.ext_validation_features) try names.append(allocator, ExtensionNames.ext_validation_features);
        if (self.ext_headless_surface) try names.append(allocator, ExtensionNames.ext_headless_surface);
        if (self.ext_surface_maintenance1) try names.append(allocator, ExtensionNames.ext_surface_maintenance1);
        if (self.ext_acquire_drm_display) try names.append(allocator, ExtensionNames.ext_acquire_drm_display);
        if (self.ext_directfb_surface) try names.append(allocator, ExtensionNames.ext_directfb_surface);
        if (self.khr_portability_enumeration) try names.append(allocator, ExtensionNames.khr_portability_enumeration);
        if (self.google_surfaceless_query) try names.append(allocator, ExtensionNames.google_surfaceless_query);
        if (self.lunarg_direct_driver_loading) try names.append(allocator, ExtensionNames.lunarg_direct_driver_loading);
        if (self.khr_surface_maintenance1) try names.append(allocator, ExtensionNames.khr_surface_maintenance1);
        if (self.ext_layer_settings) try names.append(allocator, ExtensionNames.ext_layer_settings);
        if (self.nv_display_stereo) try names.append(allocator, ExtensionNames.nv_display_stereo);
        if (self.ohos_surface) try names.append(allocator, ExtensionNames.ohos_surface);
        return names.toOwnedSlice(allocator);
    }

    pub fn supports_khr_surface(self: InstanceExtensions) bool {
        return self.khr_surface;
    }
    pub fn enable_khr_surface(self: *InstanceExtensions) void {
        self.khr_surface = true;
    }

    pub fn supports_khr_swapchain(self: InstanceExtensions) bool {
        return self.supports_khr_surface();
    }
    pub fn enable_khr_swapchain(self: *InstanceExtensions) void {
        self.enable_khr_surface();
    }

    pub fn supports_khr_display(self: InstanceExtensions) bool {
        return self.khr_display and self.supports_khr_surface();
    }
    pub fn enable_khr_display(self: *InstanceExtensions) void {
        self.khr_display = true;
        self.enable_khr_surface();
    }

    pub fn supports_khr_display_swapchain(self: InstanceExtensions) bool {
        return self.supports_khr_swapchain() and self.supports_khr_display();
    }
    pub fn enable_khr_display_swapchain(self: *InstanceExtensions) void {
        self.enable_khr_swapchain();
        self.enable_khr_display();
    }

    pub fn supports_khr_xlib_surface(self: InstanceExtensions) bool {
        return self.khr_xlib_surface and self.supports_khr_surface();
    }
    pub fn enable_khr_xlib_surface(self: *InstanceExtensions) void {
        self.khr_xlib_surface = true;
        self.enable_khr_surface();
    }

    pub fn supports_khr_xcb_surface(self: InstanceExtensions) bool {
        return self.khr_xcb_surface and self.supports_khr_surface();
    }
    pub fn enable_khr_xcb_surface(self: *InstanceExtensions) void {
        self.khr_xcb_surface = true;
        self.enable_khr_surface();
    }

    pub fn supports_khr_wayland_surface(self: InstanceExtensions) bool {
        return self.khr_wayland_surface and self.supports_khr_surface();
    }
    pub fn enable_khr_wayland_surface(self: *InstanceExtensions) void {
        self.khr_wayland_surface = true;
        self.enable_khr_surface();
    }

    pub fn supports_khr_android_surface(self: InstanceExtensions) bool {
        return self.khr_android_surface and self.supports_khr_surface();
    }
    pub fn enable_khr_android_surface(self: *InstanceExtensions) void {
        self.khr_android_surface = true;
        self.enable_khr_surface();
    }

    pub fn supports_khr_win32_surface(self: InstanceExtensions) bool {
        return self.khr_win32_surface and self.supports_khr_surface();
    }
    pub fn enable_khr_win32_surface(self: *InstanceExtensions) void {
        self.khr_win32_surface = true;
        self.enable_khr_surface();
    }

    pub fn supports_ext_debug_report(self: InstanceExtensions) bool {
        return self.ext_debug_report;
    }
    pub fn enable_ext_debug_report(self: *InstanceExtensions) void {
        self.ext_debug_report = true;
    }

    pub fn supports_ext_debug_marker(self: InstanceExtensions) bool {
        return self.supports_ext_debug_report();
    }
    pub fn enable_ext_debug_marker(self: *InstanceExtensions) void {
        self.enable_ext_debug_report();
    }

    pub fn supports_ext_transform_feedback(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_transform_feedback(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_amd_texture_gather_bias_lod(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_amd_texture_gather_bias_lod(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_dynamic_rendering(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_depth_stencil_resolve());
    }
    pub fn enable_khr_dynamic_rendering(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_physical_device_properties2();
            }
            self.enable_khr_depth_stencil_resolve();
        }
    }

    pub fn supports_nv_corner_sampled_image(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_corner_sampled_image(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_multiview(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_multiview(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_external_memory_capabilities(self: InstanceExtensions) bool {
        return self.nv_external_memory_capabilities;
    }
    pub fn enable_nv_external_memory_capabilities(self: *InstanceExtensions) void {
        self.nv_external_memory_capabilities = true;
    }

    pub fn supports_nv_external_memory(self: InstanceExtensions) bool {
        return self.supports_nv_external_memory_capabilities();
    }
    pub fn enable_nv_external_memory(self: *InstanceExtensions) void {
        self.enable_nv_external_memory_capabilities();
    }

    pub fn supports_nv_external_memory_win32(self: InstanceExtensions) bool {
        return self.supports_nv_external_memory();
    }
    pub fn enable_nv_external_memory_win32(self: *InstanceExtensions) void {
        self.enable_nv_external_memory();
    }

    pub fn supports_nv_win32_keyed_mutex(self: InstanceExtensions) bool {
        return self.supports_nv_external_memory_win32();
    }
    pub fn enable_nv_win32_keyed_mutex(self: *InstanceExtensions) void {
        self.enable_nv_external_memory_win32();
    }

    pub fn supports_khr_get_physical_device_properties2(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_get_physical_device_properties2;
    }
    pub fn enable_khr_get_physical_device_properties2(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_get_physical_device_properties2 = true;
        }
    }

    pub fn supports_khr_device_group(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_device_group_creation();
    }
    pub fn enable_khr_device_group(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_device_group_creation();
        }
    }

    pub fn supports_ext_validation_flags(self: InstanceExtensions) bool {
        return self.ext_validation_flags;
    }
    pub fn enable_ext_validation_flags(self: *InstanceExtensions) void {
        self.ext_validation_flags = true;
    }

    pub fn supports_nn_vi_surface(self: InstanceExtensions) bool {
        return self.nn_vi_surface and self.supports_khr_surface();
    }
    pub fn enable_nn_vi_surface(self: *InstanceExtensions) void {
        self.nn_vi_surface = true;
        self.enable_khr_surface();
    }

    pub fn supports_ext_texture_compression_astc_hdr(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_texture_compression_astc_hdr(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_astc_decode_mode(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_astc_decode_mode(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_pipeline_robustness(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_pipeline_robustness(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_device_group_creation(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_device_group_creation;
    }
    pub fn enable_khr_device_group_creation(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_device_group_creation = true;
        }
    }

    pub fn supports_khr_external_memory_capabilities(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.khr_external_memory_capabilities and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()));
    }
    pub fn enable_khr_external_memory_capabilities(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_external_memory_capabilities = true;
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_physical_device_properties2();
            }
        }
    }

    pub fn supports_khr_external_memory(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory_capabilities();
    }
    pub fn enable_khr_external_memory(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory_capabilities();
        }
    }

    pub fn supports_khr_external_memory_win32(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory();
    }
    pub fn enable_khr_external_memory_win32(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_khr_external_memory_fd(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory();
    }
    pub fn enable_khr_external_memory_fd(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_khr_win32_keyed_mutex(self: InstanceExtensions) bool {
        return self.supports_khr_external_memory_win32();
    }
    pub fn enable_khr_win32_keyed_mutex(self: *InstanceExtensions) void {
        self.enable_khr_external_memory_win32();
    }

    pub fn supports_khr_external_semaphore_capabilities(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.khr_external_semaphore_capabilities and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()));
    }
    pub fn enable_khr_external_semaphore_capabilities(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_external_semaphore_capabilities = true;
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_physical_device_properties2();
            }
        }
    }

    pub fn supports_khr_external_semaphore(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_semaphore_capabilities();
    }
    pub fn enable_khr_external_semaphore(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_semaphore_capabilities();
        }
    }

    pub fn supports_khr_external_semaphore_win32(self: InstanceExtensions) bool {
        return self.supports_khr_external_semaphore();
    }
    pub fn enable_khr_external_semaphore_win32(self: *InstanceExtensions) void {
        self.enable_khr_external_semaphore();
    }

    pub fn supports_khr_external_semaphore_fd(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_semaphore();
    }
    pub fn enable_khr_external_semaphore_fd(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_semaphore();
        }
    }

    pub fn supports_khr_push_descriptor(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_push_descriptor(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_conditional_rendering(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_conditional_rendering(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_shader_float16_int8(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_shader_float16_int8(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_16bit_storage(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_16bit_storage(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_incremental_present(self: InstanceExtensions) bool {
        return self.supports_khr_swapchain();
    }
    pub fn enable_khr_incremental_present(self: *InstanceExtensions) void {
        self.enable_khr_swapchain();
    }

    pub fn supports_ext_direct_mode_display(self: InstanceExtensions) bool {
        return self.ext_direct_mode_display and self.supports_khr_display();
    }
    pub fn enable_ext_direct_mode_display(self: *InstanceExtensions) void {
        self.ext_direct_mode_display = true;
        self.enable_khr_display();
    }

    pub fn supports_ext_acquire_xlib_display(self: InstanceExtensions) bool {
        return self.ext_acquire_xlib_display and self.supports_ext_direct_mode_display();
    }
    pub fn enable_ext_acquire_xlib_display(self: *InstanceExtensions) void {
        self.ext_acquire_xlib_display = true;
        self.enable_ext_direct_mode_display();
    }

    pub fn supports_ext_display_surface_counter(self: InstanceExtensions) bool {
        return self.ext_display_surface_counter and self.supports_khr_display();
    }
    pub fn enable_ext_display_surface_counter(self: *InstanceExtensions) void {
        self.ext_display_surface_counter = true;
        self.enable_khr_display();
    }

    pub fn supports_ext_display_control(self: InstanceExtensions) bool {
        return self.supports_ext_display_surface_counter() and self.supports_khr_swapchain();
    }
    pub fn enable_ext_display_control(self: *InstanceExtensions) void {
        self.enable_ext_display_surface_counter();
        self.enable_khr_swapchain();
    }

    pub fn supports_google_display_timing(self: InstanceExtensions) bool {
        return self.supports_khr_swapchain();
    }
    pub fn enable_google_display_timing(self: *InstanceExtensions) void {
        self.enable_khr_swapchain();
    }

    pub fn supports_nvx_multiview_per_view_attributes(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_multiview();
    }
    pub fn enable_nvx_multiview_per_view_attributes(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_multiview();
        }
    }

    pub fn supports_ext_discard_rectangles(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_discard_rectangles(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_conservative_rasterization(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_conservative_rasterization(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_depth_clip_enable(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_depth_clip_enable(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_swapchain_colorspace(self: InstanceExtensions) bool {
        return self.ext_swapchain_colorspace and self.supports_khr_surface();
    }
    pub fn enable_ext_swapchain_colorspace(self: *InstanceExtensions) void {
        self.ext_swapchain_colorspace = true;
        self.enable_khr_surface();
    }

    pub fn supports_ext_hdr_metadata(self: InstanceExtensions) bool {
        return self.supports_khr_swapchain();
    }
    pub fn enable_ext_hdr_metadata(self: *InstanceExtensions) void {
        self.enable_khr_swapchain();
    }

    pub fn supports_khr_imageless_framebuffer(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_imageless_framebuffer(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_create_renderpass2(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_multiview();
    }
    pub fn enable_khr_create_renderpass2(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_multiview();
        }
    }

    pub fn supports_img_relaxed_line_rasterization(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_img_relaxed_line_rasterization(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_shared_presentable_image(self: InstanceExtensions) bool {
        return self.supports_khr_swapchain() and self.supports_khr_get_surface_capabilities2() and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2());
    }
    pub fn enable_khr_shared_presentable_image(self: *InstanceExtensions) void {
        self.enable_khr_swapchain();
        self.enable_khr_get_surface_capabilities2();
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_external_fence_capabilities(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.khr_external_fence_capabilities and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()));
    }
    pub fn enable_khr_external_fence_capabilities(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_external_fence_capabilities = true;
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_physical_device_properties2();
            }
        }
    }

    pub fn supports_khr_external_fence(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_fence_capabilities();
    }
    pub fn enable_khr_external_fence(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_fence_capabilities();
        }
    }

    pub fn supports_khr_external_fence_win32(self: InstanceExtensions) bool {
        return self.supports_khr_external_fence();
    }
    pub fn enable_khr_external_fence_win32(self: *InstanceExtensions) void {
        self.enable_khr_external_fence();
    }

    pub fn supports_khr_external_fence_fd(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_fence();
    }
    pub fn enable_khr_external_fence_fd(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_fence();
        }
    }

    pub fn supports_khr_performance_query(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_performance_query(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_get_surface_capabilities2(self: InstanceExtensions) bool {
        return self.khr_get_surface_capabilities2 and self.supports_khr_surface();
    }
    pub fn enable_khr_get_surface_capabilities2(self: *InstanceExtensions) void {
        self.khr_get_surface_capabilities2 = true;
        self.enable_khr_surface();
    }

    pub fn supports_khr_variable_pointers(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_variable_pointers(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_get_display_properties2(self: InstanceExtensions) bool {
        return self.khr_get_display_properties2 and self.supports_khr_display();
    }
    pub fn enable_khr_get_display_properties2(self: *InstanceExtensions) void {
        self.khr_get_display_properties2 = true;
        self.enable_khr_display();
    }

    pub fn supports_mvk_ios_surface(self: InstanceExtensions) bool {
        return self.mvk_ios_surface and self.supports_khr_surface();
    }
    pub fn enable_mvk_ios_surface(self: *InstanceExtensions) void {
        self.mvk_ios_surface = true;
        self.enable_khr_surface();
    }

    pub fn supports_mvk_macos_surface(self: InstanceExtensions) bool {
        return self.mvk_macos_surface and self.supports_khr_surface();
    }
    pub fn enable_mvk_macos_surface(self: *InstanceExtensions) void {
        self.mvk_macos_surface = true;
        self.enable_khr_surface();
    }

    pub fn supports_ext_external_memory_dma_buf(self: InstanceExtensions) bool {
        return self.supports_khr_external_memory_fd();
    }
    pub fn enable_ext_external_memory_dma_buf(self: *InstanceExtensions) void {
        self.enable_khr_external_memory_fd();
    }

    pub fn supports_ext_queue_family_foreign(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory();
    }
    pub fn enable_ext_queue_family_foreign(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_ext_debug_utils(self: InstanceExtensions) bool {
        return self.ext_debug_utils;
    }
    pub fn enable_ext_debug_utils(self: *InstanceExtensions) void {
        self.ext_debug_utils = true;
    }

    pub fn supports_android_external_memory_android_hardware_buffer(self: InstanceExtensions) bool {
        return (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.supports_khr_sampler_ycbcr_conversion() and self.supports_khr_external_memory())) and self.supports_ext_queue_family_foreign();
    }
    pub fn enable_android_external_memory_android_hardware_buffer(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_sampler_ycbcr_conversion();
            self.enable_khr_external_memory();
        }
        self.enable_ext_queue_family_foreign();
    }

    pub fn supports_ext_sampler_filter_minmax(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_sampler_filter_minmax(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_amdx_shader_enqueue(self: InstanceExtensions) bool {
        return (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or (self.supports_khr_synchronization2() and self.supports_khr_spirv_1_4() and self.supports_ext_extended_dynamic_state())) and self.supports_khr_maintenance5();
    }
    pub fn enable_amdx_shader_enqueue(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_synchronization2();
            self.enable_khr_spirv_1_4();
            self.enable_ext_extended_dynamic_state();
        }
        self.enable_khr_maintenance5();
    }

    pub fn supports_ext_inline_uniform_block(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_inline_uniform_block(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_shader_bfloat16(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_shader_bfloat16(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_sample_locations(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_sample_locations(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_blend_operation_advanced(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_blend_operation_advanced(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_acceleration_structure(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.core_version.to_int() >= make_version(1, 1, 0).to_int() and self.supports_ext_descriptor_indexing() and self.supports_khr_buffer_device_address());
    }
    pub fn enable_khr_acceleration_structure(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
            self.enable_ext_descriptor_indexing();
            self.enable_khr_buffer_device_address();
        }
    }

    pub fn supports_khr_ray_tracing_pipeline(self: InstanceExtensions) bool {
        return (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_spirv_1_4()) and self.supports_khr_acceleration_structure();
    }
    pub fn enable_khr_ray_tracing_pipeline(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_spirv_1_4();
        }
        self.enable_khr_acceleration_structure();
    }

    pub fn supports_khr_ray_query(self: InstanceExtensions) bool {
        return (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_spirv_1_4()) and self.supports_khr_acceleration_structure();
    }
    pub fn enable_khr_ray_query(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_spirv_1_4();
        }
        self.enable_khr_acceleration_structure();
    }

    pub fn supports_khr_sampler_ycbcr_conversion(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_sampler_ycbcr_conversion(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_image_drm_format_modifier(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.supports_khr_get_physical_device_properties2() and self.supports_khr_sampler_ycbcr_conversion());
    }
    pub fn enable_ext_image_drm_format_modifier(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
            self.enable_khr_sampler_ycbcr_conversion();
        }
    }

    pub fn supports_ext_descriptor_indexing(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.supports_khr_get_physical_device_properties2() and self.supports_khr_maintenance3());
    }
    pub fn enable_ext_descriptor_indexing(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
            self.enable_khr_maintenance3();
        }
    }

    pub fn supports_khr_portability_subset(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_portability_subset(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_shading_rate_image(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_shading_rate_image(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_ray_tracing(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_ray_tracing(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_representative_fragment_test(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_representative_fragment_test(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_maintenance3(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_maintenance3(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_8bit_storage(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_8bit_storage(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_external_memory_host(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory();
    }
    pub fn enable_ext_external_memory_host(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_khr_shader_atomic_int64(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_shader_atomic_int64(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_shader_clock(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_shader_clock(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_calibrated_timestamps(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_calibrated_timestamps(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_amd_shader_core_properties(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_amd_shader_core_properties(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_global_priority(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_global_priority(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_vertex_attribute_divisor(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_vertex_attribute_divisor(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_driver_properties(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_driver_properties(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_shader_float_controls(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_shader_float_controls(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_depth_stencil_resolve(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_create_renderpass2();
    }
    pub fn enable_khr_depth_stencil_resolve(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_create_renderpass2();
        }
    }

    pub fn supports_khr_swapchain_mutable_format(self: InstanceExtensions) bool {
        return self.supports_khr_swapchain();
    }
    pub fn enable_khr_swapchain_mutable_format(self: *InstanceExtensions) void {
        self.enable_khr_swapchain();
    }

    pub fn supports_nv_compute_shader_derivatives(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_compute_shader_derivatives(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_mesh_shader(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_mesh_shader(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_fragment_shader_barycentric(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_fragment_shader_barycentric(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_shader_image_footprint(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_shader_image_footprint(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_scissor_exclusive(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_scissor_exclusive(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_device_diagnostic_checkpoints(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_device_diagnostic_checkpoints(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_timeline_semaphore(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_timeline_semaphore(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_intel_shader_integer_functions2(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_intel_shader_integer_functions2(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_vulkan_memory_model(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_vulkan_memory_model(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_pci_bus_info(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_pci_bus_info(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_amd_display_native_hdr(self: InstanceExtensions) bool {
        return (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_get_surface_capabilities2() and self.supports_khr_swapchain();
    }
    pub fn enable_amd_display_native_hdr(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
        self.enable_khr_get_surface_capabilities2();
        self.enable_khr_swapchain();
    }

    pub fn supports_fuchsia_imagepipe_surface(self: InstanceExtensions) bool {
        return self.fuchsia_imagepipe_surface and self.supports_khr_surface();
    }
    pub fn enable_fuchsia_imagepipe_surface(self: *InstanceExtensions) void {
        self.fuchsia_imagepipe_surface = true;
        self.enable_khr_surface();
    }

    pub fn supports_khr_shader_terminate_invocation(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_shader_terminate_invocation(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_metal_surface(self: InstanceExtensions) bool {
        return self.ext_metal_surface and self.supports_khr_surface();
    }
    pub fn enable_ext_metal_surface(self: *InstanceExtensions) void {
        self.ext_metal_surface = true;
        self.enable_khr_surface();
    }

    pub fn supports_ext_fragment_density_map(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_fragment_density_map(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_scalar_block_layout(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_scalar_block_layout(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_fragment_shading_rate(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_create_renderpass2());
    }
    pub fn enable_khr_fragment_shading_rate(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_physical_device_properties2();
            }
            self.enable_khr_create_renderpass2();
        }
    }

    pub fn supports_amd_shader_core_properties2(self: InstanceExtensions) bool {
        return self.supports_amd_shader_core_properties();
    }
    pub fn enable_amd_shader_core_properties2(self: *InstanceExtensions) void {
        self.enable_amd_shader_core_properties();
    }

    pub fn supports_amd_device_coherent_memory(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_amd_device_coherent_memory(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_dynamic_rendering_local_read(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_dynamic_rendering();
    }
    pub fn enable_khr_dynamic_rendering_local_read(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_dynamic_rendering();
        }
    }

    pub fn supports_ext_shader_image_atomic_int64(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_shader_image_atomic_int64(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_shader_quad_control(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.core_version.to_int() >= make_version(1, 1, 0).to_int() and self.supports_khr_vulkan_memory_model());
    }
    pub fn enable_khr_shader_quad_control(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
            self.enable_khr_vulkan_memory_model();
        }
    }

    pub fn supports_khr_spirv_1_4(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.core_version.to_int() >= make_version(1, 1, 0).to_int() and self.supports_khr_shader_float_controls());
    }
    pub fn enable_khr_spirv_1_4(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
            self.enable_khr_shader_float_controls();
        }
    }

    pub fn supports_ext_memory_budget(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_memory_budget(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_memory_priority(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_memory_priority(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_surface_protected_capabilities(self: InstanceExtensions) bool {
        return self.khr_surface_protected_capabilities and self.core_version.to_int() >= make_version(1, 1, 0).to_int() and self.supports_khr_get_surface_capabilities2();
    }
    pub fn enable_khr_surface_protected_capabilities(self: *InstanceExtensions) void {
        self.khr_surface_protected_capabilities = true;
        // depends on minimum core version, caller must specify
        assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
        self.enable_khr_get_surface_capabilities2();
    }

    pub fn supports_nv_dedicated_allocation_image_aliasing(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_dedicated_allocation_image_aliasing(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_separate_depth_stencil_layouts(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_create_renderpass2());
    }
    pub fn enable_khr_separate_depth_stencil_layouts(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_physical_device_properties2();
            }
            self.enable_khr_create_renderpass2();
        }
    }

    pub fn supports_ext_buffer_device_address(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_buffer_device_address(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_validation_features(self: InstanceExtensions) bool {
        return self.ext_validation_features;
    }
    pub fn enable_ext_validation_features(self: *InstanceExtensions) void {
        self.ext_validation_features = true;
    }

    pub fn supports_khr_present_wait(self: InstanceExtensions) bool {
        return self.supports_khr_swapchain() and self.supports_khr_present_id();
    }
    pub fn enable_khr_present_wait(self: *InstanceExtensions) void {
        self.enable_khr_swapchain();
        self.enable_khr_present_id();
    }

    pub fn supports_nv_cooperative_matrix(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_cooperative_matrix(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_coverage_reduction_mode(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_coverage_reduction_mode(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_fragment_shader_interlock(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_fragment_shader_interlock(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_ycbcr_image_arrays(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_sampler_ycbcr_conversion();
    }
    pub fn enable_ext_ycbcr_image_arrays(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_sampler_ycbcr_conversion();
        }
    }

    pub fn supports_khr_uniform_buffer_standard_layout(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_uniform_buffer_standard_layout(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_provoking_vertex(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_provoking_vertex(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_full_screen_exclusive(self: InstanceExtensions) bool {
        return (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_surface() and self.supports_khr_get_surface_capabilities2() and self.supports_khr_swapchain();
    }
    pub fn enable_ext_full_screen_exclusive(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
        self.enable_khr_surface();
        self.enable_khr_get_surface_capabilities2();
        self.enable_khr_swapchain();
    }

    pub fn supports_ext_headless_surface(self: InstanceExtensions) bool {
        return self.ext_headless_surface and self.supports_khr_surface();
    }
    pub fn enable_ext_headless_surface(self: *InstanceExtensions) void {
        self.ext_headless_surface = true;
        self.enable_khr_surface();
    }

    pub fn supports_khr_buffer_device_address(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.supports_khr_get_physical_device_properties2() and self.supports_khr_device_group());
    }
    pub fn enable_khr_buffer_device_address(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
            self.enable_khr_device_group();
        }
    }

    pub fn supports_ext_line_rasterization(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_line_rasterization(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_shader_atomic_float(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_shader_atomic_float(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_host_query_reset(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_host_query_reset(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_index_type_uint8(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_index_type_uint8(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_extended_dynamic_state(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_extended_dynamic_state(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_pipeline_executable_properties(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_pipeline_executable_properties(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_host_image_copy(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_copy_commands2() and self.supports_khr_format_feature_flags2());
    }
    pub fn enable_ext_host_image_copy(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_physical_device_properties2();
            }
            self.enable_khr_copy_commands2();
            self.enable_khr_format_feature_flags2();
        }
    }

    pub fn supports_ext_shader_atomic_float2(self: InstanceExtensions) bool {
        return self.supports_ext_shader_atomic_float();
    }
    pub fn enable_ext_shader_atomic_float2(self: *InstanceExtensions) void {
        self.enable_ext_shader_atomic_float();
    }

    pub fn supports_ext_surface_maintenance1(self: InstanceExtensions) bool {
        return self.ext_surface_maintenance1 and self.supports_khr_surface() and self.supports_khr_get_surface_capabilities2();
    }
    pub fn enable_ext_surface_maintenance1(self: *InstanceExtensions) void {
        self.ext_surface_maintenance1 = true;
        self.enable_khr_surface();
        self.enable_khr_get_surface_capabilities2();
    }

    pub fn supports_ext_swapchain_maintenance1(self: InstanceExtensions) bool {
        return self.supports_khr_swapchain() and self.supports_ext_surface_maintenance1() and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2());
    }
    pub fn enable_ext_swapchain_maintenance1(self: *InstanceExtensions) void {
        self.enable_khr_swapchain();
        self.enable_ext_surface_maintenance1();
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_shader_demote_to_helper_invocation(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_shader_demote_to_helper_invocation(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_device_generated_commands(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.core_version.to_int() >= make_version(1, 1, 0).to_int() and self.supports_khr_buffer_device_address());
    }
    pub fn enable_nv_device_generated_commands(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
            self.enable_khr_buffer_device_address();
        }
    }

    pub fn supports_nv_inherited_viewport_scissor(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_inherited_viewport_scissor(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_shader_integer_dot_product(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_shader_integer_dot_product(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_texel_buffer_alignment(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_texel_buffer_alignment(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_depth_bias_control(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_depth_bias_control(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_device_memory_report(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_device_memory_report(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_acquire_drm_display(self: InstanceExtensions) bool {
        return self.ext_acquire_drm_display and self.supports_ext_direct_mode_display();
    }
    pub fn enable_ext_acquire_drm_display(self: *InstanceExtensions) void {
        self.ext_acquire_drm_display = true;
        self.enable_ext_direct_mode_display();
    }

    pub fn supports_ext_robustness2(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_robustness2(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_custom_border_color(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_custom_border_color(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_present_barrier(self: InstanceExtensions) bool {
        return (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_surface() and self.supports_khr_get_surface_capabilities2() and self.supports_khr_swapchain();
    }
    pub fn enable_nv_present_barrier(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
        self.enable_khr_surface();
        self.enable_khr_get_surface_capabilities2();
        self.enable_khr_swapchain();
    }

    pub fn supports_khr_present_id(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.supports_khr_swapchain() and self.supports_khr_get_physical_device_properties2());
    }
    pub fn enable_khr_present_id(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_swapchain();
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_private_data(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_private_data(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_pipeline_creation_cache_control(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_pipeline_creation_cache_control(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_device_diagnostics_config(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_device_diagnostics_config(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_qcom_tile_shading(self: InstanceExtensions) bool {
        return self.supports_qcom_tile_properties() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_qcom_tile_shading(self: *InstanceExtensions) void {
        // ambiguous dependency, caller must enable one explicitly
        assert(self.supports_qcom_tile_properties() or self.supports_khr_get_physical_device_properties2());
    }

    pub fn supports_khr_synchronization2(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_synchronization2(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_descriptor_buffer(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 2, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_buffer_device_address() and self.supports_ext_descriptor_indexing())) and self.supports_khr_synchronization2());
    }
    pub fn enable_ext_descriptor_buffer(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
                if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                    self.enable_khr_get_physical_device_properties2();
                }
                self.enable_khr_buffer_device_address();
                self.enable_ext_descriptor_indexing();
            }
            self.enable_khr_synchronization2();
        }
    }

    pub fn supports_ext_graphics_pipeline_library(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_graphics_pipeline_library(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_amd_shader_early_and_late_fragment_tests(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_amd_shader_early_and_late_fragment_tests(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_fragment_shader_barycentric(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_fragment_shader_barycentric(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_zero_initialize_workgroup_memory(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_zero_initialize_workgroup_memory(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_fragment_shading_rate_enums(self: InstanceExtensions) bool {
        return self.supports_khr_fragment_shading_rate();
    }
    pub fn enable_nv_fragment_shading_rate_enums(self: *InstanceExtensions) void {
        self.enable_khr_fragment_shading_rate();
    }

    pub fn supports_nv_ray_tracing_motion_blur(self: InstanceExtensions) bool {
        return self.supports_khr_ray_tracing_pipeline();
    }
    pub fn enable_nv_ray_tracing_motion_blur(self: *InstanceExtensions) void {
        self.enable_khr_ray_tracing_pipeline();
    }

    pub fn supports_ext_mesh_shader(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_spirv_1_4();
    }
    pub fn enable_ext_mesh_shader(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_spirv_1_4();
        }
    }

    pub fn supports_ext_ycbcr_2plane_444_formats(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_sampler_ycbcr_conversion();
    }
    pub fn enable_ext_ycbcr_2plane_444_formats(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_sampler_ycbcr_conversion();
        }
    }

    pub fn supports_ext_fragment_density_map2(self: InstanceExtensions) bool {
        return self.supports_ext_fragment_density_map();
    }
    pub fn enable_ext_fragment_density_map2(self: *InstanceExtensions) void {
        self.enable_ext_fragment_density_map();
    }

    pub fn supports_qcom_rotated_copy_commands(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_copy_commands2();
    }
    pub fn enable_qcom_rotated_copy_commands(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_copy_commands2();
        }
    }

    pub fn supports_ext_image_robustness(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_image_robustness(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_workgroup_memory_explicit_layout(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_workgroup_memory_explicit_layout(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_copy_commands2(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_copy_commands2(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_image_compression_control(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_image_compression_control(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_attachment_feedback_loop_layout(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_attachment_feedback_loop_layout(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_4444_formats(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_4444_formats(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_device_fault(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_device_fault(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_arm_rasterization_order_attachment_access(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_arm_rasterization_order_attachment_access(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_rgba10x6_formats(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_sampler_ycbcr_conversion();
    }
    pub fn enable_ext_rgba10x6_formats(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_sampler_ycbcr_conversion();
        }
    }

    pub fn supports_nv_acquire_winrt_display(self: InstanceExtensions) bool {
        return self.supports_ext_direct_mode_display();
    }
    pub fn enable_nv_acquire_winrt_display(self: *InstanceExtensions) void {
        self.enable_ext_direct_mode_display();
    }

    pub fn supports_ext_directfb_surface(self: InstanceExtensions) bool {
        return self.ext_directfb_surface and self.supports_khr_surface();
    }
    pub fn enable_ext_directfb_surface(self: *InstanceExtensions) void {
        self.ext_directfb_surface = true;
        self.enable_khr_surface();
    }

    pub fn supports_valve_mutable_descriptor_type(self: InstanceExtensions) bool {
        return self.supports_khr_maintenance3();
    }
    pub fn enable_valve_mutable_descriptor_type(self: *InstanceExtensions) void {
        self.enable_khr_maintenance3();
    }

    pub fn supports_ext_vertex_input_dynamic_state(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_vertex_input_dynamic_state(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_physical_device_drm(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_physical_device_drm(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_device_address_binding_report(self: InstanceExtensions) bool {
        return (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_ext_debug_utils();
    }
    pub fn enable_ext_device_address_binding_report(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
        self.enable_ext_debug_utils();
    }

    pub fn supports_ext_depth_clip_control(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_depth_clip_control(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_primitive_topology_list_restart(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_primitive_topology_list_restart(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_format_feature_flags2(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_format_feature_flags2(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_present_mode_fifo_latest_ready(self: InstanceExtensions) bool {
        return self.supports_khr_swapchain();
    }
    pub fn enable_ext_present_mode_fifo_latest_ready(self: *InstanceExtensions) void {
        self.enable_khr_swapchain();
    }

    pub fn supports_fuchsia_external_memory(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.supports_khr_external_memory_capabilities() and self.supports_khr_external_memory());
    }
    pub fn enable_fuchsia_external_memory(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory_capabilities();
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_fuchsia_external_semaphore(self: InstanceExtensions) bool {
        return self.supports_khr_external_semaphore_capabilities() and self.supports_khr_external_semaphore();
    }
    pub fn enable_fuchsia_external_semaphore(self: *InstanceExtensions) void {
        self.enable_khr_external_semaphore_capabilities();
        self.enable_khr_external_semaphore();
    }

    pub fn supports_fuchsia_buffer_collection(self: InstanceExtensions) bool {
        return self.supports_fuchsia_external_memory() and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_sampler_ycbcr_conversion());
    }
    pub fn enable_fuchsia_buffer_collection(self: *InstanceExtensions) void {
        self.enable_fuchsia_external_memory();
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_sampler_ycbcr_conversion();
        }
    }

    pub fn supports_huawei_subpass_shading(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_create_renderpass2()) and self.supports_khr_synchronization2());
    }
    pub fn enable_huawei_subpass_shading(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
                self.enable_khr_create_renderpass2();
            }
            self.enable_khr_synchronization2();
        }
    }

    pub fn supports_huawei_invocation_mask(self: InstanceExtensions) bool {
        return self.supports_khr_ray_tracing_pipeline() and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_synchronization2());
    }
    pub fn enable_huawei_invocation_mask(self: *InstanceExtensions) void {
        self.enable_khr_ray_tracing_pipeline();
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_synchronization2();
        }
    }

    pub fn supports_nv_external_memory_rdma(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory();
    }
    pub fn enable_nv_external_memory_rdma(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_ext_pipeline_properties(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_pipeline_properties(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_multisampled_render_to_single_sampled(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.supports_khr_create_renderpass2() and self.supports_khr_depth_stencil_resolve());
    }
    pub fn enable_ext_multisampled_render_to_single_sampled(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_create_renderpass2();
            self.enable_khr_depth_stencil_resolve();
        }
    }

    pub fn supports_ext_extended_dynamic_state2(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_extended_dynamic_state2(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_color_write_enable(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_color_write_enable(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_primitives_generated_query(self: InstanceExtensions) bool {
        return self.supports_ext_transform_feedback();
    }
    pub fn enable_ext_primitives_generated_query(self: *InstanceExtensions) void {
        self.enable_ext_transform_feedback();
    }

    pub fn supports_khr_ray_tracing_maintenance1(self: InstanceExtensions) bool {
        return self.supports_khr_acceleration_structure();
    }
    pub fn enable_khr_ray_tracing_maintenance1(self: *InstanceExtensions) void {
        self.enable_khr_acceleration_structure();
    }

    pub fn supports_khr_shader_untyped_pointers(self: InstanceExtensions) bool {
        return self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_shader_untyped_pointers(self: *InstanceExtensions) void {
        self.enable_khr_get_physical_device_properties2();
    }

    pub fn supports_ext_global_priority_query(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_global_priority_query(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_image_view_min_lod(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_image_view_min_lod(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_multi_draw(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_multi_draw(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_image_2d_view_of_3d(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_image_2d_view_of_3d(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_portability_enumeration(self: InstanceExtensions) bool {
        return self.khr_portability_enumeration;
    }
    pub fn enable_khr_portability_enumeration(self: *InstanceExtensions) void {
        self.khr_portability_enumeration = true;
    }

    pub fn supports_ext_opacity_micromap(self: InstanceExtensions) bool {
        return self.supports_khr_acceleration_structure() and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_synchronization2());
    }
    pub fn enable_ext_opacity_micromap(self: *InstanceExtensions) void {
        self.enable_khr_acceleration_structure();
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_synchronization2();
        }
    }

    pub fn supports_nv_displacement_micromap(self: InstanceExtensions) bool {
        return self.supports_ext_opacity_micromap();
    }
    pub fn enable_nv_displacement_micromap(self: *InstanceExtensions) void {
        self.enable_ext_opacity_micromap();
    }

    pub fn supports_huawei_cluster_culling_shader(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_huawei_cluster_culling_shader(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_border_color_swizzle(self: InstanceExtensions) bool {
        return self.supports_ext_custom_border_color();
    }
    pub fn enable_ext_border_color_swizzle(self: *InstanceExtensions) void {
        self.enable_ext_custom_border_color();
    }

    pub fn supports_ext_pageable_device_local_memory(self: InstanceExtensions) bool {
        return self.supports_ext_memory_priority();
    }
    pub fn enable_ext_pageable_device_local_memory(self: *InstanceExtensions) void {
        self.enable_ext_memory_priority();
    }

    pub fn supports_arm_scheduling_controls(self: InstanceExtensions) bool {
        return self.supports_arm_shader_core_builtins();
    }
    pub fn enable_arm_scheduling_controls(self: *InstanceExtensions) void {
        self.enable_arm_shader_core_builtins();
    }

    pub fn supports_ext_image_sliced_view_of_3d(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_image_sliced_view_of_3d(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_valve_descriptor_set_host_mapping(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_valve_descriptor_set_host_mapping(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_depth_clamp_zero_one(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_depth_clamp_zero_one(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_non_seamless_cube_map(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_non_seamless_cube_map(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_arm_render_pass_striped(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_synchronization2());
    }
    pub fn enable_arm_render_pass_striped(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_physical_device_properties2();
            }
            self.enable_khr_synchronization2();
        }
    }

    pub fn supports_qcom_fragment_density_map_offset(self: InstanceExtensions) bool {
        return (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_ext_fragment_density_map();
    }
    pub fn enable_qcom_fragment_density_map_offset(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
        self.enable_ext_fragment_density_map();
    }

    pub fn supports_nv_copy_memory_indirect(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_buffer_device_address());
    }
    pub fn enable_nv_copy_memory_indirect(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_physical_device_properties2();
            }
            self.enable_khr_buffer_device_address();
        }
    }

    pub fn supports_nv_memory_decompression(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_buffer_device_address());
    }
    pub fn enable_nv_memory_decompression(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_physical_device_properties2();
            }
            self.enable_khr_buffer_device_address();
        }
    }

    pub fn supports_nv_device_generated_commands_compute(self: InstanceExtensions) bool {
        return self.supports_nv_device_generated_commands();
    }
    pub fn enable_nv_device_generated_commands_compute(self: *InstanceExtensions) void {
        self.enable_nv_device_generated_commands();
    }

    pub fn supports_nv_ray_tracing_linear_swept_spheres(self: InstanceExtensions) bool {
        return self.supports_khr_ray_tracing_pipeline();
    }
    pub fn enable_nv_ray_tracing_linear_swept_spheres(self: *InstanceExtensions) void {
        self.enable_khr_ray_tracing_pipeline();
    }

    pub fn supports_nv_linear_color_attachment(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_nv_linear_color_attachment(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_google_surfaceless_query(self: InstanceExtensions) bool {
        return self.google_surfaceless_query and self.supports_khr_surface();
    }
    pub fn enable_google_surfaceless_query(self: *InstanceExtensions) void {
        self.google_surfaceless_query = true;
        self.enable_khr_surface();
    }

    pub fn supports_ext_image_compression_control_swapchain(self: InstanceExtensions) bool {
        return self.supports_ext_image_compression_control();
    }
    pub fn enable_ext_image_compression_control_swapchain(self: *InstanceExtensions) void {
        self.enable_ext_image_compression_control();
    }

    pub fn supports_qcom_image_processing(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_format_feature_flags2();
    }
    pub fn enable_qcom_image_processing(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_format_feature_flags2();
        }
    }

    pub fn supports_ext_nested_command_buffer(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_nested_command_buffer(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_external_memory_acquire_unmodified(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory();
    }
    pub fn enable_ext_external_memory_acquire_unmodified(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_ext_extended_dynamic_state3(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_extended_dynamic_state3(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_subpass_merge_feedback(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_subpass_merge_feedback(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_lunarg_direct_driver_loading(self: InstanceExtensions) bool {
        return self.lunarg_direct_driver_loading;
    }
    pub fn enable_lunarg_direct_driver_loading(self: *InstanceExtensions) void {
        self.lunarg_direct_driver_loading = true;
    }

    pub fn supports_ext_shader_module_identifier(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_ext_pipeline_creation_cache_control());
    }
    pub fn enable_ext_shader_module_identifier(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_physical_device_properties2();
            }
            self.enable_ext_pipeline_creation_cache_control();
        }
    }

    pub fn supports_ext_rasterization_order_attachment_access(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_rasterization_order_attachment_access(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_optical_flow(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_format_feature_flags2() and self.supports_khr_synchronization2());
    }
    pub fn enable_nv_optical_flow(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_physical_device_properties2();
            }
            self.enable_khr_format_feature_flags2();
            self.enable_khr_synchronization2();
        }
    }

    pub fn supports_ext_legacy_dithering(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_legacy_dithering(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_pipeline_protected_access(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_pipeline_protected_access(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_android_external_format_resolve(self: InstanceExtensions) bool {
        return self.supports_android_external_memory_android_hardware_buffer();
    }
    pub fn enable_android_external_format_resolve(self: *InstanceExtensions) void {
        self.enable_android_external_memory_android_hardware_buffer();
    }

    pub fn supports_khr_maintenance5(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or (self.core_version.to_int() >= make_version(1, 1, 0).to_int() and self.supports_khr_dynamic_rendering());
    }
    pub fn enable_khr_maintenance5(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
            self.enable_khr_dynamic_rendering();
        }
    }

    pub fn supports_amdx_dense_geometry_format(self: InstanceExtensions) bool {
        return self.supports_khr_acceleration_structure() and (self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.supports_khr_maintenance5());
    }
    pub fn enable_amdx_dense_geometry_format(self: *InstanceExtensions) void {
        self.enable_khr_acceleration_structure();
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.enable_khr_maintenance5();
        }
    }

    pub fn supports_khr_present_id2(self: InstanceExtensions) bool {
        return self.supports_khr_get_surface_capabilities2() and self.supports_khr_surface() and self.supports_khr_swapchain();
    }
    pub fn enable_khr_present_id2(self: *InstanceExtensions) void {
        self.enable_khr_get_surface_capabilities2();
        self.enable_khr_surface();
        self.enable_khr_swapchain();
    }

    pub fn supports_khr_present_wait2(self: InstanceExtensions) bool {
        return self.supports_khr_get_surface_capabilities2() and self.supports_khr_surface() and self.supports_khr_swapchain() and self.supports_khr_present_id2();
    }
    pub fn enable_khr_present_wait2(self: *InstanceExtensions) void {
        self.enable_khr_get_surface_capabilities2();
        self.enable_khr_surface();
        self.enable_khr_swapchain();
        self.enable_khr_present_id2();
    }

    pub fn supports_khr_ray_tracing_position_fetch(self: InstanceExtensions) bool {
        return self.supports_khr_acceleration_structure();
    }
    pub fn enable_khr_ray_tracing_position_fetch(self: *InstanceExtensions) void {
        self.enable_khr_acceleration_structure();
    }

    pub fn supports_ext_shader_object(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_dynamic_rendering());
    }
    pub fn enable_ext_shader_object(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_physical_device_properties2();
            }
            self.enable_khr_dynamic_rendering();
        }
    }

    pub fn supports_khr_pipeline_binary(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.supports_khr_maintenance5();
    }
    pub fn enable_khr_pipeline_binary(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.enable_khr_maintenance5();
        }
    }

    pub fn supports_qcom_tile_properties(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_qcom_tile_properties(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_sec_amigo_profiling(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_sec_amigo_profiling(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_surface_maintenance1(self: InstanceExtensions) bool {
        return self.khr_surface_maintenance1 and (self.supports_khr_surface() or self.supports_khr_get_surface_capabilities2());
    }
    pub fn enable_khr_surface_maintenance1(self: *InstanceExtensions) void {
        self.khr_surface_maintenance1 = true;
        // ambiguous dependency, caller must enable one explicitly
        assert(self.supports_khr_surface() or self.supports_khr_get_surface_capabilities2());
    }

    pub fn supports_khr_swapchain_maintenance1(self: InstanceExtensions) bool {
        return self.supports_khr_swapchain() or self.supports_khr_surface_maintenance1() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_swapchain_maintenance1(self: *InstanceExtensions) void {
        // ambiguous dependency, caller must enable one explicitly
        assert(self.supports_khr_swapchain() or self.supports_khr_surface_maintenance1() or self.supports_khr_get_physical_device_properties2());
    }

    pub fn supports_qcom_multiview_per_view_viewports(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_qcom_multiview_per_view_viewports(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_ray_tracing_invocation_reorder(self: InstanceExtensions) bool {
        return self.supports_khr_ray_tracing_pipeline();
    }
    pub fn enable_nv_ray_tracing_invocation_reorder(self: *InstanceExtensions) void {
        self.enable_khr_ray_tracing_pipeline();
    }

    pub fn supports_ext_mutable_descriptor_type(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_maintenance3();
    }
    pub fn enable_ext_mutable_descriptor_type(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_maintenance3();
        }
    }

    pub fn supports_ext_legacy_vertex_attributes(self: InstanceExtensions) bool {
        return self.supports_ext_vertex_input_dynamic_state();
    }
    pub fn enable_ext_legacy_vertex_attributes(self: *InstanceExtensions) void {
        self.enable_ext_vertex_input_dynamic_state();
    }

    pub fn supports_ext_layer_settings(self: InstanceExtensions) bool {
        return self.ext_layer_settings;
    }
    pub fn enable_ext_layer_settings(self: *InstanceExtensions) void {
        self.ext_layer_settings = true;
    }

    pub fn supports_arm_shader_core_builtins(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_arm_shader_core_builtins(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_pipeline_library_group_handles(self: InstanceExtensions) bool {
        return self.supports_khr_ray_tracing_pipeline();
    }
    pub fn enable_ext_pipeline_library_group_handles(self: *InstanceExtensions) void {
        self.enable_khr_ray_tracing_pipeline();
    }

    pub fn supports_ext_dynamic_rendering_unused_attachments(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_dynamic_rendering());
    }
    pub fn enable_ext_dynamic_rendering_unused_attachments(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_physical_device_properties2();
            }
            self.enable_khr_dynamic_rendering();
        }
    }

    pub fn supports_nv_low_latency2(self: InstanceExtensions) bool {
        return (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_timeline_semaphore()) and (self.supports_khr_present_id() or self.supports_khr_present_id2());
    }
    pub fn enable_nv_low_latency2(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_timeline_semaphore();
        }
        // ambiguous dependency, caller must enable one explicitly
        assert(self.supports_khr_present_id() or self.supports_khr_present_id2());
    }

    pub fn supports_khr_cooperative_matrix(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_cooperative_matrix(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_arm_data_graph(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() and self.supports_khr_maintenance5();
    }
    pub fn enable_arm_data_graph(self: *InstanceExtensions) void {
        // depends on minimum core version, caller must specify
        assert(self.core_version.to_int() >= make_version(1, 3, 0).to_int());
        self.enable_khr_maintenance5();
    }

    pub fn supports_khr_compute_shader_derivatives(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_compute_shader_derivatives(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_qcom_image_processing2(self: InstanceExtensions) bool {
        return self.supports_qcom_image_processing();
    }
    pub fn enable_qcom_image_processing2(self: *InstanceExtensions) void {
        self.enable_qcom_image_processing();
    }

    pub fn supports_qcom_filter_cubic_clamp(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_ext_sampler_filter_minmax();
    }
    pub fn enable_qcom_filter_cubic_clamp(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_ext_sampler_filter_minmax();
        }
    }

    pub fn supports_ext_attachment_feedback_loop_dynamic_state(self: InstanceExtensions) bool {
        return (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_ext_attachment_feedback_loop_layout();
    }
    pub fn enable_ext_attachment_feedback_loop_dynamic_state(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
        self.enable_ext_attachment_feedback_loop_layout();
    }

    pub fn supports_khr_vertex_attribute_divisor(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_vertex_attribute_divisor(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_shader_float_controls2(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or (self.core_version.to_int() >= make_version(1, 1, 0).to_int() and self.supports_khr_shader_float_controls());
    }
    pub fn enable_khr_shader_float_controls2(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
            self.enable_khr_shader_float_controls();
        }
    }

    pub fn supports_msft_layered_driver(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_msft_layered_driver(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_index_type_uint8(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_index_type_uint8(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_line_rasterization(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_line_rasterization(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_calibrated_timestamps(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_calibrated_timestamps(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_shader_expect_assume(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_shader_expect_assume(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_qcom_tile_memory_heap(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_qcom_tile_memory_heap(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_nv_display_stereo(self: InstanceExtensions) bool {
        return self.nv_display_stereo and self.supports_khr_display() and self.supports_khr_get_display_properties2();
    }
    pub fn enable_nv_display_stereo(self: *InstanceExtensions) void {
        self.nv_display_stereo = true;
        self.enable_khr_display();
        self.enable_khr_get_display_properties2();
    }

    pub fn supports_nv_cluster_acceleration_structure(self: InstanceExtensions) bool {
        return self.supports_khr_acceleration_structure();
    }
    pub fn enable_nv_cluster_acceleration_structure(self: *InstanceExtensions) void {
        self.enable_khr_acceleration_structure();
    }

    pub fn supports_nv_partitioned_acceleration_structure(self: InstanceExtensions) bool {
        return self.supports_khr_acceleration_structure();
    }
    pub fn enable_nv_partitioned_acceleration_structure(self: *InstanceExtensions) void {
        self.enable_khr_acceleration_structure();
    }

    pub fn supports_ext_device_generated_commands(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_buffer_device_address()) and self.supports_khr_maintenance5());
    }
    pub fn enable_ext_device_generated_commands(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
                self.enable_khr_buffer_device_address();
            }
            self.enable_khr_maintenance5();
        }
    }

    pub fn supports_mesa_image_alignment_control(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_mesa_image_alignment_control(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_depth_clamp_control(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_depth_clamp_control(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_maintenance9(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_maintenance9(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ohos_surface(self: InstanceExtensions) bool {
        return self.ohos_surface and self.supports_khr_surface();
    }
    pub fn enable_ohos_surface(self: *InstanceExtensions) void {
        self.ohos_surface = true;
        self.enable_khr_surface();
    }

    pub fn supports_huawei_hdr_vivid(self: InstanceExtensions) bool {
        return (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_khr_swapchain() and self.supports_ext_hdr_metadata();
    }
    pub fn enable_huawei_hdr_vivid(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
        self.enable_khr_swapchain();
        self.enable_ext_hdr_metadata();
    }

    pub fn supports_nv_cooperative_matrix2(self: InstanceExtensions) bool {
        return self.supports_khr_cooperative_matrix();
    }
    pub fn enable_nv_cooperative_matrix2(self: *InstanceExtensions) void {
        self.enable_khr_cooperative_matrix();
    }

    pub fn supports_arm_pipeline_opacity_micromap(self: InstanceExtensions) bool {
        return self.supports_ext_opacity_micromap();
    }
    pub fn enable_arm_pipeline_opacity_micromap(self: *InstanceExtensions) void {
        self.enable_ext_opacity_micromap();
    }

    pub fn supports_ext_external_memory_metal(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory();
    }
    pub fn enable_ext_external_memory_metal(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_khr_depth_clamp_zero_one(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_depth_clamp_zero_one(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_vertex_attribute_robustness(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_vertex_attribute_robustness(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_valve_fragment_density_map_layered(self: InstanceExtensions) bool {
        return (self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.supports_khr_maintenance5()) and self.supports_ext_fragment_density_map();
    }
    pub fn enable_valve_fragment_density_map_layered(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.enable_khr_maintenance5();
        }
        self.enable_ext_fragment_density_map();
    }

    pub fn supports_khr_robustness2(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_khr_robustness2(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_ext_fragment_density_map_offset(self: InstanceExtensions) bool {
        return (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2()) and self.supports_ext_fragment_density_map() and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_create_renderpass2()) and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_dynamic_rendering());
    }
    pub fn enable_ext_fragment_density_map_offset(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
        self.enable_ext_fragment_density_map();
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_create_renderpass2();
        }
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_dynamic_rendering();
        }
    }

    pub fn supports_ext_zero_initialize_device_memory(self: InstanceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_physical_device_properties2();
    }
    pub fn enable_ext_zero_initialize_device_memory(self: *InstanceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_physical_device_properties2();
        }
    }

    pub fn supports_khr_present_mode_fifo_latest_ready(self: InstanceExtensions) bool {
        return self.supports_khr_swapchain();
    }
    pub fn enable_khr_present_mode_fifo_latest_ready(self: *InstanceExtensions) void {
        self.enable_khr_swapchain();
    }
};

pub const DeviceExtensions = packed struct {
    core_version: Version,
    khr_swapchain: bool = false,
    khr_display_swapchain: bool = false,
    nv_glsl_shader: bool = false,
    ext_depth_range_unrestricted: bool = false,
    khr_sampler_mirror_clamp_to_edge: bool = false,
    img_filter_cubic: bool = false,
    amd_rasterization_order: bool = false,
    amd_shader_trinary_minmax: bool = false,
    amd_shader_explicit_vertex_parameter: bool = false,
    ext_debug_marker: bool = false,
    amd_gcn_shader: bool = false,
    nv_dedicated_allocation: bool = false,
    ext_transform_feedback: bool = false,
    nvx_binary_import: bool = false,
    nvx_image_view_handle: bool = false,
    amd_draw_indirect_count: bool = false,
    amd_negative_viewport_height: bool = false,
    amd_gpu_shader_half_float: bool = false,
    amd_shader_ballot: bool = false,
    amd_texture_gather_bias_lod: bool = false,
    amd_shader_info: bool = false,
    khr_dynamic_rendering: bool = false,
    amd_shader_image_load_store_lod: bool = false,
    nv_corner_sampled_image: bool = false,
    khr_multiview: bool = false,
    img_format_pvrtc: bool = false,
    nv_external_memory: bool = false,
    nv_external_memory_win32: bool = false,
    nv_win32_keyed_mutex: bool = false,
    khr_device_group: bool = false,
    khr_shader_draw_parameters: bool = false,
    ext_shader_subgroup_ballot: bool = false,
    ext_shader_subgroup_vote: bool = false,
    ext_texture_compression_astc_hdr: bool = false,
    ext_astc_decode_mode: bool = false,
    ext_pipeline_robustness: bool = false,
    khr_maintenance1: bool = false,
    khr_external_memory: bool = false,
    khr_external_memory_win32: bool = false,
    khr_external_memory_fd: bool = false,
    khr_win32_keyed_mutex: bool = false,
    khr_external_semaphore: bool = false,
    khr_external_semaphore_win32: bool = false,
    khr_external_semaphore_fd: bool = false,
    khr_push_descriptor: bool = false,
    ext_conditional_rendering: bool = false,
    khr_shader_float16_int8: bool = false,
    khr_16bit_storage: bool = false,
    khr_incremental_present: bool = false,
    khr_descriptor_update_template: bool = false,
    nv_clip_space_w_scaling: bool = false,
    ext_display_control: bool = false,
    google_display_timing: bool = false,
    nv_sample_mask_override_coverage: bool = false,
    nv_geometry_shader_passthrough: bool = false,
    nv_viewport_array2: bool = false,
    nvx_multiview_per_view_attributes: bool = false,
    nv_viewport_swizzle: bool = false,
    ext_discard_rectangles: bool = false,
    ext_conservative_rasterization: bool = false,
    ext_depth_clip_enable: bool = false,
    ext_hdr_metadata: bool = false,
    khr_imageless_framebuffer: bool = false,
    khr_create_renderpass2: bool = false,
    img_relaxed_line_rasterization: bool = false,
    khr_shared_presentable_image: bool = false,
    khr_external_fence: bool = false,
    khr_external_fence_win32: bool = false,
    khr_external_fence_fd: bool = false,
    khr_performance_query: bool = false,
    khr_maintenance2: bool = false,
    khr_variable_pointers: bool = false,
    ext_external_memory_dma_buf: bool = false,
    ext_queue_family_foreign: bool = false,
    khr_dedicated_allocation: bool = false,
    android_external_memory_android_hardware_buffer: bool = false,
    ext_sampler_filter_minmax: bool = false,
    khr_storage_buffer_storage_class: bool = false,
    amd_gpu_shader_int16: bool = false,
    amdx_shader_enqueue: bool = false,
    amd_mixed_attachment_samples: bool = false,
    amd_shader_fragment_mask: bool = false,
    ext_inline_uniform_block: bool = false,
    ext_shader_stencil_export: bool = false,
    khr_shader_bfloat16: bool = false,
    ext_sample_locations: bool = false,
    khr_relaxed_block_layout: bool = false,
    khr_get_memory_requirements2: bool = false,
    khr_image_format_list: bool = false,
    ext_blend_operation_advanced: bool = false,
    nv_fragment_coverage_to_color: bool = false,
    khr_acceleration_structure: bool = false,
    khr_ray_tracing_pipeline: bool = false,
    khr_ray_query: bool = false,
    nv_framebuffer_mixed_samples: bool = false,
    nv_fill_rectangle: bool = false,
    nv_shader_sm_builtins: bool = false,
    ext_post_depth_coverage: bool = false,
    khr_sampler_ycbcr_conversion: bool = false,
    khr_bind_memory2: bool = false,
    ext_image_drm_format_modifier: bool = false,
    ext_validation_cache: bool = false,
    ext_descriptor_indexing: bool = false,
    ext_shader_viewport_index_layer: bool = false,
    khr_portability_subset: bool = false,
    nv_shading_rate_image: bool = false,
    nv_ray_tracing: bool = false,
    nv_representative_fragment_test: bool = false,
    khr_maintenance3: bool = false,
    khr_draw_indirect_count: bool = false,
    ext_filter_cubic: bool = false,
    qcom_render_pass_shader_resolve: bool = false,
    ext_global_priority: bool = false,
    khr_shader_subgroup_extended_types: bool = false,
    khr_8bit_storage: bool = false,
    ext_external_memory_host: bool = false,
    amd_buffer_marker: bool = false,
    khr_shader_atomic_int64: bool = false,
    khr_shader_clock: bool = false,
    amd_pipeline_compiler_control: bool = false,
    ext_calibrated_timestamps: bool = false,
    amd_shader_core_properties: bool = false,
    khr_global_priority: bool = false,
    amd_memory_overallocation_behavior: bool = false,
    ext_vertex_attribute_divisor: bool = false,
    ext_pipeline_creation_feedback: bool = false,
    khr_driver_properties: bool = false,
    khr_shader_float_controls: bool = false,
    nv_shader_subgroup_partitioned: bool = false,
    khr_depth_stencil_resolve: bool = false,
    khr_swapchain_mutable_format: bool = false,
    nv_compute_shader_derivatives: bool = false,
    nv_mesh_shader: bool = false,
    nv_fragment_shader_barycentric: bool = false,
    nv_shader_image_footprint: bool = false,
    nv_scissor_exclusive: bool = false,
    nv_device_diagnostic_checkpoints: bool = false,
    khr_timeline_semaphore: bool = false,
    intel_shader_integer_functions2: bool = false,
    intel_performance_query: bool = false,
    khr_vulkan_memory_model: bool = false,
    ext_pci_bus_info: bool = false,
    amd_display_native_hdr: bool = false,
    khr_shader_terminate_invocation: bool = false,
    ext_fragment_density_map: bool = false,
    ext_scalar_block_layout: bool = false,
    google_hlsl_functionality1: bool = false,
    google_decorate_string: bool = false,
    ext_subgroup_size_control: bool = false,
    khr_fragment_shading_rate: bool = false,
    amd_shader_core_properties2: bool = false,
    amd_device_coherent_memory: bool = false,
    khr_dynamic_rendering_local_read: bool = false,
    ext_shader_image_atomic_int64: bool = false,
    khr_shader_quad_control: bool = false,
    khr_spirv_1_4: bool = false,
    ext_memory_budget: bool = false,
    ext_memory_priority: bool = false,
    nv_dedicated_allocation_image_aliasing: bool = false,
    khr_separate_depth_stencil_layouts: bool = false,
    ext_buffer_device_address: bool = false,
    ext_tooling_info: bool = false,
    ext_separate_stencil_usage: bool = false,
    khr_present_wait: bool = false,
    nv_cooperative_matrix: bool = false,
    nv_coverage_reduction_mode: bool = false,
    ext_fragment_shader_interlock: bool = false,
    ext_ycbcr_image_arrays: bool = false,
    khr_uniform_buffer_standard_layout: bool = false,
    ext_provoking_vertex: bool = false,
    ext_full_screen_exclusive: bool = false,
    khr_buffer_device_address: bool = false,
    ext_line_rasterization: bool = false,
    ext_shader_atomic_float: bool = false,
    ext_host_query_reset: bool = false,
    ext_index_type_uint8: bool = false,
    ext_extended_dynamic_state: bool = false,
    khr_deferred_host_operations: bool = false,
    khr_pipeline_executable_properties: bool = false,
    ext_host_image_copy: bool = false,
    khr_map_memory2: bool = false,
    ext_map_memory_placed: bool = false,
    ext_shader_atomic_float2: bool = false,
    ext_swapchain_maintenance1: bool = false,
    ext_shader_demote_to_helper_invocation: bool = false,
    nv_device_generated_commands: bool = false,
    nv_inherited_viewport_scissor: bool = false,
    khr_shader_integer_dot_product: bool = false,
    ext_texel_buffer_alignment: bool = false,
    qcom_render_pass_transform: bool = false,
    ext_depth_bias_control: bool = false,
    ext_device_memory_report: bool = false,
    ext_robustness2: bool = false,
    ext_custom_border_color: bool = false,
    google_user_type: bool = false,
    khr_pipeline_library: bool = false,
    nv_present_barrier: bool = false,
    khr_shader_non_semantic_info: bool = false,
    khr_present_id: bool = false,
    ext_private_data: bool = false,
    ext_pipeline_creation_cache_control: bool = false,
    nv_device_diagnostics_config: bool = false,
    qcom_render_pass_store_ops: bool = false,
    nv_cuda_kernel_launch: bool = false,
    qcom_tile_shading: bool = false,
    nv_low_latency: bool = false,
    ext_metal_objects: bool = false,
    khr_synchronization2: bool = false,
    ext_descriptor_buffer: bool = false,
    ext_graphics_pipeline_library: bool = false,
    amd_shader_early_and_late_fragment_tests: bool = false,
    khr_fragment_shader_barycentric: bool = false,
    khr_shader_subgroup_uniform_control_flow: bool = false,
    khr_zero_initialize_workgroup_memory: bool = false,
    nv_fragment_shading_rate_enums: bool = false,
    nv_ray_tracing_motion_blur: bool = false,
    ext_mesh_shader: bool = false,
    ext_ycbcr_2plane_444_formats: bool = false,
    ext_fragment_density_map2: bool = false,
    qcom_rotated_copy_commands: bool = false,
    ext_image_robustness: bool = false,
    khr_workgroup_memory_explicit_layout: bool = false,
    khr_copy_commands2: bool = false,
    ext_image_compression_control: bool = false,
    ext_attachment_feedback_loop_layout: bool = false,
    ext_4444_formats: bool = false,
    ext_device_fault: bool = false,
    arm_rasterization_order_attachment_access: bool = false,
    ext_rgba10x6_formats: bool = false,
    nv_acquire_winrt_display: bool = false,
    valve_mutable_descriptor_type: bool = false,
    ext_vertex_input_dynamic_state: bool = false,
    ext_physical_device_drm: bool = false,
    ext_device_address_binding_report: bool = false,
    ext_depth_clip_control: bool = false,
    ext_primitive_topology_list_restart: bool = false,
    khr_format_feature_flags2: bool = false,
    ext_present_mode_fifo_latest_ready: bool = false,
    fuchsia_external_memory: bool = false,
    fuchsia_external_semaphore: bool = false,
    fuchsia_buffer_collection: bool = false,
    huawei_subpass_shading: bool = false,
    huawei_invocation_mask: bool = false,
    nv_external_memory_rdma: bool = false,
    ext_pipeline_properties: bool = false,
    ext_frame_boundary: bool = false,
    ext_multisampled_render_to_single_sampled: bool = false,
    ext_extended_dynamic_state2: bool = false,
    ext_color_write_enable: bool = false,
    ext_primitives_generated_query: bool = false,
    khr_ray_tracing_maintenance1: bool = false,
    khr_shader_untyped_pointers: bool = false,
    ext_global_priority_query: bool = false,
    ext_image_view_min_lod: bool = false,
    ext_multi_draw: bool = false,
    ext_image_2d_view_of_3d: bool = false,
    ext_shader_tile_image: bool = false,
    ext_opacity_micromap: bool = false,
    nv_displacement_micromap: bool = false,
    ext_load_store_op_none: bool = false,
    huawei_cluster_culling_shader: bool = false,
    ext_border_color_swizzle: bool = false,
    ext_pageable_device_local_memory: bool = false,
    khr_maintenance4: bool = false,
    arm_shader_core_properties: bool = false,
    khr_shader_subgroup_rotate: bool = false,
    arm_scheduling_controls: bool = false,
    ext_image_sliced_view_of_3d: bool = false,
    valve_descriptor_set_host_mapping: bool = false,
    ext_depth_clamp_zero_one: bool = false,
    ext_non_seamless_cube_map: bool = false,
    arm_render_pass_striped: bool = false,
    qcom_fragment_density_map_offset: bool = false,
    nv_copy_memory_indirect: bool = false,
    nv_memory_decompression: bool = false,
    nv_device_generated_commands_compute: bool = false,
    nv_ray_tracing_linear_swept_spheres: bool = false,
    nv_linear_color_attachment: bool = false,
    khr_shader_maximal_reconvergence: bool = false,
    ext_image_compression_control_swapchain: bool = false,
    qcom_image_processing: bool = false,
    ext_nested_command_buffer: bool = false,
    ext_external_memory_acquire_unmodified: bool = false,
    ext_extended_dynamic_state3: bool = false,
    ext_subpass_merge_feedback: bool = false,
    arm_tensors: bool = false,
    ext_shader_module_identifier: bool = false,
    ext_rasterization_order_attachment_access: bool = false,
    nv_optical_flow: bool = false,
    ext_legacy_dithering: bool = false,
    ext_pipeline_protected_access: bool = false,
    android_external_format_resolve: bool = false,
    khr_maintenance5: bool = false,
    amd_anti_lag: bool = false,
    amdx_dense_geometry_format: bool = false,
    khr_present_id2: bool = false,
    khr_present_wait2: bool = false,
    khr_ray_tracing_position_fetch: bool = false,
    ext_shader_object: bool = false,
    khr_pipeline_binary: bool = false,
    qcom_tile_properties: bool = false,
    sec_amigo_profiling: bool = false,
    khr_swapchain_maintenance1: bool = false,
    qcom_multiview_per_view_viewports: bool = false,
    nv_ray_tracing_invocation_reorder: bool = false,
    nv_cooperative_vector: bool = false,
    nv_extended_sparse_address_space: bool = false,
    ext_mutable_descriptor_type: bool = false,
    ext_legacy_vertex_attributes: bool = false,
    arm_shader_core_builtins: bool = false,
    ext_pipeline_library_group_handles: bool = false,
    ext_dynamic_rendering_unused_attachments: bool = false,
    nv_low_latency2: bool = false,
    khr_cooperative_matrix: bool = false,
    arm_data_graph: bool = false,
    qcom_multiview_per_view_render_areas: bool = false,
    khr_compute_shader_derivatives: bool = false,
    nv_per_stage_descriptor_set: bool = false,
    qcom_image_processing2: bool = false,
    qcom_filter_cubic_weights: bool = false,
    qcom_ycbcr_degamma: bool = false,
    qcom_filter_cubic_clamp: bool = false,
    ext_attachment_feedback_loop_dynamic_state: bool = false,
    khr_vertex_attribute_divisor: bool = false,
    khr_load_store_op_none: bool = false,
    khr_unified_image_layouts: bool = false,
    khr_shader_float_controls2: bool = false,
    msft_layered_driver: bool = false,
    khr_index_type_uint8: bool = false,
    khr_line_rasterization: bool = false,
    khr_calibrated_timestamps: bool = false,
    khr_shader_expect_assume: bool = false,
    khr_maintenance6: bool = false,
    nv_descriptor_pool_overallocation: bool = false,
    qcom_tile_memory_heap: bool = false,
    nv_raw_access_chains: bool = false,
    nv_external_compute_queue: bool = false,
    khr_shader_relaxed_extended_instruction: bool = false,
    nv_command_buffer_inheritance: bool = false,
    khr_maintenance7: bool = false,
    nv_shader_atomic_float16_vector: bool = false,
    ext_shader_replicated_composites: bool = false,
    ext_shader_float8: bool = false,
    nv_ray_tracing_validation: bool = false,
    nv_cluster_acceleration_structure: bool = false,
    nv_partitioned_acceleration_structure: bool = false,
    ext_device_generated_commands: bool = false,
    khr_maintenance8: bool = false,
    mesa_image_alignment_control: bool = false,
    ext_depth_clamp_control: bool = false,
    khr_maintenance9: bool = false,
    huawei_hdr_vivid: bool = false,
    nv_cooperative_matrix2: bool = false,
    arm_pipeline_opacity_micromap: bool = false,
    ext_external_memory_metal: bool = false,
    khr_depth_clamp_zero_one: bool = false,
    ext_vertex_attribute_robustness: bool = false,
    arm_format_pack: bool = false,
    valve_fragment_density_map_layered: bool = false,
    khr_robustness2: bool = false,
    nv_present_metering: bool = false,
    ext_fragment_density_map_offset: bool = false,
    ext_zero_initialize_device_memory: bool = false,
    khr_present_mode_fifo_latest_ready: bool = false,
    sec_pipeline_cache_incremental_mode: bool = false,

    pub fn enable_by_name(self: *DeviceExtensions, maybe_name: ?[*:0]const u8) void {
        const name = maybe_name orelse return;
        if (std.mem.orderZ(u8, name, ExtensionNames.khr_swapchain) == .eq) {
            self.khr_swapchain = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_display_swapchain) == .eq) {
            self.khr_display_swapchain = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_glsl_shader) == .eq) {
            self.nv_glsl_shader = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_depth_range_unrestricted) == .eq) {
            self.ext_depth_range_unrestricted = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_sampler_mirror_clamp_to_edge) == .eq) {
            self.khr_sampler_mirror_clamp_to_edge = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.img_filter_cubic) == .eq) {
            self.img_filter_cubic = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_rasterization_order) == .eq) {
            self.amd_rasterization_order = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_shader_trinary_minmax) == .eq) {
            self.amd_shader_trinary_minmax = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_shader_explicit_vertex_parameter) == .eq) {
            self.amd_shader_explicit_vertex_parameter = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_debug_marker) == .eq) {
            self.ext_debug_marker = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_gcn_shader) == .eq) {
            self.amd_gcn_shader = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_dedicated_allocation) == .eq) {
            self.nv_dedicated_allocation = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_transform_feedback) == .eq) {
            self.ext_transform_feedback = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nvx_binary_import) == .eq) {
            self.nvx_binary_import = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nvx_image_view_handle) == .eq) {
            self.nvx_image_view_handle = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_draw_indirect_count) == .eq) {
            self.amd_draw_indirect_count = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_negative_viewport_height) == .eq) {
            self.amd_negative_viewport_height = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_gpu_shader_half_float) == .eq) {
            self.amd_gpu_shader_half_float = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_shader_ballot) == .eq) {
            self.amd_shader_ballot = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_texture_gather_bias_lod) == .eq) {
            self.amd_texture_gather_bias_lod = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_shader_info) == .eq) {
            self.amd_shader_info = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_dynamic_rendering) == .eq) {
            self.khr_dynamic_rendering = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_shader_image_load_store_lod) == .eq) {
            self.amd_shader_image_load_store_lod = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_corner_sampled_image) == .eq) {
            self.nv_corner_sampled_image = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_multiview) == .eq) {
            self.khr_multiview = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.img_format_pvrtc) == .eq) {
            self.img_format_pvrtc = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_external_memory) == .eq) {
            self.nv_external_memory = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_external_memory_win32) == .eq) {
            self.nv_external_memory_win32 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_win32_keyed_mutex) == .eq) {
            self.nv_win32_keyed_mutex = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_device_group) == .eq) {
            self.khr_device_group = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_draw_parameters) == .eq) {
            self.khr_shader_draw_parameters = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_shader_subgroup_ballot) == .eq) {
            self.ext_shader_subgroup_ballot = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_shader_subgroup_vote) == .eq) {
            self.ext_shader_subgroup_vote = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_texture_compression_astc_hdr) == .eq) {
            self.ext_texture_compression_astc_hdr = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_astc_decode_mode) == .eq) {
            self.ext_astc_decode_mode = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_pipeline_robustness) == .eq) {
            self.ext_pipeline_robustness = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_maintenance1) == .eq) {
            self.khr_maintenance1 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_external_memory) == .eq) {
            self.khr_external_memory = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_external_memory_win32) == .eq) {
            self.khr_external_memory_win32 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_external_memory_fd) == .eq) {
            self.khr_external_memory_fd = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_win32_keyed_mutex) == .eq) {
            self.khr_win32_keyed_mutex = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_external_semaphore) == .eq) {
            self.khr_external_semaphore = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_external_semaphore_win32) == .eq) {
            self.khr_external_semaphore_win32 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_external_semaphore_fd) == .eq) {
            self.khr_external_semaphore_fd = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_push_descriptor) == .eq) {
            self.khr_push_descriptor = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_conditional_rendering) == .eq) {
            self.ext_conditional_rendering = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_float16_int8) == .eq) {
            self.khr_shader_float16_int8 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_16bit_storage) == .eq) {
            self.khr_16bit_storage = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_incremental_present) == .eq) {
            self.khr_incremental_present = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_descriptor_update_template) == .eq) {
            self.khr_descriptor_update_template = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_clip_space_w_scaling) == .eq) {
            self.nv_clip_space_w_scaling = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_display_control) == .eq) {
            self.ext_display_control = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.google_display_timing) == .eq) {
            self.google_display_timing = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_sample_mask_override_coverage) == .eq) {
            self.nv_sample_mask_override_coverage = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_geometry_shader_passthrough) == .eq) {
            self.nv_geometry_shader_passthrough = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_viewport_array2) == .eq) {
            self.nv_viewport_array2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nvx_multiview_per_view_attributes) == .eq) {
            self.nvx_multiview_per_view_attributes = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_viewport_swizzle) == .eq) {
            self.nv_viewport_swizzle = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_discard_rectangles) == .eq) {
            self.ext_discard_rectangles = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_conservative_rasterization) == .eq) {
            self.ext_conservative_rasterization = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_depth_clip_enable) == .eq) {
            self.ext_depth_clip_enable = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_hdr_metadata) == .eq) {
            self.ext_hdr_metadata = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_imageless_framebuffer) == .eq) {
            self.khr_imageless_framebuffer = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_create_renderpass2) == .eq) {
            self.khr_create_renderpass2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.img_relaxed_line_rasterization) == .eq) {
            self.img_relaxed_line_rasterization = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shared_presentable_image) == .eq) {
            self.khr_shared_presentable_image = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_external_fence) == .eq) {
            self.khr_external_fence = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_external_fence_win32) == .eq) {
            self.khr_external_fence_win32 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_external_fence_fd) == .eq) {
            self.khr_external_fence_fd = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_performance_query) == .eq) {
            self.khr_performance_query = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_maintenance2) == .eq) {
            self.khr_maintenance2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_variable_pointers) == .eq) {
            self.khr_variable_pointers = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_external_memory_dma_buf) == .eq) {
            self.ext_external_memory_dma_buf = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_queue_family_foreign) == .eq) {
            self.ext_queue_family_foreign = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_dedicated_allocation) == .eq) {
            self.khr_dedicated_allocation = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.android_external_memory_android_hardware_buffer) == .eq) {
            self.android_external_memory_android_hardware_buffer = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_sampler_filter_minmax) == .eq) {
            self.ext_sampler_filter_minmax = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_storage_buffer_storage_class) == .eq) {
            self.khr_storage_buffer_storage_class = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_gpu_shader_int16) == .eq) {
            self.amd_gpu_shader_int16 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amdx_shader_enqueue) == .eq) {
            self.amdx_shader_enqueue = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_mixed_attachment_samples) == .eq) {
            self.amd_mixed_attachment_samples = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_shader_fragment_mask) == .eq) {
            self.amd_shader_fragment_mask = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_inline_uniform_block) == .eq) {
            self.ext_inline_uniform_block = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_shader_stencil_export) == .eq) {
            self.ext_shader_stencil_export = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_bfloat16) == .eq) {
            self.khr_shader_bfloat16 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_sample_locations) == .eq) {
            self.ext_sample_locations = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_relaxed_block_layout) == .eq) {
            self.khr_relaxed_block_layout = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_get_memory_requirements2) == .eq) {
            self.khr_get_memory_requirements2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_image_format_list) == .eq) {
            self.khr_image_format_list = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_blend_operation_advanced) == .eq) {
            self.ext_blend_operation_advanced = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_fragment_coverage_to_color) == .eq) {
            self.nv_fragment_coverage_to_color = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_acceleration_structure) == .eq) {
            self.khr_acceleration_structure = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_ray_tracing_pipeline) == .eq) {
            self.khr_ray_tracing_pipeline = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_ray_query) == .eq) {
            self.khr_ray_query = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_framebuffer_mixed_samples) == .eq) {
            self.nv_framebuffer_mixed_samples = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_fill_rectangle) == .eq) {
            self.nv_fill_rectangle = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_shader_sm_builtins) == .eq) {
            self.nv_shader_sm_builtins = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_post_depth_coverage) == .eq) {
            self.ext_post_depth_coverage = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_sampler_ycbcr_conversion) == .eq) {
            self.khr_sampler_ycbcr_conversion = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_bind_memory2) == .eq) {
            self.khr_bind_memory2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_image_drm_format_modifier) == .eq) {
            self.ext_image_drm_format_modifier = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_validation_cache) == .eq) {
            self.ext_validation_cache = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_descriptor_indexing) == .eq) {
            self.ext_descriptor_indexing = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_shader_viewport_index_layer) == .eq) {
            self.ext_shader_viewport_index_layer = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_portability_subset) == .eq) {
            self.khr_portability_subset = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_shading_rate_image) == .eq) {
            self.nv_shading_rate_image = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_ray_tracing) == .eq) {
            self.nv_ray_tracing = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_representative_fragment_test) == .eq) {
            self.nv_representative_fragment_test = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_maintenance3) == .eq) {
            self.khr_maintenance3 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_draw_indirect_count) == .eq) {
            self.khr_draw_indirect_count = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_filter_cubic) == .eq) {
            self.ext_filter_cubic = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_render_pass_shader_resolve) == .eq) {
            self.qcom_render_pass_shader_resolve = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_global_priority) == .eq) {
            self.ext_global_priority = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_subgroup_extended_types) == .eq) {
            self.khr_shader_subgroup_extended_types = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_8bit_storage) == .eq) {
            self.khr_8bit_storage = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_external_memory_host) == .eq) {
            self.ext_external_memory_host = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_buffer_marker) == .eq) {
            self.amd_buffer_marker = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_atomic_int64) == .eq) {
            self.khr_shader_atomic_int64 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_clock) == .eq) {
            self.khr_shader_clock = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_pipeline_compiler_control) == .eq) {
            self.amd_pipeline_compiler_control = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_calibrated_timestamps) == .eq) {
            self.ext_calibrated_timestamps = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_shader_core_properties) == .eq) {
            self.amd_shader_core_properties = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_global_priority) == .eq) {
            self.khr_global_priority = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_memory_overallocation_behavior) == .eq) {
            self.amd_memory_overallocation_behavior = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_vertex_attribute_divisor) == .eq) {
            self.ext_vertex_attribute_divisor = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_pipeline_creation_feedback) == .eq) {
            self.ext_pipeline_creation_feedback = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_driver_properties) == .eq) {
            self.khr_driver_properties = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_float_controls) == .eq) {
            self.khr_shader_float_controls = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_shader_subgroup_partitioned) == .eq) {
            self.nv_shader_subgroup_partitioned = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_depth_stencil_resolve) == .eq) {
            self.khr_depth_stencil_resolve = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_swapchain_mutable_format) == .eq) {
            self.khr_swapchain_mutable_format = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_compute_shader_derivatives) == .eq) {
            self.nv_compute_shader_derivatives = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_mesh_shader) == .eq) {
            self.nv_mesh_shader = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_fragment_shader_barycentric) == .eq) {
            self.nv_fragment_shader_barycentric = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_shader_image_footprint) == .eq) {
            self.nv_shader_image_footprint = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_scissor_exclusive) == .eq) {
            self.nv_scissor_exclusive = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_device_diagnostic_checkpoints) == .eq) {
            self.nv_device_diagnostic_checkpoints = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_timeline_semaphore) == .eq) {
            self.khr_timeline_semaphore = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.intel_shader_integer_functions2) == .eq) {
            self.intel_shader_integer_functions2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.intel_performance_query) == .eq) {
            self.intel_performance_query = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_vulkan_memory_model) == .eq) {
            self.khr_vulkan_memory_model = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_pci_bus_info) == .eq) {
            self.ext_pci_bus_info = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_display_native_hdr) == .eq) {
            self.amd_display_native_hdr = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_terminate_invocation) == .eq) {
            self.khr_shader_terminate_invocation = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_fragment_density_map) == .eq) {
            self.ext_fragment_density_map = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_scalar_block_layout) == .eq) {
            self.ext_scalar_block_layout = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.google_hlsl_functionality1) == .eq) {
            self.google_hlsl_functionality1 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.google_decorate_string) == .eq) {
            self.google_decorate_string = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_subgroup_size_control) == .eq) {
            self.ext_subgroup_size_control = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_fragment_shading_rate) == .eq) {
            self.khr_fragment_shading_rate = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_shader_core_properties2) == .eq) {
            self.amd_shader_core_properties2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_device_coherent_memory) == .eq) {
            self.amd_device_coherent_memory = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_dynamic_rendering_local_read) == .eq) {
            self.khr_dynamic_rendering_local_read = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_shader_image_atomic_int64) == .eq) {
            self.ext_shader_image_atomic_int64 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_quad_control) == .eq) {
            self.khr_shader_quad_control = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_spirv_1_4) == .eq) {
            self.khr_spirv_1_4 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_memory_budget) == .eq) {
            self.ext_memory_budget = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_memory_priority) == .eq) {
            self.ext_memory_priority = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_dedicated_allocation_image_aliasing) == .eq) {
            self.nv_dedicated_allocation_image_aliasing = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_separate_depth_stencil_layouts) == .eq) {
            self.khr_separate_depth_stencil_layouts = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_buffer_device_address) == .eq) {
            self.ext_buffer_device_address = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_tooling_info) == .eq) {
            self.ext_tooling_info = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_separate_stencil_usage) == .eq) {
            self.ext_separate_stencil_usage = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_present_wait) == .eq) {
            self.khr_present_wait = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_cooperative_matrix) == .eq) {
            self.nv_cooperative_matrix = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_coverage_reduction_mode) == .eq) {
            self.nv_coverage_reduction_mode = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_fragment_shader_interlock) == .eq) {
            self.ext_fragment_shader_interlock = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_ycbcr_image_arrays) == .eq) {
            self.ext_ycbcr_image_arrays = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_uniform_buffer_standard_layout) == .eq) {
            self.khr_uniform_buffer_standard_layout = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_provoking_vertex) == .eq) {
            self.ext_provoking_vertex = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_full_screen_exclusive) == .eq) {
            self.ext_full_screen_exclusive = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_buffer_device_address) == .eq) {
            self.khr_buffer_device_address = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_line_rasterization) == .eq) {
            self.ext_line_rasterization = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_shader_atomic_float) == .eq) {
            self.ext_shader_atomic_float = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_host_query_reset) == .eq) {
            self.ext_host_query_reset = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_index_type_uint8) == .eq) {
            self.ext_index_type_uint8 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_extended_dynamic_state) == .eq) {
            self.ext_extended_dynamic_state = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_deferred_host_operations) == .eq) {
            self.khr_deferred_host_operations = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_pipeline_executable_properties) == .eq) {
            self.khr_pipeline_executable_properties = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_host_image_copy) == .eq) {
            self.ext_host_image_copy = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_map_memory2) == .eq) {
            self.khr_map_memory2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_map_memory_placed) == .eq) {
            self.ext_map_memory_placed = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_shader_atomic_float2) == .eq) {
            self.ext_shader_atomic_float2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_swapchain_maintenance1) == .eq) {
            self.ext_swapchain_maintenance1 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_shader_demote_to_helper_invocation) == .eq) {
            self.ext_shader_demote_to_helper_invocation = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_device_generated_commands) == .eq) {
            self.nv_device_generated_commands = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_inherited_viewport_scissor) == .eq) {
            self.nv_inherited_viewport_scissor = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_integer_dot_product) == .eq) {
            self.khr_shader_integer_dot_product = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_texel_buffer_alignment) == .eq) {
            self.ext_texel_buffer_alignment = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_render_pass_transform) == .eq) {
            self.qcom_render_pass_transform = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_depth_bias_control) == .eq) {
            self.ext_depth_bias_control = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_device_memory_report) == .eq) {
            self.ext_device_memory_report = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_robustness2) == .eq) {
            self.ext_robustness2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_custom_border_color) == .eq) {
            self.ext_custom_border_color = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.google_user_type) == .eq) {
            self.google_user_type = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_pipeline_library) == .eq) {
            self.khr_pipeline_library = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_present_barrier) == .eq) {
            self.nv_present_barrier = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_non_semantic_info) == .eq) {
            self.khr_shader_non_semantic_info = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_present_id) == .eq) {
            self.khr_present_id = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_private_data) == .eq) {
            self.ext_private_data = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_pipeline_creation_cache_control) == .eq) {
            self.ext_pipeline_creation_cache_control = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_device_diagnostics_config) == .eq) {
            self.nv_device_diagnostics_config = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_render_pass_store_ops) == .eq) {
            self.qcom_render_pass_store_ops = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_cuda_kernel_launch) == .eq) {
            self.nv_cuda_kernel_launch = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_tile_shading) == .eq) {
            self.qcom_tile_shading = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_low_latency) == .eq) {
            self.nv_low_latency = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_metal_objects) == .eq) {
            self.ext_metal_objects = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_synchronization2) == .eq) {
            self.khr_synchronization2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_descriptor_buffer) == .eq) {
            self.ext_descriptor_buffer = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_graphics_pipeline_library) == .eq) {
            self.ext_graphics_pipeline_library = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_shader_early_and_late_fragment_tests) == .eq) {
            self.amd_shader_early_and_late_fragment_tests = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_fragment_shader_barycentric) == .eq) {
            self.khr_fragment_shader_barycentric = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_subgroup_uniform_control_flow) == .eq) {
            self.khr_shader_subgroup_uniform_control_flow = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_zero_initialize_workgroup_memory) == .eq) {
            self.khr_zero_initialize_workgroup_memory = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_fragment_shading_rate_enums) == .eq) {
            self.nv_fragment_shading_rate_enums = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_ray_tracing_motion_blur) == .eq) {
            self.nv_ray_tracing_motion_blur = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_mesh_shader) == .eq) {
            self.ext_mesh_shader = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_ycbcr_2plane_444_formats) == .eq) {
            self.ext_ycbcr_2plane_444_formats = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_fragment_density_map2) == .eq) {
            self.ext_fragment_density_map2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_rotated_copy_commands) == .eq) {
            self.qcom_rotated_copy_commands = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_image_robustness) == .eq) {
            self.ext_image_robustness = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_workgroup_memory_explicit_layout) == .eq) {
            self.khr_workgroup_memory_explicit_layout = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_copy_commands2) == .eq) {
            self.khr_copy_commands2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_image_compression_control) == .eq) {
            self.ext_image_compression_control = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_attachment_feedback_loop_layout) == .eq) {
            self.ext_attachment_feedback_loop_layout = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_4444_formats) == .eq) {
            self.ext_4444_formats = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_device_fault) == .eq) {
            self.ext_device_fault = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.arm_rasterization_order_attachment_access) == .eq) {
            self.arm_rasterization_order_attachment_access = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_rgba10x6_formats) == .eq) {
            self.ext_rgba10x6_formats = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_acquire_winrt_display) == .eq) {
            self.nv_acquire_winrt_display = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.valve_mutable_descriptor_type) == .eq) {
            self.valve_mutable_descriptor_type = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_vertex_input_dynamic_state) == .eq) {
            self.ext_vertex_input_dynamic_state = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_physical_device_drm) == .eq) {
            self.ext_physical_device_drm = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_device_address_binding_report) == .eq) {
            self.ext_device_address_binding_report = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_depth_clip_control) == .eq) {
            self.ext_depth_clip_control = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_primitive_topology_list_restart) == .eq) {
            self.ext_primitive_topology_list_restart = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_format_feature_flags2) == .eq) {
            self.khr_format_feature_flags2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_present_mode_fifo_latest_ready) == .eq) {
            self.ext_present_mode_fifo_latest_ready = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.fuchsia_external_memory) == .eq) {
            self.fuchsia_external_memory = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.fuchsia_external_semaphore) == .eq) {
            self.fuchsia_external_semaphore = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.fuchsia_buffer_collection) == .eq) {
            self.fuchsia_buffer_collection = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.huawei_subpass_shading) == .eq) {
            self.huawei_subpass_shading = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.huawei_invocation_mask) == .eq) {
            self.huawei_invocation_mask = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_external_memory_rdma) == .eq) {
            self.nv_external_memory_rdma = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_pipeline_properties) == .eq) {
            self.ext_pipeline_properties = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_frame_boundary) == .eq) {
            self.ext_frame_boundary = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_multisampled_render_to_single_sampled) == .eq) {
            self.ext_multisampled_render_to_single_sampled = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_extended_dynamic_state2) == .eq) {
            self.ext_extended_dynamic_state2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_color_write_enable) == .eq) {
            self.ext_color_write_enable = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_primitives_generated_query) == .eq) {
            self.ext_primitives_generated_query = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_ray_tracing_maintenance1) == .eq) {
            self.khr_ray_tracing_maintenance1 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_untyped_pointers) == .eq) {
            self.khr_shader_untyped_pointers = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_global_priority_query) == .eq) {
            self.ext_global_priority_query = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_image_view_min_lod) == .eq) {
            self.ext_image_view_min_lod = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_multi_draw) == .eq) {
            self.ext_multi_draw = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_image_2d_view_of_3d) == .eq) {
            self.ext_image_2d_view_of_3d = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_shader_tile_image) == .eq) {
            self.ext_shader_tile_image = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_opacity_micromap) == .eq) {
            self.ext_opacity_micromap = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_displacement_micromap) == .eq) {
            self.nv_displacement_micromap = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_load_store_op_none) == .eq) {
            self.ext_load_store_op_none = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.huawei_cluster_culling_shader) == .eq) {
            self.huawei_cluster_culling_shader = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_border_color_swizzle) == .eq) {
            self.ext_border_color_swizzle = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_pageable_device_local_memory) == .eq) {
            self.ext_pageable_device_local_memory = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_maintenance4) == .eq) {
            self.khr_maintenance4 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.arm_shader_core_properties) == .eq) {
            self.arm_shader_core_properties = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_subgroup_rotate) == .eq) {
            self.khr_shader_subgroup_rotate = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.arm_scheduling_controls) == .eq) {
            self.arm_scheduling_controls = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_image_sliced_view_of_3d) == .eq) {
            self.ext_image_sliced_view_of_3d = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.valve_descriptor_set_host_mapping) == .eq) {
            self.valve_descriptor_set_host_mapping = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_depth_clamp_zero_one) == .eq) {
            self.ext_depth_clamp_zero_one = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_non_seamless_cube_map) == .eq) {
            self.ext_non_seamless_cube_map = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.arm_render_pass_striped) == .eq) {
            self.arm_render_pass_striped = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_fragment_density_map_offset) == .eq) {
            self.qcom_fragment_density_map_offset = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_copy_memory_indirect) == .eq) {
            self.nv_copy_memory_indirect = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_memory_decompression) == .eq) {
            self.nv_memory_decompression = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_device_generated_commands_compute) == .eq) {
            self.nv_device_generated_commands_compute = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_ray_tracing_linear_swept_spheres) == .eq) {
            self.nv_ray_tracing_linear_swept_spheres = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_linear_color_attachment) == .eq) {
            self.nv_linear_color_attachment = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_maximal_reconvergence) == .eq) {
            self.khr_shader_maximal_reconvergence = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_image_compression_control_swapchain) == .eq) {
            self.ext_image_compression_control_swapchain = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_image_processing) == .eq) {
            self.qcom_image_processing = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_nested_command_buffer) == .eq) {
            self.ext_nested_command_buffer = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_external_memory_acquire_unmodified) == .eq) {
            self.ext_external_memory_acquire_unmodified = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_extended_dynamic_state3) == .eq) {
            self.ext_extended_dynamic_state3 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_subpass_merge_feedback) == .eq) {
            self.ext_subpass_merge_feedback = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.arm_tensors) == .eq) {
            self.arm_tensors = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_shader_module_identifier) == .eq) {
            self.ext_shader_module_identifier = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_rasterization_order_attachment_access) == .eq) {
            self.ext_rasterization_order_attachment_access = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_optical_flow) == .eq) {
            self.nv_optical_flow = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_legacy_dithering) == .eq) {
            self.ext_legacy_dithering = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_pipeline_protected_access) == .eq) {
            self.ext_pipeline_protected_access = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.android_external_format_resolve) == .eq) {
            self.android_external_format_resolve = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_maintenance5) == .eq) {
            self.khr_maintenance5 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amd_anti_lag) == .eq) {
            self.amd_anti_lag = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.amdx_dense_geometry_format) == .eq) {
            self.amdx_dense_geometry_format = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_present_id2) == .eq) {
            self.khr_present_id2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_present_wait2) == .eq) {
            self.khr_present_wait2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_ray_tracing_position_fetch) == .eq) {
            self.khr_ray_tracing_position_fetch = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_shader_object) == .eq) {
            self.ext_shader_object = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_pipeline_binary) == .eq) {
            self.khr_pipeline_binary = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_tile_properties) == .eq) {
            self.qcom_tile_properties = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.sec_amigo_profiling) == .eq) {
            self.sec_amigo_profiling = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_swapchain_maintenance1) == .eq) {
            self.khr_swapchain_maintenance1 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_multiview_per_view_viewports) == .eq) {
            self.qcom_multiview_per_view_viewports = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_ray_tracing_invocation_reorder) == .eq) {
            self.nv_ray_tracing_invocation_reorder = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_cooperative_vector) == .eq) {
            self.nv_cooperative_vector = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_extended_sparse_address_space) == .eq) {
            self.nv_extended_sparse_address_space = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_mutable_descriptor_type) == .eq) {
            self.ext_mutable_descriptor_type = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_legacy_vertex_attributes) == .eq) {
            self.ext_legacy_vertex_attributes = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.arm_shader_core_builtins) == .eq) {
            self.arm_shader_core_builtins = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_pipeline_library_group_handles) == .eq) {
            self.ext_pipeline_library_group_handles = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_dynamic_rendering_unused_attachments) == .eq) {
            self.ext_dynamic_rendering_unused_attachments = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_low_latency2) == .eq) {
            self.nv_low_latency2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_cooperative_matrix) == .eq) {
            self.khr_cooperative_matrix = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.arm_data_graph) == .eq) {
            self.arm_data_graph = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_multiview_per_view_render_areas) == .eq) {
            self.qcom_multiview_per_view_render_areas = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_compute_shader_derivatives) == .eq) {
            self.khr_compute_shader_derivatives = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_per_stage_descriptor_set) == .eq) {
            self.nv_per_stage_descriptor_set = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_image_processing2) == .eq) {
            self.qcom_image_processing2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_filter_cubic_weights) == .eq) {
            self.qcom_filter_cubic_weights = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_ycbcr_degamma) == .eq) {
            self.qcom_ycbcr_degamma = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_filter_cubic_clamp) == .eq) {
            self.qcom_filter_cubic_clamp = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_attachment_feedback_loop_dynamic_state) == .eq) {
            self.ext_attachment_feedback_loop_dynamic_state = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_vertex_attribute_divisor) == .eq) {
            self.khr_vertex_attribute_divisor = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_load_store_op_none) == .eq) {
            self.khr_load_store_op_none = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_unified_image_layouts) == .eq) {
            self.khr_unified_image_layouts = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_float_controls2) == .eq) {
            self.khr_shader_float_controls2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.msft_layered_driver) == .eq) {
            self.msft_layered_driver = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_index_type_uint8) == .eq) {
            self.khr_index_type_uint8 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_line_rasterization) == .eq) {
            self.khr_line_rasterization = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_calibrated_timestamps) == .eq) {
            self.khr_calibrated_timestamps = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_expect_assume) == .eq) {
            self.khr_shader_expect_assume = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_maintenance6) == .eq) {
            self.khr_maintenance6 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_descriptor_pool_overallocation) == .eq) {
            self.nv_descriptor_pool_overallocation = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.qcom_tile_memory_heap) == .eq) {
            self.qcom_tile_memory_heap = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_raw_access_chains) == .eq) {
            self.nv_raw_access_chains = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_external_compute_queue) == .eq) {
            self.nv_external_compute_queue = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_shader_relaxed_extended_instruction) == .eq) {
            self.khr_shader_relaxed_extended_instruction = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_command_buffer_inheritance) == .eq) {
            self.nv_command_buffer_inheritance = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_maintenance7) == .eq) {
            self.khr_maintenance7 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_shader_atomic_float16_vector) == .eq) {
            self.nv_shader_atomic_float16_vector = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_shader_replicated_composites) == .eq) {
            self.ext_shader_replicated_composites = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_shader_float8) == .eq) {
            self.ext_shader_float8 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_ray_tracing_validation) == .eq) {
            self.nv_ray_tracing_validation = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_cluster_acceleration_structure) == .eq) {
            self.nv_cluster_acceleration_structure = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_partitioned_acceleration_structure) == .eq) {
            self.nv_partitioned_acceleration_structure = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_device_generated_commands) == .eq) {
            self.ext_device_generated_commands = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_maintenance8) == .eq) {
            self.khr_maintenance8 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.mesa_image_alignment_control) == .eq) {
            self.mesa_image_alignment_control = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_depth_clamp_control) == .eq) {
            self.ext_depth_clamp_control = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_maintenance9) == .eq) {
            self.khr_maintenance9 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.huawei_hdr_vivid) == .eq) {
            self.huawei_hdr_vivid = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_cooperative_matrix2) == .eq) {
            self.nv_cooperative_matrix2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.arm_pipeline_opacity_micromap) == .eq) {
            self.arm_pipeline_opacity_micromap = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_external_memory_metal) == .eq) {
            self.ext_external_memory_metal = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_depth_clamp_zero_one) == .eq) {
            self.khr_depth_clamp_zero_one = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_vertex_attribute_robustness) == .eq) {
            self.ext_vertex_attribute_robustness = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.arm_format_pack) == .eq) {
            self.arm_format_pack = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.valve_fragment_density_map_layered) == .eq) {
            self.valve_fragment_density_map_layered = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_robustness2) == .eq) {
            self.khr_robustness2 = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.nv_present_metering) == .eq) {
            self.nv_present_metering = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_fragment_density_map_offset) == .eq) {
            self.ext_fragment_density_map_offset = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.ext_zero_initialize_device_memory) == .eq) {
            self.ext_zero_initialize_device_memory = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.khr_present_mode_fifo_latest_ready) == .eq) {
            self.khr_present_mode_fifo_latest_ready = true;
        } else if (std.mem.orderZ(u8, name, ExtensionNames.sec_pipeline_cache_incremental_mode) == .eq) {
            self.sec_pipeline_cache_incremental_mode = true;
        }
    }

    pub fn from_properties(instance_version: Version, properties: []const ExtensionProperties) DeviceExtensions {
        var self: DeviceExtensions = .{
            .core_version = instance_version,
        };
        for (properties) |*prop| {
            self.enable_by_name(&prop.extension_name);
        }
        return self;
    }

    pub fn to_name_array(self: DeviceExtensions, allocator: Allocator) Allocator.Error![][*:0]const u8 {
        var names = std.ArrayListUnmanaged([*:0]const u8){};
        if (self.khr_swapchain) try names.append(allocator, ExtensionNames.khr_swapchain);
        if (self.khr_display_swapchain) try names.append(allocator, ExtensionNames.khr_display_swapchain);
        if (self.nv_glsl_shader) try names.append(allocator, ExtensionNames.nv_glsl_shader);
        if (self.ext_depth_range_unrestricted) try names.append(allocator, ExtensionNames.ext_depth_range_unrestricted);
        if (self.khr_sampler_mirror_clamp_to_edge) try names.append(allocator, ExtensionNames.khr_sampler_mirror_clamp_to_edge);
        if (self.img_filter_cubic) try names.append(allocator, ExtensionNames.img_filter_cubic);
        if (self.amd_rasterization_order) try names.append(allocator, ExtensionNames.amd_rasterization_order);
        if (self.amd_shader_trinary_minmax) try names.append(allocator, ExtensionNames.amd_shader_trinary_minmax);
        if (self.amd_shader_explicit_vertex_parameter) try names.append(allocator, ExtensionNames.amd_shader_explicit_vertex_parameter);
        if (self.ext_debug_marker) try names.append(allocator, ExtensionNames.ext_debug_marker);
        if (self.amd_gcn_shader) try names.append(allocator, ExtensionNames.amd_gcn_shader);
        if (self.nv_dedicated_allocation) try names.append(allocator, ExtensionNames.nv_dedicated_allocation);
        if (self.ext_transform_feedback) try names.append(allocator, ExtensionNames.ext_transform_feedback);
        if (self.nvx_binary_import) try names.append(allocator, ExtensionNames.nvx_binary_import);
        if (self.nvx_image_view_handle) try names.append(allocator, ExtensionNames.nvx_image_view_handle);
        if (self.amd_draw_indirect_count) try names.append(allocator, ExtensionNames.amd_draw_indirect_count);
        if (self.amd_negative_viewport_height) try names.append(allocator, ExtensionNames.amd_negative_viewport_height);
        if (self.amd_gpu_shader_half_float) try names.append(allocator, ExtensionNames.amd_gpu_shader_half_float);
        if (self.amd_shader_ballot) try names.append(allocator, ExtensionNames.amd_shader_ballot);
        if (self.amd_texture_gather_bias_lod) try names.append(allocator, ExtensionNames.amd_texture_gather_bias_lod);
        if (self.amd_shader_info) try names.append(allocator, ExtensionNames.amd_shader_info);
        if (self.khr_dynamic_rendering) try names.append(allocator, ExtensionNames.khr_dynamic_rendering);
        if (self.amd_shader_image_load_store_lod) try names.append(allocator, ExtensionNames.amd_shader_image_load_store_lod);
        if (self.nv_corner_sampled_image) try names.append(allocator, ExtensionNames.nv_corner_sampled_image);
        if (self.khr_multiview) try names.append(allocator, ExtensionNames.khr_multiview);
        if (self.img_format_pvrtc) try names.append(allocator, ExtensionNames.img_format_pvrtc);
        if (self.nv_external_memory) try names.append(allocator, ExtensionNames.nv_external_memory);
        if (self.nv_external_memory_win32) try names.append(allocator, ExtensionNames.nv_external_memory_win32);
        if (self.nv_win32_keyed_mutex) try names.append(allocator, ExtensionNames.nv_win32_keyed_mutex);
        if (self.khr_device_group) try names.append(allocator, ExtensionNames.khr_device_group);
        if (self.khr_shader_draw_parameters) try names.append(allocator, ExtensionNames.khr_shader_draw_parameters);
        if (self.ext_shader_subgroup_ballot) try names.append(allocator, ExtensionNames.ext_shader_subgroup_ballot);
        if (self.ext_shader_subgroup_vote) try names.append(allocator, ExtensionNames.ext_shader_subgroup_vote);
        if (self.ext_texture_compression_astc_hdr) try names.append(allocator, ExtensionNames.ext_texture_compression_astc_hdr);
        if (self.ext_astc_decode_mode) try names.append(allocator, ExtensionNames.ext_astc_decode_mode);
        if (self.ext_pipeline_robustness) try names.append(allocator, ExtensionNames.ext_pipeline_robustness);
        if (self.khr_maintenance1) try names.append(allocator, ExtensionNames.khr_maintenance1);
        if (self.khr_external_memory) try names.append(allocator, ExtensionNames.khr_external_memory);
        if (self.khr_external_memory_win32) try names.append(allocator, ExtensionNames.khr_external_memory_win32);
        if (self.khr_external_memory_fd) try names.append(allocator, ExtensionNames.khr_external_memory_fd);
        if (self.khr_win32_keyed_mutex) try names.append(allocator, ExtensionNames.khr_win32_keyed_mutex);
        if (self.khr_external_semaphore) try names.append(allocator, ExtensionNames.khr_external_semaphore);
        if (self.khr_external_semaphore_win32) try names.append(allocator, ExtensionNames.khr_external_semaphore_win32);
        if (self.khr_external_semaphore_fd) try names.append(allocator, ExtensionNames.khr_external_semaphore_fd);
        if (self.khr_push_descriptor) try names.append(allocator, ExtensionNames.khr_push_descriptor);
        if (self.ext_conditional_rendering) try names.append(allocator, ExtensionNames.ext_conditional_rendering);
        if (self.khr_shader_float16_int8) try names.append(allocator, ExtensionNames.khr_shader_float16_int8);
        if (self.khr_16bit_storage) try names.append(allocator, ExtensionNames.khr_16bit_storage);
        if (self.khr_incremental_present) try names.append(allocator, ExtensionNames.khr_incremental_present);
        if (self.khr_descriptor_update_template) try names.append(allocator, ExtensionNames.khr_descriptor_update_template);
        if (self.nv_clip_space_w_scaling) try names.append(allocator, ExtensionNames.nv_clip_space_w_scaling);
        if (self.ext_display_control) try names.append(allocator, ExtensionNames.ext_display_control);
        if (self.google_display_timing) try names.append(allocator, ExtensionNames.google_display_timing);
        if (self.nv_sample_mask_override_coverage) try names.append(allocator, ExtensionNames.nv_sample_mask_override_coverage);
        if (self.nv_geometry_shader_passthrough) try names.append(allocator, ExtensionNames.nv_geometry_shader_passthrough);
        if (self.nv_viewport_array2) try names.append(allocator, ExtensionNames.nv_viewport_array2);
        if (self.nvx_multiview_per_view_attributes) try names.append(allocator, ExtensionNames.nvx_multiview_per_view_attributes);
        if (self.nv_viewport_swizzle) try names.append(allocator, ExtensionNames.nv_viewport_swizzle);
        if (self.ext_discard_rectangles) try names.append(allocator, ExtensionNames.ext_discard_rectangles);
        if (self.ext_conservative_rasterization) try names.append(allocator, ExtensionNames.ext_conservative_rasterization);
        if (self.ext_depth_clip_enable) try names.append(allocator, ExtensionNames.ext_depth_clip_enable);
        if (self.ext_hdr_metadata) try names.append(allocator, ExtensionNames.ext_hdr_metadata);
        if (self.khr_imageless_framebuffer) try names.append(allocator, ExtensionNames.khr_imageless_framebuffer);
        if (self.khr_create_renderpass2) try names.append(allocator, ExtensionNames.khr_create_renderpass2);
        if (self.img_relaxed_line_rasterization) try names.append(allocator, ExtensionNames.img_relaxed_line_rasterization);
        if (self.khr_shared_presentable_image) try names.append(allocator, ExtensionNames.khr_shared_presentable_image);
        if (self.khr_external_fence) try names.append(allocator, ExtensionNames.khr_external_fence);
        if (self.khr_external_fence_win32) try names.append(allocator, ExtensionNames.khr_external_fence_win32);
        if (self.khr_external_fence_fd) try names.append(allocator, ExtensionNames.khr_external_fence_fd);
        if (self.khr_performance_query) try names.append(allocator, ExtensionNames.khr_performance_query);
        if (self.khr_maintenance2) try names.append(allocator, ExtensionNames.khr_maintenance2);
        if (self.khr_variable_pointers) try names.append(allocator, ExtensionNames.khr_variable_pointers);
        if (self.ext_external_memory_dma_buf) try names.append(allocator, ExtensionNames.ext_external_memory_dma_buf);
        if (self.ext_queue_family_foreign) try names.append(allocator, ExtensionNames.ext_queue_family_foreign);
        if (self.khr_dedicated_allocation) try names.append(allocator, ExtensionNames.khr_dedicated_allocation);
        if (self.android_external_memory_android_hardware_buffer) try names.append(allocator, ExtensionNames.android_external_memory_android_hardware_buffer);
        if (self.ext_sampler_filter_minmax) try names.append(allocator, ExtensionNames.ext_sampler_filter_minmax);
        if (self.khr_storage_buffer_storage_class) try names.append(allocator, ExtensionNames.khr_storage_buffer_storage_class);
        if (self.amd_gpu_shader_int16) try names.append(allocator, ExtensionNames.amd_gpu_shader_int16);
        if (self.amdx_shader_enqueue) try names.append(allocator, ExtensionNames.amdx_shader_enqueue);
        if (self.amd_mixed_attachment_samples) try names.append(allocator, ExtensionNames.amd_mixed_attachment_samples);
        if (self.amd_shader_fragment_mask) try names.append(allocator, ExtensionNames.amd_shader_fragment_mask);
        if (self.ext_inline_uniform_block) try names.append(allocator, ExtensionNames.ext_inline_uniform_block);
        if (self.ext_shader_stencil_export) try names.append(allocator, ExtensionNames.ext_shader_stencil_export);
        if (self.khr_shader_bfloat16) try names.append(allocator, ExtensionNames.khr_shader_bfloat16);
        if (self.ext_sample_locations) try names.append(allocator, ExtensionNames.ext_sample_locations);
        if (self.khr_relaxed_block_layout) try names.append(allocator, ExtensionNames.khr_relaxed_block_layout);
        if (self.khr_get_memory_requirements2) try names.append(allocator, ExtensionNames.khr_get_memory_requirements2);
        if (self.khr_image_format_list) try names.append(allocator, ExtensionNames.khr_image_format_list);
        if (self.ext_blend_operation_advanced) try names.append(allocator, ExtensionNames.ext_blend_operation_advanced);
        if (self.nv_fragment_coverage_to_color) try names.append(allocator, ExtensionNames.nv_fragment_coverage_to_color);
        if (self.khr_acceleration_structure) try names.append(allocator, ExtensionNames.khr_acceleration_structure);
        if (self.khr_ray_tracing_pipeline) try names.append(allocator, ExtensionNames.khr_ray_tracing_pipeline);
        if (self.khr_ray_query) try names.append(allocator, ExtensionNames.khr_ray_query);
        if (self.nv_framebuffer_mixed_samples) try names.append(allocator, ExtensionNames.nv_framebuffer_mixed_samples);
        if (self.nv_fill_rectangle) try names.append(allocator, ExtensionNames.nv_fill_rectangle);
        if (self.nv_shader_sm_builtins) try names.append(allocator, ExtensionNames.nv_shader_sm_builtins);
        if (self.ext_post_depth_coverage) try names.append(allocator, ExtensionNames.ext_post_depth_coverage);
        if (self.khr_sampler_ycbcr_conversion) try names.append(allocator, ExtensionNames.khr_sampler_ycbcr_conversion);
        if (self.khr_bind_memory2) try names.append(allocator, ExtensionNames.khr_bind_memory2);
        if (self.ext_image_drm_format_modifier) try names.append(allocator, ExtensionNames.ext_image_drm_format_modifier);
        if (self.ext_validation_cache) try names.append(allocator, ExtensionNames.ext_validation_cache);
        if (self.ext_descriptor_indexing) try names.append(allocator, ExtensionNames.ext_descriptor_indexing);
        if (self.ext_shader_viewport_index_layer) try names.append(allocator, ExtensionNames.ext_shader_viewport_index_layer);
        if (self.khr_portability_subset) try names.append(allocator, ExtensionNames.khr_portability_subset);
        if (self.nv_shading_rate_image) try names.append(allocator, ExtensionNames.nv_shading_rate_image);
        if (self.nv_ray_tracing) try names.append(allocator, ExtensionNames.nv_ray_tracing);
        if (self.nv_representative_fragment_test) try names.append(allocator, ExtensionNames.nv_representative_fragment_test);
        if (self.khr_maintenance3) try names.append(allocator, ExtensionNames.khr_maintenance3);
        if (self.khr_draw_indirect_count) try names.append(allocator, ExtensionNames.khr_draw_indirect_count);
        if (self.ext_filter_cubic) try names.append(allocator, ExtensionNames.ext_filter_cubic);
        if (self.qcom_render_pass_shader_resolve) try names.append(allocator, ExtensionNames.qcom_render_pass_shader_resolve);
        if (self.ext_global_priority) try names.append(allocator, ExtensionNames.ext_global_priority);
        if (self.khr_shader_subgroup_extended_types) try names.append(allocator, ExtensionNames.khr_shader_subgroup_extended_types);
        if (self.khr_8bit_storage) try names.append(allocator, ExtensionNames.khr_8bit_storage);
        if (self.ext_external_memory_host) try names.append(allocator, ExtensionNames.ext_external_memory_host);
        if (self.amd_buffer_marker) try names.append(allocator, ExtensionNames.amd_buffer_marker);
        if (self.khr_shader_atomic_int64) try names.append(allocator, ExtensionNames.khr_shader_atomic_int64);
        if (self.khr_shader_clock) try names.append(allocator, ExtensionNames.khr_shader_clock);
        if (self.amd_pipeline_compiler_control) try names.append(allocator, ExtensionNames.amd_pipeline_compiler_control);
        if (self.ext_calibrated_timestamps) try names.append(allocator, ExtensionNames.ext_calibrated_timestamps);
        if (self.amd_shader_core_properties) try names.append(allocator, ExtensionNames.amd_shader_core_properties);
        if (self.khr_global_priority) try names.append(allocator, ExtensionNames.khr_global_priority);
        if (self.amd_memory_overallocation_behavior) try names.append(allocator, ExtensionNames.amd_memory_overallocation_behavior);
        if (self.ext_vertex_attribute_divisor) try names.append(allocator, ExtensionNames.ext_vertex_attribute_divisor);
        if (self.ext_pipeline_creation_feedback) try names.append(allocator, ExtensionNames.ext_pipeline_creation_feedback);
        if (self.khr_driver_properties) try names.append(allocator, ExtensionNames.khr_driver_properties);
        if (self.khr_shader_float_controls) try names.append(allocator, ExtensionNames.khr_shader_float_controls);
        if (self.nv_shader_subgroup_partitioned) try names.append(allocator, ExtensionNames.nv_shader_subgroup_partitioned);
        if (self.khr_depth_stencil_resolve) try names.append(allocator, ExtensionNames.khr_depth_stencil_resolve);
        if (self.khr_swapchain_mutable_format) try names.append(allocator, ExtensionNames.khr_swapchain_mutable_format);
        if (self.nv_compute_shader_derivatives) try names.append(allocator, ExtensionNames.nv_compute_shader_derivatives);
        if (self.nv_mesh_shader) try names.append(allocator, ExtensionNames.nv_mesh_shader);
        if (self.nv_fragment_shader_barycentric) try names.append(allocator, ExtensionNames.nv_fragment_shader_barycentric);
        if (self.nv_shader_image_footprint) try names.append(allocator, ExtensionNames.nv_shader_image_footprint);
        if (self.nv_scissor_exclusive) try names.append(allocator, ExtensionNames.nv_scissor_exclusive);
        if (self.nv_device_diagnostic_checkpoints) try names.append(allocator, ExtensionNames.nv_device_diagnostic_checkpoints);
        if (self.khr_timeline_semaphore) try names.append(allocator, ExtensionNames.khr_timeline_semaphore);
        if (self.intel_shader_integer_functions2) try names.append(allocator, ExtensionNames.intel_shader_integer_functions2);
        if (self.intel_performance_query) try names.append(allocator, ExtensionNames.intel_performance_query);
        if (self.khr_vulkan_memory_model) try names.append(allocator, ExtensionNames.khr_vulkan_memory_model);
        if (self.ext_pci_bus_info) try names.append(allocator, ExtensionNames.ext_pci_bus_info);
        if (self.amd_display_native_hdr) try names.append(allocator, ExtensionNames.amd_display_native_hdr);
        if (self.khr_shader_terminate_invocation) try names.append(allocator, ExtensionNames.khr_shader_terminate_invocation);
        if (self.ext_fragment_density_map) try names.append(allocator, ExtensionNames.ext_fragment_density_map);
        if (self.ext_scalar_block_layout) try names.append(allocator, ExtensionNames.ext_scalar_block_layout);
        if (self.google_hlsl_functionality1) try names.append(allocator, ExtensionNames.google_hlsl_functionality1);
        if (self.google_decorate_string) try names.append(allocator, ExtensionNames.google_decorate_string);
        if (self.ext_subgroup_size_control) try names.append(allocator, ExtensionNames.ext_subgroup_size_control);
        if (self.khr_fragment_shading_rate) try names.append(allocator, ExtensionNames.khr_fragment_shading_rate);
        if (self.amd_shader_core_properties2) try names.append(allocator, ExtensionNames.amd_shader_core_properties2);
        if (self.amd_device_coherent_memory) try names.append(allocator, ExtensionNames.amd_device_coherent_memory);
        if (self.khr_dynamic_rendering_local_read) try names.append(allocator, ExtensionNames.khr_dynamic_rendering_local_read);
        if (self.ext_shader_image_atomic_int64) try names.append(allocator, ExtensionNames.ext_shader_image_atomic_int64);
        if (self.khr_shader_quad_control) try names.append(allocator, ExtensionNames.khr_shader_quad_control);
        if (self.khr_spirv_1_4) try names.append(allocator, ExtensionNames.khr_spirv_1_4);
        if (self.ext_memory_budget) try names.append(allocator, ExtensionNames.ext_memory_budget);
        if (self.ext_memory_priority) try names.append(allocator, ExtensionNames.ext_memory_priority);
        if (self.nv_dedicated_allocation_image_aliasing) try names.append(allocator, ExtensionNames.nv_dedicated_allocation_image_aliasing);
        if (self.khr_separate_depth_stencil_layouts) try names.append(allocator, ExtensionNames.khr_separate_depth_stencil_layouts);
        if (self.ext_buffer_device_address) try names.append(allocator, ExtensionNames.ext_buffer_device_address);
        if (self.ext_tooling_info) try names.append(allocator, ExtensionNames.ext_tooling_info);
        if (self.ext_separate_stencil_usage) try names.append(allocator, ExtensionNames.ext_separate_stencil_usage);
        if (self.khr_present_wait) try names.append(allocator, ExtensionNames.khr_present_wait);
        if (self.nv_cooperative_matrix) try names.append(allocator, ExtensionNames.nv_cooperative_matrix);
        if (self.nv_coverage_reduction_mode) try names.append(allocator, ExtensionNames.nv_coverage_reduction_mode);
        if (self.ext_fragment_shader_interlock) try names.append(allocator, ExtensionNames.ext_fragment_shader_interlock);
        if (self.ext_ycbcr_image_arrays) try names.append(allocator, ExtensionNames.ext_ycbcr_image_arrays);
        if (self.khr_uniform_buffer_standard_layout) try names.append(allocator, ExtensionNames.khr_uniform_buffer_standard_layout);
        if (self.ext_provoking_vertex) try names.append(allocator, ExtensionNames.ext_provoking_vertex);
        if (self.ext_full_screen_exclusive) try names.append(allocator, ExtensionNames.ext_full_screen_exclusive);
        if (self.khr_buffer_device_address) try names.append(allocator, ExtensionNames.khr_buffer_device_address);
        if (self.ext_line_rasterization) try names.append(allocator, ExtensionNames.ext_line_rasterization);
        if (self.ext_shader_atomic_float) try names.append(allocator, ExtensionNames.ext_shader_atomic_float);
        if (self.ext_host_query_reset) try names.append(allocator, ExtensionNames.ext_host_query_reset);
        if (self.ext_index_type_uint8) try names.append(allocator, ExtensionNames.ext_index_type_uint8);
        if (self.ext_extended_dynamic_state) try names.append(allocator, ExtensionNames.ext_extended_dynamic_state);
        if (self.khr_deferred_host_operations) try names.append(allocator, ExtensionNames.khr_deferred_host_operations);
        if (self.khr_pipeline_executable_properties) try names.append(allocator, ExtensionNames.khr_pipeline_executable_properties);
        if (self.ext_host_image_copy) try names.append(allocator, ExtensionNames.ext_host_image_copy);
        if (self.khr_map_memory2) try names.append(allocator, ExtensionNames.khr_map_memory2);
        if (self.ext_map_memory_placed) try names.append(allocator, ExtensionNames.ext_map_memory_placed);
        if (self.ext_shader_atomic_float2) try names.append(allocator, ExtensionNames.ext_shader_atomic_float2);
        if (self.ext_swapchain_maintenance1) try names.append(allocator, ExtensionNames.ext_swapchain_maintenance1);
        if (self.ext_shader_demote_to_helper_invocation) try names.append(allocator, ExtensionNames.ext_shader_demote_to_helper_invocation);
        if (self.nv_device_generated_commands) try names.append(allocator, ExtensionNames.nv_device_generated_commands);
        if (self.nv_inherited_viewport_scissor) try names.append(allocator, ExtensionNames.nv_inherited_viewport_scissor);
        if (self.khr_shader_integer_dot_product) try names.append(allocator, ExtensionNames.khr_shader_integer_dot_product);
        if (self.ext_texel_buffer_alignment) try names.append(allocator, ExtensionNames.ext_texel_buffer_alignment);
        if (self.qcom_render_pass_transform) try names.append(allocator, ExtensionNames.qcom_render_pass_transform);
        if (self.ext_depth_bias_control) try names.append(allocator, ExtensionNames.ext_depth_bias_control);
        if (self.ext_device_memory_report) try names.append(allocator, ExtensionNames.ext_device_memory_report);
        if (self.ext_robustness2) try names.append(allocator, ExtensionNames.ext_robustness2);
        if (self.ext_custom_border_color) try names.append(allocator, ExtensionNames.ext_custom_border_color);
        if (self.google_user_type) try names.append(allocator, ExtensionNames.google_user_type);
        if (self.khr_pipeline_library) try names.append(allocator, ExtensionNames.khr_pipeline_library);
        if (self.nv_present_barrier) try names.append(allocator, ExtensionNames.nv_present_barrier);
        if (self.khr_shader_non_semantic_info) try names.append(allocator, ExtensionNames.khr_shader_non_semantic_info);
        if (self.khr_present_id) try names.append(allocator, ExtensionNames.khr_present_id);
        if (self.ext_private_data) try names.append(allocator, ExtensionNames.ext_private_data);
        if (self.ext_pipeline_creation_cache_control) try names.append(allocator, ExtensionNames.ext_pipeline_creation_cache_control);
        if (self.nv_device_diagnostics_config) try names.append(allocator, ExtensionNames.nv_device_diagnostics_config);
        if (self.qcom_render_pass_store_ops) try names.append(allocator, ExtensionNames.qcom_render_pass_store_ops);
        if (self.nv_cuda_kernel_launch) try names.append(allocator, ExtensionNames.nv_cuda_kernel_launch);
        if (self.qcom_tile_shading) try names.append(allocator, ExtensionNames.qcom_tile_shading);
        if (self.nv_low_latency) try names.append(allocator, ExtensionNames.nv_low_latency);
        if (self.ext_metal_objects) try names.append(allocator, ExtensionNames.ext_metal_objects);
        if (self.khr_synchronization2) try names.append(allocator, ExtensionNames.khr_synchronization2);
        if (self.ext_descriptor_buffer) try names.append(allocator, ExtensionNames.ext_descriptor_buffer);
        if (self.ext_graphics_pipeline_library) try names.append(allocator, ExtensionNames.ext_graphics_pipeline_library);
        if (self.amd_shader_early_and_late_fragment_tests) try names.append(allocator, ExtensionNames.amd_shader_early_and_late_fragment_tests);
        if (self.khr_fragment_shader_barycentric) try names.append(allocator, ExtensionNames.khr_fragment_shader_barycentric);
        if (self.khr_shader_subgroup_uniform_control_flow) try names.append(allocator, ExtensionNames.khr_shader_subgroup_uniform_control_flow);
        if (self.khr_zero_initialize_workgroup_memory) try names.append(allocator, ExtensionNames.khr_zero_initialize_workgroup_memory);
        if (self.nv_fragment_shading_rate_enums) try names.append(allocator, ExtensionNames.nv_fragment_shading_rate_enums);
        if (self.nv_ray_tracing_motion_blur) try names.append(allocator, ExtensionNames.nv_ray_tracing_motion_blur);
        if (self.ext_mesh_shader) try names.append(allocator, ExtensionNames.ext_mesh_shader);
        if (self.ext_ycbcr_2plane_444_formats) try names.append(allocator, ExtensionNames.ext_ycbcr_2plane_444_formats);
        if (self.ext_fragment_density_map2) try names.append(allocator, ExtensionNames.ext_fragment_density_map2);
        if (self.qcom_rotated_copy_commands) try names.append(allocator, ExtensionNames.qcom_rotated_copy_commands);
        if (self.ext_image_robustness) try names.append(allocator, ExtensionNames.ext_image_robustness);
        if (self.khr_workgroup_memory_explicit_layout) try names.append(allocator, ExtensionNames.khr_workgroup_memory_explicit_layout);
        if (self.khr_copy_commands2) try names.append(allocator, ExtensionNames.khr_copy_commands2);
        if (self.ext_image_compression_control) try names.append(allocator, ExtensionNames.ext_image_compression_control);
        if (self.ext_attachment_feedback_loop_layout) try names.append(allocator, ExtensionNames.ext_attachment_feedback_loop_layout);
        if (self.ext_4444_formats) try names.append(allocator, ExtensionNames.ext_4444_formats);
        if (self.ext_device_fault) try names.append(allocator, ExtensionNames.ext_device_fault);
        if (self.arm_rasterization_order_attachment_access) try names.append(allocator, ExtensionNames.arm_rasterization_order_attachment_access);
        if (self.ext_rgba10x6_formats) try names.append(allocator, ExtensionNames.ext_rgba10x6_formats);
        if (self.nv_acquire_winrt_display) try names.append(allocator, ExtensionNames.nv_acquire_winrt_display);
        if (self.valve_mutable_descriptor_type) try names.append(allocator, ExtensionNames.valve_mutable_descriptor_type);
        if (self.ext_vertex_input_dynamic_state) try names.append(allocator, ExtensionNames.ext_vertex_input_dynamic_state);
        if (self.ext_physical_device_drm) try names.append(allocator, ExtensionNames.ext_physical_device_drm);
        if (self.ext_device_address_binding_report) try names.append(allocator, ExtensionNames.ext_device_address_binding_report);
        if (self.ext_depth_clip_control) try names.append(allocator, ExtensionNames.ext_depth_clip_control);
        if (self.ext_primitive_topology_list_restart) try names.append(allocator, ExtensionNames.ext_primitive_topology_list_restart);
        if (self.khr_format_feature_flags2) try names.append(allocator, ExtensionNames.khr_format_feature_flags2);
        if (self.ext_present_mode_fifo_latest_ready) try names.append(allocator, ExtensionNames.ext_present_mode_fifo_latest_ready);
        if (self.fuchsia_external_memory) try names.append(allocator, ExtensionNames.fuchsia_external_memory);
        if (self.fuchsia_external_semaphore) try names.append(allocator, ExtensionNames.fuchsia_external_semaphore);
        if (self.fuchsia_buffer_collection) try names.append(allocator, ExtensionNames.fuchsia_buffer_collection);
        if (self.huawei_subpass_shading) try names.append(allocator, ExtensionNames.huawei_subpass_shading);
        if (self.huawei_invocation_mask) try names.append(allocator, ExtensionNames.huawei_invocation_mask);
        if (self.nv_external_memory_rdma) try names.append(allocator, ExtensionNames.nv_external_memory_rdma);
        if (self.ext_pipeline_properties) try names.append(allocator, ExtensionNames.ext_pipeline_properties);
        if (self.ext_frame_boundary) try names.append(allocator, ExtensionNames.ext_frame_boundary);
        if (self.ext_multisampled_render_to_single_sampled) try names.append(allocator, ExtensionNames.ext_multisampled_render_to_single_sampled);
        if (self.ext_extended_dynamic_state2) try names.append(allocator, ExtensionNames.ext_extended_dynamic_state2);
        if (self.ext_color_write_enable) try names.append(allocator, ExtensionNames.ext_color_write_enable);
        if (self.ext_primitives_generated_query) try names.append(allocator, ExtensionNames.ext_primitives_generated_query);
        if (self.khr_ray_tracing_maintenance1) try names.append(allocator, ExtensionNames.khr_ray_tracing_maintenance1);
        if (self.khr_shader_untyped_pointers) try names.append(allocator, ExtensionNames.khr_shader_untyped_pointers);
        if (self.ext_global_priority_query) try names.append(allocator, ExtensionNames.ext_global_priority_query);
        if (self.ext_image_view_min_lod) try names.append(allocator, ExtensionNames.ext_image_view_min_lod);
        if (self.ext_multi_draw) try names.append(allocator, ExtensionNames.ext_multi_draw);
        if (self.ext_image_2d_view_of_3d) try names.append(allocator, ExtensionNames.ext_image_2d_view_of_3d);
        if (self.ext_shader_tile_image) try names.append(allocator, ExtensionNames.ext_shader_tile_image);
        if (self.ext_opacity_micromap) try names.append(allocator, ExtensionNames.ext_opacity_micromap);
        if (self.nv_displacement_micromap) try names.append(allocator, ExtensionNames.nv_displacement_micromap);
        if (self.ext_load_store_op_none) try names.append(allocator, ExtensionNames.ext_load_store_op_none);
        if (self.huawei_cluster_culling_shader) try names.append(allocator, ExtensionNames.huawei_cluster_culling_shader);
        if (self.ext_border_color_swizzle) try names.append(allocator, ExtensionNames.ext_border_color_swizzle);
        if (self.ext_pageable_device_local_memory) try names.append(allocator, ExtensionNames.ext_pageable_device_local_memory);
        if (self.khr_maintenance4) try names.append(allocator, ExtensionNames.khr_maintenance4);
        if (self.arm_shader_core_properties) try names.append(allocator, ExtensionNames.arm_shader_core_properties);
        if (self.khr_shader_subgroup_rotate) try names.append(allocator, ExtensionNames.khr_shader_subgroup_rotate);
        if (self.arm_scheduling_controls) try names.append(allocator, ExtensionNames.arm_scheduling_controls);
        if (self.ext_image_sliced_view_of_3d) try names.append(allocator, ExtensionNames.ext_image_sliced_view_of_3d);
        if (self.valve_descriptor_set_host_mapping) try names.append(allocator, ExtensionNames.valve_descriptor_set_host_mapping);
        if (self.ext_depth_clamp_zero_one) try names.append(allocator, ExtensionNames.ext_depth_clamp_zero_one);
        if (self.ext_non_seamless_cube_map) try names.append(allocator, ExtensionNames.ext_non_seamless_cube_map);
        if (self.arm_render_pass_striped) try names.append(allocator, ExtensionNames.arm_render_pass_striped);
        if (self.qcom_fragment_density_map_offset) try names.append(allocator, ExtensionNames.qcom_fragment_density_map_offset);
        if (self.nv_copy_memory_indirect) try names.append(allocator, ExtensionNames.nv_copy_memory_indirect);
        if (self.nv_memory_decompression) try names.append(allocator, ExtensionNames.nv_memory_decompression);
        if (self.nv_device_generated_commands_compute) try names.append(allocator, ExtensionNames.nv_device_generated_commands_compute);
        if (self.nv_ray_tracing_linear_swept_spheres) try names.append(allocator, ExtensionNames.nv_ray_tracing_linear_swept_spheres);
        if (self.nv_linear_color_attachment) try names.append(allocator, ExtensionNames.nv_linear_color_attachment);
        if (self.khr_shader_maximal_reconvergence) try names.append(allocator, ExtensionNames.khr_shader_maximal_reconvergence);
        if (self.ext_image_compression_control_swapchain) try names.append(allocator, ExtensionNames.ext_image_compression_control_swapchain);
        if (self.qcom_image_processing) try names.append(allocator, ExtensionNames.qcom_image_processing);
        if (self.ext_nested_command_buffer) try names.append(allocator, ExtensionNames.ext_nested_command_buffer);
        if (self.ext_external_memory_acquire_unmodified) try names.append(allocator, ExtensionNames.ext_external_memory_acquire_unmodified);
        if (self.ext_extended_dynamic_state3) try names.append(allocator, ExtensionNames.ext_extended_dynamic_state3);
        if (self.ext_subpass_merge_feedback) try names.append(allocator, ExtensionNames.ext_subpass_merge_feedback);
        if (self.arm_tensors) try names.append(allocator, ExtensionNames.arm_tensors);
        if (self.ext_shader_module_identifier) try names.append(allocator, ExtensionNames.ext_shader_module_identifier);
        if (self.ext_rasterization_order_attachment_access) try names.append(allocator, ExtensionNames.ext_rasterization_order_attachment_access);
        if (self.nv_optical_flow) try names.append(allocator, ExtensionNames.nv_optical_flow);
        if (self.ext_legacy_dithering) try names.append(allocator, ExtensionNames.ext_legacy_dithering);
        if (self.ext_pipeline_protected_access) try names.append(allocator, ExtensionNames.ext_pipeline_protected_access);
        if (self.android_external_format_resolve) try names.append(allocator, ExtensionNames.android_external_format_resolve);
        if (self.khr_maintenance5) try names.append(allocator, ExtensionNames.khr_maintenance5);
        if (self.amd_anti_lag) try names.append(allocator, ExtensionNames.amd_anti_lag);
        if (self.amdx_dense_geometry_format) try names.append(allocator, ExtensionNames.amdx_dense_geometry_format);
        if (self.khr_present_id2) try names.append(allocator, ExtensionNames.khr_present_id2);
        if (self.khr_present_wait2) try names.append(allocator, ExtensionNames.khr_present_wait2);
        if (self.khr_ray_tracing_position_fetch) try names.append(allocator, ExtensionNames.khr_ray_tracing_position_fetch);
        if (self.ext_shader_object) try names.append(allocator, ExtensionNames.ext_shader_object);
        if (self.khr_pipeline_binary) try names.append(allocator, ExtensionNames.khr_pipeline_binary);
        if (self.qcom_tile_properties) try names.append(allocator, ExtensionNames.qcom_tile_properties);
        if (self.sec_amigo_profiling) try names.append(allocator, ExtensionNames.sec_amigo_profiling);
        if (self.khr_swapchain_maintenance1) try names.append(allocator, ExtensionNames.khr_swapchain_maintenance1);
        if (self.qcom_multiview_per_view_viewports) try names.append(allocator, ExtensionNames.qcom_multiview_per_view_viewports);
        if (self.nv_ray_tracing_invocation_reorder) try names.append(allocator, ExtensionNames.nv_ray_tracing_invocation_reorder);
        if (self.nv_cooperative_vector) try names.append(allocator, ExtensionNames.nv_cooperative_vector);
        if (self.nv_extended_sparse_address_space) try names.append(allocator, ExtensionNames.nv_extended_sparse_address_space);
        if (self.ext_mutable_descriptor_type) try names.append(allocator, ExtensionNames.ext_mutable_descriptor_type);
        if (self.ext_legacy_vertex_attributes) try names.append(allocator, ExtensionNames.ext_legacy_vertex_attributes);
        if (self.arm_shader_core_builtins) try names.append(allocator, ExtensionNames.arm_shader_core_builtins);
        if (self.ext_pipeline_library_group_handles) try names.append(allocator, ExtensionNames.ext_pipeline_library_group_handles);
        if (self.ext_dynamic_rendering_unused_attachments) try names.append(allocator, ExtensionNames.ext_dynamic_rendering_unused_attachments);
        if (self.nv_low_latency2) try names.append(allocator, ExtensionNames.nv_low_latency2);
        if (self.khr_cooperative_matrix) try names.append(allocator, ExtensionNames.khr_cooperative_matrix);
        if (self.arm_data_graph) try names.append(allocator, ExtensionNames.arm_data_graph);
        if (self.qcom_multiview_per_view_render_areas) try names.append(allocator, ExtensionNames.qcom_multiview_per_view_render_areas);
        if (self.khr_compute_shader_derivatives) try names.append(allocator, ExtensionNames.khr_compute_shader_derivatives);
        if (self.nv_per_stage_descriptor_set) try names.append(allocator, ExtensionNames.nv_per_stage_descriptor_set);
        if (self.qcom_image_processing2) try names.append(allocator, ExtensionNames.qcom_image_processing2);
        if (self.qcom_filter_cubic_weights) try names.append(allocator, ExtensionNames.qcom_filter_cubic_weights);
        if (self.qcom_ycbcr_degamma) try names.append(allocator, ExtensionNames.qcom_ycbcr_degamma);
        if (self.qcom_filter_cubic_clamp) try names.append(allocator, ExtensionNames.qcom_filter_cubic_clamp);
        if (self.ext_attachment_feedback_loop_dynamic_state) try names.append(allocator, ExtensionNames.ext_attachment_feedback_loop_dynamic_state);
        if (self.khr_vertex_attribute_divisor) try names.append(allocator, ExtensionNames.khr_vertex_attribute_divisor);
        if (self.khr_load_store_op_none) try names.append(allocator, ExtensionNames.khr_load_store_op_none);
        if (self.khr_unified_image_layouts) try names.append(allocator, ExtensionNames.khr_unified_image_layouts);
        if (self.khr_shader_float_controls2) try names.append(allocator, ExtensionNames.khr_shader_float_controls2);
        if (self.msft_layered_driver) try names.append(allocator, ExtensionNames.msft_layered_driver);
        if (self.khr_index_type_uint8) try names.append(allocator, ExtensionNames.khr_index_type_uint8);
        if (self.khr_line_rasterization) try names.append(allocator, ExtensionNames.khr_line_rasterization);
        if (self.khr_calibrated_timestamps) try names.append(allocator, ExtensionNames.khr_calibrated_timestamps);
        if (self.khr_shader_expect_assume) try names.append(allocator, ExtensionNames.khr_shader_expect_assume);
        if (self.khr_maintenance6) try names.append(allocator, ExtensionNames.khr_maintenance6);
        if (self.nv_descriptor_pool_overallocation) try names.append(allocator, ExtensionNames.nv_descriptor_pool_overallocation);
        if (self.qcom_tile_memory_heap) try names.append(allocator, ExtensionNames.qcom_tile_memory_heap);
        if (self.nv_raw_access_chains) try names.append(allocator, ExtensionNames.nv_raw_access_chains);
        if (self.nv_external_compute_queue) try names.append(allocator, ExtensionNames.nv_external_compute_queue);
        if (self.khr_shader_relaxed_extended_instruction) try names.append(allocator, ExtensionNames.khr_shader_relaxed_extended_instruction);
        if (self.nv_command_buffer_inheritance) try names.append(allocator, ExtensionNames.nv_command_buffer_inheritance);
        if (self.khr_maintenance7) try names.append(allocator, ExtensionNames.khr_maintenance7);
        if (self.nv_shader_atomic_float16_vector) try names.append(allocator, ExtensionNames.nv_shader_atomic_float16_vector);
        if (self.ext_shader_replicated_composites) try names.append(allocator, ExtensionNames.ext_shader_replicated_composites);
        if (self.ext_shader_float8) try names.append(allocator, ExtensionNames.ext_shader_float8);
        if (self.nv_ray_tracing_validation) try names.append(allocator, ExtensionNames.nv_ray_tracing_validation);
        if (self.nv_cluster_acceleration_structure) try names.append(allocator, ExtensionNames.nv_cluster_acceleration_structure);
        if (self.nv_partitioned_acceleration_structure) try names.append(allocator, ExtensionNames.nv_partitioned_acceleration_structure);
        if (self.ext_device_generated_commands) try names.append(allocator, ExtensionNames.ext_device_generated_commands);
        if (self.khr_maintenance8) try names.append(allocator, ExtensionNames.khr_maintenance8);
        if (self.mesa_image_alignment_control) try names.append(allocator, ExtensionNames.mesa_image_alignment_control);
        if (self.ext_depth_clamp_control) try names.append(allocator, ExtensionNames.ext_depth_clamp_control);
        if (self.khr_maintenance9) try names.append(allocator, ExtensionNames.khr_maintenance9);
        if (self.huawei_hdr_vivid) try names.append(allocator, ExtensionNames.huawei_hdr_vivid);
        if (self.nv_cooperative_matrix2) try names.append(allocator, ExtensionNames.nv_cooperative_matrix2);
        if (self.arm_pipeline_opacity_micromap) try names.append(allocator, ExtensionNames.arm_pipeline_opacity_micromap);
        if (self.ext_external_memory_metal) try names.append(allocator, ExtensionNames.ext_external_memory_metal);
        if (self.khr_depth_clamp_zero_one) try names.append(allocator, ExtensionNames.khr_depth_clamp_zero_one);
        if (self.ext_vertex_attribute_robustness) try names.append(allocator, ExtensionNames.ext_vertex_attribute_robustness);
        if (self.arm_format_pack) try names.append(allocator, ExtensionNames.arm_format_pack);
        if (self.valve_fragment_density_map_layered) try names.append(allocator, ExtensionNames.valve_fragment_density_map_layered);
        if (self.khr_robustness2) try names.append(allocator, ExtensionNames.khr_robustness2);
        if (self.nv_present_metering) try names.append(allocator, ExtensionNames.nv_present_metering);
        if (self.ext_fragment_density_map_offset) try names.append(allocator, ExtensionNames.ext_fragment_density_map_offset);
        if (self.ext_zero_initialize_device_memory) try names.append(allocator, ExtensionNames.ext_zero_initialize_device_memory);
        if (self.khr_present_mode_fifo_latest_ready) try names.append(allocator, ExtensionNames.khr_present_mode_fifo_latest_ready);
        if (self.sec_pipeline_cache_incremental_mode) try names.append(allocator, ExtensionNames.sec_pipeline_cache_incremental_mode);
        return names.toOwnedSlice(allocator);
    }

    pub fn supports_khr_swapchain(self: DeviceExtensions) bool {
        return self.khr_swapchain;
    }
    pub fn enable_khr_swapchain(self: *DeviceExtensions) void {
        self.khr_swapchain = true;
    }

    pub fn supports_khr_display_swapchain(self: DeviceExtensions) bool {
        return self.khr_display_swapchain and self.supports_khr_swapchain();
    }
    pub fn enable_khr_display_swapchain(self: *DeviceExtensions) void {
        self.khr_display_swapchain = true;
        self.enable_khr_swapchain();
    }

    pub fn supports_nv_glsl_shader(self: DeviceExtensions) bool {
        return self.nv_glsl_shader;
    }
    pub fn enable_nv_glsl_shader(self: *DeviceExtensions) void {
        self.nv_glsl_shader = true;
    }

    pub fn supports_ext_depth_range_unrestricted(self: DeviceExtensions) bool {
        return self.ext_depth_range_unrestricted;
    }
    pub fn enable_ext_depth_range_unrestricted(self: *DeviceExtensions) void {
        self.ext_depth_range_unrestricted = true;
    }

    pub fn supports_khr_sampler_mirror_clamp_to_edge(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.khr_sampler_mirror_clamp_to_edge;
    }
    pub fn enable_khr_sampler_mirror_clamp_to_edge(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_sampler_mirror_clamp_to_edge = true;
        }
    }

    pub fn supports_img_filter_cubic(self: DeviceExtensions) bool {
        return self.img_filter_cubic;
    }
    pub fn enable_img_filter_cubic(self: *DeviceExtensions) void {
        self.img_filter_cubic = true;
    }

    pub fn supports_amd_rasterization_order(self: DeviceExtensions) bool {
        return self.amd_rasterization_order;
    }
    pub fn enable_amd_rasterization_order(self: *DeviceExtensions) void {
        self.amd_rasterization_order = true;
    }

    pub fn supports_amd_shader_trinary_minmax(self: DeviceExtensions) bool {
        return self.amd_shader_trinary_minmax;
    }
    pub fn enable_amd_shader_trinary_minmax(self: *DeviceExtensions) void {
        self.amd_shader_trinary_minmax = true;
    }

    pub fn supports_amd_shader_explicit_vertex_parameter(self: DeviceExtensions) bool {
        return self.amd_shader_explicit_vertex_parameter;
    }
    pub fn enable_amd_shader_explicit_vertex_parameter(self: *DeviceExtensions) void {
        self.amd_shader_explicit_vertex_parameter = true;
    }

    pub fn supports_ext_debug_marker(self: DeviceExtensions) bool {
        return self.ext_debug_marker;
    }
    pub fn enable_ext_debug_marker(self: *DeviceExtensions) void {
        self.ext_debug_marker = true;
    }

    pub fn supports_amd_gcn_shader(self: DeviceExtensions) bool {
        return self.amd_gcn_shader;
    }
    pub fn enable_amd_gcn_shader(self: *DeviceExtensions) void {
        self.amd_gcn_shader = true;
    }

    pub fn supports_nv_dedicated_allocation(self: DeviceExtensions) bool {
        return self.nv_dedicated_allocation;
    }
    pub fn enable_nv_dedicated_allocation(self: *DeviceExtensions) void {
        self.nv_dedicated_allocation = true;
    }

    pub fn supports_ext_transform_feedback(self: DeviceExtensions) bool {
        return self.ext_transform_feedback;
    }
    pub fn enable_ext_transform_feedback(self: *DeviceExtensions) void {
        self.ext_transform_feedback = true;
    }

    pub fn supports_nvx_binary_import(self: DeviceExtensions) bool {
        return self.nvx_binary_import;
    }
    pub fn enable_nvx_binary_import(self: *DeviceExtensions) void {
        self.nvx_binary_import = true;
    }

    pub fn supports_nvx_image_view_handle(self: DeviceExtensions) bool {
        return self.nvx_image_view_handle;
    }
    pub fn enable_nvx_image_view_handle(self: *DeviceExtensions) void {
        self.nvx_image_view_handle = true;
    }

    pub fn supports_amd_draw_indirect_count(self: DeviceExtensions) bool {
        return self.amd_draw_indirect_count;
    }
    pub fn enable_amd_draw_indirect_count(self: *DeviceExtensions) void {
        self.amd_draw_indirect_count = true;
    }

    pub fn supports_amd_negative_viewport_height(self: DeviceExtensions) bool {
        return self.amd_negative_viewport_height;
    }
    pub fn enable_amd_negative_viewport_height(self: *DeviceExtensions) void {
        self.amd_negative_viewport_height = true;
    }

    pub fn supports_amd_gpu_shader_half_float(self: DeviceExtensions) bool {
        return self.amd_gpu_shader_half_float;
    }
    pub fn enable_amd_gpu_shader_half_float(self: *DeviceExtensions) void {
        self.amd_gpu_shader_half_float = true;
    }

    pub fn supports_amd_shader_ballot(self: DeviceExtensions) bool {
        return self.amd_shader_ballot;
    }
    pub fn enable_amd_shader_ballot(self: *DeviceExtensions) void {
        self.amd_shader_ballot = true;
    }

    pub fn supports_amd_texture_gather_bias_lod(self: DeviceExtensions) bool {
        return self.amd_texture_gather_bias_lod;
    }
    pub fn enable_amd_texture_gather_bias_lod(self: *DeviceExtensions) void {
        self.amd_texture_gather_bias_lod = true;
    }

    pub fn supports_amd_shader_info(self: DeviceExtensions) bool {
        return self.amd_shader_info;
    }
    pub fn enable_amd_shader_info(self: *DeviceExtensions) void {
        self.amd_shader_info = true;
    }

    pub fn supports_khr_dynamic_rendering(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or (self.khr_dynamic_rendering and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_depth_stencil_resolve()));
    }
    pub fn enable_khr_dynamic_rendering(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.khr_dynamic_rendering = true;
            if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
                self.enable_khr_depth_stencil_resolve();
            }
        }
    }

    pub fn supports_amd_shader_image_load_store_lod(self: DeviceExtensions) bool {
        return self.amd_shader_image_load_store_lod;
    }
    pub fn enable_amd_shader_image_load_store_lod(self: *DeviceExtensions) void {
        self.amd_shader_image_load_store_lod = true;
    }

    pub fn supports_nv_corner_sampled_image(self: DeviceExtensions) bool {
        return self.nv_corner_sampled_image;
    }
    pub fn enable_nv_corner_sampled_image(self: *DeviceExtensions) void {
        self.nv_corner_sampled_image = true;
    }

    pub fn supports_khr_multiview(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_multiview;
    }
    pub fn enable_khr_multiview(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_multiview = true;
        }
    }

    pub fn supports_img_format_pvrtc(self: DeviceExtensions) bool {
        return self.img_format_pvrtc;
    }
    pub fn enable_img_format_pvrtc(self: *DeviceExtensions) void {
        self.img_format_pvrtc = true;
    }

    pub fn supports_nv_external_memory(self: DeviceExtensions) bool {
        return self.nv_external_memory;
    }
    pub fn enable_nv_external_memory(self: *DeviceExtensions) void {
        self.nv_external_memory = true;
    }

    pub fn supports_nv_external_memory_win32(self: DeviceExtensions) bool {
        return self.nv_external_memory_win32 and self.supports_nv_external_memory();
    }
    pub fn enable_nv_external_memory_win32(self: *DeviceExtensions) void {
        self.nv_external_memory_win32 = true;
        self.enable_nv_external_memory();
    }

    pub fn supports_nv_win32_keyed_mutex(self: DeviceExtensions) bool {
        return self.nv_win32_keyed_mutex and self.supports_nv_external_memory_win32();
    }
    pub fn enable_nv_win32_keyed_mutex(self: *DeviceExtensions) void {
        self.nv_win32_keyed_mutex = true;
        self.enable_nv_external_memory_win32();
    }

    pub fn supports_khr_device_group(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_device_group;
    }
    pub fn enable_khr_device_group(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_device_group = true;
        }
    }

    pub fn supports_khr_shader_draw_parameters(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_shader_draw_parameters;
    }
    pub fn enable_khr_shader_draw_parameters(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_shader_draw_parameters = true;
        }
    }

    pub fn supports_ext_shader_subgroup_ballot(self: DeviceExtensions) bool {
        return self.ext_shader_subgroup_ballot;
    }
    pub fn enable_ext_shader_subgroup_ballot(self: *DeviceExtensions) void {
        self.ext_shader_subgroup_ballot = true;
    }

    pub fn supports_ext_shader_subgroup_vote(self: DeviceExtensions) bool {
        return self.ext_shader_subgroup_vote;
    }
    pub fn enable_ext_shader_subgroup_vote(self: *DeviceExtensions) void {
        self.ext_shader_subgroup_vote = true;
    }

    pub fn supports_ext_texture_compression_astc_hdr(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.ext_texture_compression_astc_hdr;
    }
    pub fn enable_ext_texture_compression_astc_hdr(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.ext_texture_compression_astc_hdr = true;
        }
    }

    pub fn supports_ext_astc_decode_mode(self: DeviceExtensions) bool {
        return self.ext_astc_decode_mode;
    }
    pub fn enable_ext_astc_decode_mode(self: *DeviceExtensions) void {
        self.ext_astc_decode_mode = true;
    }

    pub fn supports_ext_pipeline_robustness(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.ext_pipeline_robustness;
    }
    pub fn enable_ext_pipeline_robustness(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.ext_pipeline_robustness = true;
        }
    }

    pub fn supports_khr_maintenance1(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_maintenance1;
    }
    pub fn enable_khr_maintenance1(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_maintenance1 = true;
        }
    }

    pub fn supports_khr_external_memory(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_external_memory;
    }
    pub fn enable_khr_external_memory(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_external_memory = true;
        }
    }

    pub fn supports_khr_external_memory_win32(self: DeviceExtensions) bool {
        return self.khr_external_memory_win32 and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory());
    }
    pub fn enable_khr_external_memory_win32(self: *DeviceExtensions) void {
        self.khr_external_memory_win32 = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_khr_external_memory_fd(self: DeviceExtensions) bool {
        return self.khr_external_memory_fd and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory());
    }
    pub fn enable_khr_external_memory_fd(self: *DeviceExtensions) void {
        self.khr_external_memory_fd = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_khr_win32_keyed_mutex(self: DeviceExtensions) bool {
        return self.khr_win32_keyed_mutex and self.supports_khr_external_memory_win32();
    }
    pub fn enable_khr_win32_keyed_mutex(self: *DeviceExtensions) void {
        self.khr_win32_keyed_mutex = true;
        self.enable_khr_external_memory_win32();
    }

    pub fn supports_khr_external_semaphore(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_external_semaphore;
    }
    pub fn enable_khr_external_semaphore(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_external_semaphore = true;
        }
    }

    pub fn supports_khr_external_semaphore_win32(self: DeviceExtensions) bool {
        return self.khr_external_semaphore_win32 and self.supports_khr_external_semaphore();
    }
    pub fn enable_khr_external_semaphore_win32(self: *DeviceExtensions) void {
        self.khr_external_semaphore_win32 = true;
        self.enable_khr_external_semaphore();
    }

    pub fn supports_khr_external_semaphore_fd(self: DeviceExtensions) bool {
        return self.khr_external_semaphore_fd and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_semaphore());
    }
    pub fn enable_khr_external_semaphore_fd(self: *DeviceExtensions) void {
        self.khr_external_semaphore_fd = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_semaphore();
        }
    }

    pub fn supports_khr_push_descriptor(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.khr_push_descriptor;
    }
    pub fn enable_khr_push_descriptor(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.khr_push_descriptor = true;
        }
    }

    pub fn supports_ext_conditional_rendering(self: DeviceExtensions) bool {
        return self.ext_conditional_rendering;
    }
    pub fn enable_ext_conditional_rendering(self: *DeviceExtensions) void {
        self.ext_conditional_rendering = true;
    }

    pub fn supports_khr_shader_float16_int8(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.khr_shader_float16_int8;
    }
    pub fn enable_khr_shader_float16_int8(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_shader_float16_int8 = true;
        }
    }

    pub fn supports_khr_16bit_storage(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.khr_16bit_storage and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_storage_buffer_storage_class()));
    }
    pub fn enable_khr_16bit_storage(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_16bit_storage = true;
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_storage_buffer_storage_class();
            }
        }
    }

    pub fn supports_khr_incremental_present(self: DeviceExtensions) bool {
        return self.khr_incremental_present and self.supports_khr_swapchain();
    }
    pub fn enable_khr_incremental_present(self: *DeviceExtensions) void {
        self.khr_incremental_present = true;
        self.enable_khr_swapchain();
    }

    pub fn supports_khr_descriptor_update_template(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_descriptor_update_template;
    }
    pub fn enable_khr_descriptor_update_template(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_descriptor_update_template = true;
        }
    }

    pub fn supports_nv_clip_space_w_scaling(self: DeviceExtensions) bool {
        return self.nv_clip_space_w_scaling;
    }
    pub fn enable_nv_clip_space_w_scaling(self: *DeviceExtensions) void {
        self.nv_clip_space_w_scaling = true;
    }

    pub fn supports_ext_display_control(self: DeviceExtensions) bool {
        return self.ext_display_control and self.supports_khr_swapchain();
    }
    pub fn enable_ext_display_control(self: *DeviceExtensions) void {
        self.ext_display_control = true;
        self.enable_khr_swapchain();
    }

    pub fn supports_google_display_timing(self: DeviceExtensions) bool {
        return self.google_display_timing and self.supports_khr_swapchain();
    }
    pub fn enable_google_display_timing(self: *DeviceExtensions) void {
        self.google_display_timing = true;
        self.enable_khr_swapchain();
    }

    pub fn supports_nv_sample_mask_override_coverage(self: DeviceExtensions) bool {
        return self.nv_sample_mask_override_coverage;
    }
    pub fn enable_nv_sample_mask_override_coverage(self: *DeviceExtensions) void {
        self.nv_sample_mask_override_coverage = true;
    }

    pub fn supports_nv_geometry_shader_passthrough(self: DeviceExtensions) bool {
        return self.nv_geometry_shader_passthrough;
    }
    pub fn enable_nv_geometry_shader_passthrough(self: *DeviceExtensions) void {
        self.nv_geometry_shader_passthrough = true;
    }

    pub fn supports_nv_viewport_array2(self: DeviceExtensions) bool {
        return self.nv_viewport_array2;
    }
    pub fn enable_nv_viewport_array2(self: *DeviceExtensions) void {
        self.nv_viewport_array2 = true;
    }

    pub fn supports_nvx_multiview_per_view_attributes(self: DeviceExtensions) bool {
        return self.nvx_multiview_per_view_attributes and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_multiview());
    }
    pub fn enable_nvx_multiview_per_view_attributes(self: *DeviceExtensions) void {
        self.nvx_multiview_per_view_attributes = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_multiview();
        }
    }

    pub fn supports_nv_viewport_swizzle(self: DeviceExtensions) bool {
        return self.nv_viewport_swizzle;
    }
    pub fn enable_nv_viewport_swizzle(self: *DeviceExtensions) void {
        self.nv_viewport_swizzle = true;
    }

    pub fn supports_ext_discard_rectangles(self: DeviceExtensions) bool {
        return self.ext_discard_rectangles;
    }
    pub fn enable_ext_discard_rectangles(self: *DeviceExtensions) void {
        self.ext_discard_rectangles = true;
    }

    pub fn supports_ext_conservative_rasterization(self: DeviceExtensions) bool {
        return self.ext_conservative_rasterization;
    }
    pub fn enable_ext_conservative_rasterization(self: *DeviceExtensions) void {
        self.ext_conservative_rasterization = true;
    }

    pub fn supports_ext_depth_clip_enable(self: DeviceExtensions) bool {
        return self.ext_depth_clip_enable;
    }
    pub fn enable_ext_depth_clip_enable(self: *DeviceExtensions) void {
        self.ext_depth_clip_enable = true;
    }

    pub fn supports_ext_hdr_metadata(self: DeviceExtensions) bool {
        return self.ext_hdr_metadata and self.supports_khr_swapchain();
    }
    pub fn enable_ext_hdr_metadata(self: *DeviceExtensions) void {
        self.ext_hdr_metadata = true;
        self.enable_khr_swapchain();
    }

    pub fn supports_khr_imageless_framebuffer(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.khr_imageless_framebuffer and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_maintenance2()) and self.supports_khr_image_format_list())));
    }
    pub fn enable_khr_imageless_framebuffer(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_imageless_framebuffer = true;
            if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
                if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                    self.enable_khr_maintenance2();
                }
                self.enable_khr_image_format_list();
            }
        }
    }

    pub fn supports_khr_create_renderpass2(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.khr_create_renderpass2 and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.supports_khr_multiview() and self.supports_khr_maintenance2())));
    }
    pub fn enable_khr_create_renderpass2(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_create_renderpass2 = true;
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_multiview();
                self.enable_khr_maintenance2();
            }
        }
    }

    pub fn supports_img_relaxed_line_rasterization(self: DeviceExtensions) bool {
        return self.img_relaxed_line_rasterization;
    }
    pub fn enable_img_relaxed_line_rasterization(self: *DeviceExtensions) void {
        self.img_relaxed_line_rasterization = true;
    }

    pub fn supports_khr_shared_presentable_image(self: DeviceExtensions) bool {
        return self.khr_shared_presentable_image and self.supports_khr_swapchain();
    }
    pub fn enable_khr_shared_presentable_image(self: *DeviceExtensions) void {
        self.khr_shared_presentable_image = true;
        self.enable_khr_swapchain();
    }

    pub fn supports_khr_external_fence(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_external_fence;
    }
    pub fn enable_khr_external_fence(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_external_fence = true;
        }
    }

    pub fn supports_khr_external_fence_win32(self: DeviceExtensions) bool {
        return self.khr_external_fence_win32 and self.supports_khr_external_fence();
    }
    pub fn enable_khr_external_fence_win32(self: *DeviceExtensions) void {
        self.khr_external_fence_win32 = true;
        self.enable_khr_external_fence();
    }

    pub fn supports_khr_external_fence_fd(self: DeviceExtensions) bool {
        return self.khr_external_fence_fd and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_fence());
    }
    pub fn enable_khr_external_fence_fd(self: *DeviceExtensions) void {
        self.khr_external_fence_fd = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_fence();
        }
    }

    pub fn supports_khr_performance_query(self: DeviceExtensions) bool {
        return self.khr_performance_query;
    }
    pub fn enable_khr_performance_query(self: *DeviceExtensions) void {
        self.khr_performance_query = true;
    }

    pub fn supports_khr_maintenance2(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_maintenance2;
    }
    pub fn enable_khr_maintenance2(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_maintenance2 = true;
        }
    }

    pub fn supports_khr_variable_pointers(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.khr_variable_pointers and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_storage_buffer_storage_class()));
    }
    pub fn enable_khr_variable_pointers(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_variable_pointers = true;
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_storage_buffer_storage_class();
            }
        }
    }

    pub fn supports_ext_external_memory_dma_buf(self: DeviceExtensions) bool {
        return self.ext_external_memory_dma_buf and self.supports_khr_external_memory_fd();
    }
    pub fn enable_ext_external_memory_dma_buf(self: *DeviceExtensions) void {
        self.ext_external_memory_dma_buf = true;
        self.enable_khr_external_memory_fd();
    }

    pub fn supports_ext_queue_family_foreign(self: DeviceExtensions) bool {
        return self.ext_queue_family_foreign and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory());
    }
    pub fn enable_ext_queue_family_foreign(self: *DeviceExtensions) void {
        self.ext_queue_family_foreign = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_khr_dedicated_allocation(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.khr_dedicated_allocation and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_memory_requirements2()));
    }
    pub fn enable_khr_dedicated_allocation(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_dedicated_allocation = true;
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_get_memory_requirements2();
            }
        }
    }

    pub fn supports_android_external_memory_android_hardware_buffer(self: DeviceExtensions) bool {
        return self.android_external_memory_android_hardware_buffer and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.supports_khr_sampler_ycbcr_conversion() and self.supports_khr_external_memory() and self.supports_khr_dedicated_allocation())) and self.supports_ext_queue_family_foreign();
    }
    pub fn enable_android_external_memory_android_hardware_buffer(self: *DeviceExtensions) void {
        self.android_external_memory_android_hardware_buffer = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_sampler_ycbcr_conversion();
            self.enable_khr_external_memory();
            self.enable_khr_dedicated_allocation();
        }
        self.enable_ext_queue_family_foreign();
    }

    pub fn supports_ext_sampler_filter_minmax(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.ext_sampler_filter_minmax;
    }
    pub fn enable_ext_sampler_filter_minmax(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.ext_sampler_filter_minmax = true;
        }
    }

    pub fn supports_khr_storage_buffer_storage_class(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_storage_buffer_storage_class;
    }
    pub fn enable_khr_storage_buffer_storage_class(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_storage_buffer_storage_class = true;
        }
    }

    pub fn supports_amd_gpu_shader_int16(self: DeviceExtensions) bool {
        return self.amd_gpu_shader_int16;
    }
    pub fn enable_amd_gpu_shader_int16(self: *DeviceExtensions) void {
        self.amd_gpu_shader_int16 = true;
    }

    pub fn supports_amdx_shader_enqueue(self: DeviceExtensions) bool {
        return self.amdx_shader_enqueue and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or (self.supports_khr_synchronization2() and self.supports_khr_spirv_1_4() and self.supports_ext_extended_dynamic_state())) and self.supports_khr_maintenance5() and self.supports_khr_pipeline_library();
    }
    pub fn enable_amdx_shader_enqueue(self: *DeviceExtensions) void {
        self.amdx_shader_enqueue = true;
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_synchronization2();
            self.enable_khr_spirv_1_4();
            self.enable_ext_extended_dynamic_state();
        }
        self.enable_khr_maintenance5();
        self.enable_khr_pipeline_library();
    }

    pub fn supports_amd_mixed_attachment_samples(self: DeviceExtensions) bool {
        return self.amd_mixed_attachment_samples;
    }
    pub fn enable_amd_mixed_attachment_samples(self: *DeviceExtensions) void {
        self.amd_mixed_attachment_samples = true;
    }

    pub fn supports_amd_shader_fragment_mask(self: DeviceExtensions) bool {
        return self.amd_shader_fragment_mask;
    }
    pub fn enable_amd_shader_fragment_mask(self: *DeviceExtensions) void {
        self.amd_shader_fragment_mask = true;
    }

    pub fn supports_ext_inline_uniform_block(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or (self.ext_inline_uniform_block and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_maintenance1()));
    }
    pub fn enable_ext_inline_uniform_block(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.ext_inline_uniform_block = true;
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_maintenance1();
            }
        }
    }

    pub fn supports_ext_shader_stencil_export(self: DeviceExtensions) bool {
        return self.ext_shader_stencil_export;
    }
    pub fn enable_ext_shader_stencil_export(self: *DeviceExtensions) void {
        self.ext_shader_stencil_export = true;
    }

    pub fn supports_khr_shader_bfloat16(self: DeviceExtensions) bool {
        return self.khr_shader_bfloat16;
    }
    pub fn enable_khr_shader_bfloat16(self: *DeviceExtensions) void {
        self.khr_shader_bfloat16 = true;
    }

    pub fn supports_ext_sample_locations(self: DeviceExtensions) bool {
        return self.ext_sample_locations;
    }
    pub fn enable_ext_sample_locations(self: *DeviceExtensions) void {
        self.ext_sample_locations = true;
    }

    pub fn supports_khr_relaxed_block_layout(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_relaxed_block_layout;
    }
    pub fn enable_khr_relaxed_block_layout(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_relaxed_block_layout = true;
        }
    }

    pub fn supports_khr_get_memory_requirements2(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_get_memory_requirements2;
    }
    pub fn enable_khr_get_memory_requirements2(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_get_memory_requirements2 = true;
        }
    }

    pub fn supports_khr_image_format_list(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.khr_image_format_list;
    }
    pub fn enable_khr_image_format_list(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_image_format_list = true;
        }
    }

    pub fn supports_ext_blend_operation_advanced(self: DeviceExtensions) bool {
        return self.ext_blend_operation_advanced;
    }
    pub fn enable_ext_blend_operation_advanced(self: *DeviceExtensions) void {
        self.ext_blend_operation_advanced = true;
    }

    pub fn supports_nv_fragment_coverage_to_color(self: DeviceExtensions) bool {
        return self.nv_fragment_coverage_to_color;
    }
    pub fn enable_nv_fragment_coverage_to_color(self: *DeviceExtensions) void {
        self.nv_fragment_coverage_to_color = true;
    }

    pub fn supports_khr_acceleration_structure(self: DeviceExtensions) bool {
        return self.khr_acceleration_structure and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.core_version.to_int() >= make_version(1, 1, 0).to_int() and self.supports_ext_descriptor_indexing() and self.supports_khr_buffer_device_address())) and self.supports_khr_deferred_host_operations();
    }
    pub fn enable_khr_acceleration_structure(self: *DeviceExtensions) void {
        self.khr_acceleration_structure = true;
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
            self.enable_ext_descriptor_indexing();
            self.enable_khr_buffer_device_address();
        }
        self.enable_khr_deferred_host_operations();
    }

    pub fn supports_khr_ray_tracing_pipeline(self: DeviceExtensions) bool {
        return self.khr_ray_tracing_pipeline and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_spirv_1_4()) and self.supports_khr_acceleration_structure();
    }
    pub fn enable_khr_ray_tracing_pipeline(self: *DeviceExtensions) void {
        self.khr_ray_tracing_pipeline = true;
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_spirv_1_4();
        }
        self.enable_khr_acceleration_structure();
    }

    pub fn supports_khr_ray_query(self: DeviceExtensions) bool {
        return self.khr_ray_query and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_spirv_1_4()) and self.supports_khr_acceleration_structure();
    }
    pub fn enable_khr_ray_query(self: *DeviceExtensions) void {
        self.khr_ray_query = true;
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_spirv_1_4();
        }
        self.enable_khr_acceleration_structure();
    }

    pub fn supports_nv_framebuffer_mixed_samples(self: DeviceExtensions) bool {
        return self.nv_framebuffer_mixed_samples;
    }
    pub fn enable_nv_framebuffer_mixed_samples(self: *DeviceExtensions) void {
        self.nv_framebuffer_mixed_samples = true;
    }

    pub fn supports_nv_fill_rectangle(self: DeviceExtensions) bool {
        return self.nv_fill_rectangle;
    }
    pub fn enable_nv_fill_rectangle(self: *DeviceExtensions) void {
        self.nv_fill_rectangle = true;
    }

    pub fn supports_nv_shader_sm_builtins(self: DeviceExtensions) bool {
        return self.nv_shader_sm_builtins and self.core_version.to_int() >= make_version(1, 1, 0).to_int();
    }
    pub fn enable_nv_shader_sm_builtins(self: *DeviceExtensions) void {
        self.nv_shader_sm_builtins = true;
        // depends on minimum core version, caller must specify
        assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
    }

    pub fn supports_ext_post_depth_coverage(self: DeviceExtensions) bool {
        return self.ext_post_depth_coverage;
    }
    pub fn enable_ext_post_depth_coverage(self: *DeviceExtensions) void {
        self.ext_post_depth_coverage = true;
    }

    pub fn supports_khr_sampler_ycbcr_conversion(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.khr_sampler_ycbcr_conversion and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.supports_khr_maintenance1() and self.supports_khr_bind_memory2() and self.supports_khr_get_memory_requirements2())));
    }
    pub fn enable_khr_sampler_ycbcr_conversion(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_sampler_ycbcr_conversion = true;
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_maintenance1();
                self.enable_khr_bind_memory2();
                self.enable_khr_get_memory_requirements2();
            }
        }
    }

    pub fn supports_khr_bind_memory2(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_bind_memory2;
    }
    pub fn enable_khr_bind_memory2(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_bind_memory2 = true;
        }
    }

    pub fn supports_ext_image_drm_format_modifier(self: DeviceExtensions) bool {
        return self.ext_image_drm_format_modifier and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 1, 0).to_int() or (self.supports_khr_bind_memory2() and self.supports_khr_sampler_ycbcr_conversion())) and self.supports_khr_image_format_list()));
    }
    pub fn enable_ext_image_drm_format_modifier(self: *DeviceExtensions) void {
        self.ext_image_drm_format_modifier = true;
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_bind_memory2();
                self.enable_khr_sampler_ycbcr_conversion();
            }
            self.enable_khr_image_format_list();
        }
    }

    pub fn supports_ext_validation_cache(self: DeviceExtensions) bool {
        return self.ext_validation_cache;
    }
    pub fn enable_ext_validation_cache(self: *DeviceExtensions) void {
        self.ext_validation_cache = true;
    }

    pub fn supports_ext_descriptor_indexing(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.ext_descriptor_indexing and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_maintenance3()));
    }
    pub fn enable_ext_descriptor_indexing(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.ext_descriptor_indexing = true;
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_maintenance3();
            }
        }
    }

    pub fn supports_ext_shader_viewport_index_layer(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.ext_shader_viewport_index_layer;
    }
    pub fn enable_ext_shader_viewport_index_layer(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.ext_shader_viewport_index_layer = true;
        }
    }

    pub fn supports_khr_portability_subset(self: DeviceExtensions) bool {
        return self.khr_portability_subset;
    }
    pub fn enable_khr_portability_subset(self: *DeviceExtensions) void {
        self.khr_portability_subset = true;
    }

    pub fn supports_nv_shading_rate_image(self: DeviceExtensions) bool {
        return self.nv_shading_rate_image;
    }
    pub fn enable_nv_shading_rate_image(self: *DeviceExtensions) void {
        self.nv_shading_rate_image = true;
    }

    pub fn supports_nv_ray_tracing(self: DeviceExtensions) bool {
        return self.nv_ray_tracing and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_memory_requirements2());
    }
    pub fn enable_nv_ray_tracing(self: *DeviceExtensions) void {
        self.nv_ray_tracing = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_memory_requirements2();
        }
    }

    pub fn supports_nv_representative_fragment_test(self: DeviceExtensions) bool {
        return self.nv_representative_fragment_test;
    }
    pub fn enable_nv_representative_fragment_test(self: *DeviceExtensions) void {
        self.nv_representative_fragment_test = true;
    }

    pub fn supports_khr_maintenance3(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.khr_maintenance3;
    }
    pub fn enable_khr_maintenance3(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.khr_maintenance3 = true;
        }
    }

    pub fn supports_khr_draw_indirect_count(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.khr_draw_indirect_count;
    }
    pub fn enable_khr_draw_indirect_count(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_draw_indirect_count = true;
        }
    }

    pub fn supports_ext_filter_cubic(self: DeviceExtensions) bool {
        return self.ext_filter_cubic;
    }
    pub fn enable_ext_filter_cubic(self: *DeviceExtensions) void {
        self.ext_filter_cubic = true;
    }

    pub fn supports_qcom_render_pass_shader_resolve(self: DeviceExtensions) bool {
        return self.qcom_render_pass_shader_resolve;
    }
    pub fn enable_qcom_render_pass_shader_resolve(self: *DeviceExtensions) void {
        self.qcom_render_pass_shader_resolve = true;
    }

    pub fn supports_ext_global_priority(self: DeviceExtensions) bool {
        return self.ext_global_priority;
    }
    pub fn enable_ext_global_priority(self: *DeviceExtensions) void {
        self.ext_global_priority = true;
    }

    pub fn supports_khr_shader_subgroup_extended_types(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.khr_shader_subgroup_extended_types and self.core_version.to_int() >= make_version(1, 1, 0).to_int());
    }
    pub fn enable_khr_shader_subgroup_extended_types(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_shader_subgroup_extended_types = true;
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
        }
    }

    pub fn supports_khr_8bit_storage(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.khr_8bit_storage and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_storage_buffer_storage_class()));
    }
    pub fn enable_khr_8bit_storage(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_8bit_storage = true;
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_storage_buffer_storage_class();
            }
        }
    }

    pub fn supports_ext_external_memory_host(self: DeviceExtensions) bool {
        return self.ext_external_memory_host and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory());
    }
    pub fn enable_ext_external_memory_host(self: *DeviceExtensions) void {
        self.ext_external_memory_host = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_amd_buffer_marker(self: DeviceExtensions) bool {
        return self.amd_buffer_marker;
    }
    pub fn enable_amd_buffer_marker(self: *DeviceExtensions) void {
        self.amd_buffer_marker = true;
    }

    pub fn supports_khr_shader_atomic_int64(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.khr_shader_atomic_int64;
    }
    pub fn enable_khr_shader_atomic_int64(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_shader_atomic_int64 = true;
        }
    }

    pub fn supports_khr_shader_clock(self: DeviceExtensions) bool {
        return self.khr_shader_clock;
    }
    pub fn enable_khr_shader_clock(self: *DeviceExtensions) void {
        self.khr_shader_clock = true;
    }

    pub fn supports_amd_pipeline_compiler_control(self: DeviceExtensions) bool {
        return self.amd_pipeline_compiler_control;
    }
    pub fn enable_amd_pipeline_compiler_control(self: *DeviceExtensions) void {
        self.amd_pipeline_compiler_control = true;
    }

    pub fn supports_ext_calibrated_timestamps(self: DeviceExtensions) bool {
        return self.ext_calibrated_timestamps;
    }
    pub fn enable_ext_calibrated_timestamps(self: *DeviceExtensions) void {
        self.ext_calibrated_timestamps = true;
    }

    pub fn supports_amd_shader_core_properties(self: DeviceExtensions) bool {
        return self.amd_shader_core_properties;
    }
    pub fn enable_amd_shader_core_properties(self: *DeviceExtensions) void {
        self.amd_shader_core_properties = true;
    }

    pub fn supports_khr_global_priority(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.khr_global_priority;
    }
    pub fn enable_khr_global_priority(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.khr_global_priority = true;
        }
    }

    pub fn supports_amd_memory_overallocation_behavior(self: DeviceExtensions) bool {
        return self.amd_memory_overallocation_behavior;
    }
    pub fn enable_amd_memory_overallocation_behavior(self: *DeviceExtensions) void {
        self.amd_memory_overallocation_behavior = true;
    }

    pub fn supports_ext_vertex_attribute_divisor(self: DeviceExtensions) bool {
        return self.ext_vertex_attribute_divisor;
    }
    pub fn enable_ext_vertex_attribute_divisor(self: *DeviceExtensions) void {
        self.ext_vertex_attribute_divisor = true;
    }

    pub fn supports_ext_pipeline_creation_feedback(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.ext_pipeline_creation_feedback;
    }
    pub fn enable_ext_pipeline_creation_feedback(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.ext_pipeline_creation_feedback = true;
        }
    }

    pub fn supports_khr_driver_properties(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.khr_driver_properties;
    }
    pub fn enable_khr_driver_properties(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_driver_properties = true;
        }
    }

    pub fn supports_khr_shader_float_controls(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.khr_shader_float_controls;
    }
    pub fn enable_khr_shader_float_controls(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_shader_float_controls = true;
        }
    }

    pub fn supports_nv_shader_subgroup_partitioned(self: DeviceExtensions) bool {
        return self.nv_shader_subgroup_partitioned and self.core_version.to_int() >= make_version(1, 1, 0).to_int();
    }
    pub fn enable_nv_shader_subgroup_partitioned(self: *DeviceExtensions) void {
        self.nv_shader_subgroup_partitioned = true;
        // depends on minimum core version, caller must specify
        assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
    }

    pub fn supports_khr_depth_stencil_resolve(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.khr_depth_stencil_resolve and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_create_renderpass2()));
    }
    pub fn enable_khr_depth_stencil_resolve(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_depth_stencil_resolve = true;
            if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
                self.enable_khr_create_renderpass2();
            }
        }
    }

    pub fn supports_khr_swapchain_mutable_format(self: DeviceExtensions) bool {
        return self.khr_swapchain_mutable_format and self.supports_khr_swapchain() and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_maintenance2()) and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_image_format_list());
    }
    pub fn enable_khr_swapchain_mutable_format(self: *DeviceExtensions) void {
        self.khr_swapchain_mutable_format = true;
        self.enable_khr_swapchain();
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_maintenance2();
        }
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_image_format_list();
        }
    }

    pub fn supports_nv_compute_shader_derivatives(self: DeviceExtensions) bool {
        return self.nv_compute_shader_derivatives;
    }
    pub fn enable_nv_compute_shader_derivatives(self: *DeviceExtensions) void {
        self.nv_compute_shader_derivatives = true;
    }

    pub fn supports_nv_mesh_shader(self: DeviceExtensions) bool {
        return self.nv_mesh_shader;
    }
    pub fn enable_nv_mesh_shader(self: *DeviceExtensions) void {
        self.nv_mesh_shader = true;
    }

    pub fn supports_nv_fragment_shader_barycentric(self: DeviceExtensions) bool {
        return self.nv_fragment_shader_barycentric;
    }
    pub fn enable_nv_fragment_shader_barycentric(self: *DeviceExtensions) void {
        self.nv_fragment_shader_barycentric = true;
    }

    pub fn supports_nv_shader_image_footprint(self: DeviceExtensions) bool {
        return self.nv_shader_image_footprint;
    }
    pub fn enable_nv_shader_image_footprint(self: *DeviceExtensions) void {
        self.nv_shader_image_footprint = true;
    }

    pub fn supports_nv_scissor_exclusive(self: DeviceExtensions) bool {
        return self.nv_scissor_exclusive;
    }
    pub fn enable_nv_scissor_exclusive(self: *DeviceExtensions) void {
        self.nv_scissor_exclusive = true;
    }

    pub fn supports_nv_device_diagnostic_checkpoints(self: DeviceExtensions) bool {
        return self.nv_device_diagnostic_checkpoints;
    }
    pub fn enable_nv_device_diagnostic_checkpoints(self: *DeviceExtensions) void {
        self.nv_device_diagnostic_checkpoints = true;
    }

    pub fn supports_khr_timeline_semaphore(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.khr_timeline_semaphore;
    }
    pub fn enable_khr_timeline_semaphore(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_timeline_semaphore = true;
        }
    }

    pub fn supports_intel_shader_integer_functions2(self: DeviceExtensions) bool {
        return self.intel_shader_integer_functions2;
    }
    pub fn enable_intel_shader_integer_functions2(self: *DeviceExtensions) void {
        self.intel_shader_integer_functions2 = true;
    }

    pub fn supports_intel_performance_query(self: DeviceExtensions) bool {
        return self.intel_performance_query;
    }
    pub fn enable_intel_performance_query(self: *DeviceExtensions) void {
        self.intel_performance_query = true;
    }

    pub fn supports_khr_vulkan_memory_model(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.khr_vulkan_memory_model;
    }
    pub fn enable_khr_vulkan_memory_model(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_vulkan_memory_model = true;
        }
    }

    pub fn supports_ext_pci_bus_info(self: DeviceExtensions) bool {
        return self.ext_pci_bus_info;
    }
    pub fn enable_ext_pci_bus_info(self: *DeviceExtensions) void {
        self.ext_pci_bus_info = true;
    }

    pub fn supports_amd_display_native_hdr(self: DeviceExtensions) bool {
        return self.amd_display_native_hdr and self.supports_khr_swapchain();
    }
    pub fn enable_amd_display_native_hdr(self: *DeviceExtensions) void {
        self.amd_display_native_hdr = true;
        self.enable_khr_swapchain();
    }

    pub fn supports_khr_shader_terminate_invocation(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.khr_shader_terminate_invocation;
    }
    pub fn enable_khr_shader_terminate_invocation(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.khr_shader_terminate_invocation = true;
        }
    }

    pub fn supports_ext_fragment_density_map(self: DeviceExtensions) bool {
        return self.ext_fragment_density_map;
    }
    pub fn enable_ext_fragment_density_map(self: *DeviceExtensions) void {
        self.ext_fragment_density_map = true;
    }

    pub fn supports_ext_scalar_block_layout(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.ext_scalar_block_layout;
    }
    pub fn enable_ext_scalar_block_layout(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.ext_scalar_block_layout = true;
        }
    }

    pub fn supports_google_hlsl_functionality1(self: DeviceExtensions) bool {
        return self.google_hlsl_functionality1;
    }
    pub fn enable_google_hlsl_functionality1(self: *DeviceExtensions) void {
        self.google_hlsl_functionality1 = true;
    }

    pub fn supports_google_decorate_string(self: DeviceExtensions) bool {
        return self.google_decorate_string;
    }
    pub fn enable_google_decorate_string(self: *DeviceExtensions) void {
        self.google_decorate_string = true;
    }

    pub fn supports_ext_subgroup_size_control(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or (self.ext_subgroup_size_control and self.core_version.to_int() >= make_version(1, 1, 0).to_int());
    }
    pub fn enable_ext_subgroup_size_control(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.ext_subgroup_size_control = true;
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
        }
    }

    pub fn supports_khr_fragment_shading_rate(self: DeviceExtensions) bool {
        return self.khr_fragment_shading_rate and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_create_renderpass2());
    }
    pub fn enable_khr_fragment_shading_rate(self: *DeviceExtensions) void {
        self.khr_fragment_shading_rate = true;
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_create_renderpass2();
        }
    }

    pub fn supports_amd_shader_core_properties2(self: DeviceExtensions) bool {
        return self.amd_shader_core_properties2 and self.supports_amd_shader_core_properties();
    }
    pub fn enable_amd_shader_core_properties2(self: *DeviceExtensions) void {
        self.amd_shader_core_properties2 = true;
        self.enable_amd_shader_core_properties();
    }

    pub fn supports_amd_device_coherent_memory(self: DeviceExtensions) bool {
        return self.amd_device_coherent_memory;
    }
    pub fn enable_amd_device_coherent_memory(self: *DeviceExtensions) void {
        self.amd_device_coherent_memory = true;
    }

    pub fn supports_khr_dynamic_rendering_local_read(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or (self.khr_dynamic_rendering_local_read and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_dynamic_rendering()));
    }
    pub fn enable_khr_dynamic_rendering_local_read(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.khr_dynamic_rendering_local_read = true;
            if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
                self.enable_khr_dynamic_rendering();
            }
        }
    }

    pub fn supports_ext_shader_image_atomic_int64(self: DeviceExtensions) bool {
        return self.ext_shader_image_atomic_int64;
    }
    pub fn enable_ext_shader_image_atomic_int64(self: *DeviceExtensions) void {
        self.ext_shader_image_atomic_int64 = true;
    }

    pub fn supports_khr_shader_quad_control(self: DeviceExtensions) bool {
        return self.khr_shader_quad_control and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.core_version.to_int() >= make_version(1, 1, 0).to_int() and self.supports_khr_vulkan_memory_model())) and self.supports_khr_shader_maximal_reconvergence();
    }
    pub fn enable_khr_shader_quad_control(self: *DeviceExtensions) void {
        self.khr_shader_quad_control = true;
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
            self.enable_khr_vulkan_memory_model();
        }
        self.enable_khr_shader_maximal_reconvergence();
    }

    pub fn supports_khr_spirv_1_4(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.khr_spirv_1_4 and self.core_version.to_int() >= make_version(1, 1, 0).to_int() and self.supports_khr_shader_float_controls());
    }
    pub fn enable_khr_spirv_1_4(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_spirv_1_4 = true;
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
            self.enable_khr_shader_float_controls();
        }
    }

    pub fn supports_ext_memory_budget(self: DeviceExtensions) bool {
        return self.ext_memory_budget;
    }
    pub fn enable_ext_memory_budget(self: *DeviceExtensions) void {
        self.ext_memory_budget = true;
    }

    pub fn supports_ext_memory_priority(self: DeviceExtensions) bool {
        return self.ext_memory_priority;
    }
    pub fn enable_ext_memory_priority(self: *DeviceExtensions) void {
        self.ext_memory_priority = true;
    }

    pub fn supports_nv_dedicated_allocation_image_aliasing(self: DeviceExtensions) bool {
        return self.nv_dedicated_allocation_image_aliasing and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_dedicated_allocation());
    }
    pub fn enable_nv_dedicated_allocation_image_aliasing(self: *DeviceExtensions) void {
        self.nv_dedicated_allocation_image_aliasing = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_dedicated_allocation();
        }
    }

    pub fn supports_khr_separate_depth_stencil_layouts(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.khr_separate_depth_stencil_layouts and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_create_renderpass2()));
    }
    pub fn enable_khr_separate_depth_stencil_layouts(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_separate_depth_stencil_layouts = true;
            if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
                self.enable_khr_create_renderpass2();
            }
        }
    }

    pub fn supports_ext_buffer_device_address(self: DeviceExtensions) bool {
        return self.ext_buffer_device_address;
    }
    pub fn enable_ext_buffer_device_address(self: *DeviceExtensions) void {
        self.ext_buffer_device_address = true;
    }

    pub fn supports_ext_tooling_info(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.ext_tooling_info;
    }
    pub fn enable_ext_tooling_info(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.ext_tooling_info = true;
        }
    }

    pub fn supports_ext_separate_stencil_usage(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.ext_separate_stencil_usage;
    }
    pub fn enable_ext_separate_stencil_usage(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.ext_separate_stencil_usage = true;
        }
    }

    pub fn supports_khr_present_wait(self: DeviceExtensions) bool {
        return self.khr_present_wait and self.supports_khr_swapchain() and self.supports_khr_present_id();
    }
    pub fn enable_khr_present_wait(self: *DeviceExtensions) void {
        self.khr_present_wait = true;
        self.enable_khr_swapchain();
        self.enable_khr_present_id();
    }

    pub fn supports_nv_cooperative_matrix(self: DeviceExtensions) bool {
        return self.nv_cooperative_matrix;
    }
    pub fn enable_nv_cooperative_matrix(self: *DeviceExtensions) void {
        self.nv_cooperative_matrix = true;
    }

    pub fn supports_nv_coverage_reduction_mode(self: DeviceExtensions) bool {
        return self.nv_coverage_reduction_mode and self.supports_nv_framebuffer_mixed_samples();
    }
    pub fn enable_nv_coverage_reduction_mode(self: *DeviceExtensions) void {
        self.nv_coverage_reduction_mode = true;
        self.enable_nv_framebuffer_mixed_samples();
    }

    pub fn supports_ext_fragment_shader_interlock(self: DeviceExtensions) bool {
        return self.ext_fragment_shader_interlock;
    }
    pub fn enable_ext_fragment_shader_interlock(self: *DeviceExtensions) void {
        self.ext_fragment_shader_interlock = true;
    }

    pub fn supports_ext_ycbcr_image_arrays(self: DeviceExtensions) bool {
        return self.ext_ycbcr_image_arrays and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_sampler_ycbcr_conversion());
    }
    pub fn enable_ext_ycbcr_image_arrays(self: *DeviceExtensions) void {
        self.ext_ycbcr_image_arrays = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_sampler_ycbcr_conversion();
        }
    }

    pub fn supports_khr_uniform_buffer_standard_layout(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.khr_uniform_buffer_standard_layout;
    }
    pub fn enable_khr_uniform_buffer_standard_layout(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_uniform_buffer_standard_layout = true;
        }
    }

    pub fn supports_ext_provoking_vertex(self: DeviceExtensions) bool {
        return self.ext_provoking_vertex;
    }
    pub fn enable_ext_provoking_vertex(self: *DeviceExtensions) void {
        self.ext_provoking_vertex = true;
    }

    pub fn supports_ext_full_screen_exclusive(self: DeviceExtensions) bool {
        return self.ext_full_screen_exclusive and self.supports_khr_swapchain();
    }
    pub fn enable_ext_full_screen_exclusive(self: *DeviceExtensions) void {
        self.ext_full_screen_exclusive = true;
        self.enable_khr_swapchain();
    }

    pub fn supports_khr_buffer_device_address(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.khr_buffer_device_address and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_device_group()));
    }
    pub fn enable_khr_buffer_device_address(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.khr_buffer_device_address = true;
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_device_group();
            }
        }
    }

    pub fn supports_ext_line_rasterization(self: DeviceExtensions) bool {
        return self.ext_line_rasterization;
    }
    pub fn enable_ext_line_rasterization(self: *DeviceExtensions) void {
        self.ext_line_rasterization = true;
    }

    pub fn supports_ext_shader_atomic_float(self: DeviceExtensions) bool {
        return self.ext_shader_atomic_float;
    }
    pub fn enable_ext_shader_atomic_float(self: *DeviceExtensions) void {
        self.ext_shader_atomic_float = true;
    }

    pub fn supports_ext_host_query_reset(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.ext_host_query_reset;
    }
    pub fn enable_ext_host_query_reset(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.ext_host_query_reset = true;
        }
    }

    pub fn supports_ext_index_type_uint8(self: DeviceExtensions) bool {
        return self.ext_index_type_uint8;
    }
    pub fn enable_ext_index_type_uint8(self: *DeviceExtensions) void {
        self.ext_index_type_uint8 = true;
    }

    pub fn supports_ext_extended_dynamic_state(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.ext_extended_dynamic_state;
    }
    pub fn enable_ext_extended_dynamic_state(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.ext_extended_dynamic_state = true;
        }
    }

    pub fn supports_khr_deferred_host_operations(self: DeviceExtensions) bool {
        return self.khr_deferred_host_operations;
    }
    pub fn enable_khr_deferred_host_operations(self: *DeviceExtensions) void {
        self.khr_deferred_host_operations = true;
    }

    pub fn supports_khr_pipeline_executable_properties(self: DeviceExtensions) bool {
        return self.khr_pipeline_executable_properties;
    }
    pub fn enable_khr_pipeline_executable_properties(self: *DeviceExtensions) void {
        self.khr_pipeline_executable_properties = true;
    }

    pub fn supports_ext_host_image_copy(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or (self.ext_host_image_copy and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or (self.supports_khr_copy_commands2() and self.supports_khr_format_feature_flags2())));
    }
    pub fn enable_ext_host_image_copy(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.ext_host_image_copy = true;
            if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
                self.enable_khr_copy_commands2();
                self.enable_khr_format_feature_flags2();
            }
        }
    }

    pub fn supports_khr_map_memory2(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.khr_map_memory2;
    }
    pub fn enable_khr_map_memory2(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.khr_map_memory2 = true;
        }
    }

    pub fn supports_ext_map_memory_placed(self: DeviceExtensions) bool {
        return self.ext_map_memory_placed and (self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.supports_khr_map_memory2());
    }
    pub fn enable_ext_map_memory_placed(self: *DeviceExtensions) void {
        self.ext_map_memory_placed = true;
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.enable_khr_map_memory2();
        }
    }

    pub fn supports_ext_shader_atomic_float2(self: DeviceExtensions) bool {
        return self.ext_shader_atomic_float2 and self.supports_ext_shader_atomic_float();
    }
    pub fn enable_ext_shader_atomic_float2(self: *DeviceExtensions) void {
        self.ext_shader_atomic_float2 = true;
        self.enable_ext_shader_atomic_float();
    }

    pub fn supports_ext_swapchain_maintenance1(self: DeviceExtensions) bool {
        return self.ext_swapchain_maintenance1 and self.supports_khr_swapchain();
    }
    pub fn enable_ext_swapchain_maintenance1(self: *DeviceExtensions) void {
        self.ext_swapchain_maintenance1 = true;
        self.enable_khr_swapchain();
    }

    pub fn supports_ext_shader_demote_to_helper_invocation(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.ext_shader_demote_to_helper_invocation;
    }
    pub fn enable_ext_shader_demote_to_helper_invocation(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.ext_shader_demote_to_helper_invocation = true;
        }
    }

    pub fn supports_nv_device_generated_commands(self: DeviceExtensions) bool {
        return self.nv_device_generated_commands and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.core_version.to_int() >= make_version(1, 1, 0).to_int() and self.supports_khr_buffer_device_address()));
    }
    pub fn enable_nv_device_generated_commands(self: *DeviceExtensions) void {
        self.nv_device_generated_commands = true;
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
            self.enable_khr_buffer_device_address();
        }
    }

    pub fn supports_nv_inherited_viewport_scissor(self: DeviceExtensions) bool {
        return self.nv_inherited_viewport_scissor;
    }
    pub fn enable_nv_inherited_viewport_scissor(self: *DeviceExtensions) void {
        self.nv_inherited_viewport_scissor = true;
    }

    pub fn supports_khr_shader_integer_dot_product(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.khr_shader_integer_dot_product;
    }
    pub fn enable_khr_shader_integer_dot_product(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.khr_shader_integer_dot_product = true;
        }
    }

    pub fn supports_ext_texel_buffer_alignment(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.ext_texel_buffer_alignment;
    }
    pub fn enable_ext_texel_buffer_alignment(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.ext_texel_buffer_alignment = true;
        }
    }

    pub fn supports_qcom_render_pass_transform(self: DeviceExtensions) bool {
        return self.qcom_render_pass_transform;
    }
    pub fn enable_qcom_render_pass_transform(self: *DeviceExtensions) void {
        self.qcom_render_pass_transform = true;
    }

    pub fn supports_ext_depth_bias_control(self: DeviceExtensions) bool {
        return self.ext_depth_bias_control;
    }
    pub fn enable_ext_depth_bias_control(self: *DeviceExtensions) void {
        self.ext_depth_bias_control = true;
    }

    pub fn supports_ext_device_memory_report(self: DeviceExtensions) bool {
        return self.ext_device_memory_report;
    }
    pub fn enable_ext_device_memory_report(self: *DeviceExtensions) void {
        self.ext_device_memory_report = true;
    }

    pub fn supports_ext_robustness2(self: DeviceExtensions) bool {
        return self.ext_robustness2;
    }
    pub fn enable_ext_robustness2(self: *DeviceExtensions) void {
        self.ext_robustness2 = true;
    }

    pub fn supports_ext_custom_border_color(self: DeviceExtensions) bool {
        return self.ext_custom_border_color;
    }
    pub fn enable_ext_custom_border_color(self: *DeviceExtensions) void {
        self.ext_custom_border_color = true;
    }

    pub fn supports_google_user_type(self: DeviceExtensions) bool {
        return self.google_user_type;
    }
    pub fn enable_google_user_type(self: *DeviceExtensions) void {
        self.google_user_type = true;
    }

    pub fn supports_khr_pipeline_library(self: DeviceExtensions) bool {
        return self.khr_pipeline_library;
    }
    pub fn enable_khr_pipeline_library(self: *DeviceExtensions) void {
        self.khr_pipeline_library = true;
    }

    pub fn supports_nv_present_barrier(self: DeviceExtensions) bool {
        return self.nv_present_barrier and self.supports_khr_swapchain();
    }
    pub fn enable_nv_present_barrier(self: *DeviceExtensions) void {
        self.nv_present_barrier = true;
        self.enable_khr_swapchain();
    }

    pub fn supports_khr_shader_non_semantic_info(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.khr_shader_non_semantic_info;
    }
    pub fn enable_khr_shader_non_semantic_info(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.khr_shader_non_semantic_info = true;
        }
    }

    pub fn supports_khr_present_id(self: DeviceExtensions) bool {
        return self.khr_present_id and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_swapchain());
    }
    pub fn enable_khr_present_id(self: *DeviceExtensions) void {
        self.khr_present_id = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_swapchain();
        }
    }

    pub fn supports_ext_private_data(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.ext_private_data;
    }
    pub fn enable_ext_private_data(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.ext_private_data = true;
        }
    }

    pub fn supports_ext_pipeline_creation_cache_control(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.ext_pipeline_creation_cache_control;
    }
    pub fn enable_ext_pipeline_creation_cache_control(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.ext_pipeline_creation_cache_control = true;
        }
    }

    pub fn supports_nv_device_diagnostics_config(self: DeviceExtensions) bool {
        return self.nv_device_diagnostics_config;
    }
    pub fn enable_nv_device_diagnostics_config(self: *DeviceExtensions) void {
        self.nv_device_diagnostics_config = true;
    }

    pub fn supports_qcom_render_pass_store_ops(self: DeviceExtensions) bool {
        return self.qcom_render_pass_store_ops;
    }
    pub fn enable_qcom_render_pass_store_ops(self: *DeviceExtensions) void {
        self.qcom_render_pass_store_ops = true;
    }

    pub fn supports_nv_cuda_kernel_launch(self: DeviceExtensions) bool {
        return self.nv_cuda_kernel_launch;
    }
    pub fn enable_nv_cuda_kernel_launch(self: *DeviceExtensions) void {
        self.nv_cuda_kernel_launch = true;
    }

    pub fn supports_qcom_tile_shading(self: DeviceExtensions) bool {
        return self.qcom_tile_shading;
    }
    pub fn enable_qcom_tile_shading(self: *DeviceExtensions) void {
        self.qcom_tile_shading = true;
    }

    pub fn supports_nv_low_latency(self: DeviceExtensions) bool {
        return self.nv_low_latency;
    }
    pub fn enable_nv_low_latency(self: *DeviceExtensions) void {
        self.nv_low_latency = true;
    }

    pub fn supports_ext_metal_objects(self: DeviceExtensions) bool {
        return self.ext_metal_objects;
    }
    pub fn enable_ext_metal_objects(self: *DeviceExtensions) void {
        self.ext_metal_objects = true;
    }

    pub fn supports_khr_synchronization2(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.khr_synchronization2;
    }
    pub fn enable_khr_synchronization2(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.khr_synchronization2 = true;
        }
    }

    pub fn supports_ext_descriptor_buffer(self: DeviceExtensions) bool {
        return self.ext_descriptor_buffer and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.supports_khr_buffer_device_address() and self.supports_ext_descriptor_indexing())) and self.supports_khr_synchronization2()));
    }
    pub fn enable_ext_descriptor_buffer(self: *DeviceExtensions) void {
        self.ext_descriptor_buffer = true;
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
                self.enable_khr_buffer_device_address();
                self.enable_ext_descriptor_indexing();
            }
            self.enable_khr_synchronization2();
        }
    }

    pub fn supports_ext_graphics_pipeline_library(self: DeviceExtensions) bool {
        return self.ext_graphics_pipeline_library and self.supports_khr_pipeline_library();
    }
    pub fn enable_ext_graphics_pipeline_library(self: *DeviceExtensions) void {
        self.ext_graphics_pipeline_library = true;
        self.enable_khr_pipeline_library();
    }

    pub fn supports_amd_shader_early_and_late_fragment_tests(self: DeviceExtensions) bool {
        return self.amd_shader_early_and_late_fragment_tests;
    }
    pub fn enable_amd_shader_early_and_late_fragment_tests(self: *DeviceExtensions) void {
        self.amd_shader_early_and_late_fragment_tests = true;
    }

    pub fn supports_khr_fragment_shader_barycentric(self: DeviceExtensions) bool {
        return self.khr_fragment_shader_barycentric;
    }
    pub fn enable_khr_fragment_shader_barycentric(self: *DeviceExtensions) void {
        self.khr_fragment_shader_barycentric = true;
    }

    pub fn supports_khr_shader_subgroup_uniform_control_flow(self: DeviceExtensions) bool {
        return self.khr_shader_subgroup_uniform_control_flow and self.core_version.to_int() >= make_version(1, 1, 0).to_int();
    }
    pub fn enable_khr_shader_subgroup_uniform_control_flow(self: *DeviceExtensions) void {
        self.khr_shader_subgroup_uniform_control_flow = true;
        // depends on minimum core version, caller must specify
        assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
    }

    pub fn supports_khr_zero_initialize_workgroup_memory(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.khr_zero_initialize_workgroup_memory;
    }
    pub fn enable_khr_zero_initialize_workgroup_memory(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.khr_zero_initialize_workgroup_memory = true;
        }
    }

    pub fn supports_nv_fragment_shading_rate_enums(self: DeviceExtensions) bool {
        return self.nv_fragment_shading_rate_enums and self.supports_khr_fragment_shading_rate();
    }
    pub fn enable_nv_fragment_shading_rate_enums(self: *DeviceExtensions) void {
        self.nv_fragment_shading_rate_enums = true;
        self.enable_khr_fragment_shading_rate();
    }

    pub fn supports_nv_ray_tracing_motion_blur(self: DeviceExtensions) bool {
        return self.nv_ray_tracing_motion_blur and self.supports_khr_ray_tracing_pipeline();
    }
    pub fn enable_nv_ray_tracing_motion_blur(self: *DeviceExtensions) void {
        self.nv_ray_tracing_motion_blur = true;
        self.enable_khr_ray_tracing_pipeline();
    }

    pub fn supports_ext_mesh_shader(self: DeviceExtensions) bool {
        return self.ext_mesh_shader and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_spirv_1_4());
    }
    pub fn enable_ext_mesh_shader(self: *DeviceExtensions) void {
        self.ext_mesh_shader = true;
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_spirv_1_4();
        }
    }

    pub fn supports_ext_ycbcr_2plane_444_formats(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or (self.ext_ycbcr_2plane_444_formats and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_sampler_ycbcr_conversion()));
    }
    pub fn enable_ext_ycbcr_2plane_444_formats(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.ext_ycbcr_2plane_444_formats = true;
            if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
                self.enable_khr_sampler_ycbcr_conversion();
            }
        }
    }

    pub fn supports_ext_fragment_density_map2(self: DeviceExtensions) bool {
        return self.ext_fragment_density_map2 and self.supports_ext_fragment_density_map();
    }
    pub fn enable_ext_fragment_density_map2(self: *DeviceExtensions) void {
        self.ext_fragment_density_map2 = true;
        self.enable_ext_fragment_density_map();
    }

    pub fn supports_qcom_rotated_copy_commands(self: DeviceExtensions) bool {
        return self.qcom_rotated_copy_commands and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_copy_commands2());
    }
    pub fn enable_qcom_rotated_copy_commands(self: *DeviceExtensions) void {
        self.qcom_rotated_copy_commands = true;
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_copy_commands2();
        }
    }

    pub fn supports_ext_image_robustness(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.ext_image_robustness;
    }
    pub fn enable_ext_image_robustness(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.ext_image_robustness = true;
        }
    }

    pub fn supports_khr_workgroup_memory_explicit_layout(self: DeviceExtensions) bool {
        return self.khr_workgroup_memory_explicit_layout;
    }
    pub fn enable_khr_workgroup_memory_explicit_layout(self: *DeviceExtensions) void {
        self.khr_workgroup_memory_explicit_layout = true;
    }

    pub fn supports_khr_copy_commands2(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.khr_copy_commands2;
    }
    pub fn enable_khr_copy_commands2(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.khr_copy_commands2 = true;
        }
    }

    pub fn supports_ext_image_compression_control(self: DeviceExtensions) bool {
        return self.ext_image_compression_control;
    }
    pub fn enable_ext_image_compression_control(self: *DeviceExtensions) void {
        self.ext_image_compression_control = true;
    }

    pub fn supports_ext_attachment_feedback_loop_layout(self: DeviceExtensions) bool {
        return self.ext_attachment_feedback_loop_layout;
    }
    pub fn enable_ext_attachment_feedback_loop_layout(self: *DeviceExtensions) void {
        self.ext_attachment_feedback_loop_layout = true;
    }

    pub fn supports_ext_4444_formats(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.ext_4444_formats;
    }
    pub fn enable_ext_4444_formats(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.ext_4444_formats = true;
        }
    }

    pub fn supports_ext_device_fault(self: DeviceExtensions) bool {
        return self.ext_device_fault;
    }
    pub fn enable_ext_device_fault(self: *DeviceExtensions) void {
        self.ext_device_fault = true;
    }

    pub fn supports_arm_rasterization_order_attachment_access(self: DeviceExtensions) bool {
        return self.arm_rasterization_order_attachment_access;
    }
    pub fn enable_arm_rasterization_order_attachment_access(self: *DeviceExtensions) void {
        self.arm_rasterization_order_attachment_access = true;
    }

    pub fn supports_ext_rgba10x6_formats(self: DeviceExtensions) bool {
        return self.ext_rgba10x6_formats and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_sampler_ycbcr_conversion());
    }
    pub fn enable_ext_rgba10x6_formats(self: *DeviceExtensions) void {
        self.ext_rgba10x6_formats = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_sampler_ycbcr_conversion();
        }
    }

    pub fn supports_nv_acquire_winrt_display(self: DeviceExtensions) bool {
        return self.nv_acquire_winrt_display;
    }
    pub fn enable_nv_acquire_winrt_display(self: *DeviceExtensions) void {
        self.nv_acquire_winrt_display = true;
    }

    pub fn supports_valve_mutable_descriptor_type(self: DeviceExtensions) bool {
        return self.valve_mutable_descriptor_type and self.supports_khr_maintenance3();
    }
    pub fn enable_valve_mutable_descriptor_type(self: *DeviceExtensions) void {
        self.valve_mutable_descriptor_type = true;
        self.enable_khr_maintenance3();
    }

    pub fn supports_ext_vertex_input_dynamic_state(self: DeviceExtensions) bool {
        return self.ext_vertex_input_dynamic_state;
    }
    pub fn enable_ext_vertex_input_dynamic_state(self: *DeviceExtensions) void {
        self.ext_vertex_input_dynamic_state = true;
    }

    pub fn supports_ext_physical_device_drm(self: DeviceExtensions) bool {
        return self.ext_physical_device_drm;
    }
    pub fn enable_ext_physical_device_drm(self: *DeviceExtensions) void {
        self.ext_physical_device_drm = true;
    }

    pub fn supports_ext_device_address_binding_report(self: DeviceExtensions) bool {
        return self.ext_device_address_binding_report;
    }
    pub fn enable_ext_device_address_binding_report(self: *DeviceExtensions) void {
        self.ext_device_address_binding_report = true;
    }

    pub fn supports_ext_depth_clip_control(self: DeviceExtensions) bool {
        return self.ext_depth_clip_control;
    }
    pub fn enable_ext_depth_clip_control(self: *DeviceExtensions) void {
        self.ext_depth_clip_control = true;
    }

    pub fn supports_ext_primitive_topology_list_restart(self: DeviceExtensions) bool {
        return self.ext_primitive_topology_list_restart;
    }
    pub fn enable_ext_primitive_topology_list_restart(self: *DeviceExtensions) void {
        self.ext_primitive_topology_list_restart = true;
    }

    pub fn supports_khr_format_feature_flags2(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.khr_format_feature_flags2;
    }
    pub fn enable_khr_format_feature_flags2(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.khr_format_feature_flags2 = true;
        }
    }

    pub fn supports_ext_present_mode_fifo_latest_ready(self: DeviceExtensions) bool {
        return self.ext_present_mode_fifo_latest_ready and self.supports_khr_swapchain();
    }
    pub fn enable_ext_present_mode_fifo_latest_ready(self: *DeviceExtensions) void {
        self.ext_present_mode_fifo_latest_ready = true;
        self.enable_khr_swapchain();
    }

    pub fn supports_fuchsia_external_memory(self: DeviceExtensions) bool {
        return self.fuchsia_external_memory and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory());
    }
    pub fn enable_fuchsia_external_memory(self: *DeviceExtensions) void {
        self.fuchsia_external_memory = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_fuchsia_external_semaphore(self: DeviceExtensions) bool {
        return self.fuchsia_external_semaphore and self.supports_khr_external_semaphore();
    }
    pub fn enable_fuchsia_external_semaphore(self: *DeviceExtensions) void {
        self.fuchsia_external_semaphore = true;
        self.enable_khr_external_semaphore();
    }

    pub fn supports_fuchsia_buffer_collection(self: DeviceExtensions) bool {
        return self.fuchsia_buffer_collection and self.supports_fuchsia_external_memory() and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_sampler_ycbcr_conversion());
    }
    pub fn enable_fuchsia_buffer_collection(self: *DeviceExtensions) void {
        self.fuchsia_buffer_collection = true;
        self.enable_fuchsia_external_memory();
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_sampler_ycbcr_conversion();
        }
    }

    pub fn supports_huawei_subpass_shading(self: DeviceExtensions) bool {
        return self.huawei_subpass_shading and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_create_renderpass2()) and self.supports_khr_synchronization2()));
    }
    pub fn enable_huawei_subpass_shading(self: *DeviceExtensions) void {
        self.huawei_subpass_shading = true;
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
                self.enable_khr_create_renderpass2();
            }
            self.enable_khr_synchronization2();
        }
    }

    pub fn supports_huawei_invocation_mask(self: DeviceExtensions) bool {
        return self.huawei_invocation_mask and self.supports_khr_ray_tracing_pipeline() and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_synchronization2());
    }
    pub fn enable_huawei_invocation_mask(self: *DeviceExtensions) void {
        self.huawei_invocation_mask = true;
        self.enable_khr_ray_tracing_pipeline();
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_synchronization2();
        }
    }

    pub fn supports_nv_external_memory_rdma(self: DeviceExtensions) bool {
        return self.nv_external_memory_rdma and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory());
    }
    pub fn enable_nv_external_memory_rdma(self: *DeviceExtensions) void {
        self.nv_external_memory_rdma = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_ext_pipeline_properties(self: DeviceExtensions) bool {
        return self.ext_pipeline_properties;
    }
    pub fn enable_ext_pipeline_properties(self: *DeviceExtensions) void {
        self.ext_pipeline_properties = true;
    }

    pub fn supports_ext_frame_boundary(self: DeviceExtensions) bool {
        return self.ext_frame_boundary;
    }
    pub fn enable_ext_frame_boundary(self: *DeviceExtensions) void {
        self.ext_frame_boundary = true;
    }

    pub fn supports_ext_multisampled_render_to_single_sampled(self: DeviceExtensions) bool {
        return self.ext_multisampled_render_to_single_sampled and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or (self.supports_khr_create_renderpass2() and self.supports_khr_depth_stencil_resolve()));
    }
    pub fn enable_ext_multisampled_render_to_single_sampled(self: *DeviceExtensions) void {
        self.ext_multisampled_render_to_single_sampled = true;
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_create_renderpass2();
            self.enable_khr_depth_stencil_resolve();
        }
    }

    pub fn supports_ext_extended_dynamic_state2(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.ext_extended_dynamic_state2;
    }
    pub fn enable_ext_extended_dynamic_state2(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.ext_extended_dynamic_state2 = true;
        }
    }

    pub fn supports_ext_color_write_enable(self: DeviceExtensions) bool {
        return self.ext_color_write_enable;
    }
    pub fn enable_ext_color_write_enable(self: *DeviceExtensions) void {
        self.ext_color_write_enable = true;
    }

    pub fn supports_ext_primitives_generated_query(self: DeviceExtensions) bool {
        return self.ext_primitives_generated_query and self.supports_ext_transform_feedback();
    }
    pub fn enable_ext_primitives_generated_query(self: *DeviceExtensions) void {
        self.ext_primitives_generated_query = true;
        self.enable_ext_transform_feedback();
    }

    pub fn supports_khr_ray_tracing_maintenance1(self: DeviceExtensions) bool {
        return self.khr_ray_tracing_maintenance1 and self.supports_khr_acceleration_structure();
    }
    pub fn enable_khr_ray_tracing_maintenance1(self: *DeviceExtensions) void {
        self.khr_ray_tracing_maintenance1 = true;
        self.enable_khr_acceleration_structure();
    }

    pub fn supports_khr_shader_untyped_pointers(self: DeviceExtensions) bool {
        return self.khr_shader_untyped_pointers;
    }
    pub fn enable_khr_shader_untyped_pointers(self: *DeviceExtensions) void {
        self.khr_shader_untyped_pointers = true;
    }

    pub fn supports_ext_global_priority_query(self: DeviceExtensions) bool {
        return self.ext_global_priority_query and self.supports_ext_global_priority();
    }
    pub fn enable_ext_global_priority_query(self: *DeviceExtensions) void {
        self.ext_global_priority_query = true;
        self.enable_ext_global_priority();
    }

    pub fn supports_ext_image_view_min_lod(self: DeviceExtensions) bool {
        return self.ext_image_view_min_lod;
    }
    pub fn enable_ext_image_view_min_lod(self: *DeviceExtensions) void {
        self.ext_image_view_min_lod = true;
    }

    pub fn supports_ext_multi_draw(self: DeviceExtensions) bool {
        return self.ext_multi_draw;
    }
    pub fn enable_ext_multi_draw(self: *DeviceExtensions) void {
        self.ext_multi_draw = true;
    }

    pub fn supports_ext_image_2d_view_of_3d(self: DeviceExtensions) bool {
        return self.ext_image_2d_view_of_3d and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_maintenance1());
    }
    pub fn enable_ext_image_2d_view_of_3d(self: *DeviceExtensions) void {
        self.ext_image_2d_view_of_3d = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_maintenance1();
        }
    }

    pub fn supports_ext_shader_tile_image(self: DeviceExtensions) bool {
        return self.ext_shader_tile_image and self.core_version.to_int() >= make_version(1, 3, 0).to_int();
    }
    pub fn enable_ext_shader_tile_image(self: *DeviceExtensions) void {
        self.ext_shader_tile_image = true;
        // depends on minimum core version, caller must specify
        assert(self.core_version.to_int() >= make_version(1, 3, 0).to_int());
    }

    pub fn supports_ext_opacity_micromap(self: DeviceExtensions) bool {
        return self.ext_opacity_micromap and self.supports_khr_acceleration_structure() and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_synchronization2());
    }
    pub fn enable_ext_opacity_micromap(self: *DeviceExtensions) void {
        self.ext_opacity_micromap = true;
        self.enable_khr_acceleration_structure();
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_synchronization2();
        }
    }

    pub fn supports_nv_displacement_micromap(self: DeviceExtensions) bool {
        return self.nv_displacement_micromap and self.supports_ext_opacity_micromap();
    }
    pub fn enable_nv_displacement_micromap(self: *DeviceExtensions) void {
        self.nv_displacement_micromap = true;
        self.enable_ext_opacity_micromap();
    }

    pub fn supports_ext_load_store_op_none(self: DeviceExtensions) bool {
        return self.ext_load_store_op_none;
    }
    pub fn enable_ext_load_store_op_none(self: *DeviceExtensions) void {
        self.ext_load_store_op_none = true;
    }

    pub fn supports_huawei_cluster_culling_shader(self: DeviceExtensions) bool {
        return self.huawei_cluster_culling_shader;
    }
    pub fn enable_huawei_cluster_culling_shader(self: *DeviceExtensions) void {
        self.huawei_cluster_culling_shader = true;
    }

    pub fn supports_ext_border_color_swizzle(self: DeviceExtensions) bool {
        return self.ext_border_color_swizzle and self.supports_ext_custom_border_color();
    }
    pub fn enable_ext_border_color_swizzle(self: *DeviceExtensions) void {
        self.ext_border_color_swizzle = true;
        self.enable_ext_custom_border_color();
    }

    pub fn supports_ext_pageable_device_local_memory(self: DeviceExtensions) bool {
        return self.ext_pageable_device_local_memory and self.supports_ext_memory_priority();
    }
    pub fn enable_ext_pageable_device_local_memory(self: *DeviceExtensions) void {
        self.ext_pageable_device_local_memory = true;
        self.enable_ext_memory_priority();
    }

    pub fn supports_khr_maintenance4(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 3, 0).to_int() or (self.khr_maintenance4 and self.core_version.to_int() >= make_version(1, 1, 0).to_int());
    }
    pub fn enable_khr_maintenance4(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.khr_maintenance4 = true;
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
        }
    }

    pub fn supports_arm_shader_core_properties(self: DeviceExtensions) bool {
        return self.arm_shader_core_properties and self.core_version.to_int() >= make_version(1, 1, 0).to_int();
    }
    pub fn enable_arm_shader_core_properties(self: *DeviceExtensions) void {
        self.arm_shader_core_properties = true;
        // depends on minimum core version, caller must specify
        assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
    }

    pub fn supports_khr_shader_subgroup_rotate(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.khr_shader_subgroup_rotate;
    }
    pub fn enable_khr_shader_subgroup_rotate(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.khr_shader_subgroup_rotate = true;
        }
    }

    pub fn supports_arm_scheduling_controls(self: DeviceExtensions) bool {
        return self.arm_scheduling_controls and self.supports_arm_shader_core_builtins();
    }
    pub fn enable_arm_scheduling_controls(self: *DeviceExtensions) void {
        self.arm_scheduling_controls = true;
        self.enable_arm_shader_core_builtins();
    }

    pub fn supports_ext_image_sliced_view_of_3d(self: DeviceExtensions) bool {
        return self.ext_image_sliced_view_of_3d and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_maintenance1());
    }
    pub fn enable_ext_image_sliced_view_of_3d(self: *DeviceExtensions) void {
        self.ext_image_sliced_view_of_3d = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_maintenance1();
        }
    }

    pub fn supports_valve_descriptor_set_host_mapping(self: DeviceExtensions) bool {
        return self.valve_descriptor_set_host_mapping;
    }
    pub fn enable_valve_descriptor_set_host_mapping(self: *DeviceExtensions) void {
        self.valve_descriptor_set_host_mapping = true;
    }

    pub fn supports_ext_depth_clamp_zero_one(self: DeviceExtensions) bool {
        return self.ext_depth_clamp_zero_one;
    }
    pub fn enable_ext_depth_clamp_zero_one(self: *DeviceExtensions) void {
        self.ext_depth_clamp_zero_one = true;
    }

    pub fn supports_ext_non_seamless_cube_map(self: DeviceExtensions) bool {
        return self.ext_non_seamless_cube_map;
    }
    pub fn enable_ext_non_seamless_cube_map(self: *DeviceExtensions) void {
        self.ext_non_seamless_cube_map = true;
    }

    pub fn supports_arm_render_pass_striped(self: DeviceExtensions) bool {
        return self.arm_render_pass_striped and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_synchronization2());
    }
    pub fn enable_arm_render_pass_striped(self: *DeviceExtensions) void {
        self.arm_render_pass_striped = true;
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_synchronization2();
        }
    }

    pub fn supports_qcom_fragment_density_map_offset(self: DeviceExtensions) bool {
        return self.qcom_fragment_density_map_offset and self.supports_ext_fragment_density_map();
    }
    pub fn enable_qcom_fragment_density_map_offset(self: *DeviceExtensions) void {
        self.qcom_fragment_density_map_offset = true;
        self.enable_ext_fragment_density_map();
    }

    pub fn supports_nv_copy_memory_indirect(self: DeviceExtensions) bool {
        return self.nv_copy_memory_indirect and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_buffer_device_address());
    }
    pub fn enable_nv_copy_memory_indirect(self: *DeviceExtensions) void {
        self.nv_copy_memory_indirect = true;
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_buffer_device_address();
        }
    }

    pub fn supports_nv_memory_decompression(self: DeviceExtensions) bool {
        return self.nv_memory_decompression and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_buffer_device_address());
    }
    pub fn enable_nv_memory_decompression(self: *DeviceExtensions) void {
        self.nv_memory_decompression = true;
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_buffer_device_address();
        }
    }

    pub fn supports_nv_device_generated_commands_compute(self: DeviceExtensions) bool {
        return self.nv_device_generated_commands_compute and self.supports_nv_device_generated_commands();
    }
    pub fn enable_nv_device_generated_commands_compute(self: *DeviceExtensions) void {
        self.nv_device_generated_commands_compute = true;
        self.enable_nv_device_generated_commands();
    }

    pub fn supports_nv_ray_tracing_linear_swept_spheres(self: DeviceExtensions) bool {
        return self.nv_ray_tracing_linear_swept_spheres and self.supports_khr_ray_tracing_pipeline();
    }
    pub fn enable_nv_ray_tracing_linear_swept_spheres(self: *DeviceExtensions) void {
        self.nv_ray_tracing_linear_swept_spheres = true;
        self.enable_khr_ray_tracing_pipeline();
    }

    pub fn supports_nv_linear_color_attachment(self: DeviceExtensions) bool {
        return self.nv_linear_color_attachment;
    }
    pub fn enable_nv_linear_color_attachment(self: *DeviceExtensions) void {
        self.nv_linear_color_attachment = true;
    }

    pub fn supports_khr_shader_maximal_reconvergence(self: DeviceExtensions) bool {
        return self.khr_shader_maximal_reconvergence and self.core_version.to_int() >= make_version(1, 1, 0).to_int();
    }
    pub fn enable_khr_shader_maximal_reconvergence(self: *DeviceExtensions) void {
        self.khr_shader_maximal_reconvergence = true;
        // depends on minimum core version, caller must specify
        assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
    }

    pub fn supports_ext_image_compression_control_swapchain(self: DeviceExtensions) bool {
        return self.ext_image_compression_control_swapchain and self.supports_ext_image_compression_control();
    }
    pub fn enable_ext_image_compression_control_swapchain(self: *DeviceExtensions) void {
        self.ext_image_compression_control_swapchain = true;
        self.enable_ext_image_compression_control();
    }

    pub fn supports_qcom_image_processing(self: DeviceExtensions) bool {
        return self.qcom_image_processing and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_format_feature_flags2());
    }
    pub fn enable_qcom_image_processing(self: *DeviceExtensions) void {
        self.qcom_image_processing = true;
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_format_feature_flags2();
        }
    }

    pub fn supports_ext_nested_command_buffer(self: DeviceExtensions) bool {
        return self.ext_nested_command_buffer;
    }
    pub fn enable_ext_nested_command_buffer(self: *DeviceExtensions) void {
        self.ext_nested_command_buffer = true;
    }

    pub fn supports_ext_external_memory_acquire_unmodified(self: DeviceExtensions) bool {
        return self.ext_external_memory_acquire_unmodified and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory());
    }
    pub fn enable_ext_external_memory_acquire_unmodified(self: *DeviceExtensions) void {
        self.ext_external_memory_acquire_unmodified = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_ext_extended_dynamic_state3(self: DeviceExtensions) bool {
        return self.ext_extended_dynamic_state3;
    }
    pub fn enable_ext_extended_dynamic_state3(self: *DeviceExtensions) void {
        self.ext_extended_dynamic_state3 = true;
    }

    pub fn supports_ext_subpass_merge_feedback(self: DeviceExtensions) bool {
        return self.ext_subpass_merge_feedback;
    }
    pub fn enable_ext_subpass_merge_feedback(self: *DeviceExtensions) void {
        self.ext_subpass_merge_feedback = true;
    }

    pub fn supports_arm_tensors(self: DeviceExtensions) bool {
        return self.arm_tensors and self.core_version.to_int() >= make_version(1, 3, 0).to_int();
    }
    pub fn enable_arm_tensors(self: *DeviceExtensions) void {
        self.arm_tensors = true;
        // depends on minimum core version, caller must specify
        assert(self.core_version.to_int() >= make_version(1, 3, 0).to_int());
    }

    pub fn supports_ext_shader_module_identifier(self: DeviceExtensions) bool {
        return self.ext_shader_module_identifier and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_ext_pipeline_creation_cache_control());
    }
    pub fn enable_ext_shader_module_identifier(self: *DeviceExtensions) void {
        self.ext_shader_module_identifier = true;
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_ext_pipeline_creation_cache_control();
        }
    }

    pub fn supports_ext_rasterization_order_attachment_access(self: DeviceExtensions) bool {
        return self.ext_rasterization_order_attachment_access;
    }
    pub fn enable_ext_rasterization_order_attachment_access(self: *DeviceExtensions) void {
        self.ext_rasterization_order_attachment_access = true;
    }

    pub fn supports_nv_optical_flow(self: DeviceExtensions) bool {
        return self.nv_optical_flow and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or (self.supports_khr_format_feature_flags2() and self.supports_khr_synchronization2()));
    }
    pub fn enable_nv_optical_flow(self: *DeviceExtensions) void {
        self.nv_optical_flow = true;
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_format_feature_flags2();
            self.enable_khr_synchronization2();
        }
    }

    pub fn supports_ext_legacy_dithering(self: DeviceExtensions) bool {
        return self.ext_legacy_dithering;
    }
    pub fn enable_ext_legacy_dithering(self: *DeviceExtensions) void {
        self.ext_legacy_dithering = true;
    }

    pub fn supports_ext_pipeline_protected_access(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.ext_pipeline_protected_access;
    }
    pub fn enable_ext_pipeline_protected_access(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.ext_pipeline_protected_access = true;
        }
    }

    pub fn supports_android_external_format_resolve(self: DeviceExtensions) bool {
        return self.android_external_format_resolve and self.supports_android_external_memory_android_hardware_buffer();
    }
    pub fn enable_android_external_format_resolve(self: *DeviceExtensions) void {
        self.android_external_format_resolve = true;
        self.enable_android_external_memory_android_hardware_buffer();
    }

    pub fn supports_khr_maintenance5(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or (self.khr_maintenance5 and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or (self.core_version.to_int() >= make_version(1, 1, 0).to_int() and self.supports_khr_dynamic_rendering())));
    }
    pub fn enable_khr_maintenance5(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.khr_maintenance5 = true;
            if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
                // depends on minimum core version, caller must specify
                assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
                self.enable_khr_dynamic_rendering();
            }
        }
    }

    pub fn supports_amd_anti_lag(self: DeviceExtensions) bool {
        return self.amd_anti_lag;
    }
    pub fn enable_amd_anti_lag(self: *DeviceExtensions) void {
        self.amd_anti_lag = true;
    }

    pub fn supports_amdx_dense_geometry_format(self: DeviceExtensions) bool {
        return self.amdx_dense_geometry_format and self.supports_khr_acceleration_structure() and (self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.supports_khr_maintenance5());
    }
    pub fn enable_amdx_dense_geometry_format(self: *DeviceExtensions) void {
        self.amdx_dense_geometry_format = true;
        self.enable_khr_acceleration_structure();
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.enable_khr_maintenance5();
        }
    }

    pub fn supports_khr_present_id2(self: DeviceExtensions) bool {
        return self.khr_present_id2 and self.supports_khr_swapchain();
    }
    pub fn enable_khr_present_id2(self: *DeviceExtensions) void {
        self.khr_present_id2 = true;
        self.enable_khr_swapchain();
    }

    pub fn supports_khr_present_wait2(self: DeviceExtensions) bool {
        return self.khr_present_wait2 and self.supports_khr_swapchain() and self.supports_khr_present_id2();
    }
    pub fn enable_khr_present_wait2(self: *DeviceExtensions) void {
        self.khr_present_wait2 = true;
        self.enable_khr_swapchain();
        self.enable_khr_present_id2();
    }

    pub fn supports_khr_ray_tracing_position_fetch(self: DeviceExtensions) bool {
        return self.khr_ray_tracing_position_fetch and self.supports_khr_acceleration_structure();
    }
    pub fn enable_khr_ray_tracing_position_fetch(self: *DeviceExtensions) void {
        self.khr_ray_tracing_position_fetch = true;
        self.enable_khr_acceleration_structure();
    }

    pub fn supports_ext_shader_object(self: DeviceExtensions) bool {
        return self.ext_shader_object and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_dynamic_rendering());
    }
    pub fn enable_ext_shader_object(self: *DeviceExtensions) void {
        self.ext_shader_object = true;
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_dynamic_rendering();
        }
    }

    pub fn supports_khr_pipeline_binary(self: DeviceExtensions) bool {
        return self.khr_pipeline_binary and (self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.supports_khr_maintenance5());
    }
    pub fn enable_khr_pipeline_binary(self: *DeviceExtensions) void {
        self.khr_pipeline_binary = true;
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.enable_khr_maintenance5();
        }
    }

    pub fn supports_qcom_tile_properties(self: DeviceExtensions) bool {
        return self.qcom_tile_properties;
    }
    pub fn enable_qcom_tile_properties(self: *DeviceExtensions) void {
        self.qcom_tile_properties = true;
    }

    pub fn supports_sec_amigo_profiling(self: DeviceExtensions) bool {
        return self.sec_amigo_profiling;
    }
    pub fn enable_sec_amigo_profiling(self: *DeviceExtensions) void {
        self.sec_amigo_profiling = true;
    }

    pub fn supports_khr_swapchain_maintenance1(self: DeviceExtensions) bool {
        return self.khr_swapchain_maintenance1;
    }
    pub fn enable_khr_swapchain_maintenance1(self: *DeviceExtensions) void {
        self.khr_swapchain_maintenance1 = true;
    }

    pub fn supports_qcom_multiview_per_view_viewports(self: DeviceExtensions) bool {
        return self.qcom_multiview_per_view_viewports;
    }
    pub fn enable_qcom_multiview_per_view_viewports(self: *DeviceExtensions) void {
        self.qcom_multiview_per_view_viewports = true;
    }

    pub fn supports_nv_ray_tracing_invocation_reorder(self: DeviceExtensions) bool {
        return self.nv_ray_tracing_invocation_reorder and self.supports_khr_ray_tracing_pipeline();
    }
    pub fn enable_nv_ray_tracing_invocation_reorder(self: *DeviceExtensions) void {
        self.nv_ray_tracing_invocation_reorder = true;
        self.enable_khr_ray_tracing_pipeline();
    }

    pub fn supports_nv_cooperative_vector(self: DeviceExtensions) bool {
        return self.nv_cooperative_vector;
    }
    pub fn enable_nv_cooperative_vector(self: *DeviceExtensions) void {
        self.nv_cooperative_vector = true;
    }

    pub fn supports_nv_extended_sparse_address_space(self: DeviceExtensions) bool {
        return self.nv_extended_sparse_address_space;
    }
    pub fn enable_nv_extended_sparse_address_space(self: *DeviceExtensions) void {
        self.nv_extended_sparse_address_space = true;
    }

    pub fn supports_ext_mutable_descriptor_type(self: DeviceExtensions) bool {
        return self.ext_mutable_descriptor_type and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_maintenance3());
    }
    pub fn enable_ext_mutable_descriptor_type(self: *DeviceExtensions) void {
        self.ext_mutable_descriptor_type = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_maintenance3();
        }
    }

    pub fn supports_ext_legacy_vertex_attributes(self: DeviceExtensions) bool {
        return self.ext_legacy_vertex_attributes and self.supports_ext_vertex_input_dynamic_state();
    }
    pub fn enable_ext_legacy_vertex_attributes(self: *DeviceExtensions) void {
        self.ext_legacy_vertex_attributes = true;
        self.enable_ext_vertex_input_dynamic_state();
    }

    pub fn supports_arm_shader_core_builtins(self: DeviceExtensions) bool {
        return self.arm_shader_core_builtins;
    }
    pub fn enable_arm_shader_core_builtins(self: *DeviceExtensions) void {
        self.arm_shader_core_builtins = true;
    }

    pub fn supports_ext_pipeline_library_group_handles(self: DeviceExtensions) bool {
        return self.ext_pipeline_library_group_handles and self.supports_khr_ray_tracing_pipeline() and self.supports_khr_pipeline_library();
    }
    pub fn enable_ext_pipeline_library_group_handles(self: *DeviceExtensions) void {
        self.ext_pipeline_library_group_handles = true;
        self.enable_khr_ray_tracing_pipeline();
        self.enable_khr_pipeline_library();
    }

    pub fn supports_ext_dynamic_rendering_unused_attachments(self: DeviceExtensions) bool {
        return self.ext_dynamic_rendering_unused_attachments and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_dynamic_rendering());
    }
    pub fn enable_ext_dynamic_rendering_unused_attachments(self: *DeviceExtensions) void {
        self.ext_dynamic_rendering_unused_attachments = true;
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_dynamic_rendering();
        }
    }

    pub fn supports_nv_low_latency2(self: DeviceExtensions) bool {
        return self.nv_low_latency2 and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_timeline_semaphore()) and (self.supports_khr_present_id() or self.supports_khr_present_id2());
    }
    pub fn enable_nv_low_latency2(self: *DeviceExtensions) void {
        self.nv_low_latency2 = true;
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_timeline_semaphore();
        }
        // ambiguous dependency, caller must enable one explicitly
        assert(self.supports_khr_present_id() or self.supports_khr_present_id2());
    }

    pub fn supports_khr_cooperative_matrix(self: DeviceExtensions) bool {
        return self.khr_cooperative_matrix;
    }
    pub fn enable_khr_cooperative_matrix(self: *DeviceExtensions) void {
        self.khr_cooperative_matrix = true;
    }

    pub fn supports_arm_data_graph(self: DeviceExtensions) bool {
        return self.arm_data_graph and self.core_version.to_int() >= make_version(1, 3, 0).to_int() and self.supports_khr_maintenance5() and self.supports_khr_deferred_host_operations();
    }
    pub fn enable_arm_data_graph(self: *DeviceExtensions) void {
        self.arm_data_graph = true;
        // depends on minimum core version, caller must specify
        assert(self.core_version.to_int() >= make_version(1, 3, 0).to_int());
        self.enable_khr_maintenance5();
        self.enable_khr_deferred_host_operations();
    }

    pub fn supports_qcom_multiview_per_view_render_areas(self: DeviceExtensions) bool {
        return self.qcom_multiview_per_view_render_areas;
    }
    pub fn enable_qcom_multiview_per_view_render_areas(self: *DeviceExtensions) void {
        self.qcom_multiview_per_view_render_areas = true;
    }

    pub fn supports_khr_compute_shader_derivatives(self: DeviceExtensions) bool {
        return self.khr_compute_shader_derivatives;
    }
    pub fn enable_khr_compute_shader_derivatives(self: *DeviceExtensions) void {
        self.khr_compute_shader_derivatives = true;
    }

    pub fn supports_nv_per_stage_descriptor_set(self: DeviceExtensions) bool {
        return self.nv_per_stage_descriptor_set and (self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.supports_khr_maintenance6());
    }
    pub fn enable_nv_per_stage_descriptor_set(self: *DeviceExtensions) void {
        self.nv_per_stage_descriptor_set = true;
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.enable_khr_maintenance6();
        }
    }

    pub fn supports_qcom_image_processing2(self: DeviceExtensions) bool {
        return self.qcom_image_processing2 and self.supports_qcom_image_processing();
    }
    pub fn enable_qcom_image_processing2(self: *DeviceExtensions) void {
        self.qcom_image_processing2 = true;
        self.enable_qcom_image_processing();
    }

    pub fn supports_qcom_filter_cubic_weights(self: DeviceExtensions) bool {
        return self.qcom_filter_cubic_weights and self.supports_ext_filter_cubic();
    }
    pub fn enable_qcom_filter_cubic_weights(self: *DeviceExtensions) void {
        self.qcom_filter_cubic_weights = true;
        self.enable_ext_filter_cubic();
    }

    pub fn supports_qcom_ycbcr_degamma(self: DeviceExtensions) bool {
        return self.qcom_ycbcr_degamma;
    }
    pub fn enable_qcom_ycbcr_degamma(self: *DeviceExtensions) void {
        self.qcom_ycbcr_degamma = true;
    }

    pub fn supports_qcom_filter_cubic_clamp(self: DeviceExtensions) bool {
        return self.qcom_filter_cubic_clamp and self.supports_ext_filter_cubic() and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_ext_sampler_filter_minmax());
    }
    pub fn enable_qcom_filter_cubic_clamp(self: *DeviceExtensions) void {
        self.qcom_filter_cubic_clamp = true;
        self.enable_ext_filter_cubic();
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_ext_sampler_filter_minmax();
        }
    }

    pub fn supports_ext_attachment_feedback_loop_dynamic_state(self: DeviceExtensions) bool {
        return self.ext_attachment_feedback_loop_dynamic_state and self.supports_ext_attachment_feedback_loop_layout();
    }
    pub fn enable_ext_attachment_feedback_loop_dynamic_state(self: *DeviceExtensions) void {
        self.ext_attachment_feedback_loop_dynamic_state = true;
        self.enable_ext_attachment_feedback_loop_layout();
    }

    pub fn supports_khr_vertex_attribute_divisor(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.khr_vertex_attribute_divisor;
    }
    pub fn enable_khr_vertex_attribute_divisor(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.khr_vertex_attribute_divisor = true;
        }
    }

    pub fn supports_khr_load_store_op_none(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.khr_load_store_op_none;
    }
    pub fn enable_khr_load_store_op_none(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.khr_load_store_op_none = true;
        }
    }

    pub fn supports_khr_unified_image_layouts(self: DeviceExtensions) bool {
        return self.khr_unified_image_layouts;
    }
    pub fn enable_khr_unified_image_layouts(self: *DeviceExtensions) void {
        self.khr_unified_image_layouts = true;
    }

    pub fn supports_khr_shader_float_controls2(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or (self.khr_shader_float_controls2 and self.core_version.to_int() >= make_version(1, 1, 0).to_int() and self.supports_khr_shader_float_controls());
    }
    pub fn enable_khr_shader_float_controls2(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.khr_shader_float_controls2 = true;
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
            self.enable_khr_shader_float_controls();
        }
    }

    pub fn supports_msft_layered_driver(self: DeviceExtensions) bool {
        return self.msft_layered_driver;
    }
    pub fn enable_msft_layered_driver(self: *DeviceExtensions) void {
        self.msft_layered_driver = true;
    }

    pub fn supports_khr_index_type_uint8(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.khr_index_type_uint8;
    }
    pub fn enable_khr_index_type_uint8(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.khr_index_type_uint8 = true;
        }
    }

    pub fn supports_khr_line_rasterization(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.khr_line_rasterization;
    }
    pub fn enable_khr_line_rasterization(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.khr_line_rasterization = true;
        }
    }

    pub fn supports_khr_calibrated_timestamps(self: DeviceExtensions) bool {
        return self.khr_calibrated_timestamps;
    }
    pub fn enable_khr_calibrated_timestamps(self: *DeviceExtensions) void {
        self.khr_calibrated_timestamps = true;
    }

    pub fn supports_khr_shader_expect_assume(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.khr_shader_expect_assume;
    }
    pub fn enable_khr_shader_expect_assume(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.khr_shader_expect_assume = true;
        }
    }

    pub fn supports_khr_maintenance6(self: DeviceExtensions) bool {
        return self.core_version.to_int() >= make_version(1, 4, 0).to_int() or (self.khr_maintenance6 and self.core_version.to_int() >= make_version(1, 1, 0).to_int());
    }
    pub fn enable_khr_maintenance6(self: *DeviceExtensions) void {
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.khr_maintenance6 = true;
            // depends on minimum core version, caller must specify
            assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
        }
    }

    pub fn supports_nv_descriptor_pool_overallocation(self: DeviceExtensions) bool {
        return self.nv_descriptor_pool_overallocation and self.core_version.to_int() >= make_version(1, 1, 0).to_int();
    }
    pub fn enable_nv_descriptor_pool_overallocation(self: *DeviceExtensions) void {
        self.nv_descriptor_pool_overallocation = true;
        // depends on minimum core version, caller must specify
        assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
    }

    pub fn supports_qcom_tile_memory_heap(self: DeviceExtensions) bool {
        return self.qcom_tile_memory_heap and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_get_memory_requirements2());
    }
    pub fn enable_qcom_tile_memory_heap(self: *DeviceExtensions) void {
        self.qcom_tile_memory_heap = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_get_memory_requirements2();
        }
    }

    pub fn supports_nv_raw_access_chains(self: DeviceExtensions) bool {
        return self.nv_raw_access_chains;
    }
    pub fn enable_nv_raw_access_chains(self: *DeviceExtensions) void {
        self.nv_raw_access_chains = true;
    }

    pub fn supports_nv_external_compute_queue(self: DeviceExtensions) bool {
        return self.nv_external_compute_queue;
    }
    pub fn enable_nv_external_compute_queue(self: *DeviceExtensions) void {
        self.nv_external_compute_queue = true;
    }

    pub fn supports_khr_shader_relaxed_extended_instruction(self: DeviceExtensions) bool {
        return self.khr_shader_relaxed_extended_instruction;
    }
    pub fn enable_khr_shader_relaxed_extended_instruction(self: *DeviceExtensions) void {
        self.khr_shader_relaxed_extended_instruction = true;
    }

    pub fn supports_nv_command_buffer_inheritance(self: DeviceExtensions) bool {
        return self.nv_command_buffer_inheritance;
    }
    pub fn enable_nv_command_buffer_inheritance(self: *DeviceExtensions) void {
        self.nv_command_buffer_inheritance = true;
    }

    pub fn supports_khr_maintenance7(self: DeviceExtensions) bool {
        return self.khr_maintenance7 and self.core_version.to_int() >= make_version(1, 1, 0).to_int();
    }
    pub fn enable_khr_maintenance7(self: *DeviceExtensions) void {
        self.khr_maintenance7 = true;
        // depends on minimum core version, caller must specify
        assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
    }

    pub fn supports_nv_shader_atomic_float16_vector(self: DeviceExtensions) bool {
        return self.nv_shader_atomic_float16_vector;
    }
    pub fn enable_nv_shader_atomic_float16_vector(self: *DeviceExtensions) void {
        self.nv_shader_atomic_float16_vector = true;
    }

    pub fn supports_ext_shader_replicated_composites(self: DeviceExtensions) bool {
        return self.ext_shader_replicated_composites;
    }
    pub fn enable_ext_shader_replicated_composites(self: *DeviceExtensions) void {
        self.ext_shader_replicated_composites = true;
    }

    pub fn supports_ext_shader_float8(self: DeviceExtensions) bool {
        return self.ext_shader_float8;
    }
    pub fn enable_ext_shader_float8(self: *DeviceExtensions) void {
        self.ext_shader_float8 = true;
    }

    pub fn supports_nv_ray_tracing_validation(self: DeviceExtensions) bool {
        return self.nv_ray_tracing_validation;
    }
    pub fn enable_nv_ray_tracing_validation(self: *DeviceExtensions) void {
        self.nv_ray_tracing_validation = true;
    }

    pub fn supports_nv_cluster_acceleration_structure(self: DeviceExtensions) bool {
        return self.nv_cluster_acceleration_structure and self.supports_khr_acceleration_structure();
    }
    pub fn enable_nv_cluster_acceleration_structure(self: *DeviceExtensions) void {
        self.nv_cluster_acceleration_structure = true;
        self.enable_khr_acceleration_structure();
    }

    pub fn supports_nv_partitioned_acceleration_structure(self: DeviceExtensions) bool {
        return self.nv_partitioned_acceleration_structure and self.supports_khr_acceleration_structure();
    }
    pub fn enable_nv_partitioned_acceleration_structure(self: *DeviceExtensions) void {
        self.nv_partitioned_acceleration_structure = true;
        self.enable_khr_acceleration_structure();
    }

    pub fn supports_ext_device_generated_commands(self: DeviceExtensions) bool {
        return self.ext_device_generated_commands and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or ((self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_buffer_device_address()) and self.supports_khr_maintenance5()));
    }
    pub fn enable_ext_device_generated_commands(self: *DeviceExtensions) void {
        self.ext_device_generated_commands = true;
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
                self.enable_khr_buffer_device_address();
            }
            self.enable_khr_maintenance5();
        }
    }

    pub fn supports_khr_maintenance8(self: DeviceExtensions) bool {
        return self.khr_maintenance8 and self.core_version.to_int() >= make_version(1, 1, 0).to_int();
    }
    pub fn enable_khr_maintenance8(self: *DeviceExtensions) void {
        self.khr_maintenance8 = true;
        // depends on minimum core version, caller must specify
        assert(self.core_version.to_int() >= make_version(1, 1, 0).to_int());
    }

    pub fn supports_mesa_image_alignment_control(self: DeviceExtensions) bool {
        return self.mesa_image_alignment_control;
    }
    pub fn enable_mesa_image_alignment_control(self: *DeviceExtensions) void {
        self.mesa_image_alignment_control = true;
    }

    pub fn supports_ext_depth_clamp_control(self: DeviceExtensions) bool {
        return self.ext_depth_clamp_control;
    }
    pub fn enable_ext_depth_clamp_control(self: *DeviceExtensions) void {
        self.ext_depth_clamp_control = true;
    }

    pub fn supports_khr_maintenance9(self: DeviceExtensions) bool {
        return self.khr_maintenance9;
    }
    pub fn enable_khr_maintenance9(self: *DeviceExtensions) void {
        self.khr_maintenance9 = true;
    }

    pub fn supports_huawei_hdr_vivid(self: DeviceExtensions) bool {
        return self.huawei_hdr_vivid and self.supports_khr_swapchain() and self.supports_ext_hdr_metadata();
    }
    pub fn enable_huawei_hdr_vivid(self: *DeviceExtensions) void {
        self.huawei_hdr_vivid = true;
        self.enable_khr_swapchain();
        self.enable_ext_hdr_metadata();
    }

    pub fn supports_nv_cooperative_matrix2(self: DeviceExtensions) bool {
        return self.nv_cooperative_matrix2 and self.supports_khr_cooperative_matrix();
    }
    pub fn enable_nv_cooperative_matrix2(self: *DeviceExtensions) void {
        self.nv_cooperative_matrix2 = true;
        self.enable_khr_cooperative_matrix();
    }

    pub fn supports_arm_pipeline_opacity_micromap(self: DeviceExtensions) bool {
        return self.arm_pipeline_opacity_micromap and self.supports_ext_opacity_micromap();
    }
    pub fn enable_arm_pipeline_opacity_micromap(self: *DeviceExtensions) void {
        self.arm_pipeline_opacity_micromap = true;
        self.enable_ext_opacity_micromap();
    }

    pub fn supports_ext_external_memory_metal(self: DeviceExtensions) bool {
        return self.ext_external_memory_metal and (self.core_version.to_int() >= make_version(1, 1, 0).to_int() or self.supports_khr_external_memory());
    }
    pub fn enable_ext_external_memory_metal(self: *DeviceExtensions) void {
        self.ext_external_memory_metal = true;
        if (self.core_version.to_int() < make_version(1, 1, 0).to_int()) {
            self.enable_khr_external_memory();
        }
    }

    pub fn supports_khr_depth_clamp_zero_one(self: DeviceExtensions) bool {
        return self.khr_depth_clamp_zero_one;
    }
    pub fn enable_khr_depth_clamp_zero_one(self: *DeviceExtensions) void {
        self.khr_depth_clamp_zero_one = true;
    }

    pub fn supports_ext_vertex_attribute_robustness(self: DeviceExtensions) bool {
        return self.ext_vertex_attribute_robustness;
    }
    pub fn enable_ext_vertex_attribute_robustness(self: *DeviceExtensions) void {
        self.ext_vertex_attribute_robustness = true;
    }

    pub fn supports_arm_format_pack(self: DeviceExtensions) bool {
        return self.arm_format_pack;
    }
    pub fn enable_arm_format_pack(self: *DeviceExtensions) void {
        self.arm_format_pack = true;
    }

    pub fn supports_valve_fragment_density_map_layered(self: DeviceExtensions) bool {
        return self.valve_fragment_density_map_layered and (self.core_version.to_int() >= make_version(1, 4, 0).to_int() or self.supports_khr_maintenance5()) and self.supports_ext_fragment_density_map();
    }
    pub fn enable_valve_fragment_density_map_layered(self: *DeviceExtensions) void {
        self.valve_fragment_density_map_layered = true;
        if (self.core_version.to_int() < make_version(1, 4, 0).to_int()) {
            self.enable_khr_maintenance5();
        }
        self.enable_ext_fragment_density_map();
    }

    pub fn supports_khr_robustness2(self: DeviceExtensions) bool {
        return self.khr_robustness2;
    }
    pub fn enable_khr_robustness2(self: *DeviceExtensions) void {
        self.khr_robustness2 = true;
    }

    pub fn supports_nv_present_metering(self: DeviceExtensions) bool {
        return self.nv_present_metering;
    }
    pub fn enable_nv_present_metering(self: *DeviceExtensions) void {
        self.nv_present_metering = true;
    }

    pub fn supports_ext_fragment_density_map_offset(self: DeviceExtensions) bool {
        return self.ext_fragment_density_map_offset and self.supports_ext_fragment_density_map() and (self.core_version.to_int() >= make_version(1, 2, 0).to_int() or self.supports_khr_create_renderpass2()) and (self.core_version.to_int() >= make_version(1, 3, 0).to_int() or self.supports_khr_dynamic_rendering());
    }
    pub fn enable_ext_fragment_density_map_offset(self: *DeviceExtensions) void {
        self.ext_fragment_density_map_offset = true;
        self.enable_ext_fragment_density_map();
        if (self.core_version.to_int() < make_version(1, 2, 0).to_int()) {
            self.enable_khr_create_renderpass2();
        }
        if (self.core_version.to_int() < make_version(1, 3, 0).to_int()) {
            self.enable_khr_dynamic_rendering();
        }
    }

    pub fn supports_ext_zero_initialize_device_memory(self: DeviceExtensions) bool {
        return self.ext_zero_initialize_device_memory;
    }
    pub fn enable_ext_zero_initialize_device_memory(self: *DeviceExtensions) void {
        self.ext_zero_initialize_device_memory = true;
    }

    pub fn supports_khr_present_mode_fifo_latest_ready(self: DeviceExtensions) bool {
        return self.khr_present_mode_fifo_latest_ready and self.supports_khr_swapchain();
    }
    pub fn enable_khr_present_mode_fifo_latest_ready(self: *DeviceExtensions) void {
        self.khr_present_mode_fifo_latest_ready = true;
        self.enable_khr_swapchain();
    }

    pub fn supports_sec_pipeline_cache_incremental_mode(self: DeviceExtensions) bool {
        return self.sec_pipeline_cache_incremental_mode;
    }
    pub fn enable_sec_pipeline_cache_incremental_mode(self: *DeviceExtensions) void {
        self.sec_pipeline_cache_incremental_mode = true;
    }
};

pub const GlobalCommands = struct {
    fp_create_instance: FpCreateInstance,
    fp_get_instance_proc_addr: FpGetInstanceProcAddr,
    fp_enumerate_instance_version: ?FpEnumerateInstanceVersion,
    fp_enumerate_instance_layer_properties: FpEnumerateInstanceLayerProperties,
    fp_enumerate_instance_extension_properties: FpEnumerateInstanceExtensionProperties,

    pub fn init(fp_get_instance_proc_addr: FpGetInstanceProcAddr) MissingFunctionError!GlobalCommands {
        return .{
            .fp_create_instance = @ptrCast(try get_proc_addr(fp_get_instance_proc_addr, "vkCreateInstance")),
            .fp_get_instance_proc_addr = fp_get_instance_proc_addr,
            .fp_enumerate_instance_version = @ptrCast(fp_get_instance_proc_addr(.null_handle, "vkEnumerateInstanceVersion")),
            .fp_enumerate_instance_layer_properties = @ptrCast(try get_proc_addr(fp_get_instance_proc_addr, "vkEnumerateInstanceLayerProperties")),
            .fp_enumerate_instance_extension_properties = @ptrCast(try get_proc_addr(fp_get_instance_proc_addr, "vkEnumerateInstanceExtensionProperties")),
        };
    }
    fn get_proc_addr(
        fp_get_instance_proc_addr: FpGetInstanceProcAddr,
        p_name: [*:0]const u8,
    ) MissingFunctionError!FpVoidFunction {
        return fp_get_instance_proc_addr(.null_handle, p_name) orelse return error.MissingFunction;
    }

    pub fn get_instance_proc_addr(
        self: GlobalCommands,
        instance: Instance,
        p_name: [*:0]const u8,
    ) MissingFunctionError!FpVoidFunction {
        return self.fp_get_instance_proc_addr(instance, p_name) orelse return error.MissingFunction;
    }

    pub const EnumerateInstanceVersionError = error{
        OutOfHostMemory,
        Unexpected,
    };
    pub fn enumerate_instance_version(
        self: GlobalCommands,
    ) EnumerateInstanceVersionError!Version {
        if (self.fp_enumerate_instance_version) |fp| {
            var version: Version = undefined;
            switch (fp(&version)) {
                .success => return version,
                .error_out_of_host_memory => return error.OutOfHostMemory,
                else => return error.Unexpected,
            }
        } else {
            return make_version(1, 0, 0);
        }
    }

    pub const CreateInstanceOrMissingFunctionError = CreateInstanceError || MissingFunctionError;
    pub fn create_instance_to_commands(
        self: GlobalCommands,
        p_create_info: *const InstanceCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateInstanceOrMissingFunctionError!InstanceCommands {
        const instance = try self.create_instance(p_create_info, p_allocator);
        return InstanceCommands.init(self, instance, p_create_info);
    }
    pub const CreateInstanceError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InitializationFailed,
        LayerNotPresent,
        ExtensionNotPresent,
        IncompatibleDriver,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_instance(
        self: GlobalCommands,
        p_create_info: *const InstanceCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateInstanceError!Instance {
        var p_instance: Instance = undefined;
        switch (self.fp_create_instance(p_create_info, p_allocator, &p_instance)) {
            .success => return p_instance,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_layer_not_present => return error.LayerNotPresent,
            .error_extension_not_present => return error.ExtensionNotPresent,
            .error_incompatible_driver => return error.IncompatibleDriver,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const EnumerateInstanceLayerPropertiesError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn enumerate_instance_layer_properties(
        self: GlobalCommands,
        p_property_count: *u32,
        p_properties: ?[*]LayerProperties,
    ) EnumerateInstanceLayerPropertiesError!EnumerateResult {
        switch (self.fp_enumerate_instance_layer_properties(p_property_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const EnumerateInstanceLayerPropertiesOrAllocatorError = EnumerateInstanceLayerPropertiesError || Allocator.Error;
    pub fn enumerate_instance_layer_properties_to_array(
        self: GlobalCommands,
        allocator: Allocator,
    ) EnumerateInstanceLayerPropertiesOrAllocatorError![]LayerProperties {
        const enumerator = struct {
            self: *const GlobalCommands,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]LayerProperties) !EnumerateResult {
                return enumerator.self.enumerate_instance_layer_properties(
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
        };
        return enumerate_generic_to_array(EnumerateInstanceLayerPropertiesOrAllocatorError, LayerProperties, enumerator, allocator);
    }
    pub const EnumerateInstanceExtensionPropertiesError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        LayerNotPresent,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn enumerate_instance_extension_properties(
        self: GlobalCommands,
        p_layer_name: ?[*:0]const u8,
        p_property_count: *u32,
        p_properties: ?[*]ExtensionProperties,
    ) EnumerateInstanceExtensionPropertiesError!EnumerateResult {
        switch (self.fp_enumerate_instance_extension_properties(p_layer_name, p_property_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_layer_not_present => return error.LayerNotPresent,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const EnumerateInstanceExtensionPropertiesOrAllocatorError = EnumerateInstanceExtensionPropertiesError || Allocator.Error;
    pub fn enumerate_instance_extension_properties_to_array(
        self: GlobalCommands,
        allocator: Allocator,
        p_layer_name: ?[*:0]const u8,
    ) EnumerateInstanceExtensionPropertiesOrAllocatorError![]ExtensionProperties {
        const enumerator = struct {
            self: *const GlobalCommands,
            p_layer_name: ?[*:0]const u8,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]ExtensionProperties) !EnumerateResult {
                return enumerator.self.enumerate_instance_extension_properties(
                    enumerator.p_layer_name,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .p_layer_name = p_layer_name,
        };
        return enumerate_generic_to_array(EnumerateInstanceExtensionPropertiesOrAllocatorError, ExtensionProperties, enumerator, allocator);
    }
};

pub const InstanceCommands = struct {
    handle: Instance,
    extensions: InstanceExtensions,
    fp_destroy_instance: FpDestroyInstance,
    fp_enumerate_physical_devices: FpEnumeratePhysicalDevices,
    fp_get_device_proc_addr: FpGetDeviceProcAddr,
    fp_get_physical_device_properties: FpGetPhysicalDeviceProperties,
    fp_get_physical_device_queue_family_properties: FpGetPhysicalDeviceQueueFamilyProperties,
    fp_get_physical_device_memory_properties: FpGetPhysicalDeviceMemoryProperties,
    fp_get_physical_device_features: FpGetPhysicalDeviceFeatures,
    fp_get_physical_device_format_properties: FpGetPhysicalDeviceFormatProperties,
    fp_get_physical_device_image_format_properties: FpGetPhysicalDeviceImageFormatProperties,
    fp_create_device: FpCreateDevice,
    fp_enumerate_device_layer_properties: FpEnumerateDeviceLayerProperties,
    fp_enumerate_device_extension_properties: FpEnumerateDeviceExtensionProperties,
    fp_get_physical_device_sparse_image_format_properties: FpGetPhysicalDeviceSparseImageFormatProperties,
    fp_create_android_surface_khr: ?FpCreateAndroidSurfaceKHR,
    fp_create_surface_ohos: ?FpCreateSurfaceOHOS,
    fp_get_physical_device_display_properties_khr: ?FpGetPhysicalDeviceDisplayPropertiesKHR,
    fp_get_physical_device_display_plane_properties_khr: ?FpGetPhysicalDeviceDisplayPlanePropertiesKHR,
    fp_get_display_plane_supported_displays_khr: ?FpGetDisplayPlaneSupportedDisplaysKHR,
    fp_get_display_mode_properties_khr: ?FpGetDisplayModePropertiesKHR,
    fp_create_display_mode_khr: ?FpCreateDisplayModeKHR,
    fp_get_display_plane_capabilities_khr: ?FpGetDisplayPlaneCapabilitiesKHR,
    fp_create_display_plane_surface_khr: ?FpCreateDisplayPlaneSurfaceKHR,
    fp_destroy_surface_khr: ?FpDestroySurfaceKHR,
    fp_get_physical_device_surface_support_khr: ?FpGetPhysicalDeviceSurfaceSupportKHR,
    fp_get_physical_device_surface_capabilities_khr: ?FpGetPhysicalDeviceSurfaceCapabilitiesKHR,
    fp_get_physical_device_surface_formats_khr: ?FpGetPhysicalDeviceSurfaceFormatsKHR,
    fp_get_physical_device_surface_present_modes_khr: ?FpGetPhysicalDeviceSurfacePresentModesKHR,
    fp_create_vi_surface_nn: ?FpCreateViSurfaceNN,
    fp_create_wayland_surface_khr: ?FpCreateWaylandSurfaceKHR,
    fp_get_physical_device_wayland_presentation_support_khr: ?FpGetPhysicalDeviceWaylandPresentationSupportKHR,
    fp_create_win32_surface_khr: ?FpCreateWin32SurfaceKHR,
    fp_get_physical_device_win32_presentation_support_khr: ?FpGetPhysicalDeviceWin32PresentationSupportKHR,
    fp_create_xlib_surface_khr: ?FpCreateXlibSurfaceKHR,
    fp_get_physical_device_xlib_presentation_support_khr: ?FpGetPhysicalDeviceXlibPresentationSupportKHR,
    fp_create_xcb_surface_khr: ?FpCreateXcbSurfaceKHR,
    fp_get_physical_device_xcb_presentation_support_khr: ?FpGetPhysicalDeviceXcbPresentationSupportKHR,
    fp_create_direct_fb_surface_ext: ?FpCreateDirectFBSurfaceEXT,
    fp_get_physical_device_direct_fb_presentation_support_ext: ?FpGetPhysicalDeviceDirectFBPresentationSupportEXT,
    fp_create_image_pipe_surface_fuchsia: ?FpCreateImagePipeSurfaceFUCHSIA,
    fp_create_debug_report_callback_ext: ?FpCreateDebugReportCallbackEXT,
    fp_destroy_debug_report_callback_ext: ?FpDestroyDebugReportCallbackEXT,
    fp_debug_report_message_ext: ?FpDebugReportMessageEXT,
    fp_get_physical_device_external_image_format_properties_nv: ?FpGetPhysicalDeviceExternalImageFormatPropertiesNV,
    fp_get_physical_device_features2: ?FpGetPhysicalDeviceFeatures2,
    fp_get_physical_device_properties2: ?FpGetPhysicalDeviceProperties2,
    fp_get_physical_device_format_properties2: ?FpGetPhysicalDeviceFormatProperties2,
    fp_get_physical_device_image_format_properties2: ?FpGetPhysicalDeviceImageFormatProperties2,
    fp_get_physical_device_queue_family_properties2: ?FpGetPhysicalDeviceQueueFamilyProperties2,
    fp_get_physical_device_memory_properties2: ?FpGetPhysicalDeviceMemoryProperties2,
    fp_get_physical_device_sparse_image_format_properties2: ?FpGetPhysicalDeviceSparseImageFormatProperties2,
    fp_get_physical_device_external_buffer_properties: ?FpGetPhysicalDeviceExternalBufferProperties,
    fp_get_physical_device_external_semaphore_properties: ?FpGetPhysicalDeviceExternalSemaphoreProperties,
    fp_get_physical_device_external_fence_properties: ?FpGetPhysicalDeviceExternalFenceProperties,
    fp_release_display_ext: ?FpReleaseDisplayEXT,
    fp_acquire_xlib_display_ext: ?FpAcquireXlibDisplayEXT,
    fp_get_rand_r_output_display_ext: ?FpGetRandROutputDisplayEXT,
    fp_get_physical_device_surface_capabilities2_ext: ?FpGetPhysicalDeviceSurfaceCapabilities2EXT,
    fp_enumerate_physical_device_groups: ?FpEnumeratePhysicalDeviceGroups,
    fp_create_ios_surface_mvk: ?FpCreateIOSSurfaceMVK,
    fp_create_mac_os_surface_mvk: ?FpCreateMacOSSurfaceMVK,
    fp_create_metal_surface_ext: ?FpCreateMetalSurfaceEXT,
    fp_get_physical_device_surface_capabilities2_khr: ?FpGetPhysicalDeviceSurfaceCapabilities2KHR,
    fp_get_physical_device_surface_formats2_khr: ?FpGetPhysicalDeviceSurfaceFormats2KHR,
    fp_get_physical_device_display_properties2_khr: ?FpGetPhysicalDeviceDisplayProperties2KHR,
    fp_get_physical_device_display_plane_properties2_khr: ?FpGetPhysicalDeviceDisplayPlaneProperties2KHR,
    fp_get_display_mode_properties2_khr: ?FpGetDisplayModeProperties2KHR,
    fp_get_display_plane_capabilities2_khr: ?FpGetDisplayPlaneCapabilities2KHR,
    fp_set_debug_utils_object_name_ext: ?FpSetDebugUtilsObjectNameEXT,
    fp_set_debug_utils_object_tag_ext: ?FpSetDebugUtilsObjectTagEXT,
    fp_queue_begin_debug_utils_label_ext: ?FpQueueBeginDebugUtilsLabelEXT,
    fp_queue_end_debug_utils_label_ext: ?FpQueueEndDebugUtilsLabelEXT,
    fp_queue_insert_debug_utils_label_ext: ?FpQueueInsertDebugUtilsLabelEXT,
    fp_cmd_begin_debug_utils_label_ext: ?FpCmdBeginDebugUtilsLabelEXT,
    fp_cmd_end_debug_utils_label_ext: ?FpCmdEndDebugUtilsLabelEXT,
    fp_cmd_insert_debug_utils_label_ext: ?FpCmdInsertDebugUtilsLabelEXT,
    fp_create_debug_utils_messenger_ext: ?FpCreateDebugUtilsMessengerEXT,
    fp_destroy_debug_utils_messenger_ext: ?FpDestroyDebugUtilsMessengerEXT,
    fp_submit_debug_utils_message_ext: ?FpSubmitDebugUtilsMessageEXT,
    fp_create_headless_surface_ext: ?FpCreateHeadlessSurfaceEXT,
    fp_acquire_drm_display_ext: ?FpAcquireDrmDisplayEXT,
    fp_get_drm_display_ext: ?FpGetDrmDisplayEXT,

    pub fn init(globals: GlobalCommands, instance: Instance, create_info: *const InstanceCreateInfo) MissingFunctionError!InstanceCommands {
        var extensions: InstanceExtensions = .{
            .core_version = make_version(1, 0, 0),
        };
        if (create_info.p_application_info) |app_info| {
            extensions.core_version = app_info.api_version;
        }
        if (create_info.pp_enabled_extension_names) |extension_names| {
            for (0..create_info.enabled_extension_count) |i| {
                extensions.enable_by_name(extension_names[i]);
            }
        }
        return .{
            .handle = instance,
            .extensions = extensions,
            .fp_destroy_instance = @ptrCast(try globals.get_instance_proc_addr(instance, "vkDestroyInstance")),
            .fp_enumerate_physical_devices = @ptrCast(try globals.get_instance_proc_addr(instance, "vkEnumeratePhysicalDevices")),
            .fp_get_device_proc_addr = @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetDeviceProcAddr")),
            .fp_get_physical_device_properties = @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceProperties")),
            .fp_get_physical_device_queue_family_properties = @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceQueueFamilyProperties")),
            .fp_get_physical_device_memory_properties = @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceMemoryProperties")),
            .fp_get_physical_device_features = @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceFeatures")),
            .fp_get_physical_device_format_properties = @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceFormatProperties")),
            .fp_get_physical_device_image_format_properties = @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceImageFormatProperties")),
            .fp_create_device = @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateDevice")),
            .fp_enumerate_device_layer_properties = @ptrCast(try globals.get_instance_proc_addr(instance, "vkEnumerateDeviceLayerProperties")),
            .fp_enumerate_device_extension_properties = @ptrCast(try globals.get_instance_proc_addr(instance, "vkEnumerateDeviceExtensionProperties")),
            .fp_get_physical_device_sparse_image_format_properties = @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties")),
            .fp_create_android_surface_khr = if (extensions.khr_android_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateAndroidSurfaceKHR")) else null,
            .fp_create_surface_ohos = if (extensions.ohos_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateSurfaceOHOS")) else null,
            .fp_get_physical_device_display_properties_khr = if (extensions.khr_display) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceDisplayPropertiesKHR")) else null,
            .fp_get_physical_device_display_plane_properties_khr = if (extensions.khr_display) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR")) else null,
            .fp_get_display_plane_supported_displays_khr = if (extensions.khr_display) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetDisplayPlaneSupportedDisplaysKHR")) else null,
            .fp_get_display_mode_properties_khr = if (extensions.khr_display) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetDisplayModePropertiesKHR")) else null,
            .fp_create_display_mode_khr = if (extensions.khr_display) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateDisplayModeKHR")) else null,
            .fp_get_display_plane_capabilities_khr = if (extensions.khr_display) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetDisplayPlaneCapabilitiesKHR")) else null,
            .fp_create_display_plane_surface_khr = if (extensions.khr_display) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateDisplayPlaneSurfaceKHR")) else null,
            .fp_destroy_surface_khr = if (extensions.khr_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkDestroySurfaceKHR")) else null,
            .fp_get_physical_device_surface_support_khr = if (extensions.khr_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceSurfaceSupportKHR")) else null,
            .fp_get_physical_device_surface_capabilities_khr = if (extensions.khr_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR")) else null,
            .fp_get_physical_device_surface_formats_khr = if (extensions.khr_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceSurfaceFormatsKHR")) else null,
            .fp_get_physical_device_surface_present_modes_khr = if (extensions.khr_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceSurfacePresentModesKHR")) else null,
            .fp_create_vi_surface_nn = if (extensions.nn_vi_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateViSurfaceNN")) else null,
            .fp_create_wayland_surface_khr = if (extensions.khr_wayland_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateWaylandSurfaceKHR")) else null,
            .fp_get_physical_device_wayland_presentation_support_khr = if (extensions.khr_wayland_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceWaylandPresentationSupportKHR")) else null,
            .fp_create_win32_surface_khr = if (extensions.khr_win32_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateWin32SurfaceKHR")) else null,
            .fp_get_physical_device_win32_presentation_support_khr = if (extensions.khr_win32_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceWin32PresentationSupportKHR")) else null,
            .fp_create_xlib_surface_khr = if (extensions.khr_xlib_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateXlibSurfaceKHR")) else null,
            .fp_get_physical_device_xlib_presentation_support_khr = if (extensions.khr_xlib_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceXlibPresentationSupportKHR")) else null,
            .fp_create_xcb_surface_khr = if (extensions.khr_xcb_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateXcbSurfaceKHR")) else null,
            .fp_get_physical_device_xcb_presentation_support_khr = if (extensions.khr_xcb_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceXcbPresentationSupportKHR")) else null,
            .fp_create_direct_fb_surface_ext = if (extensions.ext_directfb_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateDirectFBSurfaceEXT")) else null,
            .fp_get_physical_device_direct_fb_presentation_support_ext = if (extensions.ext_directfb_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT")) else null,
            .fp_create_image_pipe_surface_fuchsia = if (extensions.fuchsia_imagepipe_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateImagePipeSurfaceFUCHSIA")) else null,
            .fp_create_debug_report_callback_ext = if (extensions.ext_debug_report) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateDebugReportCallbackEXT")) else null,
            .fp_destroy_debug_report_callback_ext = if (extensions.ext_debug_report) @ptrCast(try globals.get_instance_proc_addr(instance, "vkDestroyDebugReportCallbackEXT")) else null,
            .fp_debug_report_message_ext = if (extensions.ext_debug_report) @ptrCast(try globals.get_instance_proc_addr(instance, "vkDebugReportMessageEXT")) else null,
            .fp_get_physical_device_external_image_format_properties_nv = if (extensions.nv_external_memory_capabilities) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV")) else null,
            .fp_get_physical_device_features2 = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceFeatures2")) else if (extensions.khr_get_physical_device_properties2) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceFeatures2KHR")) else null,
            .fp_get_physical_device_properties2 = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceProperties2")) else if (extensions.khr_get_physical_device_properties2) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceProperties2KHR")) else null,
            .fp_get_physical_device_format_properties2 = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceFormatProperties2")) else if (extensions.khr_get_physical_device_properties2) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceFormatProperties2KHR")) else null,
            .fp_get_physical_device_image_format_properties2 = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceImageFormatProperties2")) else if (extensions.khr_get_physical_device_properties2) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceImageFormatProperties2KHR")) else null,
            .fp_get_physical_device_queue_family_properties2 = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceQueueFamilyProperties2")) else if (extensions.khr_get_physical_device_properties2) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceQueueFamilyProperties2KHR")) else null,
            .fp_get_physical_device_memory_properties2 = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceMemoryProperties2")) else if (extensions.khr_get_physical_device_properties2) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceMemoryProperties2KHR")) else null,
            .fp_get_physical_device_sparse_image_format_properties2 = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties2")) else if (extensions.khr_get_physical_device_properties2) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR")) else null,
            .fp_get_physical_device_external_buffer_properties = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceExternalBufferProperties")) else if (extensions.khr_external_memory_capabilities) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceExternalBufferPropertiesKHR")) else null,
            .fp_get_physical_device_external_semaphore_properties = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceExternalSemaphoreProperties")) else if (extensions.khr_external_semaphore_capabilities) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR")) else null,
            .fp_get_physical_device_external_fence_properties = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceExternalFenceProperties")) else if (extensions.khr_external_fence_capabilities) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceExternalFencePropertiesKHR")) else null,
            .fp_release_display_ext = if (extensions.ext_direct_mode_display) @ptrCast(try globals.get_instance_proc_addr(instance, "vkReleaseDisplayEXT")) else null,
            .fp_acquire_xlib_display_ext = if (extensions.ext_acquire_xlib_display) @ptrCast(try globals.get_instance_proc_addr(instance, "vkAcquireXlibDisplayEXT")) else null,
            .fp_get_rand_r_output_display_ext = if (extensions.ext_acquire_xlib_display) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetRandROutputDisplayEXT")) else null,
            .fp_get_physical_device_surface_capabilities2_ext = if (extensions.ext_display_surface_counter) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceSurfaceCapabilities2EXT")) else null,
            .fp_enumerate_physical_device_groups = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try globals.get_instance_proc_addr(instance, "vkEnumeratePhysicalDeviceGroups")) else if (extensions.khr_device_group_creation) @ptrCast(try globals.get_instance_proc_addr(instance, "vkEnumeratePhysicalDeviceGroupsKHR")) else null,
            .fp_create_ios_surface_mvk = if (extensions.mvk_ios_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateIOSSurfaceMVK")) else null,
            .fp_create_mac_os_surface_mvk = if (extensions.mvk_macos_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateMacOSSurfaceMVK")) else null,
            .fp_create_metal_surface_ext = if (extensions.ext_metal_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateMetalSurfaceEXT")) else null,
            .fp_get_physical_device_surface_capabilities2_khr = if (extensions.khr_get_surface_capabilities2) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceSurfaceCapabilities2KHR")) else null,
            .fp_get_physical_device_surface_formats2_khr = if (extensions.khr_get_surface_capabilities2) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceSurfaceFormats2KHR")) else null,
            .fp_get_physical_device_display_properties2_khr = if (extensions.khr_get_display_properties2) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceDisplayProperties2KHR")) else null,
            .fp_get_physical_device_display_plane_properties2_khr = if (extensions.khr_get_display_properties2) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR")) else null,
            .fp_get_display_mode_properties2_khr = if (extensions.khr_get_display_properties2) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetDisplayModeProperties2KHR")) else null,
            .fp_get_display_plane_capabilities2_khr = if (extensions.khr_get_display_properties2) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetDisplayPlaneCapabilities2KHR")) else null,
            .fp_set_debug_utils_object_name_ext = if (extensions.ext_debug_utils) @ptrCast(try globals.get_instance_proc_addr(instance, "vkSetDebugUtilsObjectNameEXT")) else null,
            .fp_set_debug_utils_object_tag_ext = if (extensions.ext_debug_utils) @ptrCast(try globals.get_instance_proc_addr(instance, "vkSetDebugUtilsObjectTagEXT")) else null,
            .fp_queue_begin_debug_utils_label_ext = if (extensions.ext_debug_utils) @ptrCast(try globals.get_instance_proc_addr(instance, "vkQueueBeginDebugUtilsLabelEXT")) else null,
            .fp_queue_end_debug_utils_label_ext = if (extensions.ext_debug_utils) @ptrCast(try globals.get_instance_proc_addr(instance, "vkQueueEndDebugUtilsLabelEXT")) else null,
            .fp_queue_insert_debug_utils_label_ext = if (extensions.ext_debug_utils) @ptrCast(try globals.get_instance_proc_addr(instance, "vkQueueInsertDebugUtilsLabelEXT")) else null,
            .fp_cmd_begin_debug_utils_label_ext = if (extensions.ext_debug_utils) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCmdBeginDebugUtilsLabelEXT")) else null,
            .fp_cmd_end_debug_utils_label_ext = if (extensions.ext_debug_utils) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCmdEndDebugUtilsLabelEXT")) else null,
            .fp_cmd_insert_debug_utils_label_ext = if (extensions.ext_debug_utils) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCmdInsertDebugUtilsLabelEXT")) else null,
            .fp_create_debug_utils_messenger_ext = if (extensions.ext_debug_utils) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateDebugUtilsMessengerEXT")) else null,
            .fp_destroy_debug_utils_messenger_ext = if (extensions.ext_debug_utils) @ptrCast(try globals.get_instance_proc_addr(instance, "vkDestroyDebugUtilsMessengerEXT")) else null,
            .fp_submit_debug_utils_message_ext = if (extensions.ext_debug_utils) @ptrCast(try globals.get_instance_proc_addr(instance, "vkSubmitDebugUtilsMessageEXT")) else null,
            .fp_create_headless_surface_ext = if (extensions.ext_headless_surface) @ptrCast(try globals.get_instance_proc_addr(instance, "vkCreateHeadlessSurfaceEXT")) else null,
            .fp_acquire_drm_display_ext = if (extensions.ext_acquire_drm_display) @ptrCast(try globals.get_instance_proc_addr(instance, "vkAcquireDrmDisplayEXT")) else null,
            .fp_get_drm_display_ext = if (extensions.ext_acquire_drm_display) @ptrCast(try globals.get_instance_proc_addr(instance, "vkGetDrmDisplayEXT")) else null,
        };
    }
    pub fn get_device_proc_addr(
        self: InstanceCommands,
        device: Device,
        p_name: [*:0]const u8,
    ) MissingFunctionError!FpVoidFunction {
        return self.fp_get_device_proc_addr(device, p_name) orelse return error.MissingFunction;
    }

    pub const CreateDeviceOrMissingFunctionError = CreateDeviceError || MissingFunctionError;
    pub fn create_device_to_commands(
        self: InstanceCommands,
        globals: GlobalCommands,
        physical_device: PhysicalDevice,
        p_create_info: *const DeviceCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateDeviceOrMissingFunctionError!DeviceCommands {
        const device = try self.create_device(physical_device, p_create_info, p_allocator);
        return DeviceCommands.init(globals, self, device, p_create_info);
    }
    pub fn destroy_instance(
        self: InstanceCommands,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_instance(self.handle, p_allocator);
    }
    pub const EnumeratePhysicalDevicesError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn enumerate_physical_devices(
        self: InstanceCommands,
        p_physical_device_count: *u32,
        p_physical_devices: ?[*]PhysicalDevice,
    ) EnumeratePhysicalDevicesError!EnumerateResult {
        switch (self.fp_enumerate_physical_devices(self.handle, p_physical_device_count, p_physical_devices)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const EnumeratePhysicalDevicesOrAllocatorError = EnumeratePhysicalDevicesError || Allocator.Error;
    pub fn enumerate_physical_devices_to_array(
        self: InstanceCommands,
        allocator: Allocator,
    ) EnumeratePhysicalDevicesOrAllocatorError![]PhysicalDevice {
        const enumerator = struct {
            self: *const InstanceCommands,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]PhysicalDevice) !EnumerateResult {
                return enumerator.self.enumerate_physical_devices(
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
        };
        return enumerate_generic_to_array(EnumeratePhysicalDevicesOrAllocatorError, PhysicalDevice, enumerator, allocator);
    }
    pub fn get_physical_device_properties(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
    ) PhysicalDeviceProperties {
        var p_properties: PhysicalDeviceProperties = undefined;
        self.fp_get_physical_device_properties(physical_device, &p_properties);
        return p_properties;
    }
    pub fn get_physical_device_queue_family_properties(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_queue_family_property_count: *u32,
        p_queue_family_properties: ?[*]QueueFamilyProperties,
    ) void {
        self.fp_get_physical_device_queue_family_properties(physical_device, p_queue_family_property_count, p_queue_family_properties);
    }
    pub fn get_physical_device_queue_family_properties_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
    ) Allocator.Error![]QueueFamilyProperties {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]QueueFamilyProperties) void {
                return enumerator.self.get_physical_device_queue_family_properties(
                    enumerator.physical_device,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
        };
        return enumerate_generic_unchecked_to_array(QueueFamilyProperties, enumerator, allocator);
    }
    pub fn get_physical_device_memory_properties(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
    ) PhysicalDeviceMemoryProperties {
        var p_memory_properties: PhysicalDeviceMemoryProperties = undefined;
        self.fp_get_physical_device_memory_properties(physical_device, &p_memory_properties);
        return p_memory_properties;
    }
    pub fn get_physical_device_features(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
    ) PhysicalDeviceFeatures {
        var p_features: PhysicalDeviceFeatures = undefined;
        self.fp_get_physical_device_features(physical_device, &p_features);
        return p_features;
    }
    pub fn get_physical_device_format_properties(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        format: Format,
    ) FormatProperties {
        var p_format_properties: FormatProperties = undefined;
        self.fp_get_physical_device_format_properties(physical_device, format, &p_format_properties);
        return p_format_properties;
    }
    pub const GetPhysicalDeviceImageFormatPropertiesError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        FormatNotSupported,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_image_format_properties(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        format: Format,
        @"type": ImageType,
        tiling: ImageTiling,
        usage: ImageUsageFlags,
        flags: ImageCreateFlags,
    ) GetPhysicalDeviceImageFormatPropertiesError!ImageFormatProperties {
        var p_image_format_properties: ImageFormatProperties = undefined;
        switch (self.fp_get_physical_device_image_format_properties(physical_device, format, @"type", tiling, usage, flags, &p_image_format_properties)) {
            .success => return p_image_format_properties,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_format_not_supported => return error.FormatNotSupported,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateDeviceError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InitializationFailed,
        ExtensionNotPresent,
        FeatureNotPresent,
        TooManyObjects,
        DeviceLost,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_device(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_create_info: *const DeviceCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateDeviceError!Device {
        var p_device: Device = undefined;
        switch (self.fp_create_device(physical_device, p_create_info, p_allocator, &p_device)) {
            .success => return p_device,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_extension_not_present => return error.ExtensionNotPresent,
            .error_feature_not_present => return error.FeatureNotPresent,
            .error_too_many_objects => return error.TooManyObjects,
            .error_device_lost => return error.DeviceLost,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const EnumerateDeviceLayerPropertiesError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn enumerate_device_layer_properties(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_property_count: *u32,
        p_properties: ?[*]LayerProperties,
    ) EnumerateDeviceLayerPropertiesError!EnumerateResult {
        switch (self.fp_enumerate_device_layer_properties(physical_device, p_property_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const EnumerateDeviceLayerPropertiesOrAllocatorError = EnumerateDeviceLayerPropertiesError || Allocator.Error;
    pub fn enumerate_device_layer_properties_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
    ) EnumerateDeviceLayerPropertiesOrAllocatorError![]LayerProperties {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]LayerProperties) !EnumerateResult {
                return enumerator.self.enumerate_device_layer_properties(
                    enumerator.physical_device,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
        };
        return enumerate_generic_to_array(EnumerateDeviceLayerPropertiesOrAllocatorError, LayerProperties, enumerator, allocator);
    }
    pub const EnumerateDeviceExtensionPropertiesError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        LayerNotPresent,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn enumerate_device_extension_properties(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_layer_name: ?[*:0]const u8,
        p_property_count: *u32,
        p_properties: ?[*]ExtensionProperties,
    ) EnumerateDeviceExtensionPropertiesError!EnumerateResult {
        switch (self.fp_enumerate_device_extension_properties(physical_device, p_layer_name, p_property_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_layer_not_present => return error.LayerNotPresent,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const EnumerateDeviceExtensionPropertiesOrAllocatorError = EnumerateDeviceExtensionPropertiesError || Allocator.Error;
    pub fn enumerate_device_extension_properties_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
        p_layer_name: ?[*:0]const u8,
    ) EnumerateDeviceExtensionPropertiesOrAllocatorError![]ExtensionProperties {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            p_layer_name: ?[*:0]const u8,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]ExtensionProperties) !EnumerateResult {
                return enumerator.self.enumerate_device_extension_properties(
                    enumerator.physical_device,
                    enumerator.p_layer_name,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
            .p_layer_name = p_layer_name,
        };
        return enumerate_generic_to_array(EnumerateDeviceExtensionPropertiesOrAllocatorError, ExtensionProperties, enumerator, allocator);
    }
    pub fn get_physical_device_sparse_image_format_properties(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        format: Format,
        @"type": ImageType,
        samples: SampleCountFlags,
        usage: ImageUsageFlags,
        tiling: ImageTiling,
        p_property_count: *u32,
        p_properties: ?[*]SparseImageFormatProperties,
    ) void {
        self.fp_get_physical_device_sparse_image_format_properties(physical_device, format, @"type", samples, usage, tiling, p_property_count, p_properties);
    }
    pub fn get_physical_device_sparse_image_format_properties_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
        format: Format,
        @"type": ImageType,
        samples: SampleCountFlags,
        usage: ImageUsageFlags,
        tiling: ImageTiling,
    ) Allocator.Error![]SparseImageFormatProperties {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            format: Format,
            type: ImageType,
            samples: SampleCountFlags,
            usage: ImageUsageFlags,
            tiling: ImageTiling,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]SparseImageFormatProperties) void {
                return enumerator.self.get_physical_device_sparse_image_format_properties(
                    enumerator.physical_device,
                    enumerator.format,
                    enumerator.type,
                    enumerator.samples,
                    enumerator.usage,
                    enumerator.tiling,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
            .format = format,
            .type = @"type",
            .samples = samples,
            .usage = usage,
            .tiling = tiling,
        };
        return enumerate_generic_unchecked_to_array(SparseImageFormatProperties, enumerator, allocator);
    }
    pub const CreateAndroidSurfaceKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        NativeWindowInUseKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_android_surface_khr(
        self: InstanceCommands,
        p_create_info: *const AndroidSurfaceCreateInfoKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateAndroidSurfaceKHRError!SurfaceKHR {
        var p_surface: SurfaceKHR = undefined;
        switch (self.fp_create_android_surface_khr.?(self.handle, p_create_info, p_allocator, &p_surface)) {
            .success => return p_surface,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_native_window_in_use_khr => return error.NativeWindowInUseKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateSurfaceOHOSError = error{
        OutOfHostMemory,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_surface_ohos(
        self: InstanceCommands,
        p_create_info: *const SurfaceCreateInfoOHOS,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateSurfaceOHOSError!SurfaceKHR {
        var p_surface: SurfaceKHR = undefined;
        switch (self.fp_create_surface_ohos.?(self.handle, p_create_info, p_allocator, &p_surface)) {
            .success => return p_surface,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceDisplayPropertiesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_display_properties_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_property_count: *u32,
        p_properties: ?[*]DisplayPropertiesKHR,
    ) GetPhysicalDeviceDisplayPropertiesKHRError!EnumerateResult {
        switch (self.fp_get_physical_device_display_properties_khr.?(physical_device, p_property_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceDisplayPropertiesKHROrAllocatorError = GetPhysicalDeviceDisplayPropertiesKHRError || Allocator.Error;
    pub fn get_physical_device_display_properties_khr_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
    ) GetPhysicalDeviceDisplayPropertiesKHROrAllocatorError![]DisplayPropertiesKHR {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]DisplayPropertiesKHR) !EnumerateResult {
                return enumerator.self.get_physical_device_display_properties_khr(
                    enumerator.physical_device,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceDisplayPropertiesKHROrAllocatorError, DisplayPropertiesKHR, enumerator, allocator);
    }
    pub const GetPhysicalDeviceDisplayPlanePropertiesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_display_plane_properties_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_property_count: *u32,
        p_properties: ?[*]DisplayPlanePropertiesKHR,
    ) GetPhysicalDeviceDisplayPlanePropertiesKHRError!EnumerateResult {
        switch (self.fp_get_physical_device_display_plane_properties_khr.?(physical_device, p_property_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceDisplayPlanePropertiesKHROrAllocatorError = GetPhysicalDeviceDisplayPlanePropertiesKHRError || Allocator.Error;
    pub fn get_physical_device_display_plane_properties_khr_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
    ) GetPhysicalDeviceDisplayPlanePropertiesKHROrAllocatorError![]DisplayPlanePropertiesKHR {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]DisplayPlanePropertiesKHR) !EnumerateResult {
                return enumerator.self.get_physical_device_display_plane_properties_khr(
                    enumerator.physical_device,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceDisplayPlanePropertiesKHROrAllocatorError, DisplayPlanePropertiesKHR, enumerator, allocator);
    }
    pub const GetDisplayPlaneSupportedDisplaysKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_display_plane_supported_displays_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        plane_index: u32,
        p_display_count: *u32,
        p_displays: ?[*]DisplayKHR,
    ) GetDisplayPlaneSupportedDisplaysKHRError!EnumerateResult {
        switch (self.fp_get_display_plane_supported_displays_khr.?(physical_device, plane_index, p_display_count, p_displays)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetDisplayPlaneSupportedDisplaysKHROrAllocatorError = GetDisplayPlaneSupportedDisplaysKHRError || Allocator.Error;
    pub fn get_display_plane_supported_displays_khr_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
        plane_index: u32,
    ) GetDisplayPlaneSupportedDisplaysKHROrAllocatorError![]DisplayKHR {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            plane_index: u32,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]DisplayKHR) !EnumerateResult {
                return enumerator.self.get_display_plane_supported_displays_khr(
                    enumerator.physical_device,
                    enumerator.plane_index,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
            .plane_index = plane_index,
        };
        return enumerate_generic_to_array(GetDisplayPlaneSupportedDisplaysKHROrAllocatorError, DisplayKHR, enumerator, allocator);
    }
    pub const GetDisplayModePropertiesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_display_mode_properties_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        display: DisplayKHR,
        p_property_count: *u32,
        p_properties: ?[*]DisplayModePropertiesKHR,
    ) GetDisplayModePropertiesKHRError!EnumerateResult {
        switch (self.fp_get_display_mode_properties_khr.?(physical_device, display, p_property_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetDisplayModePropertiesKHROrAllocatorError = GetDisplayModePropertiesKHRError || Allocator.Error;
    pub fn get_display_mode_properties_khr_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
        display: DisplayKHR,
    ) GetDisplayModePropertiesKHROrAllocatorError![]DisplayModePropertiesKHR {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            display: DisplayKHR,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]DisplayModePropertiesKHR) !EnumerateResult {
                return enumerator.self.get_display_mode_properties_khr(
                    enumerator.physical_device,
                    enumerator.display,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
            .display = display,
        };
        return enumerate_generic_to_array(GetDisplayModePropertiesKHROrAllocatorError, DisplayModePropertiesKHR, enumerator, allocator);
    }
    pub const CreateDisplayModeKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_display_mode_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        display: DisplayKHR,
        p_create_info: *const DisplayModeCreateInfoKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateDisplayModeKHRError!DisplayModeKHR {
        var p_mode: DisplayModeKHR = undefined;
        switch (self.fp_create_display_mode_khr.?(physical_device, display, p_create_info, p_allocator, &p_mode)) {
            .success => return p_mode,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetDisplayPlaneCapabilitiesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_display_plane_capabilities_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        mode: DisplayModeKHR,
        plane_index: u32,
    ) GetDisplayPlaneCapabilitiesKHRError!DisplayPlaneCapabilitiesKHR {
        var p_capabilities: DisplayPlaneCapabilitiesKHR = undefined;
        switch (self.fp_get_display_plane_capabilities_khr.?(physical_device, mode, plane_index, &p_capabilities)) {
            .success => return p_capabilities,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateDisplayPlaneSurfaceKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_display_plane_surface_khr(
        self: InstanceCommands,
        p_create_info: *const DisplaySurfaceCreateInfoKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateDisplayPlaneSurfaceKHRError!SurfaceKHR {
        var p_surface: SurfaceKHR = undefined;
        switch (self.fp_create_display_plane_surface_khr.?(self.handle, p_create_info, p_allocator, &p_surface)) {
            .success => return p_surface,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_surface_khr(
        self: InstanceCommands,
        surface: SurfaceKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_surface_khr.?(self.handle, surface, p_allocator);
    }
    pub const GetPhysicalDeviceSurfaceSupportKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_surface_support_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
        surface: SurfaceKHR,
    ) GetPhysicalDeviceSurfaceSupportKHRError!bool {
        var p_supported: Bool32 = undefined;
        switch (self.fp_get_physical_device_surface_support_khr.?(physical_device, queue_family_index, surface, &p_supported)) {
            .success => return p_supported.to_bool(),
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceSurfaceCapabilitiesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_surface_capabilities_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        surface: SurfaceKHR,
    ) GetPhysicalDeviceSurfaceCapabilitiesKHRError!SurfaceCapabilitiesKHR {
        var p_surface_capabilities: SurfaceCapabilitiesKHR = undefined;
        switch (self.fp_get_physical_device_surface_capabilities_khr.?(physical_device, surface, &p_surface_capabilities)) {
            .success => return p_surface_capabilities,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceSurfaceFormatsKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_surface_formats_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        surface: SurfaceKHR,
        p_surface_format_count: *u32,
        p_surface_formats: ?[*]SurfaceFormatKHR,
    ) GetPhysicalDeviceSurfaceFormatsKHRError!EnumerateResult {
        switch (self.fp_get_physical_device_surface_formats_khr.?(physical_device, surface, p_surface_format_count, p_surface_formats)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceSurfaceFormatsKHROrAllocatorError = GetPhysicalDeviceSurfaceFormatsKHRError || Allocator.Error;
    pub fn get_physical_device_surface_formats_khr_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
        surface: SurfaceKHR,
    ) GetPhysicalDeviceSurfaceFormatsKHROrAllocatorError![]SurfaceFormatKHR {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            surface: SurfaceKHR,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]SurfaceFormatKHR) !EnumerateResult {
                return enumerator.self.get_physical_device_surface_formats_khr(
                    enumerator.physical_device,
                    enumerator.surface,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
            .surface = surface,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceSurfaceFormatsKHROrAllocatorError, SurfaceFormatKHR, enumerator, allocator);
    }
    pub const GetPhysicalDeviceSurfacePresentModesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_surface_present_modes_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        surface: SurfaceKHR,
        p_present_mode_count: *u32,
        p_present_modes: ?[*]PresentModeKHR,
    ) GetPhysicalDeviceSurfacePresentModesKHRError!EnumerateResult {
        switch (self.fp_get_physical_device_surface_present_modes_khr.?(physical_device, surface, p_present_mode_count, p_present_modes)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceSurfacePresentModesKHROrAllocatorError = GetPhysicalDeviceSurfacePresentModesKHRError || Allocator.Error;
    pub fn get_physical_device_surface_present_modes_khr_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
        surface: SurfaceKHR,
    ) GetPhysicalDeviceSurfacePresentModesKHROrAllocatorError![]PresentModeKHR {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            surface: SurfaceKHR,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]PresentModeKHR) !EnumerateResult {
                return enumerator.self.get_physical_device_surface_present_modes_khr(
                    enumerator.physical_device,
                    enumerator.surface,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
            .surface = surface,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceSurfacePresentModesKHROrAllocatorError, PresentModeKHR, enumerator, allocator);
    }
    pub const CreateViSurfaceNNError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        NativeWindowInUseKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_vi_surface_nn(
        self: InstanceCommands,
        p_create_info: *const ViSurfaceCreateInfoNN,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateViSurfaceNNError!SurfaceKHR {
        var p_surface: SurfaceKHR = undefined;
        switch (self.fp_create_vi_surface_nn.?(self.handle, p_create_info, p_allocator, &p_surface)) {
            .success => return p_surface,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_native_window_in_use_khr => return error.NativeWindowInUseKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateWaylandSurfaceKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_wayland_surface_khr(
        self: InstanceCommands,
        p_create_info: *const WaylandSurfaceCreateInfoKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateWaylandSurfaceKHRError!SurfaceKHR {
        var p_surface: SurfaceKHR = undefined;
        switch (self.fp_create_wayland_surface_khr.?(self.handle, p_create_info, p_allocator, &p_surface)) {
            .success => return p_surface,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_physical_device_wayland_presentation_support_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
        display: *wl_display,
    ) bool {
        return self.fp_get_physical_device_wayland_presentation_support_khr.?(physical_device, queue_family_index, display).to_bool();
    }
    pub const CreateWin32SurfaceKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_win32_surface_khr(
        self: InstanceCommands,
        p_create_info: *const Win32SurfaceCreateInfoKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateWin32SurfaceKHRError!SurfaceKHR {
        var p_surface: SurfaceKHR = undefined;
        switch (self.fp_create_win32_surface_khr.?(self.handle, p_create_info, p_allocator, &p_surface)) {
            .success => return p_surface,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_physical_device_win32_presentation_support_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
    ) bool {
        return self.fp_get_physical_device_win32_presentation_support_khr.?(physical_device, queue_family_index).to_bool();
    }
    pub const CreateXlibSurfaceKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_xlib_surface_khr(
        self: InstanceCommands,
        p_create_info: *const XlibSurfaceCreateInfoKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateXlibSurfaceKHRError!SurfaceKHR {
        var p_surface: SurfaceKHR = undefined;
        switch (self.fp_create_xlib_surface_khr.?(self.handle, p_create_info, p_allocator, &p_surface)) {
            .success => return p_surface,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_physical_device_xlib_presentation_support_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
        dpy: *Display,
        visual_id: VisualID,
    ) bool {
        return self.fp_get_physical_device_xlib_presentation_support_khr.?(physical_device, queue_family_index, dpy, visual_id).to_bool();
    }
    pub const CreateXcbSurfaceKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_xcb_surface_khr(
        self: InstanceCommands,
        p_create_info: *const XcbSurfaceCreateInfoKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateXcbSurfaceKHRError!SurfaceKHR {
        var p_surface: SurfaceKHR = undefined;
        switch (self.fp_create_xcb_surface_khr.?(self.handle, p_create_info, p_allocator, &p_surface)) {
            .success => return p_surface,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_physical_device_xcb_presentation_support_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
        connection: *xcb_connection_t,
        visual_id: xcb_visualid_t,
    ) bool {
        return self.fp_get_physical_device_xcb_presentation_support_khr.?(physical_device, queue_family_index, connection, visual_id).to_bool();
    }
    pub const CreateDirectFBSurfaceEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_direct_fb_surface_ext(
        self: InstanceCommands,
        p_create_info: *const DirectFBSurfaceCreateInfoEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateDirectFBSurfaceEXTError!SurfaceKHR {
        var p_surface: SurfaceKHR = undefined;
        switch (self.fp_create_direct_fb_surface_ext.?(self.handle, p_create_info, p_allocator, &p_surface)) {
            .success => return p_surface,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_physical_device_direct_fb_presentation_support_ext(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
        dfb: *IDirectFB,
    ) bool {
        return self.fp_get_physical_device_direct_fb_presentation_support_ext.?(physical_device, queue_family_index, dfb).to_bool();
    }
    pub const CreateImagePipeSurfaceFUCHSIAError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_image_pipe_surface_fuchsia(
        self: InstanceCommands,
        p_create_info: *const ImagePipeSurfaceCreateInfoFUCHSIA,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateImagePipeSurfaceFUCHSIAError!SurfaceKHR {
        var p_surface: SurfaceKHR = undefined;
        switch (self.fp_create_image_pipe_surface_fuchsia.?(self.handle, p_create_info, p_allocator, &p_surface)) {
            .success => return p_surface,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateDebugReportCallbackEXTError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_debug_report_callback_ext(
        self: InstanceCommands,
        p_create_info: *const DebugReportCallbackCreateInfoEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateDebugReportCallbackEXTError!DebugReportCallbackEXT {
        var p_callback: DebugReportCallbackEXT = undefined;
        switch (self.fp_create_debug_report_callback_ext.?(self.handle, p_create_info, p_allocator, &p_callback)) {
            .success => return p_callback,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_debug_report_callback_ext(
        self: InstanceCommands,
        callback: DebugReportCallbackEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_debug_report_callback_ext.?(self.handle, callback, p_allocator);
    }
    pub fn debug_report_message_ext(
        self: InstanceCommands,
        flags: DebugReportFlagsEXT,
        object_type: DebugReportObjectTypeEXT,
        object: u64,
        location: usize,
        message_code: i32,
        p_layer_prefix: [*:0]const u8,
        p_message: [*:0]const u8,
    ) void {
        self.fp_debug_report_message_ext.?(self.handle, flags, object_type, object, location, message_code, p_layer_prefix, p_message);
    }
    pub const GetPhysicalDeviceExternalImageFormatPropertiesNVError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        FormatNotSupported,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_external_image_format_properties_nv(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        format: Format,
        @"type": ImageType,
        tiling: ImageTiling,
        usage: ImageUsageFlags,
        flags: ImageCreateFlags,
        external_handle_type: ExternalMemoryHandleTypeFlagsNV,
    ) GetPhysicalDeviceExternalImageFormatPropertiesNVError!ExternalImageFormatPropertiesNV {
        var p_external_image_format_properties: ExternalImageFormatPropertiesNV = undefined;
        switch (self.fp_get_physical_device_external_image_format_properties_nv.?(physical_device, format, @"type", tiling, usage, flags, external_handle_type, &p_external_image_format_properties)) {
            .success => return p_external_image_format_properties,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_format_not_supported => return error.FormatNotSupported,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_physical_device_features2(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_features: *PhysicalDeviceFeatures2,
    ) void {
        self.fp_get_physical_device_features2.?(physical_device, p_features);
    }
    pub fn get_physical_device_properties2(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_properties: *PhysicalDeviceProperties2,
    ) void {
        self.fp_get_physical_device_properties2.?(physical_device, p_properties);
    }
    pub fn get_physical_device_format_properties2(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        format: Format,
        p_format_properties: *FormatProperties2,
    ) void {
        self.fp_get_physical_device_format_properties2.?(physical_device, format, p_format_properties);
    }
    pub const GetPhysicalDeviceImageFormatProperties2Error = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        FormatNotSupported,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_image_format_properties2(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_image_format_info: *const PhysicalDeviceImageFormatInfo2,
        p_image_format_properties: *ImageFormatProperties2,
    ) GetPhysicalDeviceImageFormatProperties2Error!void {
        switch (self.fp_get_physical_device_image_format_properties2.?(physical_device, p_image_format_info, p_image_format_properties)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_format_not_supported => return error.FormatNotSupported,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_physical_device_queue_family_properties2(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_queue_family_property_count: *u32,
        p_queue_family_properties: ?[*]QueueFamilyProperties2,
    ) void {
        self.fp_get_physical_device_queue_family_properties2.?(physical_device, p_queue_family_property_count, p_queue_family_properties);
    }
    pub fn get_physical_device_queue_family_properties2_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
    ) Allocator.Error![]QueueFamilyProperties2 {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]QueueFamilyProperties2) void {
                return enumerator.self.get_physical_device_queue_family_properties2(
                    enumerator.physical_device,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
        };
        return enumerate_generic_unchecked_to_array(QueueFamilyProperties2, enumerator, allocator);
    }
    pub fn get_physical_device_memory_properties2(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_memory_properties: *PhysicalDeviceMemoryProperties2,
    ) void {
        self.fp_get_physical_device_memory_properties2.?(physical_device, p_memory_properties);
    }
    pub fn get_physical_device_sparse_image_format_properties2(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_format_info: *const PhysicalDeviceSparseImageFormatInfo2,
        p_property_count: *u32,
        p_properties: ?[*]SparseImageFormatProperties2,
    ) void {
        self.fp_get_physical_device_sparse_image_format_properties2.?(physical_device, p_format_info, p_property_count, p_properties);
    }
    pub fn get_physical_device_sparse_image_format_properties2_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
        p_format_info: *const PhysicalDeviceSparseImageFormatInfo2,
    ) Allocator.Error![]SparseImageFormatProperties2 {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            p_format_info: *const PhysicalDeviceSparseImageFormatInfo2,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]SparseImageFormatProperties2) void {
                return enumerator.self.get_physical_device_sparse_image_format_properties2(
                    enumerator.physical_device,
                    enumerator.p_format_info,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
            .p_format_info = p_format_info,
        };
        return enumerate_generic_unchecked_to_array(SparseImageFormatProperties2, enumerator, allocator);
    }
    pub fn get_physical_device_external_buffer_properties(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_external_buffer_info: *const PhysicalDeviceExternalBufferInfo,
        p_external_buffer_properties: *ExternalBufferProperties,
    ) void {
        self.fp_get_physical_device_external_buffer_properties.?(physical_device, p_external_buffer_info, p_external_buffer_properties);
    }
    pub fn get_physical_device_external_semaphore_properties(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_external_semaphore_info: *const PhysicalDeviceExternalSemaphoreInfo,
        p_external_semaphore_properties: *ExternalSemaphoreProperties,
    ) void {
        self.fp_get_physical_device_external_semaphore_properties.?(physical_device, p_external_semaphore_info, p_external_semaphore_properties);
    }
    pub fn get_physical_device_external_fence_properties(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_external_fence_info: *const PhysicalDeviceExternalFenceInfo,
        p_external_fence_properties: *ExternalFenceProperties,
    ) void {
        self.fp_get_physical_device_external_fence_properties.?(physical_device, p_external_fence_info, p_external_fence_properties);
    }
    pub const ReleaseDisplayEXTError = error{
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn release_display_ext(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        display: DisplayKHR,
    ) ReleaseDisplayEXTError!void {
        switch (self.fp_release_display_ext.?(physical_device, display)) {
            .success => return,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const AcquireXlibDisplayEXTError = error{
        OutOfHostMemory,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn acquire_xlib_display_ext(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        dpy: *Display,
        display: DisplayKHR,
    ) AcquireXlibDisplayEXTError!void {
        switch (self.fp_acquire_xlib_display_ext.?(physical_device, dpy, display)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetRandROutputDisplayEXTError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_rand_r_output_display_ext(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        dpy: *Display,
        rr_output: RROutput,
    ) GetRandROutputDisplayEXTError!DisplayKHR {
        var p_display: DisplayKHR = undefined;
        switch (self.fp_get_rand_r_output_display_ext.?(physical_device, dpy, rr_output, &p_display)) {
            .success => return p_display,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceSurfaceCapabilities2EXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_surface_capabilities2_ext(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        surface: SurfaceKHR,
        p_surface_capabilities: *SurfaceCapabilities2EXT,
    ) GetPhysicalDeviceSurfaceCapabilities2EXTError!void {
        switch (self.fp_get_physical_device_surface_capabilities2_ext.?(physical_device, surface, p_surface_capabilities)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const EnumeratePhysicalDeviceGroupsError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn enumerate_physical_device_groups(
        self: InstanceCommands,
        p_physical_device_group_count: *u32,
        p_physical_device_group_properties: ?[*]PhysicalDeviceGroupProperties,
    ) EnumeratePhysicalDeviceGroupsError!EnumerateResult {
        switch (self.fp_enumerate_physical_device_groups.?(self.handle, p_physical_device_group_count, p_physical_device_group_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const EnumeratePhysicalDeviceGroupsOrAllocatorError = EnumeratePhysicalDeviceGroupsError || Allocator.Error;
    pub fn enumerate_physical_device_groups_to_array(
        self: InstanceCommands,
        allocator: Allocator,
    ) EnumeratePhysicalDeviceGroupsOrAllocatorError![]PhysicalDeviceGroupProperties {
        const enumerator = struct {
            self: *const InstanceCommands,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]PhysicalDeviceGroupProperties) !EnumerateResult {
                return enumerator.self.enumerate_physical_device_groups(
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
        };
        return enumerate_generic_to_array(EnumeratePhysicalDeviceGroupsOrAllocatorError, PhysicalDeviceGroupProperties, enumerator, allocator);
    }
    pub const CreateIOSSurfaceMVKError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        NativeWindowInUseKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_ios_surface_mvk(
        self: InstanceCommands,
        p_create_info: *const IOSSurfaceCreateInfoMVK,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateIOSSurfaceMVKError!SurfaceKHR {
        var p_surface: SurfaceKHR = undefined;
        switch (self.fp_create_ios_surface_mvk.?(self.handle, p_create_info, p_allocator, &p_surface)) {
            .success => return p_surface,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_native_window_in_use_khr => return error.NativeWindowInUseKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateMacOSSurfaceMVKError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        NativeWindowInUseKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_mac_os_surface_mvk(
        self: InstanceCommands,
        p_create_info: *const MacOSSurfaceCreateInfoMVK,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateMacOSSurfaceMVKError!SurfaceKHR {
        var p_surface: SurfaceKHR = undefined;
        switch (self.fp_create_mac_os_surface_mvk.?(self.handle, p_create_info, p_allocator, &p_surface)) {
            .success => return p_surface,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_native_window_in_use_khr => return error.NativeWindowInUseKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateMetalSurfaceEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        NativeWindowInUseKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_metal_surface_ext(
        self: InstanceCommands,
        p_create_info: *const MetalSurfaceCreateInfoEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateMetalSurfaceEXTError!SurfaceKHR {
        var p_surface: SurfaceKHR = undefined;
        switch (self.fp_create_metal_surface_ext.?(self.handle, p_create_info, p_allocator, &p_surface)) {
            .success => return p_surface,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_native_window_in_use_khr => return error.NativeWindowInUseKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceSurfaceCapabilities2KHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_surface_capabilities2_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
        p_surface_capabilities: *SurfaceCapabilities2KHR,
    ) GetPhysicalDeviceSurfaceCapabilities2KHRError!void {
        switch (self.fp_get_physical_device_surface_capabilities2_khr.?(physical_device, p_surface_info, p_surface_capabilities)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceSurfaceFormats2KHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_surface_formats2_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
        p_surface_format_count: *u32,
        p_surface_formats: ?[*]SurfaceFormat2KHR,
    ) GetPhysicalDeviceSurfaceFormats2KHRError!EnumerateResult {
        switch (self.fp_get_physical_device_surface_formats2_khr.?(physical_device, p_surface_info, p_surface_format_count, p_surface_formats)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceSurfaceFormats2KHROrAllocatorError = GetPhysicalDeviceSurfaceFormats2KHRError || Allocator.Error;
    pub fn get_physical_device_surface_formats2_khr_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
        p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    ) GetPhysicalDeviceSurfaceFormats2KHROrAllocatorError![]SurfaceFormat2KHR {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]SurfaceFormat2KHR) !EnumerateResult {
                return enumerator.self.get_physical_device_surface_formats2_khr(
                    enumerator.physical_device,
                    enumerator.p_surface_info,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
            .p_surface_info = p_surface_info,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceSurfaceFormats2KHROrAllocatorError, SurfaceFormat2KHR, enumerator, allocator);
    }
    pub const GetPhysicalDeviceDisplayProperties2KHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_display_properties2_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_property_count: *u32,
        p_properties: ?[*]DisplayProperties2KHR,
    ) GetPhysicalDeviceDisplayProperties2KHRError!EnumerateResult {
        switch (self.fp_get_physical_device_display_properties2_khr.?(physical_device, p_property_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceDisplayProperties2KHROrAllocatorError = GetPhysicalDeviceDisplayProperties2KHRError || Allocator.Error;
    pub fn get_physical_device_display_properties2_khr_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
    ) GetPhysicalDeviceDisplayProperties2KHROrAllocatorError![]DisplayProperties2KHR {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]DisplayProperties2KHR) !EnumerateResult {
                return enumerator.self.get_physical_device_display_properties2_khr(
                    enumerator.physical_device,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceDisplayProperties2KHROrAllocatorError, DisplayProperties2KHR, enumerator, allocator);
    }
    pub const GetPhysicalDeviceDisplayPlaneProperties2KHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_display_plane_properties2_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_property_count: *u32,
        p_properties: ?[*]DisplayPlaneProperties2KHR,
    ) GetPhysicalDeviceDisplayPlaneProperties2KHRError!EnumerateResult {
        switch (self.fp_get_physical_device_display_plane_properties2_khr.?(physical_device, p_property_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceDisplayPlaneProperties2KHROrAllocatorError = GetPhysicalDeviceDisplayPlaneProperties2KHRError || Allocator.Error;
    pub fn get_physical_device_display_plane_properties2_khr_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
    ) GetPhysicalDeviceDisplayPlaneProperties2KHROrAllocatorError![]DisplayPlaneProperties2KHR {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]DisplayPlaneProperties2KHR) !EnumerateResult {
                return enumerator.self.get_physical_device_display_plane_properties2_khr(
                    enumerator.physical_device,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceDisplayPlaneProperties2KHROrAllocatorError, DisplayPlaneProperties2KHR, enumerator, allocator);
    }
    pub const GetDisplayModeProperties2KHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_display_mode_properties2_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        display: DisplayKHR,
        p_property_count: *u32,
        p_properties: ?[*]DisplayModeProperties2KHR,
    ) GetDisplayModeProperties2KHRError!EnumerateResult {
        switch (self.fp_get_display_mode_properties2_khr.?(physical_device, display, p_property_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetDisplayModeProperties2KHROrAllocatorError = GetDisplayModeProperties2KHRError || Allocator.Error;
    pub fn get_display_mode_properties2_khr_to_array(
        self: InstanceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
        display: DisplayKHR,
    ) GetDisplayModeProperties2KHROrAllocatorError![]DisplayModeProperties2KHR {
        const enumerator = struct {
            self: *const InstanceCommands,
            physical_device: PhysicalDevice,
            display: DisplayKHR,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]DisplayModeProperties2KHR) !EnumerateResult {
                return enumerator.self.get_display_mode_properties2_khr(
                    enumerator.physical_device,
                    enumerator.display,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
            .display = display,
        };
        return enumerate_generic_to_array(GetDisplayModeProperties2KHROrAllocatorError, DisplayModeProperties2KHR, enumerator, allocator);
    }
    pub const GetDisplayPlaneCapabilities2KHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_display_plane_capabilities2_khr(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        p_display_plane_info: *const DisplayPlaneInfo2KHR,
        p_capabilities: *DisplayPlaneCapabilities2KHR,
    ) GetDisplayPlaneCapabilities2KHRError!void {
        switch (self.fp_get_display_plane_capabilities2_khr.?(physical_device, p_display_plane_info, p_capabilities)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const SetDebugUtilsObjectNameEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn set_debug_utils_object_name_ext(
        self: InstanceCommands,
        device: Device,
        p_name_info: *const DebugUtilsObjectNameInfoEXT,
    ) SetDebugUtilsObjectNameEXTError!void {
        switch (self.fp_set_debug_utils_object_name_ext.?(device, p_name_info)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const SetDebugUtilsObjectTagEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn set_debug_utils_object_tag_ext(
        self: InstanceCommands,
        device: Device,
        p_tag_info: *const DebugUtilsObjectTagInfoEXT,
    ) SetDebugUtilsObjectTagEXTError!void {
        switch (self.fp_set_debug_utils_object_tag_ext.?(device, p_tag_info)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn queue_begin_debug_utils_label_ext(
        self: InstanceCommands,
        queue: Queue,
        p_label_info: *const DebugUtilsLabelEXT,
    ) void {
        self.fp_queue_begin_debug_utils_label_ext.?(queue, p_label_info);
    }
    pub fn queue_end_debug_utils_label_ext(
        self: InstanceCommands,
        queue: Queue,
    ) void {
        self.fp_queue_end_debug_utils_label_ext.?(queue);
    }
    pub fn queue_insert_debug_utils_label_ext(
        self: InstanceCommands,
        queue: Queue,
        p_label_info: *const DebugUtilsLabelEXT,
    ) void {
        self.fp_queue_insert_debug_utils_label_ext.?(queue, p_label_info);
    }
    pub fn cmd_begin_debug_utils_label_ext(
        self: InstanceCommands,
        command_buffer: CommandBuffer,
        p_label_info: *const DebugUtilsLabelEXT,
    ) void {
        self.fp_cmd_begin_debug_utils_label_ext.?(command_buffer, p_label_info);
    }
    pub fn cmd_end_debug_utils_label_ext(
        self: InstanceCommands,
        command_buffer: CommandBuffer,
    ) void {
        self.fp_cmd_end_debug_utils_label_ext.?(command_buffer);
    }
    pub fn cmd_insert_debug_utils_label_ext(
        self: InstanceCommands,
        command_buffer: CommandBuffer,
        p_label_info: *const DebugUtilsLabelEXT,
    ) void {
        self.fp_cmd_insert_debug_utils_label_ext.?(command_buffer, p_label_info);
    }
    pub const CreateDebugUtilsMessengerEXTError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_debug_utils_messenger_ext(
        self: InstanceCommands,
        p_create_info: *const DebugUtilsMessengerCreateInfoEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateDebugUtilsMessengerEXTError!DebugUtilsMessengerEXT {
        var p_messenger: DebugUtilsMessengerEXT = undefined;
        switch (self.fp_create_debug_utils_messenger_ext.?(self.handle, p_create_info, p_allocator, &p_messenger)) {
            .success => return p_messenger,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_debug_utils_messenger_ext(
        self: InstanceCommands,
        messenger: DebugUtilsMessengerEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_debug_utils_messenger_ext.?(self.handle, messenger, p_allocator);
    }
    pub fn submit_debug_utils_message_ext(
        self: InstanceCommands,
        message_severity: DebugUtilsMessageSeverityFlagsEXT,
        message_types: DebugUtilsMessageTypeFlagsEXT,
        p_callback_data: *const DebugUtilsMessengerCallbackDataEXT,
    ) void {
        self.fp_submit_debug_utils_message_ext.?(self.handle, message_severity, message_types, p_callback_data);
    }
    pub const CreateHeadlessSurfaceEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_headless_surface_ext(
        self: InstanceCommands,
        p_create_info: *const HeadlessSurfaceCreateInfoEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateHeadlessSurfaceEXTError!SurfaceKHR {
        var p_surface: SurfaceKHR = undefined;
        switch (self.fp_create_headless_surface_ext.?(self.handle, p_create_info, p_allocator, &p_surface)) {
            .success => return p_surface,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const AcquireDrmDisplayEXTError = error{
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn acquire_drm_display_ext(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        drm_fd: i32,
        display: DisplayKHR,
    ) AcquireDrmDisplayEXTError!void {
        switch (self.fp_acquire_drm_display_ext.?(physical_device, drm_fd, display)) {
            .success => return,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetDrmDisplayEXTError = error{
        InitializationFailed,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_drm_display_ext(
        self: InstanceCommands,
        physical_device: PhysicalDevice,
        drm_fd: i32,
        connector_id: u32,
    ) GetDrmDisplayEXTError!DisplayKHR {
        var display: DisplayKHR = undefined;
        switch (self.fp_get_drm_display_ext.?(physical_device, drm_fd, connector_id, &display)) {
            .success => return display,
            .error_initialization_failed => return error.InitializationFailed,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
};

pub const DeviceCommands = struct {
    handle: Device,
    extensions: DeviceExtensions,
    fp_destroy_device: FpDestroyDevice,
    fp_get_device_queue: FpGetDeviceQueue,
    fp_queue_submit: FpQueueSubmit,
    fp_queue_wait_idle: FpQueueWaitIdle,
    fp_device_wait_idle: FpDeviceWaitIdle,
    fp_allocate_memory: FpAllocateMemory,
    fp_free_memory: FpFreeMemory,
    fp_map_memory: FpMapMemory,
    fp_unmap_memory: FpUnmapMemory,
    fp_flush_mapped_memory_ranges: FpFlushMappedMemoryRanges,
    fp_invalidate_mapped_memory_ranges: FpInvalidateMappedMemoryRanges,
    fp_get_device_memory_commitment: FpGetDeviceMemoryCommitment,
    fp_get_buffer_memory_requirements: FpGetBufferMemoryRequirements,
    fp_bind_buffer_memory: FpBindBufferMemory,
    fp_get_image_memory_requirements: FpGetImageMemoryRequirements,
    fp_bind_image_memory: FpBindImageMemory,
    fp_get_image_sparse_memory_requirements: FpGetImageSparseMemoryRequirements,
    fp_queue_bind_sparse: FpQueueBindSparse,
    fp_create_fence: FpCreateFence,
    fp_destroy_fence: FpDestroyFence,
    fp_reset_fences: FpResetFences,
    fp_get_fence_status: FpGetFenceStatus,
    fp_wait_for_fences: FpWaitForFences,
    fp_create_semaphore: FpCreateSemaphore,
    fp_destroy_semaphore: FpDestroySemaphore,
    fp_create_event: FpCreateEvent,
    fp_destroy_event: FpDestroyEvent,
    fp_get_event_status: FpGetEventStatus,
    fp_set_event: FpSetEvent,
    fp_reset_event: FpResetEvent,
    fp_create_query_pool: FpCreateQueryPool,
    fp_destroy_query_pool: FpDestroyQueryPool,
    fp_get_query_pool_results: FpGetQueryPoolResults,
    fp_reset_query_pool: ?FpResetQueryPool,
    fp_create_buffer: FpCreateBuffer,
    fp_destroy_buffer: FpDestroyBuffer,
    fp_create_buffer_view: FpCreateBufferView,
    fp_destroy_buffer_view: FpDestroyBufferView,
    fp_create_image: FpCreateImage,
    fp_destroy_image: FpDestroyImage,
    fp_get_image_subresource_layout: FpGetImageSubresourceLayout,
    fp_create_image_view: FpCreateImageView,
    fp_destroy_image_view: FpDestroyImageView,
    fp_create_shader_module: FpCreateShaderModule,
    fp_destroy_shader_module: FpDestroyShaderModule,
    fp_create_pipeline_cache: FpCreatePipelineCache,
    fp_destroy_pipeline_cache: FpDestroyPipelineCache,
    fp_get_pipeline_cache_data: FpGetPipelineCacheData,
    fp_merge_pipeline_caches: FpMergePipelineCaches,
    fp_create_pipeline_binaries_khr: ?FpCreatePipelineBinariesKHR,
    fp_destroy_pipeline_binary_khr: ?FpDestroyPipelineBinaryKHR,
    fp_get_pipeline_key_khr: ?FpGetPipelineKeyKHR,
    fp_get_pipeline_binary_data_khr: ?FpGetPipelineBinaryDataKHR,
    fp_release_captured_pipeline_data_khr: ?FpReleaseCapturedPipelineDataKHR,
    fp_create_graphics_pipelines: FpCreateGraphicsPipelines,
    fp_create_compute_pipelines: FpCreateComputePipelines,
    fp_get_device_subpass_shading_max_workgroup_size_huawei: ?FpGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI,
    fp_destroy_pipeline: FpDestroyPipeline,
    fp_create_pipeline_layout: FpCreatePipelineLayout,
    fp_destroy_pipeline_layout: FpDestroyPipelineLayout,
    fp_create_sampler: FpCreateSampler,
    fp_destroy_sampler: FpDestroySampler,
    fp_create_descriptor_set_layout: FpCreateDescriptorSetLayout,
    fp_destroy_descriptor_set_layout: FpDestroyDescriptorSetLayout,
    fp_create_descriptor_pool: FpCreateDescriptorPool,
    fp_destroy_descriptor_pool: FpDestroyDescriptorPool,
    fp_reset_descriptor_pool: FpResetDescriptorPool,
    fp_allocate_descriptor_sets: FpAllocateDescriptorSets,
    fp_free_descriptor_sets: FpFreeDescriptorSets,
    fp_update_descriptor_sets: FpUpdateDescriptorSets,
    fp_create_framebuffer: FpCreateFramebuffer,
    fp_destroy_framebuffer: FpDestroyFramebuffer,
    fp_create_render_pass: FpCreateRenderPass,
    fp_destroy_render_pass: FpDestroyRenderPass,
    fp_get_render_area_granularity: FpGetRenderAreaGranularity,
    fp_get_rendering_area_granularity: ?FpGetRenderingAreaGranularity,
    fp_create_command_pool: FpCreateCommandPool,
    fp_destroy_command_pool: FpDestroyCommandPool,
    fp_reset_command_pool: FpResetCommandPool,
    fp_allocate_command_buffers: FpAllocateCommandBuffers,
    fp_free_command_buffers: FpFreeCommandBuffers,
    fp_begin_command_buffer: FpBeginCommandBuffer,
    fp_end_command_buffer: FpEndCommandBuffer,
    fp_reset_command_buffer: FpResetCommandBuffer,
    fp_cmd_bind_pipeline: FpCmdBindPipeline,
    fp_cmd_set_attachment_feedback_loop_enable_ext: ?FpCmdSetAttachmentFeedbackLoopEnableEXT,
    fp_cmd_set_viewport: FpCmdSetViewport,
    fp_cmd_set_scissor: FpCmdSetScissor,
    fp_cmd_set_line_width: FpCmdSetLineWidth,
    fp_cmd_set_depth_bias: FpCmdSetDepthBias,
    fp_cmd_set_blend_constants: FpCmdSetBlendConstants,
    fp_cmd_set_depth_bounds: FpCmdSetDepthBounds,
    fp_cmd_set_stencil_compare_mask: FpCmdSetStencilCompareMask,
    fp_cmd_set_stencil_write_mask: FpCmdSetStencilWriteMask,
    fp_cmd_set_stencil_reference: FpCmdSetStencilReference,
    fp_cmd_bind_descriptor_sets: FpCmdBindDescriptorSets,
    fp_cmd_bind_index_buffer: FpCmdBindIndexBuffer,
    fp_cmd_bind_vertex_buffers: FpCmdBindVertexBuffers,
    fp_cmd_draw: FpCmdDraw,
    fp_cmd_draw_indexed: FpCmdDrawIndexed,
    fp_cmd_draw_multi_ext: ?FpCmdDrawMultiEXT,
    fp_cmd_draw_multi_indexed_ext: ?FpCmdDrawMultiIndexedEXT,
    fp_cmd_draw_indirect: FpCmdDrawIndirect,
    fp_cmd_draw_indexed_indirect: FpCmdDrawIndexedIndirect,
    fp_cmd_dispatch: FpCmdDispatch,
    fp_cmd_dispatch_indirect: FpCmdDispatchIndirect,
    fp_cmd_subpass_shading_huawei: ?FpCmdSubpassShadingHUAWEI,
    fp_cmd_draw_cluster_huawei: ?FpCmdDrawClusterHUAWEI,
    fp_cmd_draw_cluster_indirect_huawei: ?FpCmdDrawClusterIndirectHUAWEI,
    fp_cmd_update_pipeline_indirect_buffer_nv: ?FpCmdUpdatePipelineIndirectBufferNV,
    fp_cmd_copy_buffer: FpCmdCopyBuffer,
    fp_cmd_copy_image: FpCmdCopyImage,
    fp_cmd_blit_image: FpCmdBlitImage,
    fp_cmd_copy_buffer_to_image: FpCmdCopyBufferToImage,
    fp_cmd_copy_image_to_buffer: FpCmdCopyImageToBuffer,
    fp_cmd_copy_memory_indirect_nv: ?FpCmdCopyMemoryIndirectNV,
    fp_cmd_copy_memory_to_image_indirect_nv: ?FpCmdCopyMemoryToImageIndirectNV,
    fp_cmd_update_buffer: FpCmdUpdateBuffer,
    fp_cmd_fill_buffer: FpCmdFillBuffer,
    fp_cmd_clear_color_image: FpCmdClearColorImage,
    fp_cmd_clear_depth_stencil_image: FpCmdClearDepthStencilImage,
    fp_cmd_clear_attachments: FpCmdClearAttachments,
    fp_cmd_resolve_image: FpCmdResolveImage,
    fp_cmd_set_event: FpCmdSetEvent,
    fp_cmd_reset_event: FpCmdResetEvent,
    fp_cmd_wait_events: FpCmdWaitEvents,
    fp_cmd_pipeline_barrier: FpCmdPipelineBarrier,
    fp_cmd_begin_query: FpCmdBeginQuery,
    fp_cmd_end_query: FpCmdEndQuery,
    fp_cmd_begin_conditional_rendering_ext: ?FpCmdBeginConditionalRenderingEXT,
    fp_cmd_end_conditional_rendering_ext: ?FpCmdEndConditionalRenderingEXT,
    fp_cmd_reset_query_pool: FpCmdResetQueryPool,
    fp_cmd_write_timestamp: FpCmdWriteTimestamp,
    fp_cmd_copy_query_pool_results: FpCmdCopyQueryPoolResults,
    fp_cmd_push_constants: FpCmdPushConstants,
    fp_cmd_begin_render_pass: FpCmdBeginRenderPass,
    fp_cmd_next_subpass: FpCmdNextSubpass,
    fp_cmd_end_render_pass: FpCmdEndRenderPass,
    fp_cmd_execute_commands: FpCmdExecuteCommands,
    fp_create_shared_swapchains_khr: ?FpCreateSharedSwapchainsKHR,
    fp_create_swapchain_khr: ?FpCreateSwapchainKHR,
    fp_destroy_swapchain_khr: ?FpDestroySwapchainKHR,
    fp_get_swapchain_images_khr: ?FpGetSwapchainImagesKHR,
    fp_acquire_next_image_khr: ?FpAcquireNextImageKHR,
    fp_queue_present_khr: ?FpQueuePresentKHR,
    fp_debug_marker_set_object_name_ext: ?FpDebugMarkerSetObjectNameEXT,
    fp_debug_marker_set_object_tag_ext: ?FpDebugMarkerSetObjectTagEXT,
    fp_cmd_debug_marker_begin_ext: ?FpCmdDebugMarkerBeginEXT,
    fp_cmd_debug_marker_end_ext: ?FpCmdDebugMarkerEndEXT,
    fp_cmd_debug_marker_insert_ext: ?FpCmdDebugMarkerInsertEXT,
    fp_get_memory_win32_handle_nv: ?FpGetMemoryWin32HandleNV,
    fp_cmd_execute_generated_commands_nv: ?FpCmdExecuteGeneratedCommandsNV,
    fp_cmd_preprocess_generated_commands_nv: ?FpCmdPreprocessGeneratedCommandsNV,
    fp_cmd_bind_pipeline_shader_group_nv: ?FpCmdBindPipelineShaderGroupNV,
    fp_get_generated_commands_memory_requirements_nv: ?FpGetGeneratedCommandsMemoryRequirementsNV,
    fp_create_indirect_commands_layout_nv: ?FpCreateIndirectCommandsLayoutNV,
    fp_destroy_indirect_commands_layout_nv: ?FpDestroyIndirectCommandsLayoutNV,
    fp_cmd_execute_generated_commands_ext: ?FpCmdExecuteGeneratedCommandsEXT,
    fp_cmd_preprocess_generated_commands_ext: ?FpCmdPreprocessGeneratedCommandsEXT,
    fp_get_generated_commands_memory_requirements_ext: ?FpGetGeneratedCommandsMemoryRequirementsEXT,
    fp_create_indirect_commands_layout_ext: ?FpCreateIndirectCommandsLayoutEXT,
    fp_destroy_indirect_commands_layout_ext: ?FpDestroyIndirectCommandsLayoutEXT,
    fp_create_indirect_execution_set_ext: ?FpCreateIndirectExecutionSetEXT,
    fp_destroy_indirect_execution_set_ext: ?FpDestroyIndirectExecutionSetEXT,
    fp_update_indirect_execution_set_pipeline_ext: ?FpUpdateIndirectExecutionSetPipelineEXT,
    fp_update_indirect_execution_set_shader_ext: ?FpUpdateIndirectExecutionSetShaderEXT,
    fp_cmd_push_descriptor_set: ?FpCmdPushDescriptorSet,
    fp_trim_command_pool: ?FpTrimCommandPool,
    fp_get_memory_win32_handle_khr: ?FpGetMemoryWin32HandleKHR,
    fp_get_memory_win32_handle_properties_khr: ?FpGetMemoryWin32HandlePropertiesKHR,
    fp_get_memory_fd_khr: ?FpGetMemoryFdKHR,
    fp_get_memory_fd_properties_khr: ?FpGetMemoryFdPropertiesKHR,
    fp_get_memory_zircon_handle_fuchsia: ?FpGetMemoryZirconHandleFUCHSIA,
    fp_get_memory_zircon_handle_properties_fuchsia: ?FpGetMemoryZirconHandlePropertiesFUCHSIA,
    fp_get_memory_remote_address_nv: ?FpGetMemoryRemoteAddressNV,
    fp_get_semaphore_win32_handle_khr: ?FpGetSemaphoreWin32HandleKHR,
    fp_import_semaphore_win32_handle_khr: ?FpImportSemaphoreWin32HandleKHR,
    fp_get_semaphore_fd_khr: ?FpGetSemaphoreFdKHR,
    fp_import_semaphore_fd_khr: ?FpImportSemaphoreFdKHR,
    fp_get_semaphore_zircon_handle_fuchsia: ?FpGetSemaphoreZirconHandleFUCHSIA,
    fp_import_semaphore_zircon_handle_fuchsia: ?FpImportSemaphoreZirconHandleFUCHSIA,
    fp_get_fence_win32_handle_khr: ?FpGetFenceWin32HandleKHR,
    fp_import_fence_win32_handle_khr: ?FpImportFenceWin32HandleKHR,
    fp_get_fence_fd_khr: ?FpGetFenceFdKHR,
    fp_import_fence_fd_khr: ?FpImportFenceFdKHR,
    fp_acquire_winrt_display_nv: ?FpAcquireWinrtDisplayNV,
    fp_get_winrt_display_nv: ?FpGetWinrtDisplayNV,
    fp_display_power_control_ext: ?FpDisplayPowerControlEXT,
    fp_register_device_event_ext: ?FpRegisterDeviceEventEXT,
    fp_register_display_event_ext: ?FpRegisterDisplayEventEXT,
    fp_get_swapchain_counter_ext: ?FpGetSwapchainCounterEXT,
    fp_get_device_group_peer_memory_features: ?FpGetDeviceGroupPeerMemoryFeatures,
    fp_bind_buffer_memory2: ?FpBindBufferMemory2,
    fp_bind_image_memory2: ?FpBindImageMemory2,
    fp_cmd_set_device_mask: ?FpCmdSetDeviceMask,
    fp_get_device_group_present_capabilities_khr: ?FpGetDeviceGroupPresentCapabilitiesKHR,
    fp_get_device_group_surface_present_modes_khr: ?FpGetDeviceGroupSurfacePresentModesKHR,
    fp_acquire_next_image2_khr: ?FpAcquireNextImage2KHR,
    fp_cmd_dispatch_base: ?FpCmdDispatchBase,
    fp_get_physical_device_present_rectangles_khr: ?FpGetPhysicalDevicePresentRectanglesKHR,
    fp_create_descriptor_update_template: ?FpCreateDescriptorUpdateTemplate,
    fp_destroy_descriptor_update_template: ?FpDestroyDescriptorUpdateTemplate,
    fp_update_descriptor_set_with_template: ?FpUpdateDescriptorSetWithTemplate,
    fp_cmd_push_descriptor_set_with_template: ?FpCmdPushDescriptorSetWithTemplate,
    fp_set_hdr_metadata_ext: ?FpSetHdrMetadataEXT,
    fp_get_swapchain_status_khr: ?FpGetSwapchainStatusKHR,
    fp_get_refresh_cycle_duration_google: ?FpGetRefreshCycleDurationGOOGLE,
    fp_get_past_presentation_timing_google: ?FpGetPastPresentationTimingGOOGLE,
    fp_cmd_set_viewport_w_scaling_nv: ?FpCmdSetViewportWScalingNV,
    fp_cmd_set_discard_rectangle_ext: ?FpCmdSetDiscardRectangleEXT,
    fp_cmd_set_discard_rectangle_enable_ext: ?FpCmdSetDiscardRectangleEnableEXT,
    fp_cmd_set_discard_rectangle_mode_ext: ?FpCmdSetDiscardRectangleModeEXT,
    fp_cmd_set_sample_locations_ext: ?FpCmdSetSampleLocationsEXT,
    fp_get_physical_device_multisample_properties_ext: ?FpGetPhysicalDeviceMultisamplePropertiesEXT,
    fp_get_buffer_memory_requirements2: ?FpGetBufferMemoryRequirements2,
    fp_get_image_memory_requirements2: ?FpGetImageMemoryRequirements2,
    fp_get_image_sparse_memory_requirements2: ?FpGetImageSparseMemoryRequirements2,
    fp_get_device_buffer_memory_requirements: ?FpGetDeviceBufferMemoryRequirements,
    fp_get_device_image_memory_requirements: ?FpGetDeviceImageMemoryRequirements,
    fp_get_device_image_sparse_memory_requirements: ?FpGetDeviceImageSparseMemoryRequirements,
    fp_create_sampler_ycbcr_conversion: ?FpCreateSamplerYcbcrConversion,
    fp_destroy_sampler_ycbcr_conversion: ?FpDestroySamplerYcbcrConversion,
    fp_get_device_queue2: ?FpGetDeviceQueue2,
    fp_create_validation_cache_ext: ?FpCreateValidationCacheEXT,
    fp_destroy_validation_cache_ext: ?FpDestroyValidationCacheEXT,
    fp_get_validation_cache_data_ext: ?FpGetValidationCacheDataEXT,
    fp_merge_validation_caches_ext: ?FpMergeValidationCachesEXT,
    fp_get_descriptor_set_layout_support: ?FpGetDescriptorSetLayoutSupport,
    fp_get_shader_info_amd: ?FpGetShaderInfoAMD,
    fp_set_local_dimming_amd: ?FpSetLocalDimmingAMD,
    fp_get_physical_device_calibrateable_time_domains_khr: ?FpGetPhysicalDeviceCalibrateableTimeDomainsKHR,
    fp_get_calibrated_timestamps_khr: ?FpGetCalibratedTimestampsKHR,
    fp_get_memory_host_pointer_properties_ext: ?FpGetMemoryHostPointerPropertiesEXT,
    fp_cmd_write_buffer_marker_amd: ?FpCmdWriteBufferMarkerAMD,
    fp_create_render_pass2: ?FpCreateRenderPass2,
    fp_cmd_begin_render_pass2: ?FpCmdBeginRenderPass2,
    fp_cmd_next_subpass2: ?FpCmdNextSubpass2,
    fp_cmd_end_render_pass2: ?FpCmdEndRenderPass2,
    fp_get_semaphore_counter_value: ?FpGetSemaphoreCounterValue,
    fp_wait_semaphores: ?FpWaitSemaphores,
    fp_signal_semaphore: ?FpSignalSemaphore,
    fp_get_android_hardware_buffer_properties_android: ?FpGetAndroidHardwareBufferPropertiesANDROID,
    fp_get_memory_android_hardware_buffer_android: ?FpGetMemoryAndroidHardwareBufferANDROID,
    fp_cmd_draw_indirect_count: ?FpCmdDrawIndirectCount,
    fp_cmd_draw_indexed_indirect_count: ?FpCmdDrawIndexedIndirectCount,
    fp_cmd_set_checkpoint_nv: ?FpCmdSetCheckpointNV,
    fp_get_queue_checkpoint_data_nv: ?FpGetQueueCheckpointDataNV,
    fp_cmd_bind_transform_feedback_buffers_ext: ?FpCmdBindTransformFeedbackBuffersEXT,
    fp_cmd_begin_transform_feedback_ext: ?FpCmdBeginTransformFeedbackEXT,
    fp_cmd_end_transform_feedback_ext: ?FpCmdEndTransformFeedbackEXT,
    fp_cmd_begin_query_indexed_ext: ?FpCmdBeginQueryIndexedEXT,
    fp_cmd_end_query_indexed_ext: ?FpCmdEndQueryIndexedEXT,
    fp_cmd_draw_indirect_byte_count_ext: ?FpCmdDrawIndirectByteCountEXT,
    fp_cmd_set_exclusive_scissor_nv: ?FpCmdSetExclusiveScissorNV,
    fp_cmd_set_exclusive_scissor_enable_nv: ?FpCmdSetExclusiveScissorEnableNV,
    fp_cmd_bind_shading_rate_image_nv: ?FpCmdBindShadingRateImageNV,
    fp_cmd_set_viewport_shading_rate_palette_nv: ?FpCmdSetViewportShadingRatePaletteNV,
    fp_cmd_set_coarse_sample_order_nv: ?FpCmdSetCoarseSampleOrderNV,
    fp_cmd_draw_mesh_tasks_nv: ?FpCmdDrawMeshTasksNV,
    fp_cmd_draw_mesh_tasks_indirect_nv: ?FpCmdDrawMeshTasksIndirectNV,
    fp_cmd_draw_mesh_tasks_indirect_count_nv: ?FpCmdDrawMeshTasksIndirectCountNV,
    fp_cmd_draw_mesh_tasks_ext: ?FpCmdDrawMeshTasksEXT,
    fp_cmd_draw_mesh_tasks_indirect_ext: ?FpCmdDrawMeshTasksIndirectEXT,
    fp_cmd_draw_mesh_tasks_indirect_count_ext: ?FpCmdDrawMeshTasksIndirectCountEXT,
    fp_compile_deferred_nv: ?FpCompileDeferredNV,
    fp_create_acceleration_structure_nv: ?FpCreateAccelerationStructureNV,
    fp_cmd_bind_invocation_mask_huawei: ?FpCmdBindInvocationMaskHUAWEI,
    fp_destroy_acceleration_structure_khr: ?FpDestroyAccelerationStructureKHR,
    fp_destroy_acceleration_structure_nv: ?FpDestroyAccelerationStructureNV,
    fp_get_acceleration_structure_memory_requirements_nv: ?FpGetAccelerationStructureMemoryRequirementsNV,
    fp_bind_acceleration_structure_memory_nv: ?FpBindAccelerationStructureMemoryNV,
    fp_cmd_copy_acceleration_structure_nv: ?FpCmdCopyAccelerationStructureNV,
    fp_cmd_copy_acceleration_structure_khr: ?FpCmdCopyAccelerationStructureKHR,
    fp_copy_acceleration_structure_khr: ?FpCopyAccelerationStructureKHR,
    fp_cmd_copy_acceleration_structure_to_memory_khr: ?FpCmdCopyAccelerationStructureToMemoryKHR,
    fp_copy_acceleration_structure_to_memory_khr: ?FpCopyAccelerationStructureToMemoryKHR,
    fp_cmd_copy_memory_to_acceleration_structure_khr: ?FpCmdCopyMemoryToAccelerationStructureKHR,
    fp_copy_memory_to_acceleration_structure_khr: ?FpCopyMemoryToAccelerationStructureKHR,
    fp_cmd_write_acceleration_structures_properties_khr: ?FpCmdWriteAccelerationStructuresPropertiesKHR,
    fp_cmd_write_acceleration_structures_properties_nv: ?FpCmdWriteAccelerationStructuresPropertiesNV,
    fp_cmd_build_acceleration_structure_nv: ?FpCmdBuildAccelerationStructureNV,
    fp_write_acceleration_structures_properties_khr: ?FpWriteAccelerationStructuresPropertiesKHR,
    fp_cmd_trace_rays_khr: ?FpCmdTraceRaysKHR,
    fp_cmd_trace_rays_nv: ?FpCmdTraceRaysNV,
    fp_get_ray_tracing_shader_group_handles_khr: ?FpGetRayTracingShaderGroupHandlesKHR,
    fp_get_ray_tracing_capture_replay_shader_group_handles_khr: ?FpGetRayTracingCaptureReplayShaderGroupHandlesKHR,
    fp_get_acceleration_structure_handle_nv: ?FpGetAccelerationStructureHandleNV,
    fp_create_ray_tracing_pipelines_nv: ?FpCreateRayTracingPipelinesNV,
    fp_create_ray_tracing_pipelines_khr: ?FpCreateRayTracingPipelinesKHR,
    fp_get_physical_device_cooperative_matrix_properties_nv: ?FpGetPhysicalDeviceCooperativeMatrixPropertiesNV,
    fp_cmd_trace_rays_indirect_khr: ?FpCmdTraceRaysIndirectKHR,
    fp_cmd_trace_rays_indirect2_khr: ?FpCmdTraceRaysIndirect2KHR,
    fp_get_cluster_acceleration_structure_build_sizes_nv: ?FpGetClusterAccelerationStructureBuildSizesNV,
    fp_cmd_build_cluster_acceleration_structure_indirect_nv: ?FpCmdBuildClusterAccelerationStructureIndirectNV,
    fp_get_device_acceleration_structure_compatibility_khr: ?FpGetDeviceAccelerationStructureCompatibilityKHR,
    fp_get_ray_tracing_shader_group_stack_size_khr: ?FpGetRayTracingShaderGroupStackSizeKHR,
    fp_cmd_set_ray_tracing_pipeline_stack_size_khr: ?FpCmdSetRayTracingPipelineStackSizeKHR,
    fp_get_image_view_handle_nvx: ?FpGetImageViewHandleNVX,
    fp_get_image_view_handle64_nvx: ?FpGetImageViewHandle64NVX,
    fp_get_image_view_address_nvx: ?FpGetImageViewAddressNVX,
    fp_get_physical_device_surface_present_modes2_ext: ?FpGetPhysicalDeviceSurfacePresentModes2EXT,
    fp_get_device_group_surface_present_modes2_ext: ?FpGetDeviceGroupSurfacePresentModes2EXT,
    fp_acquire_full_screen_exclusive_mode_ext: ?FpAcquireFullScreenExclusiveModeEXT,
    fp_release_full_screen_exclusive_mode_ext: ?FpReleaseFullScreenExclusiveModeEXT,
    fp_enumerate_physical_device_queue_family_performance_query_counters_khr: ?FpEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR,
    fp_get_physical_device_queue_family_performance_query_passes_khr: ?FpGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR,
    fp_acquire_profiling_lock_khr: ?FpAcquireProfilingLockKHR,
    fp_release_profiling_lock_khr: ?FpReleaseProfilingLockKHR,
    fp_get_image_drm_format_modifier_properties_ext: ?FpGetImageDrmFormatModifierPropertiesEXT,
    fp_get_buffer_opaque_capture_address: ?FpGetBufferOpaqueCaptureAddress,
    fp_get_buffer_device_address: ?FpGetBufferDeviceAddress,
    fp_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv: ?FpGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV,
    fp_initialize_performance_api_intel: ?FpInitializePerformanceApiINTEL,
    fp_uninitialize_performance_api_intel: ?FpUninitializePerformanceApiINTEL,
    fp_cmd_set_performance_marker_intel: ?FpCmdSetPerformanceMarkerINTEL,
    fp_cmd_set_performance_stream_marker_intel: ?FpCmdSetPerformanceStreamMarkerINTEL,
    fp_cmd_set_performance_override_intel: ?FpCmdSetPerformanceOverrideINTEL,
    fp_acquire_performance_configuration_intel: ?FpAcquirePerformanceConfigurationINTEL,
    fp_release_performance_configuration_intel: ?FpReleasePerformanceConfigurationINTEL,
    fp_queue_set_performance_configuration_intel: ?FpQueueSetPerformanceConfigurationINTEL,
    fp_get_performance_parameter_intel: ?FpGetPerformanceParameterINTEL,
    fp_get_device_memory_opaque_capture_address: ?FpGetDeviceMemoryOpaqueCaptureAddress,
    fp_get_pipeline_executable_properties_khr: ?FpGetPipelineExecutablePropertiesKHR,
    fp_get_pipeline_executable_statistics_khr: ?FpGetPipelineExecutableStatisticsKHR,
    fp_get_pipeline_executable_internal_representations_khr: ?FpGetPipelineExecutableInternalRepresentationsKHR,
    fp_cmd_set_line_stipple: ?FpCmdSetLineStipple,
    fp_get_physical_device_tool_properties: ?FpGetPhysicalDeviceToolProperties,
    fp_create_acceleration_structure_khr: ?FpCreateAccelerationStructureKHR,
    fp_cmd_build_acceleration_structures_khr: ?FpCmdBuildAccelerationStructuresKHR,
    fp_cmd_build_acceleration_structures_indirect_khr: ?FpCmdBuildAccelerationStructuresIndirectKHR,
    fp_build_acceleration_structures_khr: ?FpBuildAccelerationStructuresKHR,
    fp_get_acceleration_structure_device_address_khr: ?FpGetAccelerationStructureDeviceAddressKHR,
    fp_create_deferred_operation_khr: ?FpCreateDeferredOperationKHR,
    fp_destroy_deferred_operation_khr: ?FpDestroyDeferredOperationKHR,
    fp_get_deferred_operation_max_concurrency_khr: ?FpGetDeferredOperationMaxConcurrencyKHR,
    fp_get_deferred_operation_result_khr: ?FpGetDeferredOperationResultKHR,
    fp_deferred_operation_join_khr: ?FpDeferredOperationJoinKHR,
    fp_get_pipeline_indirect_memory_requirements_nv: ?FpGetPipelineIndirectMemoryRequirementsNV,
    fp_get_pipeline_indirect_device_address_nv: ?FpGetPipelineIndirectDeviceAddressNV,
    fp_anti_lag_update_amd: ?FpAntiLagUpdateAMD,
    fp_cmd_set_cull_mode: ?FpCmdSetCullMode,
    fp_cmd_set_front_face: ?FpCmdSetFrontFace,
    fp_cmd_set_primitive_topology: ?FpCmdSetPrimitiveTopology,
    fp_cmd_set_viewport_with_count: ?FpCmdSetViewportWithCount,
    fp_cmd_set_scissor_with_count: ?FpCmdSetScissorWithCount,
    fp_cmd_bind_index_buffer2: ?FpCmdBindIndexBuffer2,
    fp_cmd_bind_vertex_buffers2: ?FpCmdBindVertexBuffers2,
    fp_cmd_set_depth_test_enable: ?FpCmdSetDepthTestEnable,
    fp_cmd_set_depth_write_enable: ?FpCmdSetDepthWriteEnable,
    fp_cmd_set_depth_compare_op: ?FpCmdSetDepthCompareOp,
    fp_cmd_set_depth_bounds_test_enable: ?FpCmdSetDepthBoundsTestEnable,
    fp_cmd_set_stencil_test_enable: ?FpCmdSetStencilTestEnable,
    fp_cmd_set_stencil_op: ?FpCmdSetStencilOp,
    fp_cmd_set_patch_control_points_ext: ?FpCmdSetPatchControlPointsEXT,
    fp_cmd_set_rasterizer_discard_enable: ?FpCmdSetRasterizerDiscardEnable,
    fp_cmd_set_depth_bias_enable: ?FpCmdSetDepthBiasEnable,
    fp_cmd_set_logic_op_ext: ?FpCmdSetLogicOpEXT,
    fp_cmd_set_primitive_restart_enable: ?FpCmdSetPrimitiveRestartEnable,
    fp_cmd_set_tessellation_domain_origin_ext: ?FpCmdSetTessellationDomainOriginEXT,
    fp_cmd_set_depth_clamp_enable_ext: ?FpCmdSetDepthClampEnableEXT,
    fp_cmd_set_polygon_mode_ext: ?FpCmdSetPolygonModeEXT,
    fp_cmd_set_rasterization_samples_ext: ?FpCmdSetRasterizationSamplesEXT,
    fp_cmd_set_sample_mask_ext: ?FpCmdSetSampleMaskEXT,
    fp_cmd_set_alpha_to_coverage_enable_ext: ?FpCmdSetAlphaToCoverageEnableEXT,
    fp_cmd_set_alpha_to_one_enable_ext: ?FpCmdSetAlphaToOneEnableEXT,
    fp_cmd_set_logic_op_enable_ext: ?FpCmdSetLogicOpEnableEXT,
    fp_cmd_set_color_blend_enable_ext: ?FpCmdSetColorBlendEnableEXT,
    fp_cmd_set_color_blend_equation_ext: ?FpCmdSetColorBlendEquationEXT,
    fp_cmd_set_color_write_mask_ext: ?FpCmdSetColorWriteMaskEXT,
    fp_cmd_set_rasterization_stream_ext: ?FpCmdSetRasterizationStreamEXT,
    fp_cmd_set_conservative_rasterization_mode_ext: ?FpCmdSetConservativeRasterizationModeEXT,
    fp_cmd_set_extra_primitive_overestimation_size_ext: ?FpCmdSetExtraPrimitiveOverestimationSizeEXT,
    fp_cmd_set_depth_clip_enable_ext: ?FpCmdSetDepthClipEnableEXT,
    fp_cmd_set_sample_locations_enable_ext: ?FpCmdSetSampleLocationsEnableEXT,
    fp_cmd_set_color_blend_advanced_ext: ?FpCmdSetColorBlendAdvancedEXT,
    fp_cmd_set_provoking_vertex_mode_ext: ?FpCmdSetProvokingVertexModeEXT,
    fp_cmd_set_line_rasterization_mode_ext: ?FpCmdSetLineRasterizationModeEXT,
    fp_cmd_set_line_stipple_enable_ext: ?FpCmdSetLineStippleEnableEXT,
    fp_cmd_set_depth_clip_negative_one_to_one_ext: ?FpCmdSetDepthClipNegativeOneToOneEXT,
    fp_cmd_set_viewport_w_scaling_enable_nv: ?FpCmdSetViewportWScalingEnableNV,
    fp_cmd_set_viewport_swizzle_nv: ?FpCmdSetViewportSwizzleNV,
    fp_cmd_set_coverage_to_color_enable_nv: ?FpCmdSetCoverageToColorEnableNV,
    fp_cmd_set_coverage_to_color_location_nv: ?FpCmdSetCoverageToColorLocationNV,
    fp_cmd_set_coverage_modulation_mode_nv: ?FpCmdSetCoverageModulationModeNV,
    fp_cmd_set_coverage_modulation_table_enable_nv: ?FpCmdSetCoverageModulationTableEnableNV,
    fp_cmd_set_coverage_modulation_table_nv: ?FpCmdSetCoverageModulationTableNV,
    fp_cmd_set_shading_rate_image_enable_nv: ?FpCmdSetShadingRateImageEnableNV,
    fp_cmd_set_coverage_reduction_mode_nv: ?FpCmdSetCoverageReductionModeNV,
    fp_cmd_set_representative_fragment_test_enable_nv: ?FpCmdSetRepresentativeFragmentTestEnableNV,
    fp_create_private_data_slot: ?FpCreatePrivateDataSlot,
    fp_destroy_private_data_slot: ?FpDestroyPrivateDataSlot,
    fp_set_private_data: ?FpSetPrivateData,
    fp_get_private_data: ?FpGetPrivateData,
    fp_cmd_copy_buffer2: ?FpCmdCopyBuffer2,
    fp_cmd_copy_image2: ?FpCmdCopyImage2,
    fp_cmd_blit_image2: ?FpCmdBlitImage2,
    fp_cmd_copy_buffer_to_image2: ?FpCmdCopyBufferToImage2,
    fp_cmd_copy_image_to_buffer2: ?FpCmdCopyImageToBuffer2,
    fp_cmd_resolve_image2: ?FpCmdResolveImage2,
    fp_cmd_set_fragment_shading_rate_khr: ?FpCmdSetFragmentShadingRateKHR,
    fp_get_physical_device_fragment_shading_rates_khr: ?FpGetPhysicalDeviceFragmentShadingRatesKHR,
    fp_cmd_set_fragment_shading_rate_enum_nv: ?FpCmdSetFragmentShadingRateEnumNV,
    fp_get_acceleration_structure_build_sizes_khr: ?FpGetAccelerationStructureBuildSizesKHR,
    fp_cmd_set_vertex_input_ext: ?FpCmdSetVertexInputEXT,
    fp_cmd_set_color_write_enable_ext: ?FpCmdSetColorWriteEnableEXT,
    fp_cmd_set_event2: ?FpCmdSetEvent2,
    fp_cmd_reset_event2: ?FpCmdResetEvent2,
    fp_cmd_wait_events2: ?FpCmdWaitEvents2,
    fp_cmd_pipeline_barrier2: ?FpCmdPipelineBarrier2,
    fp_queue_submit2: ?FpQueueSubmit2,
    fp_cmd_write_timestamp2: ?FpCmdWriteTimestamp2,
    fp_cmd_write_buffer_marker2_amd: ?FpCmdWriteBufferMarker2AMD,
    fp_get_queue_checkpoint_data2_nv: ?FpGetQueueCheckpointData2NV,
    fp_copy_memory_to_image: ?FpCopyMemoryToImage,
    fp_copy_image_to_memory: ?FpCopyImageToMemory,
    fp_copy_image_to_image: ?FpCopyImageToImage,
    fp_transition_image_layout: ?FpTransitionImageLayout,
    fp_cmd_decompress_memory_nv: ?FpCmdDecompressMemoryNV,
    fp_cmd_decompress_memory_indirect_count_nv: ?FpCmdDecompressMemoryIndirectCountNV,
    fp_get_partitioned_acceleration_structures_build_sizes_nv: ?FpGetPartitionedAccelerationStructuresBuildSizesNV,
    fp_cmd_build_partitioned_acceleration_structures_nv: ?FpCmdBuildPartitionedAccelerationStructuresNV,
    fp_create_cu_module_nvx: ?FpCreateCuModuleNVX,
    fp_create_cu_function_nvx: ?FpCreateCuFunctionNVX,
    fp_destroy_cu_module_nvx: ?FpDestroyCuModuleNVX,
    fp_destroy_cu_function_nvx: ?FpDestroyCuFunctionNVX,
    fp_cmd_cu_launch_kernel_nvx: ?FpCmdCuLaunchKernelNVX,
    fp_get_descriptor_set_layout_size_ext: ?FpGetDescriptorSetLayoutSizeEXT,
    fp_get_descriptor_set_layout_binding_offset_ext: ?FpGetDescriptorSetLayoutBindingOffsetEXT,
    fp_get_descriptor_ext: ?FpGetDescriptorEXT,
    fp_cmd_bind_descriptor_buffers_ext: ?FpCmdBindDescriptorBuffersEXT,
    fp_cmd_set_descriptor_buffer_offsets_ext: ?FpCmdSetDescriptorBufferOffsetsEXT,
    fp_cmd_bind_descriptor_buffer_embedded_samplers_ext: ?FpCmdBindDescriptorBufferEmbeddedSamplersEXT,
    fp_get_buffer_opaque_capture_descriptor_data_ext: ?FpGetBufferOpaqueCaptureDescriptorDataEXT,
    fp_get_image_opaque_capture_descriptor_data_ext: ?FpGetImageOpaqueCaptureDescriptorDataEXT,
    fp_get_image_view_opaque_capture_descriptor_data_ext: ?FpGetImageViewOpaqueCaptureDescriptorDataEXT,
    fp_get_sampler_opaque_capture_descriptor_data_ext: ?FpGetSamplerOpaqueCaptureDescriptorDataEXT,
    fp_get_acceleration_structure_opaque_capture_descriptor_data_ext: ?FpGetAccelerationStructureOpaqueCaptureDescriptorDataEXT,
    fp_set_device_memory_priority_ext: ?FpSetDeviceMemoryPriorityEXT,
    fp_wait_for_present2_khr: ?FpWaitForPresent2KHR,
    fp_wait_for_present_khr: ?FpWaitForPresentKHR,
    fp_create_buffer_collection_fuchsia: ?FpCreateBufferCollectionFUCHSIA,
    fp_set_buffer_collection_buffer_constraints_fuchsia: ?FpSetBufferCollectionBufferConstraintsFUCHSIA,
    fp_set_buffer_collection_image_constraints_fuchsia: ?FpSetBufferCollectionImageConstraintsFUCHSIA,
    fp_destroy_buffer_collection_fuchsia: ?FpDestroyBufferCollectionFUCHSIA,
    fp_get_buffer_collection_properties_fuchsia: ?FpGetBufferCollectionPropertiesFUCHSIA,
    fp_create_cuda_module_nv: ?FpCreateCudaModuleNV,
    fp_get_cuda_module_cache_nv: ?FpGetCudaModuleCacheNV,
    fp_create_cuda_function_nv: ?FpCreateCudaFunctionNV,
    fp_destroy_cuda_module_nv: ?FpDestroyCudaModuleNV,
    fp_destroy_cuda_function_nv: ?FpDestroyCudaFunctionNV,
    fp_cmd_cuda_launch_kernel_nv: ?FpCmdCudaLaunchKernelNV,
    fp_cmd_begin_rendering: ?FpCmdBeginRendering,
    fp_cmd_end_rendering: ?FpCmdEndRendering,
    fp_cmd_end_rendering2_ext: ?FpCmdEndRendering2EXT,
    fp_get_descriptor_set_layout_host_mapping_info_valve: ?FpGetDescriptorSetLayoutHostMappingInfoVALVE,
    fp_get_descriptor_set_host_mapping_valve: ?FpGetDescriptorSetHostMappingVALVE,
    fp_create_micromap_ext: ?FpCreateMicromapEXT,
    fp_cmd_build_micromaps_ext: ?FpCmdBuildMicromapsEXT,
    fp_build_micromaps_ext: ?FpBuildMicromapsEXT,
    fp_destroy_micromap_ext: ?FpDestroyMicromapEXT,
    fp_cmd_copy_micromap_ext: ?FpCmdCopyMicromapEXT,
    fp_copy_micromap_ext: ?FpCopyMicromapEXT,
    fp_cmd_copy_micromap_to_memory_ext: ?FpCmdCopyMicromapToMemoryEXT,
    fp_copy_micromap_to_memory_ext: ?FpCopyMicromapToMemoryEXT,
    fp_cmd_copy_memory_to_micromap_ext: ?FpCmdCopyMemoryToMicromapEXT,
    fp_copy_memory_to_micromap_ext: ?FpCopyMemoryToMicromapEXT,
    fp_cmd_write_micromaps_properties_ext: ?FpCmdWriteMicromapsPropertiesEXT,
    fp_write_micromaps_properties_ext: ?FpWriteMicromapsPropertiesEXT,
    fp_get_device_micromap_compatibility_ext: ?FpGetDeviceMicromapCompatibilityEXT,
    fp_get_micromap_build_sizes_ext: ?FpGetMicromapBuildSizesEXT,
    fp_get_shader_module_identifier_ext: ?FpGetShaderModuleIdentifierEXT,
    fp_get_shader_module_create_info_identifier_ext: ?FpGetShaderModuleCreateInfoIdentifierEXT,
    fp_get_image_subresource_layout2: ?FpGetImageSubresourceLayout2,
    fp_get_pipeline_properties_ext: ?FpGetPipelinePropertiesEXT,
    fp_export_metal_objects_ext: ?FpExportMetalObjectsEXT,
    fp_cmd_bind_tile_memory_qcom: ?FpCmdBindTileMemoryQCOM,
    fp_get_framebuffer_tile_properties_qcom: ?FpGetFramebufferTilePropertiesQCOM,
    fp_get_dynamic_rendering_tile_properties_qcom: ?FpGetDynamicRenderingTilePropertiesQCOM,
    fp_get_physical_device_optical_flow_image_formats_nv: ?FpGetPhysicalDeviceOpticalFlowImageFormatsNV,
    fp_create_optical_flow_session_nv: ?FpCreateOpticalFlowSessionNV,
    fp_destroy_optical_flow_session_nv: ?FpDestroyOpticalFlowSessionNV,
    fp_bind_optical_flow_session_image_nv: ?FpBindOpticalFlowSessionImageNV,
    fp_cmd_optical_flow_execute_nv: ?FpCmdOpticalFlowExecuteNV,
    fp_get_device_fault_info_ext: ?FpGetDeviceFaultInfoEXT,
    fp_cmd_set_depth_bias2_ext: ?FpCmdSetDepthBias2EXT,
    fp_release_swapchain_images_khr: ?FpReleaseSwapchainImagesKHR,
    fp_get_device_image_subresource_layout: ?FpGetDeviceImageSubresourceLayout,
    fp_map_memory2: ?FpMapMemory2,
    fp_unmap_memory2: ?FpUnmapMemory2,
    fp_create_shaders_ext: ?FpCreateShadersEXT,
    fp_destroy_shader_ext: ?FpDestroyShaderEXT,
    fp_get_shader_binary_data_ext: ?FpGetShaderBinaryDataEXT,
    fp_cmd_bind_shaders_ext: ?FpCmdBindShadersEXT,
    fp_get_physical_device_cooperative_matrix_properties_khr: ?FpGetPhysicalDeviceCooperativeMatrixPropertiesKHR,
    fp_get_execution_graph_pipeline_scratch_size_amdx: ?FpGetExecutionGraphPipelineScratchSizeAMDX,
    fp_get_execution_graph_pipeline_node_index_amdx: ?FpGetExecutionGraphPipelineNodeIndexAMDX,
    fp_create_execution_graph_pipelines_amdx: ?FpCreateExecutionGraphPipelinesAMDX,
    fp_cmd_initialize_graph_scratch_memory_amdx: ?FpCmdInitializeGraphScratchMemoryAMDX,
    fp_cmd_dispatch_graph_amdx: ?FpCmdDispatchGraphAMDX,
    fp_cmd_dispatch_graph_indirect_amdx: ?FpCmdDispatchGraphIndirectAMDX,
    fp_cmd_dispatch_graph_indirect_count_amdx: ?FpCmdDispatchGraphIndirectCountAMDX,
    fp_cmd_bind_descriptor_sets2: ?FpCmdBindDescriptorSets2,
    fp_cmd_push_constants2: ?FpCmdPushConstants2,
    fp_cmd_push_descriptor_set2: ?FpCmdPushDescriptorSet2,
    fp_cmd_push_descriptor_set_with_template2: ?FpCmdPushDescriptorSetWithTemplate2,
    fp_cmd_set_descriptor_buffer_offsets2_ext: ?FpCmdSetDescriptorBufferOffsets2EXT,
    fp_cmd_bind_descriptor_buffer_embedded_samplers2_ext: ?FpCmdBindDescriptorBufferEmbeddedSamplers2EXT,
    fp_set_latency_sleep_mode_nv: ?FpSetLatencySleepModeNV,
    fp_latency_sleep_nv: ?FpLatencySleepNV,
    fp_set_latency_marker_nv: ?FpSetLatencyMarkerNV,
    fp_get_latency_timings_nv: ?FpGetLatencyTimingsNV,
    fp_queue_notify_out_of_band_nv: ?FpQueueNotifyOutOfBandNV,
    fp_cmd_set_rendering_attachment_locations: ?FpCmdSetRenderingAttachmentLocations,
    fp_cmd_set_rendering_input_attachment_indices: ?FpCmdSetRenderingInputAttachmentIndices,
    fp_cmd_set_depth_clamp_range_ext: ?FpCmdSetDepthClampRangeEXT,
    fp_get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv: ?FpGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV,
    fp_get_memory_metal_handle_ext: ?FpGetMemoryMetalHandleEXT,
    fp_get_memory_metal_handle_properties_ext: ?FpGetMemoryMetalHandlePropertiesEXT,
    fp_get_physical_device_cooperative_vector_properties_nv: ?FpGetPhysicalDeviceCooperativeVectorPropertiesNV,
    fp_convert_cooperative_vector_matrix_nv: ?FpConvertCooperativeVectorMatrixNV,
    fp_cmd_convert_cooperative_vector_matrix_nv: ?FpCmdConvertCooperativeVectorMatrixNV,
    fp_cmd_dispatch_tile_qcom: ?FpCmdDispatchTileQCOM,
    fp_cmd_begin_per_tile_execution_qcom: ?FpCmdBeginPerTileExecutionQCOM,
    fp_cmd_end_per_tile_execution_qcom: ?FpCmdEndPerTileExecutionQCOM,
    fp_create_external_compute_queue_nv: ?FpCreateExternalComputeQueueNV,
    fp_destroy_external_compute_queue_nv: ?FpDestroyExternalComputeQueueNV,
    fp_get_external_compute_queue_data_nv: ?FpGetExternalComputeQueueDataNV,
    fp_create_tensor_arm: ?FpCreateTensorARM,
    fp_destroy_tensor_arm: ?FpDestroyTensorARM,
    fp_create_tensor_view_arm: ?FpCreateTensorViewARM,
    fp_destroy_tensor_view_arm: ?FpDestroyTensorViewARM,
    fp_get_tensor_memory_requirements_arm: ?FpGetTensorMemoryRequirementsARM,
    fp_bind_tensor_memory_arm: ?FpBindTensorMemoryARM,
    fp_get_device_tensor_memory_requirements_arm: ?FpGetDeviceTensorMemoryRequirementsARM,
    fp_cmd_copy_tensor_arm: ?FpCmdCopyTensorARM,
    fp_get_tensor_opaque_capture_descriptor_data_arm: ?FpGetTensorOpaqueCaptureDescriptorDataARM,
    fp_get_tensor_view_opaque_capture_descriptor_data_arm: ?FpGetTensorViewOpaqueCaptureDescriptorDataARM,
    fp_get_physical_device_external_tensor_properties_arm: ?FpGetPhysicalDeviceExternalTensorPropertiesARM,
    fp_create_data_graph_pipelines_arm: ?FpCreateDataGraphPipelinesARM,
    fp_create_data_graph_pipeline_session_arm: ?FpCreateDataGraphPipelineSessionARM,
    fp_get_data_graph_pipeline_session_bind_point_requirements_arm: ?FpGetDataGraphPipelineSessionBindPointRequirementsARM,
    fp_get_data_graph_pipeline_session_memory_requirements_arm: ?FpGetDataGraphPipelineSessionMemoryRequirementsARM,
    fp_bind_data_graph_pipeline_session_memory_arm: ?FpBindDataGraphPipelineSessionMemoryARM,
    fp_destroy_data_graph_pipeline_session_arm: ?FpDestroyDataGraphPipelineSessionARM,
    fp_cmd_dispatch_data_graph_arm: ?FpCmdDispatchDataGraphARM,
    fp_get_data_graph_pipeline_available_properties_arm: ?FpGetDataGraphPipelineAvailablePropertiesARM,
    fp_get_data_graph_pipeline_properties_arm: ?FpGetDataGraphPipelinePropertiesARM,
    fp_get_physical_device_queue_family_data_graph_properties_arm: ?FpGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM,
    fp_get_physical_device_queue_family_data_graph_processing_engine_properties_arm: ?FpGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM,

    pub fn init(globals: GlobalCommands, instance: InstanceCommands, device: Device, create_info: *const DeviceCreateInfo) MissingFunctionError!DeviceCommands {
        var extensions: DeviceExtensions = .{
            .core_version = instance.extensions.core_version,
        };
        if (create_info.pp_enabled_extension_names) |extension_names| {
            for (0..create_info.enabled_extension_count) |i| {
                extensions.enable_by_name(extension_names[i]);
            }
        }
        return .{
            .handle = device,
            .extensions = extensions,
            .fp_destroy_device = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyDevice")),
            .fp_get_device_queue = @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceQueue")),
            .fp_queue_submit = @ptrCast(try instance.get_device_proc_addr(device, "vkQueueSubmit")),
            .fp_queue_wait_idle = @ptrCast(try instance.get_device_proc_addr(device, "vkQueueWaitIdle")),
            .fp_device_wait_idle = @ptrCast(try instance.get_device_proc_addr(device, "vkDeviceWaitIdle")),
            .fp_allocate_memory = @ptrCast(try instance.get_device_proc_addr(device, "vkAllocateMemory")),
            .fp_free_memory = @ptrCast(try instance.get_device_proc_addr(device, "vkFreeMemory")),
            .fp_map_memory = @ptrCast(try instance.get_device_proc_addr(device, "vkMapMemory")),
            .fp_unmap_memory = @ptrCast(try instance.get_device_proc_addr(device, "vkUnmapMemory")),
            .fp_flush_mapped_memory_ranges = @ptrCast(try instance.get_device_proc_addr(device, "vkFlushMappedMemoryRanges")),
            .fp_invalidate_mapped_memory_ranges = @ptrCast(try instance.get_device_proc_addr(device, "vkInvalidateMappedMemoryRanges")),
            .fp_get_device_memory_commitment = @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceMemoryCommitment")),
            .fp_get_buffer_memory_requirements = @ptrCast(try instance.get_device_proc_addr(device, "vkGetBufferMemoryRequirements")),
            .fp_bind_buffer_memory = @ptrCast(try instance.get_device_proc_addr(device, "vkBindBufferMemory")),
            .fp_get_image_memory_requirements = @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageMemoryRequirements")),
            .fp_bind_image_memory = @ptrCast(try instance.get_device_proc_addr(device, "vkBindImageMemory")),
            .fp_get_image_sparse_memory_requirements = @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageSparseMemoryRequirements")),
            .fp_queue_bind_sparse = @ptrCast(try instance.get_device_proc_addr(device, "vkQueueBindSparse")),
            .fp_create_fence = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateFence")),
            .fp_destroy_fence = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyFence")),
            .fp_reset_fences = @ptrCast(try instance.get_device_proc_addr(device, "vkResetFences")),
            .fp_get_fence_status = @ptrCast(try instance.get_device_proc_addr(device, "vkGetFenceStatus")),
            .fp_wait_for_fences = @ptrCast(try instance.get_device_proc_addr(device, "vkWaitForFences")),
            .fp_create_semaphore = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateSemaphore")),
            .fp_destroy_semaphore = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroySemaphore")),
            .fp_create_event = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateEvent")),
            .fp_destroy_event = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyEvent")),
            .fp_get_event_status = @ptrCast(try instance.get_device_proc_addr(device, "vkGetEventStatus")),
            .fp_set_event = @ptrCast(try instance.get_device_proc_addr(device, "vkSetEvent")),
            .fp_reset_event = @ptrCast(try instance.get_device_proc_addr(device, "vkResetEvent")),
            .fp_create_query_pool = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateQueryPool")),
            .fp_destroy_query_pool = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyQueryPool")),
            .fp_get_query_pool_results = @ptrCast(try instance.get_device_proc_addr(device, "vkGetQueryPoolResults")),
            .fp_reset_query_pool = if (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkResetQueryPool")) else if (extensions.ext_host_query_reset) @ptrCast(try instance.get_device_proc_addr(device, "vkResetQueryPoolEXT")) else null,
            .fp_create_buffer = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateBuffer")),
            .fp_destroy_buffer = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyBuffer")),
            .fp_create_buffer_view = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateBufferView")),
            .fp_destroy_buffer_view = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyBufferView")),
            .fp_create_image = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateImage")),
            .fp_destroy_image = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyImage")),
            .fp_get_image_subresource_layout = @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageSubresourceLayout")),
            .fp_create_image_view = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateImageView")),
            .fp_destroy_image_view = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyImageView")),
            .fp_create_shader_module = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateShaderModule")),
            .fp_destroy_shader_module = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyShaderModule")),
            .fp_create_pipeline_cache = @ptrCast(try instance.get_device_proc_addr(device, "vkCreatePipelineCache")),
            .fp_destroy_pipeline_cache = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyPipelineCache")),
            .fp_get_pipeline_cache_data = @ptrCast(try instance.get_device_proc_addr(device, "vkGetPipelineCacheData")),
            .fp_merge_pipeline_caches = @ptrCast(try instance.get_device_proc_addr(device, "vkMergePipelineCaches")),
            .fp_create_pipeline_binaries_khr = if (extensions.khr_pipeline_binary) @ptrCast(try instance.get_device_proc_addr(device, "vkCreatePipelineBinariesKHR")) else null,
            .fp_destroy_pipeline_binary_khr = if (extensions.khr_pipeline_binary) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyPipelineBinaryKHR")) else null,
            .fp_get_pipeline_key_khr = if (extensions.khr_pipeline_binary) @ptrCast(try instance.get_device_proc_addr(device, "vkGetPipelineKeyKHR")) else null,
            .fp_get_pipeline_binary_data_khr = if (extensions.khr_pipeline_binary) @ptrCast(try instance.get_device_proc_addr(device, "vkGetPipelineBinaryDataKHR")) else null,
            .fp_release_captured_pipeline_data_khr = if (extensions.khr_pipeline_binary) @ptrCast(try instance.get_device_proc_addr(device, "vkReleaseCapturedPipelineDataKHR")) else null,
            .fp_create_graphics_pipelines = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateGraphicsPipelines")),
            .fp_create_compute_pipelines = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateComputePipelines")),
            .fp_get_device_subpass_shading_max_workgroup_size_huawei = if (extensions.huawei_subpass_shading) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI")) else null,
            .fp_destroy_pipeline = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyPipeline")),
            .fp_create_pipeline_layout = @ptrCast(try instance.get_device_proc_addr(device, "vkCreatePipelineLayout")),
            .fp_destroy_pipeline_layout = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyPipelineLayout")),
            .fp_create_sampler = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateSampler")),
            .fp_destroy_sampler = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroySampler")),
            .fp_create_descriptor_set_layout = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateDescriptorSetLayout")),
            .fp_destroy_descriptor_set_layout = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyDescriptorSetLayout")),
            .fp_create_descriptor_pool = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateDescriptorPool")),
            .fp_destroy_descriptor_pool = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyDescriptorPool")),
            .fp_reset_descriptor_pool = @ptrCast(try instance.get_device_proc_addr(device, "vkResetDescriptorPool")),
            .fp_allocate_descriptor_sets = @ptrCast(try instance.get_device_proc_addr(device, "vkAllocateDescriptorSets")),
            .fp_free_descriptor_sets = @ptrCast(try instance.get_device_proc_addr(device, "vkFreeDescriptorSets")),
            .fp_update_descriptor_sets = @ptrCast(try instance.get_device_proc_addr(device, "vkUpdateDescriptorSets")),
            .fp_create_framebuffer = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateFramebuffer")),
            .fp_destroy_framebuffer = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyFramebuffer")),
            .fp_create_render_pass = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateRenderPass")),
            .fp_destroy_render_pass = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyRenderPass")),
            .fp_get_render_area_granularity = @ptrCast(try instance.get_device_proc_addr(device, "vkGetRenderAreaGranularity")),
            .fp_get_rendering_area_granularity = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetRenderingAreaGranularity")) else if (extensions.khr_maintenance5) @ptrCast(try instance.get_device_proc_addr(device, "vkGetRenderingAreaGranularityKHR")) else null,
            .fp_create_command_pool = @ptrCast(try instance.get_device_proc_addr(device, "vkCreateCommandPool")),
            .fp_destroy_command_pool = @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyCommandPool")),
            .fp_reset_command_pool = @ptrCast(try instance.get_device_proc_addr(device, "vkResetCommandPool")),
            .fp_allocate_command_buffers = @ptrCast(try instance.get_device_proc_addr(device, "vkAllocateCommandBuffers")),
            .fp_free_command_buffers = @ptrCast(try instance.get_device_proc_addr(device, "vkFreeCommandBuffers")),
            .fp_begin_command_buffer = @ptrCast(try instance.get_device_proc_addr(device, "vkBeginCommandBuffer")),
            .fp_end_command_buffer = @ptrCast(try instance.get_device_proc_addr(device, "vkEndCommandBuffer")),
            .fp_reset_command_buffer = @ptrCast(try instance.get_device_proc_addr(device, "vkResetCommandBuffer")),
            .fp_cmd_bind_pipeline = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindPipeline")),
            .fp_cmd_set_attachment_feedback_loop_enable_ext = if (extensions.ext_attachment_feedback_loop_dynamic_state) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetAttachmentFeedbackLoopEnableEXT")) else null,
            .fp_cmd_set_viewport = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetViewport")),
            .fp_cmd_set_scissor = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetScissor")),
            .fp_cmd_set_line_width = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetLineWidth")),
            .fp_cmd_set_depth_bias = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthBias")),
            .fp_cmd_set_blend_constants = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetBlendConstants")),
            .fp_cmd_set_depth_bounds = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthBounds")),
            .fp_cmd_set_stencil_compare_mask = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetStencilCompareMask")),
            .fp_cmd_set_stencil_write_mask = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetStencilWriteMask")),
            .fp_cmd_set_stencil_reference = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetStencilReference")),
            .fp_cmd_bind_descriptor_sets = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindDescriptorSets")),
            .fp_cmd_bind_index_buffer = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindIndexBuffer")),
            .fp_cmd_bind_vertex_buffers = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindVertexBuffers")),
            .fp_cmd_draw = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDraw")),
            .fp_cmd_draw_indexed = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawIndexed")),
            .fp_cmd_draw_multi_ext = if (extensions.ext_multi_draw) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawMultiEXT")) else null,
            .fp_cmd_draw_multi_indexed_ext = if (extensions.ext_multi_draw) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawMultiIndexedEXT")) else null,
            .fp_cmd_draw_indirect = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawIndirect")),
            .fp_cmd_draw_indexed_indirect = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawIndexedIndirect")),
            .fp_cmd_dispatch = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDispatch")),
            .fp_cmd_dispatch_indirect = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDispatchIndirect")),
            .fp_cmd_subpass_shading_huawei = if (extensions.huawei_subpass_shading) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSubpassShadingHUAWEI")) else null,
            .fp_cmd_draw_cluster_huawei = if (extensions.huawei_cluster_culling_shader) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawClusterHUAWEI")) else null,
            .fp_cmd_draw_cluster_indirect_huawei = if (extensions.huawei_cluster_culling_shader) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawClusterIndirectHUAWEI")) else null,
            .fp_cmd_update_pipeline_indirect_buffer_nv = if (extensions.nv_device_generated_commands_compute) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdUpdatePipelineIndirectBufferNV")) else null,
            .fp_cmd_copy_buffer = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyBuffer")),
            .fp_cmd_copy_image = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyImage")),
            .fp_cmd_blit_image = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBlitImage")),
            .fp_cmd_copy_buffer_to_image = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyBufferToImage")),
            .fp_cmd_copy_image_to_buffer = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyImageToBuffer")),
            .fp_cmd_copy_memory_indirect_nv = if (extensions.nv_copy_memory_indirect) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyMemoryIndirectNV")) else null,
            .fp_cmd_copy_memory_to_image_indirect_nv = if (extensions.nv_copy_memory_indirect) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyMemoryToImageIndirectNV")) else null,
            .fp_cmd_update_buffer = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdUpdateBuffer")),
            .fp_cmd_fill_buffer = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdFillBuffer")),
            .fp_cmd_clear_color_image = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdClearColorImage")),
            .fp_cmd_clear_depth_stencil_image = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdClearDepthStencilImage")),
            .fp_cmd_clear_attachments = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdClearAttachments")),
            .fp_cmd_resolve_image = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdResolveImage")),
            .fp_cmd_set_event = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetEvent")),
            .fp_cmd_reset_event = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdResetEvent")),
            .fp_cmd_wait_events = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdWaitEvents")),
            .fp_cmd_pipeline_barrier = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPipelineBarrier")),
            .fp_cmd_begin_query = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBeginQuery")),
            .fp_cmd_end_query = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdEndQuery")),
            .fp_cmd_begin_conditional_rendering_ext = if (extensions.ext_conditional_rendering) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBeginConditionalRenderingEXT")) else null,
            .fp_cmd_end_conditional_rendering_ext = if (extensions.ext_conditional_rendering) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdEndConditionalRenderingEXT")) else null,
            .fp_cmd_reset_query_pool = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdResetQueryPool")),
            .fp_cmd_write_timestamp = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdWriteTimestamp")),
            .fp_cmd_copy_query_pool_results = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyQueryPoolResults")),
            .fp_cmd_push_constants = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPushConstants")),
            .fp_cmd_begin_render_pass = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBeginRenderPass")),
            .fp_cmd_next_subpass = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdNextSubpass")),
            .fp_cmd_end_render_pass = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdEndRenderPass")),
            .fp_cmd_execute_commands = @ptrCast(try instance.get_device_proc_addr(device, "vkCmdExecuteCommands")),
            .fp_create_shared_swapchains_khr = if (extensions.khr_display_swapchain) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateSharedSwapchainsKHR")) else null,
            .fp_create_swapchain_khr = if (extensions.khr_swapchain) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateSwapchainKHR")) else null,
            .fp_destroy_swapchain_khr = if (extensions.khr_swapchain) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroySwapchainKHR")) else null,
            .fp_get_swapchain_images_khr = if (extensions.khr_swapchain) @ptrCast(try instance.get_device_proc_addr(device, "vkGetSwapchainImagesKHR")) else null,
            .fp_acquire_next_image_khr = if (extensions.khr_swapchain) @ptrCast(try instance.get_device_proc_addr(device, "vkAcquireNextImageKHR")) else null,
            .fp_queue_present_khr = if (extensions.khr_swapchain) @ptrCast(try instance.get_device_proc_addr(device, "vkQueuePresentKHR")) else null,
            .fp_debug_marker_set_object_name_ext = if (extensions.ext_debug_marker) @ptrCast(try instance.get_device_proc_addr(device, "vkDebugMarkerSetObjectNameEXT")) else null,
            .fp_debug_marker_set_object_tag_ext = if (extensions.ext_debug_marker) @ptrCast(try instance.get_device_proc_addr(device, "vkDebugMarkerSetObjectTagEXT")) else null,
            .fp_cmd_debug_marker_begin_ext = if (extensions.ext_debug_marker) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDebugMarkerBeginEXT")) else null,
            .fp_cmd_debug_marker_end_ext = if (extensions.ext_debug_marker) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDebugMarkerEndEXT")) else null,
            .fp_cmd_debug_marker_insert_ext = if (extensions.ext_debug_marker) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDebugMarkerInsertEXT")) else null,
            .fp_get_memory_win32_handle_nv = if (extensions.nv_external_memory_win32) @ptrCast(try instance.get_device_proc_addr(device, "vkGetMemoryWin32HandleNV")) else null,
            .fp_cmd_execute_generated_commands_nv = if (extensions.nv_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdExecuteGeneratedCommandsNV")) else null,
            .fp_cmd_preprocess_generated_commands_nv = if (extensions.nv_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPreprocessGeneratedCommandsNV")) else null,
            .fp_cmd_bind_pipeline_shader_group_nv = if (extensions.nv_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindPipelineShaderGroupNV")) else null,
            .fp_get_generated_commands_memory_requirements_nv = if (extensions.nv_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkGetGeneratedCommandsMemoryRequirementsNV")) else null,
            .fp_create_indirect_commands_layout_nv = if (extensions.nv_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateIndirectCommandsLayoutNV")) else null,
            .fp_destroy_indirect_commands_layout_nv = if (extensions.nv_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyIndirectCommandsLayoutNV")) else null,
            .fp_cmd_execute_generated_commands_ext = if (extensions.ext_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdExecuteGeneratedCommandsEXT")) else null,
            .fp_cmd_preprocess_generated_commands_ext = if (extensions.ext_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPreprocessGeneratedCommandsEXT")) else null,
            .fp_get_generated_commands_memory_requirements_ext = if (extensions.ext_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkGetGeneratedCommandsMemoryRequirementsEXT")) else null,
            .fp_create_indirect_commands_layout_ext = if (extensions.ext_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateIndirectCommandsLayoutEXT")) else null,
            .fp_destroy_indirect_commands_layout_ext = if (extensions.ext_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyIndirectCommandsLayoutEXT")) else null,
            .fp_create_indirect_execution_set_ext = if (extensions.ext_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateIndirectExecutionSetEXT")) else null,
            .fp_destroy_indirect_execution_set_ext = if (extensions.ext_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyIndirectExecutionSetEXT")) else null,
            .fp_update_indirect_execution_set_pipeline_ext = if (extensions.ext_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkUpdateIndirectExecutionSetPipelineEXT")) else null,
            .fp_update_indirect_execution_set_shader_ext = if (extensions.ext_device_generated_commands) @ptrCast(try instance.get_device_proc_addr(device, "vkUpdateIndirectExecutionSetShaderEXT")) else null,
            .fp_cmd_push_descriptor_set = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPushDescriptorSet")) else if (extensions.khr_push_descriptor) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPushDescriptorSetKHR")) else null,
            .fp_trim_command_pool = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkTrimCommandPool")) else if (extensions.khr_maintenance1) @ptrCast(try instance.get_device_proc_addr(device, "vkTrimCommandPoolKHR")) else null,
            .fp_get_memory_win32_handle_khr = if (extensions.khr_external_memory_win32) @ptrCast(try instance.get_device_proc_addr(device, "vkGetMemoryWin32HandleKHR")) else null,
            .fp_get_memory_win32_handle_properties_khr = if (extensions.khr_external_memory_win32) @ptrCast(try instance.get_device_proc_addr(device, "vkGetMemoryWin32HandlePropertiesKHR")) else null,
            .fp_get_memory_fd_khr = if (extensions.khr_external_memory_fd) @ptrCast(try instance.get_device_proc_addr(device, "vkGetMemoryFdKHR")) else null,
            .fp_get_memory_fd_properties_khr = if (extensions.khr_external_memory_fd) @ptrCast(try instance.get_device_proc_addr(device, "vkGetMemoryFdPropertiesKHR")) else null,
            .fp_get_memory_zircon_handle_fuchsia = if (extensions.fuchsia_external_memory) @ptrCast(try instance.get_device_proc_addr(device, "vkGetMemoryZirconHandleFUCHSIA")) else null,
            .fp_get_memory_zircon_handle_properties_fuchsia = if (extensions.fuchsia_external_memory) @ptrCast(try instance.get_device_proc_addr(device, "vkGetMemoryZirconHandlePropertiesFUCHSIA")) else null,
            .fp_get_memory_remote_address_nv = if (extensions.nv_external_memory_rdma) @ptrCast(try instance.get_device_proc_addr(device, "vkGetMemoryRemoteAddressNV")) else null,
            .fp_get_semaphore_win32_handle_khr = if (extensions.khr_external_semaphore_win32) @ptrCast(try instance.get_device_proc_addr(device, "vkGetSemaphoreWin32HandleKHR")) else null,
            .fp_import_semaphore_win32_handle_khr = if (extensions.khr_external_semaphore_win32) @ptrCast(try instance.get_device_proc_addr(device, "vkImportSemaphoreWin32HandleKHR")) else null,
            .fp_get_semaphore_fd_khr = if (extensions.khr_external_semaphore_fd) @ptrCast(try instance.get_device_proc_addr(device, "vkGetSemaphoreFdKHR")) else null,
            .fp_import_semaphore_fd_khr = if (extensions.khr_external_semaphore_fd) @ptrCast(try instance.get_device_proc_addr(device, "vkImportSemaphoreFdKHR")) else null,
            .fp_get_semaphore_zircon_handle_fuchsia = if (extensions.fuchsia_external_semaphore) @ptrCast(try instance.get_device_proc_addr(device, "vkGetSemaphoreZirconHandleFUCHSIA")) else null,
            .fp_import_semaphore_zircon_handle_fuchsia = if (extensions.fuchsia_external_semaphore) @ptrCast(try instance.get_device_proc_addr(device, "vkImportSemaphoreZirconHandleFUCHSIA")) else null,
            .fp_get_fence_win32_handle_khr = if (extensions.khr_external_fence_win32) @ptrCast(try instance.get_device_proc_addr(device, "vkGetFenceWin32HandleKHR")) else null,
            .fp_import_fence_win32_handle_khr = if (extensions.khr_external_fence_win32) @ptrCast(try instance.get_device_proc_addr(device, "vkImportFenceWin32HandleKHR")) else null,
            .fp_get_fence_fd_khr = if (extensions.khr_external_fence_fd) @ptrCast(try instance.get_device_proc_addr(device, "vkGetFenceFdKHR")) else null,
            .fp_import_fence_fd_khr = if (extensions.khr_external_fence_fd) @ptrCast(try instance.get_device_proc_addr(device, "vkImportFenceFdKHR")) else null,
            .fp_acquire_winrt_display_nv = if (extensions.nv_acquire_winrt_display) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkAcquireWinrtDisplayNV")) else null,
            .fp_get_winrt_display_nv = if (extensions.nv_acquire_winrt_display) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetWinrtDisplayNV")) else null,
            .fp_display_power_control_ext = if (extensions.ext_display_control) @ptrCast(try instance.get_device_proc_addr(device, "vkDisplayPowerControlEXT")) else null,
            .fp_register_device_event_ext = if (extensions.ext_display_control) @ptrCast(try instance.get_device_proc_addr(device, "vkRegisterDeviceEventEXT")) else null,
            .fp_register_display_event_ext = if (extensions.ext_display_control) @ptrCast(try instance.get_device_proc_addr(device, "vkRegisterDisplayEventEXT")) else null,
            .fp_get_swapchain_counter_ext = if (extensions.ext_display_control) @ptrCast(try instance.get_device_proc_addr(device, "vkGetSwapchainCounterEXT")) else null,
            .fp_get_device_group_peer_memory_features = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceGroupPeerMemoryFeatures")) else if (extensions.khr_device_group) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceGroupPeerMemoryFeaturesKHR")) else null,
            .fp_bind_buffer_memory2 = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkBindBufferMemory2")) else if (extensions.khr_bind_memory2) @ptrCast(try instance.get_device_proc_addr(device, "vkBindBufferMemory2KHR")) else null,
            .fp_bind_image_memory2 = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkBindImageMemory2")) else if (extensions.khr_bind_memory2) @ptrCast(try instance.get_device_proc_addr(device, "vkBindImageMemory2KHR")) else null,
            .fp_cmd_set_device_mask = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDeviceMask")) else if (extensions.khr_device_group) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDeviceMaskKHR")) else null,
            .fp_get_device_group_present_capabilities_khr = if ((extensions.khr_swapchain and extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) or (extensions.khr_device_group and instance.extensions.khr_surface)) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceGroupPresentCapabilitiesKHR")) else null,
            .fp_get_device_group_surface_present_modes_khr = if ((extensions.khr_swapchain and extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) or (extensions.khr_device_group and instance.extensions.khr_surface)) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceGroupSurfacePresentModesKHR")) else null,
            .fp_acquire_next_image2_khr = if ((extensions.khr_swapchain and extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) or (extensions.khr_device_group and extensions.khr_swapchain)) @ptrCast(try instance.get_device_proc_addr(device, "vkAcquireNextImage2KHR")) else null,
            .fp_cmd_dispatch_base = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDispatchBase")) else if (extensions.khr_device_group) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDispatchBaseKHR")) else null,
            .fp_get_physical_device_present_rectangles_khr = if ((extensions.khr_swapchain and extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) or (extensions.khr_device_group and instance.extensions.khr_surface)) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDevicePresentRectanglesKHR")) else null,
            .fp_create_descriptor_update_template = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateDescriptorUpdateTemplate")) else if (extensions.khr_descriptor_update_template) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateDescriptorUpdateTemplateKHR")) else null,
            .fp_destroy_descriptor_update_template = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyDescriptorUpdateTemplate")) else if (extensions.khr_descriptor_update_template) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyDescriptorUpdateTemplateKHR")) else null,
            .fp_update_descriptor_set_with_template = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkUpdateDescriptorSetWithTemplate")) else if (extensions.khr_descriptor_update_template) @ptrCast(try instance.get_device_proc_addr(device, "vkUpdateDescriptorSetWithTemplateKHR")) else null,
            .fp_cmd_push_descriptor_set_with_template = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPushDescriptorSetWithTemplate")) else if ((extensions.khr_push_descriptor and (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int() or extensions.khr_descriptor_update_template)) or (extensions.khr_descriptor_update_template and extensions.khr_push_descriptor)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPushDescriptorSetWithTemplateKHR")) else null,
            .fp_set_hdr_metadata_ext = if (extensions.ext_hdr_metadata) @ptrCast(try instance.get_device_proc_addr(device, "vkSetHdrMetadataEXT")) else null,
            .fp_get_swapchain_status_khr = if (extensions.khr_shared_presentable_image) @ptrCast(try instance.get_device_proc_addr(device, "vkGetSwapchainStatusKHR")) else null,
            .fp_get_refresh_cycle_duration_google = if (extensions.google_display_timing) @ptrCast(try instance.get_device_proc_addr(device, "vkGetRefreshCycleDurationGOOGLE")) else null,
            .fp_get_past_presentation_timing_google = if (extensions.google_display_timing) @ptrCast(try instance.get_device_proc_addr(device, "vkGetPastPresentationTimingGOOGLE")) else null,
            .fp_cmd_set_viewport_w_scaling_nv = if (extensions.nv_clip_space_w_scaling) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetViewportWScalingNV")) else null,
            .fp_cmd_set_discard_rectangle_ext = if (extensions.ext_discard_rectangles) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDiscardRectangleEXT")) else null,
            .fp_cmd_set_discard_rectangle_enable_ext = if (extensions.ext_discard_rectangles) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDiscardRectangleEnableEXT")) else null,
            .fp_cmd_set_discard_rectangle_mode_ext = if (extensions.ext_discard_rectangles) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDiscardRectangleModeEXT")) else null,
            .fp_cmd_set_sample_locations_ext = if (extensions.ext_sample_locations) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetSampleLocationsEXT")) else null,
            .fp_get_physical_device_multisample_properties_ext = if (extensions.ext_sample_locations) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceMultisamplePropertiesEXT")) else null,
            .fp_get_buffer_memory_requirements2 = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetBufferMemoryRequirements2")) else if (extensions.khr_get_memory_requirements2) @ptrCast(try instance.get_device_proc_addr(device, "vkGetBufferMemoryRequirements2KHR")) else null,
            .fp_get_image_memory_requirements2 = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageMemoryRequirements2")) else if (extensions.khr_get_memory_requirements2) @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageMemoryRequirements2KHR")) else null,
            .fp_get_image_sparse_memory_requirements2 = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageSparseMemoryRequirements2")) else if (extensions.khr_get_memory_requirements2) @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageSparseMemoryRequirements2KHR")) else null,
            .fp_get_device_buffer_memory_requirements = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceBufferMemoryRequirements")) else if (extensions.khr_maintenance4) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceBufferMemoryRequirementsKHR")) else null,
            .fp_get_device_image_memory_requirements = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceImageMemoryRequirements")) else if (extensions.khr_maintenance4) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceImageMemoryRequirementsKHR")) else null,
            .fp_get_device_image_sparse_memory_requirements = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceImageSparseMemoryRequirements")) else if (extensions.khr_maintenance4) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceImageSparseMemoryRequirementsKHR")) else null,
            .fp_create_sampler_ycbcr_conversion = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateSamplerYcbcrConversion")) else if (extensions.khr_sampler_ycbcr_conversion) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateSamplerYcbcrConversionKHR")) else null,
            .fp_destroy_sampler_ycbcr_conversion = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroySamplerYcbcrConversion")) else if (extensions.khr_sampler_ycbcr_conversion) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroySamplerYcbcrConversionKHR")) else null,
            .fp_get_device_queue2 = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceQueue2")) else null,
            .fp_create_validation_cache_ext = if (extensions.ext_validation_cache) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateValidationCacheEXT")) else null,
            .fp_destroy_validation_cache_ext = if (extensions.ext_validation_cache) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyValidationCacheEXT")) else null,
            .fp_get_validation_cache_data_ext = if (extensions.ext_validation_cache) @ptrCast(try instance.get_device_proc_addr(device, "vkGetValidationCacheDataEXT")) else null,
            .fp_merge_validation_caches_ext = if (extensions.ext_validation_cache) @ptrCast(try instance.get_device_proc_addr(device, "vkMergeValidationCachesEXT")) else null,
            .fp_get_descriptor_set_layout_support = if (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDescriptorSetLayoutSupport")) else if (extensions.khr_maintenance3) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDescriptorSetLayoutSupportKHR")) else null,
            .fp_get_shader_info_amd = if (extensions.amd_shader_info) @ptrCast(try instance.get_device_proc_addr(device, "vkGetShaderInfoAMD")) else null,
            .fp_set_local_dimming_amd = if (extensions.amd_display_native_hdr) @ptrCast(try instance.get_device_proc_addr(device, "vkSetLocalDimmingAMD")) else null,
            .fp_get_physical_device_calibrateable_time_domains_khr = if (extensions.khr_calibrated_timestamps) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR")) else if (extensions.ext_calibrated_timestamps) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT")) else null,
            .fp_get_calibrated_timestamps_khr = if (extensions.khr_calibrated_timestamps) @ptrCast(try instance.get_device_proc_addr(device, "vkGetCalibratedTimestampsKHR")) else if (extensions.ext_calibrated_timestamps) @ptrCast(try instance.get_device_proc_addr(device, "vkGetCalibratedTimestampsEXT")) else null,
            .fp_get_memory_host_pointer_properties_ext = if (extensions.ext_external_memory_host) @ptrCast(try instance.get_device_proc_addr(device, "vkGetMemoryHostPointerPropertiesEXT")) else null,
            .fp_cmd_write_buffer_marker_amd = if (extensions.amd_buffer_marker) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdWriteBufferMarkerAMD")) else null,
            .fp_create_render_pass2 = if (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateRenderPass2")) else if (extensions.khr_create_renderpass2) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateRenderPass2KHR")) else null,
            .fp_cmd_begin_render_pass2 = if (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBeginRenderPass2")) else if (extensions.khr_create_renderpass2) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBeginRenderPass2KHR")) else null,
            .fp_cmd_next_subpass2 = if (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdNextSubpass2")) else if (extensions.khr_create_renderpass2) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdNextSubpass2KHR")) else null,
            .fp_cmd_end_render_pass2 = if (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdEndRenderPass2")) else if (extensions.khr_create_renderpass2) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdEndRenderPass2KHR")) else null,
            .fp_get_semaphore_counter_value = if (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetSemaphoreCounterValue")) else if (extensions.khr_timeline_semaphore) @ptrCast(try instance.get_device_proc_addr(device, "vkGetSemaphoreCounterValueKHR")) else null,
            .fp_wait_semaphores = if (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkWaitSemaphores")) else if (extensions.khr_timeline_semaphore) @ptrCast(try instance.get_device_proc_addr(device, "vkWaitSemaphoresKHR")) else null,
            .fp_signal_semaphore = if (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkSignalSemaphore")) else if (extensions.khr_timeline_semaphore) @ptrCast(try instance.get_device_proc_addr(device, "vkSignalSemaphoreKHR")) else null,
            .fp_get_android_hardware_buffer_properties_android = if (extensions.android_external_memory_android_hardware_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkGetAndroidHardwareBufferPropertiesANDROID")) else null,
            .fp_get_memory_android_hardware_buffer_android = if (extensions.android_external_memory_android_hardware_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkGetMemoryAndroidHardwareBufferANDROID")) else null,
            .fp_cmd_draw_indirect_count = if (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawIndirectCount")) else if (extensions.khr_draw_indirect_count) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawIndirectCountKHR")) else if (extensions.amd_draw_indirect_count) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawIndirectCountAMD")) else null,
            .fp_cmd_draw_indexed_indirect_count = if (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawIndexedIndirectCount")) else if (extensions.khr_draw_indirect_count) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawIndexedIndirectCountKHR")) else if (extensions.amd_draw_indirect_count) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawIndexedIndirectCountAMD")) else null,
            .fp_cmd_set_checkpoint_nv = if (extensions.nv_device_diagnostic_checkpoints) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetCheckpointNV")) else null,
            .fp_get_queue_checkpoint_data_nv = if (extensions.nv_device_diagnostic_checkpoints) @ptrCast(try instance.get_device_proc_addr(device, "vkGetQueueCheckpointDataNV")) else null,
            .fp_cmd_bind_transform_feedback_buffers_ext = if (extensions.ext_transform_feedback) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindTransformFeedbackBuffersEXT")) else null,
            .fp_cmd_begin_transform_feedback_ext = if (extensions.ext_transform_feedback) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBeginTransformFeedbackEXT")) else null,
            .fp_cmd_end_transform_feedback_ext = if (extensions.ext_transform_feedback) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdEndTransformFeedbackEXT")) else null,
            .fp_cmd_begin_query_indexed_ext = if (extensions.ext_transform_feedback) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBeginQueryIndexedEXT")) else null,
            .fp_cmd_end_query_indexed_ext = if (extensions.ext_transform_feedback) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdEndQueryIndexedEXT")) else null,
            .fp_cmd_draw_indirect_byte_count_ext = if (extensions.ext_transform_feedback) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawIndirectByteCountEXT")) else null,
            .fp_cmd_set_exclusive_scissor_nv = if (extensions.nv_scissor_exclusive) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetExclusiveScissorNV")) else null,
            .fp_cmd_set_exclusive_scissor_enable_nv = if (extensions.nv_scissor_exclusive) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetExclusiveScissorEnableNV")) else null,
            .fp_cmd_bind_shading_rate_image_nv = if (extensions.nv_shading_rate_image) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindShadingRateImageNV")) else null,
            .fp_cmd_set_viewport_shading_rate_palette_nv = if (extensions.nv_shading_rate_image) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetViewportShadingRatePaletteNV")) else null,
            .fp_cmd_set_coarse_sample_order_nv = if (extensions.nv_shading_rate_image) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetCoarseSampleOrderNV")) else null,
            .fp_cmd_draw_mesh_tasks_nv = if (extensions.nv_mesh_shader) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawMeshTasksNV")) else null,
            .fp_cmd_draw_mesh_tasks_indirect_nv = if (extensions.nv_mesh_shader) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawMeshTasksIndirectNV")) else null,
            .fp_cmd_draw_mesh_tasks_indirect_count_nv = if (extensions.nv_mesh_shader and (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int() or extensions.khr_draw_indirect_count or extensions.amd_draw_indirect_count)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawMeshTasksIndirectCountNV")) else null,
            .fp_cmd_draw_mesh_tasks_ext = if (extensions.ext_mesh_shader) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawMeshTasksEXT")) else null,
            .fp_cmd_draw_mesh_tasks_indirect_ext = if (extensions.ext_mesh_shader) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawMeshTasksIndirectEXT")) else null,
            .fp_cmd_draw_mesh_tasks_indirect_count_ext = if (extensions.ext_mesh_shader and (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int() or extensions.khr_draw_indirect_count or extensions.amd_draw_indirect_count)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDrawMeshTasksIndirectCountEXT")) else null,
            .fp_compile_deferred_nv = if (extensions.nv_ray_tracing) @ptrCast(try instance.get_device_proc_addr(device, "vkCompileDeferredNV")) else null,
            .fp_create_acceleration_structure_nv = if (extensions.nv_ray_tracing) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateAccelerationStructureNV")) else null,
            .fp_cmd_bind_invocation_mask_huawei = if (extensions.huawei_invocation_mask) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindInvocationMaskHUAWEI")) else null,
            .fp_destroy_acceleration_structure_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyAccelerationStructureKHR")) else null,
            .fp_destroy_acceleration_structure_nv = if (extensions.nv_ray_tracing) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyAccelerationStructureNV")) else null,
            .fp_get_acceleration_structure_memory_requirements_nv = if (extensions.nv_ray_tracing) @ptrCast(try instance.get_device_proc_addr(device, "vkGetAccelerationStructureMemoryRequirementsNV")) else null,
            .fp_bind_acceleration_structure_memory_nv = if (extensions.nv_ray_tracing) @ptrCast(try instance.get_device_proc_addr(device, "vkBindAccelerationStructureMemoryNV")) else null,
            .fp_cmd_copy_acceleration_structure_nv = if (extensions.nv_ray_tracing) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyAccelerationStructureNV")) else null,
            .fp_cmd_copy_acceleration_structure_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyAccelerationStructureKHR")) else null,
            .fp_copy_acceleration_structure_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkCopyAccelerationStructureKHR")) else null,
            .fp_cmd_copy_acceleration_structure_to_memory_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyAccelerationStructureToMemoryKHR")) else null,
            .fp_copy_acceleration_structure_to_memory_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkCopyAccelerationStructureToMemoryKHR")) else null,
            .fp_cmd_copy_memory_to_acceleration_structure_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyMemoryToAccelerationStructureKHR")) else null,
            .fp_copy_memory_to_acceleration_structure_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkCopyMemoryToAccelerationStructureKHR")) else null,
            .fp_cmd_write_acceleration_structures_properties_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdWriteAccelerationStructuresPropertiesKHR")) else null,
            .fp_cmd_write_acceleration_structures_properties_nv = if (extensions.nv_ray_tracing) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdWriteAccelerationStructuresPropertiesNV")) else null,
            .fp_cmd_build_acceleration_structure_nv = if (extensions.nv_ray_tracing) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBuildAccelerationStructureNV")) else null,
            .fp_write_acceleration_structures_properties_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkWriteAccelerationStructuresPropertiesKHR")) else null,
            .fp_cmd_trace_rays_khr = if (extensions.khr_ray_tracing_pipeline) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdTraceRaysKHR")) else null,
            .fp_cmd_trace_rays_nv = if (extensions.nv_ray_tracing) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdTraceRaysNV")) else null,
            .fp_get_ray_tracing_shader_group_handles_khr = if (extensions.khr_ray_tracing_pipeline) @ptrCast(try instance.get_device_proc_addr(device, "vkGetRayTracingShaderGroupHandlesKHR")) else if (extensions.nv_ray_tracing) @ptrCast(try instance.get_device_proc_addr(device, "vkGetRayTracingShaderGroupHandlesNV")) else null,
            .fp_get_ray_tracing_capture_replay_shader_group_handles_khr = if (extensions.khr_ray_tracing_pipeline) @ptrCast(try instance.get_device_proc_addr(device, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR")) else null,
            .fp_get_acceleration_structure_handle_nv = if (extensions.nv_ray_tracing) @ptrCast(try instance.get_device_proc_addr(device, "vkGetAccelerationStructureHandleNV")) else null,
            .fp_create_ray_tracing_pipelines_nv = if (extensions.nv_ray_tracing) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateRayTracingPipelinesNV")) else null,
            .fp_create_ray_tracing_pipelines_khr = if (extensions.khr_ray_tracing_pipeline) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateRayTracingPipelinesKHR")) else null,
            .fp_get_physical_device_cooperative_matrix_properties_nv = if (extensions.nv_cooperative_matrix) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV")) else null,
            .fp_cmd_trace_rays_indirect_khr = if (extensions.khr_ray_tracing_pipeline) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdTraceRaysIndirectKHR")) else null,
            .fp_cmd_trace_rays_indirect2_khr = if (extensions.khr_ray_tracing_maintenance1 and extensions.khr_ray_tracing_pipeline) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdTraceRaysIndirect2KHR")) else null,
            .fp_get_cluster_acceleration_structure_build_sizes_nv = if (extensions.nv_cluster_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkGetClusterAccelerationStructureBuildSizesNV")) else null,
            .fp_cmd_build_cluster_acceleration_structure_indirect_nv = if (extensions.nv_cluster_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBuildClusterAccelerationStructureIndirectNV")) else null,
            .fp_get_device_acceleration_structure_compatibility_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceAccelerationStructureCompatibilityKHR")) else null,
            .fp_get_ray_tracing_shader_group_stack_size_khr = if (extensions.khr_ray_tracing_pipeline) @ptrCast(try instance.get_device_proc_addr(device, "vkGetRayTracingShaderGroupStackSizeKHR")) else null,
            .fp_cmd_set_ray_tracing_pipeline_stack_size_khr = if (extensions.khr_ray_tracing_pipeline) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetRayTracingPipelineStackSizeKHR")) else null,
            .fp_get_image_view_handle_nvx = if (extensions.nvx_image_view_handle) @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageViewHandleNVX")) else null,
            .fp_get_image_view_handle64_nvx = if (extensions.nvx_image_view_handle) @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageViewHandle64NVX")) else null,
            .fp_get_image_view_address_nvx = if (extensions.nvx_image_view_handle) @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageViewAddressNVX")) else null,
            .fp_get_physical_device_surface_present_modes2_ext = if (extensions.ext_full_screen_exclusive) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceSurfacePresentModes2EXT")) else null,
            .fp_get_device_group_surface_present_modes2_ext = if (extensions.ext_full_screen_exclusive and (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int() or extensions.khr_device_group)) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceGroupSurfacePresentModes2EXT")) else null,
            .fp_acquire_full_screen_exclusive_mode_ext = if (extensions.ext_full_screen_exclusive) @ptrCast(try instance.get_device_proc_addr(device, "vkAcquireFullScreenExclusiveModeEXT")) else null,
            .fp_release_full_screen_exclusive_mode_ext = if (extensions.ext_full_screen_exclusive) @ptrCast(try instance.get_device_proc_addr(device, "vkReleaseFullScreenExclusiveModeEXT")) else null,
            .fp_enumerate_physical_device_queue_family_performance_query_counters_khr = if (extensions.khr_performance_query) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR")) else null,
            .fp_get_physical_device_queue_family_performance_query_passes_khr = if (extensions.khr_performance_query) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR")) else null,
            .fp_acquire_profiling_lock_khr = if (extensions.khr_performance_query) @ptrCast(try instance.get_device_proc_addr(device, "vkAcquireProfilingLockKHR")) else null,
            .fp_release_profiling_lock_khr = if (extensions.khr_performance_query) @ptrCast(try instance.get_device_proc_addr(device, "vkReleaseProfilingLockKHR")) else null,
            .fp_get_image_drm_format_modifier_properties_ext = if (extensions.ext_image_drm_format_modifier) @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageDrmFormatModifierPropertiesEXT")) else null,
            .fp_get_buffer_opaque_capture_address = if (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetBufferOpaqueCaptureAddress")) else if (extensions.khr_buffer_device_address) @ptrCast(try instance.get_device_proc_addr(device, "vkGetBufferOpaqueCaptureAddressKHR")) else null,
            .fp_get_buffer_device_address = if (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetBufferDeviceAddress")) else if (extensions.khr_buffer_device_address) @ptrCast(try instance.get_device_proc_addr(device, "vkGetBufferDeviceAddressKHR")) else if (extensions.ext_buffer_device_address) @ptrCast(try instance.get_device_proc_addr(device, "vkGetBufferDeviceAddressEXT")) else null,
            .fp_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv = if (extensions.nv_coverage_reduction_mode) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV")) else null,
            .fp_initialize_performance_api_intel = if (extensions.intel_performance_query) @ptrCast(try instance.get_device_proc_addr(device, "vkInitializePerformanceApiINTEL")) else null,
            .fp_uninitialize_performance_api_intel = if (extensions.intel_performance_query) @ptrCast(try instance.get_device_proc_addr(device, "vkUninitializePerformanceApiINTEL")) else null,
            .fp_cmd_set_performance_marker_intel = if (extensions.intel_performance_query) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetPerformanceMarkerINTEL")) else null,
            .fp_cmd_set_performance_stream_marker_intel = if (extensions.intel_performance_query) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetPerformanceStreamMarkerINTEL")) else null,
            .fp_cmd_set_performance_override_intel = if (extensions.intel_performance_query) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetPerformanceOverrideINTEL")) else null,
            .fp_acquire_performance_configuration_intel = if (extensions.intel_performance_query) @ptrCast(try instance.get_device_proc_addr(device, "vkAcquirePerformanceConfigurationINTEL")) else null,
            .fp_release_performance_configuration_intel = if (extensions.intel_performance_query) @ptrCast(try instance.get_device_proc_addr(device, "vkReleasePerformanceConfigurationINTEL")) else null,
            .fp_queue_set_performance_configuration_intel = if (extensions.intel_performance_query) @ptrCast(try instance.get_device_proc_addr(device, "vkQueueSetPerformanceConfigurationINTEL")) else null,
            .fp_get_performance_parameter_intel = if (extensions.intel_performance_query) @ptrCast(try instance.get_device_proc_addr(device, "vkGetPerformanceParameterINTEL")) else null,
            .fp_get_device_memory_opaque_capture_address = if (extensions.core_version.to_int() >= make_version(1, 2, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceMemoryOpaqueCaptureAddress")) else if (extensions.khr_buffer_device_address) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceMemoryOpaqueCaptureAddressKHR")) else null,
            .fp_get_pipeline_executable_properties_khr = if (extensions.khr_pipeline_executable_properties) @ptrCast(try instance.get_device_proc_addr(device, "vkGetPipelineExecutablePropertiesKHR")) else null,
            .fp_get_pipeline_executable_statistics_khr = if (extensions.khr_pipeline_executable_properties) @ptrCast(try instance.get_device_proc_addr(device, "vkGetPipelineExecutableStatisticsKHR")) else null,
            .fp_get_pipeline_executable_internal_representations_khr = if (extensions.khr_pipeline_executable_properties) @ptrCast(try instance.get_device_proc_addr(device, "vkGetPipelineExecutableInternalRepresentationsKHR")) else null,
            .fp_cmd_set_line_stipple = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetLineStipple")) else if (extensions.khr_line_rasterization) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetLineStippleKHR")) else if (extensions.ext_line_rasterization) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetLineStippleEXT")) else null,
            .fp_get_physical_device_tool_properties = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceToolProperties")) else if (extensions.ext_tooling_info) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceToolPropertiesEXT")) else null,
            .fp_create_acceleration_structure_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateAccelerationStructureKHR")) else null,
            .fp_cmd_build_acceleration_structures_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBuildAccelerationStructuresKHR")) else null,
            .fp_cmd_build_acceleration_structures_indirect_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBuildAccelerationStructuresIndirectKHR")) else null,
            .fp_build_acceleration_structures_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkBuildAccelerationStructuresKHR")) else null,
            .fp_get_acceleration_structure_device_address_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkGetAccelerationStructureDeviceAddressKHR")) else null,
            .fp_create_deferred_operation_khr = if (extensions.khr_deferred_host_operations) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateDeferredOperationKHR")) else null,
            .fp_destroy_deferred_operation_khr = if (extensions.khr_deferred_host_operations) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyDeferredOperationKHR")) else null,
            .fp_get_deferred_operation_max_concurrency_khr = if (extensions.khr_deferred_host_operations) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeferredOperationMaxConcurrencyKHR")) else null,
            .fp_get_deferred_operation_result_khr = if (extensions.khr_deferred_host_operations) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeferredOperationResultKHR")) else null,
            .fp_deferred_operation_join_khr = if (extensions.khr_deferred_host_operations) @ptrCast(try instance.get_device_proc_addr(device, "vkDeferredOperationJoinKHR")) else null,
            .fp_get_pipeline_indirect_memory_requirements_nv = if (extensions.nv_device_generated_commands_compute) @ptrCast(try instance.get_device_proc_addr(device, "vkGetPipelineIndirectMemoryRequirementsNV")) else null,
            .fp_get_pipeline_indirect_device_address_nv = if (extensions.nv_device_generated_commands_compute) @ptrCast(try instance.get_device_proc_addr(device, "vkGetPipelineIndirectDeviceAddressNV")) else null,
            .fp_anti_lag_update_amd = if (extensions.amd_anti_lag) @ptrCast(try instance.get_device_proc_addr(device, "vkAntiLagUpdateAMD")) else null,
            .fp_cmd_set_cull_mode = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetCullMode")) else if (extensions.ext_extended_dynamic_state or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetCullModeEXT")) else null,
            .fp_cmd_set_front_face = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetFrontFace")) else if (extensions.ext_extended_dynamic_state or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetFrontFaceEXT")) else null,
            .fp_cmd_set_primitive_topology = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetPrimitiveTopology")) else if (extensions.ext_extended_dynamic_state or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetPrimitiveTopologyEXT")) else null,
            .fp_cmd_set_viewport_with_count = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetViewportWithCount")) else if (extensions.ext_extended_dynamic_state or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetViewportWithCountEXT")) else null,
            .fp_cmd_set_scissor_with_count = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetScissorWithCount")) else if (extensions.ext_extended_dynamic_state or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetScissorWithCountEXT")) else null,
            .fp_cmd_bind_index_buffer2 = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindIndexBuffer2")) else if (extensions.khr_maintenance5) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindIndexBuffer2KHR")) else null,
            .fp_cmd_bind_vertex_buffers2 = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindVertexBuffers2")) else if (extensions.ext_extended_dynamic_state or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindVertexBuffers2EXT")) else null,
            .fp_cmd_set_depth_test_enable = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthTestEnable")) else if (extensions.ext_extended_dynamic_state or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthTestEnableEXT")) else null,
            .fp_cmd_set_depth_write_enable = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthWriteEnable")) else if (extensions.ext_extended_dynamic_state or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthWriteEnableEXT")) else null,
            .fp_cmd_set_depth_compare_op = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthCompareOp")) else if (extensions.ext_extended_dynamic_state or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthCompareOpEXT")) else null,
            .fp_cmd_set_depth_bounds_test_enable = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthBoundsTestEnable")) else if (extensions.ext_extended_dynamic_state or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthBoundsTestEnableEXT")) else null,
            .fp_cmd_set_stencil_test_enable = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetStencilTestEnable")) else if (extensions.ext_extended_dynamic_state or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetStencilTestEnableEXT")) else null,
            .fp_cmd_set_stencil_op = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetStencilOp")) else if (extensions.ext_extended_dynamic_state or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetStencilOpEXT")) else null,
            .fp_cmd_set_patch_control_points_ext = if (extensions.ext_extended_dynamic_state2 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetPatchControlPointsEXT")) else null,
            .fp_cmd_set_rasterizer_discard_enable = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetRasterizerDiscardEnable")) else if (extensions.ext_extended_dynamic_state2 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetRasterizerDiscardEnableEXT")) else null,
            .fp_cmd_set_depth_bias_enable = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthBiasEnable")) else if (extensions.ext_extended_dynamic_state2 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthBiasEnableEXT")) else null,
            .fp_cmd_set_logic_op_ext = if (extensions.ext_extended_dynamic_state2 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetLogicOpEXT")) else null,
            .fp_cmd_set_primitive_restart_enable = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetPrimitiveRestartEnable")) else if (extensions.ext_extended_dynamic_state2 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetPrimitiveRestartEnableEXT")) else null,
            .fp_cmd_set_tessellation_domain_origin_ext = if ((extensions.ext_extended_dynamic_state3 and (extensions.core_version.to_int() >= make_version(1, 1, 0).to_int() or extensions.khr_maintenance2)) or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetTessellationDomainOriginEXT")) else null,
            .fp_cmd_set_depth_clamp_enable_ext = if (extensions.ext_extended_dynamic_state3 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthClampEnableEXT")) else null,
            .fp_cmd_set_polygon_mode_ext = if (extensions.ext_extended_dynamic_state3 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetPolygonModeEXT")) else null,
            .fp_cmd_set_rasterization_samples_ext = if (extensions.ext_extended_dynamic_state3 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetRasterizationSamplesEXT")) else null,
            .fp_cmd_set_sample_mask_ext = if (extensions.ext_extended_dynamic_state3 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetSampleMaskEXT")) else null,
            .fp_cmd_set_alpha_to_coverage_enable_ext = if (extensions.ext_extended_dynamic_state3 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetAlphaToCoverageEnableEXT")) else null,
            .fp_cmd_set_alpha_to_one_enable_ext = if (extensions.ext_extended_dynamic_state3 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetAlphaToOneEnableEXT")) else null,
            .fp_cmd_set_logic_op_enable_ext = if (extensions.ext_extended_dynamic_state3 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetLogicOpEnableEXT")) else null,
            .fp_cmd_set_color_blend_enable_ext = if (extensions.ext_extended_dynamic_state3 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetColorBlendEnableEXT")) else null,
            .fp_cmd_set_color_blend_equation_ext = if (extensions.ext_extended_dynamic_state3 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetColorBlendEquationEXT")) else null,
            .fp_cmd_set_color_write_mask_ext = if (extensions.ext_extended_dynamic_state3 or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetColorWriteMaskEXT")) else null,
            .fp_cmd_set_rasterization_stream_ext = if ((extensions.ext_extended_dynamic_state3 and extensions.ext_transform_feedback) or (extensions.ext_shader_object and extensions.ext_transform_feedback)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetRasterizationStreamEXT")) else null,
            .fp_cmd_set_conservative_rasterization_mode_ext = if ((extensions.ext_extended_dynamic_state3 and extensions.ext_conservative_rasterization) or (extensions.ext_shader_object and extensions.ext_conservative_rasterization)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetConservativeRasterizationModeEXT")) else null,
            .fp_cmd_set_extra_primitive_overestimation_size_ext = if ((extensions.ext_extended_dynamic_state3 and extensions.ext_conservative_rasterization) or (extensions.ext_shader_object and extensions.ext_conservative_rasterization)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetExtraPrimitiveOverestimationSizeEXT")) else null,
            .fp_cmd_set_depth_clip_enable_ext = if ((extensions.ext_extended_dynamic_state3 and extensions.ext_depth_clip_enable) or (extensions.ext_shader_object and extensions.ext_depth_clip_enable)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthClipEnableEXT")) else null,
            .fp_cmd_set_sample_locations_enable_ext = if ((extensions.ext_extended_dynamic_state3 and extensions.ext_sample_locations) or (extensions.ext_shader_object and extensions.ext_sample_locations)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetSampleLocationsEnableEXT")) else null,
            .fp_cmd_set_color_blend_advanced_ext = if ((extensions.ext_extended_dynamic_state3 and extensions.ext_blend_operation_advanced) or (extensions.ext_shader_object and extensions.ext_blend_operation_advanced)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetColorBlendAdvancedEXT")) else null,
            .fp_cmd_set_provoking_vertex_mode_ext = if ((extensions.ext_extended_dynamic_state3 and extensions.ext_provoking_vertex) or (extensions.ext_shader_object and extensions.ext_provoking_vertex)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetProvokingVertexModeEXT")) else null,
            .fp_cmd_set_line_rasterization_mode_ext = if ((extensions.ext_extended_dynamic_state3 and extensions.ext_line_rasterization) or (extensions.ext_shader_object and extensions.ext_line_rasterization)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetLineRasterizationModeEXT")) else null,
            .fp_cmd_set_line_stipple_enable_ext = if ((extensions.ext_extended_dynamic_state3 and extensions.ext_line_rasterization) or (extensions.ext_shader_object and extensions.ext_line_rasterization)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetLineStippleEnableEXT")) else null,
            .fp_cmd_set_depth_clip_negative_one_to_one_ext = if ((extensions.ext_extended_dynamic_state3 and extensions.ext_depth_clip_control) or (extensions.ext_shader_object and extensions.ext_depth_clip_control)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthClipNegativeOneToOneEXT")) else null,
            .fp_cmd_set_viewport_w_scaling_enable_nv = if ((extensions.ext_extended_dynamic_state3 and extensions.nv_clip_space_w_scaling) or (extensions.ext_shader_object and extensions.nv_clip_space_w_scaling)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetViewportWScalingEnableNV")) else null,
            .fp_cmd_set_viewport_swizzle_nv = if ((extensions.ext_extended_dynamic_state3 and extensions.nv_viewport_swizzle) or (extensions.ext_shader_object and extensions.nv_viewport_swizzle)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetViewportSwizzleNV")) else null,
            .fp_cmd_set_coverage_to_color_enable_nv = if ((extensions.ext_extended_dynamic_state3 and extensions.nv_fragment_coverage_to_color) or (extensions.ext_shader_object and extensions.nv_fragment_coverage_to_color)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetCoverageToColorEnableNV")) else null,
            .fp_cmd_set_coverage_to_color_location_nv = if ((extensions.ext_extended_dynamic_state3 and extensions.nv_fragment_coverage_to_color) or (extensions.ext_shader_object and extensions.nv_fragment_coverage_to_color)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetCoverageToColorLocationNV")) else null,
            .fp_cmd_set_coverage_modulation_mode_nv = if ((extensions.ext_extended_dynamic_state3 and extensions.nv_framebuffer_mixed_samples) or (extensions.ext_shader_object and extensions.nv_framebuffer_mixed_samples)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetCoverageModulationModeNV")) else null,
            .fp_cmd_set_coverage_modulation_table_enable_nv = if ((extensions.ext_extended_dynamic_state3 and extensions.nv_framebuffer_mixed_samples) or (extensions.ext_shader_object and extensions.nv_framebuffer_mixed_samples)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetCoverageModulationTableEnableNV")) else null,
            .fp_cmd_set_coverage_modulation_table_nv = if ((extensions.ext_extended_dynamic_state3 and extensions.nv_framebuffer_mixed_samples) or (extensions.ext_shader_object and extensions.nv_framebuffer_mixed_samples)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetCoverageModulationTableNV")) else null,
            .fp_cmd_set_shading_rate_image_enable_nv = if ((extensions.ext_extended_dynamic_state3 and extensions.nv_shading_rate_image) or (extensions.ext_shader_object and extensions.nv_shading_rate_image)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetShadingRateImageEnableNV")) else null,
            .fp_cmd_set_coverage_reduction_mode_nv = if ((extensions.ext_extended_dynamic_state3 and extensions.nv_coverage_reduction_mode) or (extensions.ext_shader_object and extensions.nv_coverage_reduction_mode)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetCoverageReductionModeNV")) else null,
            .fp_cmd_set_representative_fragment_test_enable_nv = if ((extensions.ext_extended_dynamic_state3 and extensions.nv_representative_fragment_test) or (extensions.ext_shader_object and extensions.nv_representative_fragment_test)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetRepresentativeFragmentTestEnableNV")) else null,
            .fp_create_private_data_slot = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCreatePrivateDataSlot")) else if (extensions.ext_private_data) @ptrCast(try instance.get_device_proc_addr(device, "vkCreatePrivateDataSlotEXT")) else null,
            .fp_destroy_private_data_slot = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyPrivateDataSlot")) else if (extensions.ext_private_data) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyPrivateDataSlotEXT")) else null,
            .fp_set_private_data = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkSetPrivateData")) else if (extensions.ext_private_data) @ptrCast(try instance.get_device_proc_addr(device, "vkSetPrivateDataEXT")) else null,
            .fp_get_private_data = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetPrivateData")) else if (extensions.ext_private_data) @ptrCast(try instance.get_device_proc_addr(device, "vkGetPrivateDataEXT")) else null,
            .fp_cmd_copy_buffer2 = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyBuffer2")) else if (extensions.khr_copy_commands2) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyBuffer2KHR")) else null,
            .fp_cmd_copy_image2 = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyImage2")) else if (extensions.khr_copy_commands2) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyImage2KHR")) else null,
            .fp_cmd_blit_image2 = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBlitImage2")) else if (extensions.khr_copy_commands2) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBlitImage2KHR")) else null,
            .fp_cmd_copy_buffer_to_image2 = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyBufferToImage2")) else if (extensions.khr_copy_commands2) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyBufferToImage2KHR")) else null,
            .fp_cmd_copy_image_to_buffer2 = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyImageToBuffer2")) else if (extensions.khr_copy_commands2) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyImageToBuffer2KHR")) else null,
            .fp_cmd_resolve_image2 = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdResolveImage2")) else if (extensions.khr_copy_commands2) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdResolveImage2KHR")) else null,
            .fp_cmd_set_fragment_shading_rate_khr = if (extensions.khr_fragment_shading_rate) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetFragmentShadingRateKHR")) else null,
            .fp_get_physical_device_fragment_shading_rates_khr = if (extensions.khr_fragment_shading_rate) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceFragmentShadingRatesKHR")) else null,
            .fp_cmd_set_fragment_shading_rate_enum_nv = if (extensions.nv_fragment_shading_rate_enums) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetFragmentShadingRateEnumNV")) else null,
            .fp_get_acceleration_structure_build_sizes_khr = if (extensions.khr_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkGetAccelerationStructureBuildSizesKHR")) else null,
            .fp_cmd_set_vertex_input_ext = if (extensions.ext_vertex_input_dynamic_state or extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetVertexInputEXT")) else null,
            .fp_cmd_set_color_write_enable_ext = if (extensions.ext_color_write_enable) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetColorWriteEnableEXT")) else null,
            .fp_cmd_set_event2 = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetEvent2")) else if (extensions.khr_synchronization2) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetEvent2KHR")) else null,
            .fp_cmd_reset_event2 = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdResetEvent2")) else if (extensions.khr_synchronization2) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdResetEvent2KHR")) else null,
            .fp_cmd_wait_events2 = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdWaitEvents2")) else if (extensions.khr_synchronization2) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdWaitEvents2KHR")) else null,
            .fp_cmd_pipeline_barrier2 = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPipelineBarrier2")) else if (extensions.khr_synchronization2) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPipelineBarrier2KHR")) else null,
            .fp_queue_submit2 = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkQueueSubmit2")) else if (extensions.khr_synchronization2) @ptrCast(try instance.get_device_proc_addr(device, "vkQueueSubmit2KHR")) else null,
            .fp_cmd_write_timestamp2 = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdWriteTimestamp2")) else if (extensions.khr_synchronization2) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdWriteTimestamp2KHR")) else null,
            .fp_cmd_write_buffer_marker2_amd = if (extensions.amd_buffer_marker and (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int() or extensions.khr_synchronization2)) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdWriteBufferMarker2AMD")) else null,
            .fp_get_queue_checkpoint_data2_nv = if (extensions.nv_device_diagnostic_checkpoints and (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int() or extensions.khr_synchronization2)) @ptrCast(try instance.get_device_proc_addr(device, "vkGetQueueCheckpointData2NV")) else null,
            .fp_copy_memory_to_image = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCopyMemoryToImage")) else if (extensions.ext_host_image_copy) @ptrCast(try instance.get_device_proc_addr(device, "vkCopyMemoryToImageEXT")) else null,
            .fp_copy_image_to_memory = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCopyImageToMemory")) else if (extensions.ext_host_image_copy) @ptrCast(try instance.get_device_proc_addr(device, "vkCopyImageToMemoryEXT")) else null,
            .fp_copy_image_to_image = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCopyImageToImage")) else if (extensions.ext_host_image_copy) @ptrCast(try instance.get_device_proc_addr(device, "vkCopyImageToImageEXT")) else null,
            .fp_transition_image_layout = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkTransitionImageLayout")) else if (extensions.ext_host_image_copy) @ptrCast(try instance.get_device_proc_addr(device, "vkTransitionImageLayoutEXT")) else null,
            .fp_cmd_decompress_memory_nv = if (extensions.nv_memory_decompression) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDecompressMemoryNV")) else null,
            .fp_cmd_decompress_memory_indirect_count_nv = if (extensions.nv_memory_decompression) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDecompressMemoryIndirectCountNV")) else null,
            .fp_get_partitioned_acceleration_structures_build_sizes_nv = if (extensions.nv_partitioned_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkGetPartitionedAccelerationStructuresBuildSizesNV")) else null,
            .fp_cmd_build_partitioned_acceleration_structures_nv = if (extensions.nv_partitioned_acceleration_structure) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBuildPartitionedAccelerationStructuresNV")) else null,
            .fp_create_cu_module_nvx = if (extensions.nvx_binary_import) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateCuModuleNVX")) else null,
            .fp_create_cu_function_nvx = if (extensions.nvx_binary_import) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateCuFunctionNVX")) else null,
            .fp_destroy_cu_module_nvx = if (extensions.nvx_binary_import) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyCuModuleNVX")) else null,
            .fp_destroy_cu_function_nvx = if (extensions.nvx_binary_import) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyCuFunctionNVX")) else null,
            .fp_cmd_cu_launch_kernel_nvx = if (extensions.nvx_binary_import) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCuLaunchKernelNVX")) else null,
            .fp_get_descriptor_set_layout_size_ext = if (extensions.ext_descriptor_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDescriptorSetLayoutSizeEXT")) else null,
            .fp_get_descriptor_set_layout_binding_offset_ext = if (extensions.ext_descriptor_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDescriptorSetLayoutBindingOffsetEXT")) else null,
            .fp_get_descriptor_ext = if (extensions.ext_descriptor_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDescriptorEXT")) else null,
            .fp_cmd_bind_descriptor_buffers_ext = if (extensions.ext_descriptor_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindDescriptorBuffersEXT")) else null,
            .fp_cmd_set_descriptor_buffer_offsets_ext = if (extensions.ext_descriptor_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDescriptorBufferOffsetsEXT")) else null,
            .fp_cmd_bind_descriptor_buffer_embedded_samplers_ext = if (extensions.ext_descriptor_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindDescriptorBufferEmbeddedSamplersEXT")) else null,
            .fp_get_buffer_opaque_capture_descriptor_data_ext = if (extensions.ext_descriptor_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkGetBufferOpaqueCaptureDescriptorDataEXT")) else null,
            .fp_get_image_opaque_capture_descriptor_data_ext = if (extensions.ext_descriptor_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageOpaqueCaptureDescriptorDataEXT")) else null,
            .fp_get_image_view_opaque_capture_descriptor_data_ext = if (extensions.ext_descriptor_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageViewOpaqueCaptureDescriptorDataEXT")) else null,
            .fp_get_sampler_opaque_capture_descriptor_data_ext = if (extensions.ext_descriptor_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkGetSamplerOpaqueCaptureDescriptorDataEXT")) else null,
            .fp_get_acceleration_structure_opaque_capture_descriptor_data_ext = if (extensions.ext_descriptor_buffer and (extensions.khr_acceleration_structure or extensions.nv_ray_tracing)) @ptrCast(try instance.get_device_proc_addr(device, "vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT")) else null,
            .fp_set_device_memory_priority_ext = if (extensions.ext_pageable_device_local_memory) @ptrCast(try instance.get_device_proc_addr(device, "vkSetDeviceMemoryPriorityEXT")) else null,
            .fp_wait_for_present2_khr = if (extensions.khr_present_wait2) @ptrCast(try instance.get_device_proc_addr(device, "vkWaitForPresent2KHR")) else null,
            .fp_wait_for_present_khr = if (extensions.khr_present_wait) @ptrCast(try instance.get_device_proc_addr(device, "vkWaitForPresentKHR")) else null,
            .fp_create_buffer_collection_fuchsia = if (extensions.fuchsia_buffer_collection) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateBufferCollectionFUCHSIA")) else null,
            .fp_set_buffer_collection_buffer_constraints_fuchsia = if (extensions.fuchsia_buffer_collection) @ptrCast(try instance.get_device_proc_addr(device, "vkSetBufferCollectionBufferConstraintsFUCHSIA")) else null,
            .fp_set_buffer_collection_image_constraints_fuchsia = if (extensions.fuchsia_buffer_collection) @ptrCast(try instance.get_device_proc_addr(device, "vkSetBufferCollectionImageConstraintsFUCHSIA")) else null,
            .fp_destroy_buffer_collection_fuchsia = if (extensions.fuchsia_buffer_collection) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyBufferCollectionFUCHSIA")) else null,
            .fp_get_buffer_collection_properties_fuchsia = if (extensions.fuchsia_buffer_collection) @ptrCast(try instance.get_device_proc_addr(device, "vkGetBufferCollectionPropertiesFUCHSIA")) else null,
            .fp_create_cuda_module_nv = if (extensions.nv_cuda_kernel_launch) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateCudaModuleNV")) else null,
            .fp_get_cuda_module_cache_nv = if (extensions.nv_cuda_kernel_launch) @ptrCast(try instance.get_device_proc_addr(device, "vkGetCudaModuleCacheNV")) else null,
            .fp_create_cuda_function_nv = if (extensions.nv_cuda_kernel_launch) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateCudaFunctionNV")) else null,
            .fp_destroy_cuda_module_nv = if (extensions.nv_cuda_kernel_launch) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyCudaModuleNV")) else null,
            .fp_destroy_cuda_function_nv = if (extensions.nv_cuda_kernel_launch) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyCudaFunctionNV")) else null,
            .fp_cmd_cuda_launch_kernel_nv = if (extensions.nv_cuda_kernel_launch) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCudaLaunchKernelNV")) else null,
            .fp_cmd_begin_rendering = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBeginRendering")) else if (extensions.khr_dynamic_rendering) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBeginRenderingKHR")) else null,
            .fp_cmd_end_rendering = if (extensions.core_version.to_int() >= make_version(1, 3, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdEndRendering")) else if (extensions.khr_dynamic_rendering) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdEndRenderingKHR")) else null,
            .fp_cmd_end_rendering2_ext = if (extensions.ext_fragment_density_map_offset) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdEndRendering2EXT")) else null,
            .fp_get_descriptor_set_layout_host_mapping_info_valve = if (extensions.valve_descriptor_set_host_mapping) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDescriptorSetLayoutHostMappingInfoVALVE")) else null,
            .fp_get_descriptor_set_host_mapping_valve = if (extensions.valve_descriptor_set_host_mapping) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDescriptorSetHostMappingVALVE")) else null,
            .fp_create_micromap_ext = if (extensions.ext_opacity_micromap) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateMicromapEXT")) else null,
            .fp_cmd_build_micromaps_ext = if (extensions.ext_opacity_micromap) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBuildMicromapsEXT")) else null,
            .fp_build_micromaps_ext = if (extensions.ext_opacity_micromap) @ptrCast(try instance.get_device_proc_addr(device, "vkBuildMicromapsEXT")) else null,
            .fp_destroy_micromap_ext = if (extensions.ext_opacity_micromap) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyMicromapEXT")) else null,
            .fp_cmd_copy_micromap_ext = if (extensions.ext_opacity_micromap) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyMicromapEXT")) else null,
            .fp_copy_micromap_ext = if (extensions.ext_opacity_micromap) @ptrCast(try instance.get_device_proc_addr(device, "vkCopyMicromapEXT")) else null,
            .fp_cmd_copy_micromap_to_memory_ext = if (extensions.ext_opacity_micromap) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyMicromapToMemoryEXT")) else null,
            .fp_copy_micromap_to_memory_ext = if (extensions.ext_opacity_micromap) @ptrCast(try instance.get_device_proc_addr(device, "vkCopyMicromapToMemoryEXT")) else null,
            .fp_cmd_copy_memory_to_micromap_ext = if (extensions.ext_opacity_micromap) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyMemoryToMicromapEXT")) else null,
            .fp_copy_memory_to_micromap_ext = if (extensions.ext_opacity_micromap) @ptrCast(try instance.get_device_proc_addr(device, "vkCopyMemoryToMicromapEXT")) else null,
            .fp_cmd_write_micromaps_properties_ext = if (extensions.ext_opacity_micromap) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdWriteMicromapsPropertiesEXT")) else null,
            .fp_write_micromaps_properties_ext = if (extensions.ext_opacity_micromap) @ptrCast(try instance.get_device_proc_addr(device, "vkWriteMicromapsPropertiesEXT")) else null,
            .fp_get_device_micromap_compatibility_ext = if (extensions.ext_opacity_micromap) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceMicromapCompatibilityEXT")) else null,
            .fp_get_micromap_build_sizes_ext = if (extensions.ext_opacity_micromap) @ptrCast(try instance.get_device_proc_addr(device, "vkGetMicromapBuildSizesEXT")) else null,
            .fp_get_shader_module_identifier_ext = if (extensions.ext_shader_module_identifier) @ptrCast(try instance.get_device_proc_addr(device, "vkGetShaderModuleIdentifierEXT")) else null,
            .fp_get_shader_module_create_info_identifier_ext = if (extensions.ext_shader_module_identifier) @ptrCast(try instance.get_device_proc_addr(device, "vkGetShaderModuleCreateInfoIdentifierEXT")) else null,
            .fp_get_image_subresource_layout2 = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageSubresourceLayout2")) else if (extensions.khr_maintenance5) @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageSubresourceLayout2KHR")) else if (extensions.ext_host_image_copy or extensions.ext_image_compression_control) @ptrCast(try instance.get_device_proc_addr(device, "vkGetImageSubresourceLayout2EXT")) else null,
            .fp_get_pipeline_properties_ext = if (extensions.ext_pipeline_properties) @ptrCast(try instance.get_device_proc_addr(device, "vkGetPipelinePropertiesEXT")) else null,
            .fp_export_metal_objects_ext = if (extensions.ext_metal_objects) @ptrCast(try instance.get_device_proc_addr(device, "vkExportMetalObjectsEXT")) else null,
            .fp_cmd_bind_tile_memory_qcom = if (extensions.qcom_tile_memory_heap) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindTileMemoryQCOM")) else null,
            .fp_get_framebuffer_tile_properties_qcom = if (extensions.qcom_tile_properties) @ptrCast(try instance.get_device_proc_addr(device, "vkGetFramebufferTilePropertiesQCOM")) else null,
            .fp_get_dynamic_rendering_tile_properties_qcom = if (extensions.qcom_tile_properties) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDynamicRenderingTilePropertiesQCOM")) else null,
            .fp_get_physical_device_optical_flow_image_formats_nv = if (extensions.nv_optical_flow) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV")) else null,
            .fp_create_optical_flow_session_nv = if (extensions.nv_optical_flow) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateOpticalFlowSessionNV")) else null,
            .fp_destroy_optical_flow_session_nv = if (extensions.nv_optical_flow) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyOpticalFlowSessionNV")) else null,
            .fp_bind_optical_flow_session_image_nv = if (extensions.nv_optical_flow) @ptrCast(try instance.get_device_proc_addr(device, "vkBindOpticalFlowSessionImageNV")) else null,
            .fp_cmd_optical_flow_execute_nv = if (extensions.nv_optical_flow) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdOpticalFlowExecuteNV")) else null,
            .fp_get_device_fault_info_ext = if (extensions.ext_device_fault) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceFaultInfoEXT")) else null,
            .fp_cmd_set_depth_bias2_ext = if (extensions.ext_depth_bias_control) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthBias2EXT")) else null,
            .fp_release_swapchain_images_khr = if (extensions.khr_swapchain_maintenance1) @ptrCast(try instance.get_device_proc_addr(device, "vkReleaseSwapchainImagesKHR")) else if (extensions.ext_swapchain_maintenance1) @ptrCast(try instance.get_device_proc_addr(device, "vkReleaseSwapchainImagesEXT")) else null,
            .fp_get_device_image_subresource_layout = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceImageSubresourceLayout")) else if (extensions.khr_maintenance5) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceImageSubresourceLayoutKHR")) else null,
            .fp_map_memory2 = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkMapMemory2")) else if (extensions.khr_map_memory2) @ptrCast(try instance.get_device_proc_addr(device, "vkMapMemory2KHR")) else null,
            .fp_unmap_memory2 = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkUnmapMemory2")) else if (extensions.khr_map_memory2) @ptrCast(try instance.get_device_proc_addr(device, "vkUnmapMemory2KHR")) else null,
            .fp_create_shaders_ext = if (extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateShadersEXT")) else null,
            .fp_destroy_shader_ext = if (extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyShaderEXT")) else null,
            .fp_get_shader_binary_data_ext = if (extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkGetShaderBinaryDataEXT")) else null,
            .fp_cmd_bind_shaders_ext = if (extensions.ext_shader_object) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindShadersEXT")) else null,
            .fp_get_physical_device_cooperative_matrix_properties_khr = if (extensions.khr_cooperative_matrix) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR")) else null,
            .fp_get_execution_graph_pipeline_scratch_size_amdx = if (extensions.amdx_shader_enqueue) @ptrCast(try instance.get_device_proc_addr(device, "vkGetExecutionGraphPipelineScratchSizeAMDX")) else null,
            .fp_get_execution_graph_pipeline_node_index_amdx = if (extensions.amdx_shader_enqueue) @ptrCast(try instance.get_device_proc_addr(device, "vkGetExecutionGraphPipelineNodeIndexAMDX")) else null,
            .fp_create_execution_graph_pipelines_amdx = if (extensions.amdx_shader_enqueue) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateExecutionGraphPipelinesAMDX")) else null,
            .fp_cmd_initialize_graph_scratch_memory_amdx = if (extensions.amdx_shader_enqueue) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdInitializeGraphScratchMemoryAMDX")) else null,
            .fp_cmd_dispatch_graph_amdx = if (extensions.amdx_shader_enqueue) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDispatchGraphAMDX")) else null,
            .fp_cmd_dispatch_graph_indirect_amdx = if (extensions.amdx_shader_enqueue) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDispatchGraphIndirectAMDX")) else null,
            .fp_cmd_dispatch_graph_indirect_count_amdx = if (extensions.amdx_shader_enqueue) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDispatchGraphIndirectCountAMDX")) else null,
            .fp_cmd_bind_descriptor_sets2 = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindDescriptorSets2")) else if (extensions.khr_maintenance6) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindDescriptorSets2KHR")) else null,
            .fp_cmd_push_constants2 = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPushConstants2")) else if (extensions.khr_maintenance6) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPushConstants2KHR")) else null,
            .fp_cmd_push_descriptor_set2 = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPushDescriptorSet2")) else if (extensions.khr_maintenance6 and extensions.khr_push_descriptor) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPushDescriptorSet2KHR")) else null,
            .fp_cmd_push_descriptor_set_with_template2 = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPushDescriptorSetWithTemplate2")) else if (extensions.khr_maintenance6 and extensions.khr_push_descriptor) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdPushDescriptorSetWithTemplate2KHR")) else null,
            .fp_cmd_set_descriptor_buffer_offsets2_ext = if (extensions.khr_maintenance6 and extensions.ext_descriptor_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDescriptorBufferOffsets2EXT")) else null,
            .fp_cmd_bind_descriptor_buffer_embedded_samplers2_ext = if (extensions.khr_maintenance6 and extensions.ext_descriptor_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBindDescriptorBufferEmbeddedSamplers2EXT")) else null,
            .fp_set_latency_sleep_mode_nv = if (extensions.nv_low_latency2) @ptrCast(try instance.get_device_proc_addr(device, "vkSetLatencySleepModeNV")) else null,
            .fp_latency_sleep_nv = if (extensions.nv_low_latency2) @ptrCast(try instance.get_device_proc_addr(device, "vkLatencySleepNV")) else null,
            .fp_set_latency_marker_nv = if (extensions.nv_low_latency2) @ptrCast(try instance.get_device_proc_addr(device, "vkSetLatencyMarkerNV")) else null,
            .fp_get_latency_timings_nv = if (extensions.nv_low_latency2) @ptrCast(try instance.get_device_proc_addr(device, "vkGetLatencyTimingsNV")) else null,
            .fp_queue_notify_out_of_band_nv = if (extensions.nv_low_latency2) @ptrCast(try instance.get_device_proc_addr(device, "vkQueueNotifyOutOfBandNV")) else null,
            .fp_cmd_set_rendering_attachment_locations = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetRenderingAttachmentLocations")) else if (extensions.khr_dynamic_rendering_local_read) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetRenderingAttachmentLocationsKHR")) else null,
            .fp_cmd_set_rendering_input_attachment_indices = if (extensions.core_version.to_int() >= make_version(1, 4, 0).to_int()) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetRenderingInputAttachmentIndices")) else if (extensions.khr_dynamic_rendering_local_read) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetRenderingInputAttachmentIndicesKHR")) else null,
            .fp_cmd_set_depth_clamp_range_ext = if (extensions.ext_depth_clamp_control) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdSetDepthClampRangeEXT")) else null,
            .fp_get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv = if (extensions.nv_cooperative_matrix2) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV")) else null,
            .fp_get_memory_metal_handle_ext = if (extensions.ext_external_memory_metal) @ptrCast(try instance.get_device_proc_addr(device, "vkGetMemoryMetalHandleEXT")) else null,
            .fp_get_memory_metal_handle_properties_ext = if (extensions.ext_external_memory_metal) @ptrCast(try instance.get_device_proc_addr(device, "vkGetMemoryMetalHandlePropertiesEXT")) else null,
            .fp_get_physical_device_cooperative_vector_properties_nv = if (extensions.nv_cooperative_vector) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceCooperativeVectorPropertiesNV")) else null,
            .fp_convert_cooperative_vector_matrix_nv = if (extensions.nv_cooperative_vector) @ptrCast(try instance.get_device_proc_addr(device, "vkConvertCooperativeVectorMatrixNV")) else null,
            .fp_cmd_convert_cooperative_vector_matrix_nv = if (extensions.nv_cooperative_vector) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdConvertCooperativeVectorMatrixNV")) else null,
            .fp_cmd_dispatch_tile_qcom = if (extensions.qcom_tile_shading) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDispatchTileQCOM")) else null,
            .fp_cmd_begin_per_tile_execution_qcom = if (extensions.qcom_tile_shading) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdBeginPerTileExecutionQCOM")) else null,
            .fp_cmd_end_per_tile_execution_qcom = if (extensions.qcom_tile_shading) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdEndPerTileExecutionQCOM")) else null,
            .fp_create_external_compute_queue_nv = if (extensions.nv_external_compute_queue) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateExternalComputeQueueNV")) else null,
            .fp_destroy_external_compute_queue_nv = if (extensions.nv_external_compute_queue) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyExternalComputeQueueNV")) else null,
            .fp_get_external_compute_queue_data_nv = if (extensions.nv_external_compute_queue) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetExternalComputeQueueDataNV")) else null,
            .fp_create_tensor_arm = if (extensions.arm_tensors) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateTensorARM")) else null,
            .fp_destroy_tensor_arm = if (extensions.arm_tensors) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyTensorARM")) else null,
            .fp_create_tensor_view_arm = if (extensions.arm_tensors) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateTensorViewARM")) else null,
            .fp_destroy_tensor_view_arm = if (extensions.arm_tensors) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyTensorViewARM")) else null,
            .fp_get_tensor_memory_requirements_arm = if (extensions.arm_tensors) @ptrCast(try instance.get_device_proc_addr(device, "vkGetTensorMemoryRequirementsARM")) else null,
            .fp_bind_tensor_memory_arm = if (extensions.arm_tensors) @ptrCast(try instance.get_device_proc_addr(device, "vkBindTensorMemoryARM")) else null,
            .fp_get_device_tensor_memory_requirements_arm = if (extensions.arm_tensors) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDeviceTensorMemoryRequirementsARM")) else null,
            .fp_cmd_copy_tensor_arm = if (extensions.arm_tensors) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdCopyTensorARM")) else null,
            .fp_get_tensor_opaque_capture_descriptor_data_arm = if (extensions.arm_tensors and extensions.ext_descriptor_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkGetTensorOpaqueCaptureDescriptorDataARM")) else null,
            .fp_get_tensor_view_opaque_capture_descriptor_data_arm = if (extensions.arm_tensors and extensions.ext_descriptor_buffer) @ptrCast(try instance.get_device_proc_addr(device, "vkGetTensorViewOpaqueCaptureDescriptorDataARM")) else null,
            .fp_get_physical_device_external_tensor_properties_arm = if (extensions.arm_tensors) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceExternalTensorPropertiesARM")) else null,
            .fp_create_data_graph_pipelines_arm = if (extensions.arm_data_graph) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateDataGraphPipelinesARM")) else null,
            .fp_create_data_graph_pipeline_session_arm = if (extensions.arm_data_graph) @ptrCast(try instance.get_device_proc_addr(device, "vkCreateDataGraphPipelineSessionARM")) else null,
            .fp_get_data_graph_pipeline_session_bind_point_requirements_arm = if (extensions.arm_data_graph) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDataGraphPipelineSessionBindPointRequirementsARM")) else null,
            .fp_get_data_graph_pipeline_session_memory_requirements_arm = if (extensions.arm_data_graph) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDataGraphPipelineSessionMemoryRequirementsARM")) else null,
            .fp_bind_data_graph_pipeline_session_memory_arm = if (extensions.arm_data_graph) @ptrCast(try instance.get_device_proc_addr(device, "vkBindDataGraphPipelineSessionMemoryARM")) else null,
            .fp_destroy_data_graph_pipeline_session_arm = if (extensions.arm_data_graph) @ptrCast(try instance.get_device_proc_addr(device, "vkDestroyDataGraphPipelineSessionARM")) else null,
            .fp_cmd_dispatch_data_graph_arm = if (extensions.arm_data_graph) @ptrCast(try instance.get_device_proc_addr(device, "vkCmdDispatchDataGraphARM")) else null,
            .fp_get_data_graph_pipeline_available_properties_arm = if (extensions.arm_data_graph) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDataGraphPipelineAvailablePropertiesARM")) else null,
            .fp_get_data_graph_pipeline_properties_arm = if (extensions.arm_data_graph) @ptrCast(try instance.get_device_proc_addr(device, "vkGetDataGraphPipelinePropertiesARM")) else null,
            .fp_get_physical_device_queue_family_data_graph_properties_arm = if (extensions.arm_data_graph) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM")) else null,
            .fp_get_physical_device_queue_family_data_graph_processing_engine_properties_arm = if (extensions.arm_data_graph) @ptrCast(try globals.get_instance_proc_addr(instance.handle, "vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM")) else null,
        };
    }
    pub fn destroy_device(
        self: DeviceCommands,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_device(self.handle, p_allocator);
    }
    pub fn get_device_queue(
        self: DeviceCommands,
        queue_family_index: u32,
        queue_index: u32,
    ) Queue {
        var p_queue: Queue = undefined;
        self.fp_get_device_queue(self.handle, queue_family_index, queue_index, &p_queue);
        return p_queue;
    }
    pub const QueueSubmitError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn queue_submit(
        self: DeviceCommands,
        queue: Queue,
        p_submits: []const SubmitInfo,
        fence: Fence,
    ) QueueSubmitError!void {
        const submit_count: u32 = @intCast(p_submits.len);
        switch (self.fp_queue_submit(queue, submit_count, p_submits.ptr, fence)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const QueueWaitIdleError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn queue_wait_idle(
        self: DeviceCommands,
        queue: Queue,
    ) QueueWaitIdleError!void {
        switch (self.fp_queue_wait_idle(queue)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const DeviceWaitIdleError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn device_wait_idle(
        self: DeviceCommands,
    ) DeviceWaitIdleError!void {
        switch (self.fp_device_wait_idle(self.handle)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const AllocateMemoryError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InvalidExternalHandle,
        InvalidOpaqueCaptureAddress,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn allocate_memory(
        self: DeviceCommands,
        p_allocate_info: *const MemoryAllocateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) AllocateMemoryError!DeviceMemory {
        var p_memory: DeviceMemory = undefined;
        switch (self.fp_allocate_memory(self.handle, p_allocate_info, p_allocator, &p_memory)) {
            .success => return p_memory,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_invalid_external_handle => return error.InvalidExternalHandle,
            .error_invalid_opaque_capture_address => return error.InvalidOpaqueCaptureAddress,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn free_memory(
        self: DeviceCommands,
        memory: DeviceMemory,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_free_memory(self.handle, memory, p_allocator);
    }
    pub const MapMemoryError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        MemoryMapFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn map_memory(
        self: DeviceCommands,
        memory: DeviceMemory,
        offset: DeviceSize,
        size: DeviceSize,
        flags: MemoryMapFlags,
    ) MapMemoryError!?*anyopaque {
        var pp_data: ?*anyopaque = undefined;
        switch (self.fp_map_memory(self.handle, memory, offset, size, flags, &pp_data)) {
            .success => return pp_data,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_memory_map_failed => return error.MemoryMapFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn unmap_memory(
        self: DeviceCommands,
        memory: DeviceMemory,
    ) void {
        self.fp_unmap_memory(self.handle, memory);
    }
    pub const FlushMappedMemoryRangesError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn flush_mapped_memory_ranges(
        self: DeviceCommands,
        p_memory_ranges: []const MappedMemoryRange,
    ) FlushMappedMemoryRangesError!void {
        const memory_range_count: u32 = @intCast(p_memory_ranges.len);
        switch (self.fp_flush_mapped_memory_ranges(self.handle, memory_range_count, p_memory_ranges.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const InvalidateMappedMemoryRangesError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn invalidate_mapped_memory_ranges(
        self: DeviceCommands,
        p_memory_ranges: []const MappedMemoryRange,
    ) InvalidateMappedMemoryRangesError!void {
        const memory_range_count: u32 = @intCast(p_memory_ranges.len);
        switch (self.fp_invalidate_mapped_memory_ranges(self.handle, memory_range_count, p_memory_ranges.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_device_memory_commitment(
        self: DeviceCommands,
        memory: DeviceMemory,
    ) DeviceSize {
        var p_committed_memory_in_bytes: DeviceSize = undefined;
        self.fp_get_device_memory_commitment(self.handle, memory, &p_committed_memory_in_bytes);
        return p_committed_memory_in_bytes;
    }
    pub fn get_buffer_memory_requirements(
        self: DeviceCommands,
        buffer: Buffer,
    ) MemoryRequirements {
        var p_memory_requirements: MemoryRequirements = undefined;
        self.fp_get_buffer_memory_requirements(self.handle, buffer, &p_memory_requirements);
        return p_memory_requirements;
    }
    pub const BindBufferMemoryError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InvalidOpaqueCaptureAddress,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn bind_buffer_memory(
        self: DeviceCommands,
        buffer: Buffer,
        memory: DeviceMemory,
        memory_offset: DeviceSize,
    ) BindBufferMemoryError!void {
        switch (self.fp_bind_buffer_memory(self.handle, buffer, memory, memory_offset)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_invalid_opaque_capture_address => return error.InvalidOpaqueCaptureAddress,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_image_memory_requirements(
        self: DeviceCommands,
        image: Image,
    ) MemoryRequirements {
        var p_memory_requirements: MemoryRequirements = undefined;
        self.fp_get_image_memory_requirements(self.handle, image, &p_memory_requirements);
        return p_memory_requirements;
    }
    pub const BindImageMemoryError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn bind_image_memory(
        self: DeviceCommands,
        image: Image,
        memory: DeviceMemory,
        memory_offset: DeviceSize,
    ) BindImageMemoryError!void {
        switch (self.fp_bind_image_memory(self.handle, image, memory, memory_offset)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_image_sparse_memory_requirements(
        self: DeviceCommands,
        image: Image,
        p_sparse_memory_requirement_count: *u32,
        p_sparse_memory_requirements: ?[*]SparseImageMemoryRequirements,
    ) void {
        self.fp_get_image_sparse_memory_requirements(self.handle, image, p_sparse_memory_requirement_count, p_sparse_memory_requirements);
    }
    pub fn get_image_sparse_memory_requirements_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        image: Image,
    ) Allocator.Error![]SparseImageMemoryRequirements {
        const enumerator = struct {
            self: *const DeviceCommands,
            image: Image,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]SparseImageMemoryRequirements) void {
                return enumerator.self.get_image_sparse_memory_requirements(
                    enumerator.image,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .image = image,
        };
        return enumerate_generic_unchecked_to_array(SparseImageMemoryRequirements, enumerator, allocator);
    }
    pub const QueueBindSparseError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn queue_bind_sparse(
        self: DeviceCommands,
        queue: Queue,
        p_bind_info: []const BindSparseInfo,
        fence: Fence,
    ) QueueBindSparseError!void {
        const bind_info_count: u32 = @intCast(p_bind_info.len);
        switch (self.fp_queue_bind_sparse(queue, bind_info_count, p_bind_info.ptr, fence)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateFenceError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_fence(
        self: DeviceCommands,
        p_create_info: *const FenceCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateFenceError!Fence {
        var p_fence: Fence = undefined;
        switch (self.fp_create_fence(self.handle, p_create_info, p_allocator, &p_fence)) {
            .success => return p_fence,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_fence(
        self: DeviceCommands,
        fence: Fence,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_fence(self.handle, fence, p_allocator);
    }
    pub const ResetFencesError = error{
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn reset_fences(
        self: DeviceCommands,
        p_fences: []const Fence,
    ) ResetFencesError!void {
        const fence_count: u32 = @intCast(p_fences.len);
        switch (self.fp_reset_fences(self.handle, fence_count, p_fences.ptr)) {
            .success => return,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetFenceStatusResult = enum {
        success,
        not_ready,
    };
    pub const GetFenceStatusError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_fence_status(
        self: DeviceCommands,
        fence: Fence,
    ) GetFenceStatusError!GetFenceStatusResult {
        switch (self.fp_get_fence_status(self.handle, fence)) {
            .success => return .success,
            .not_ready => return .not_ready,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const WaitForFencesResult = enum {
        success,
        timeout,
    };
    pub const WaitForFencesError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn wait_for_fences(
        self: DeviceCommands,
        p_fences: []const Fence,
        wait_all: bool,
        timeout: u64,
    ) WaitForFencesError!WaitForFencesResult {
        const fence_count: u32 = @intCast(p_fences.len);
        switch (self.fp_wait_for_fences(self.handle, fence_count, p_fences.ptr, Bool32.from_bool(wait_all), timeout)) {
            .success => return .success,
            .timeout => return .timeout,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateSemaphoreError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_semaphore(
        self: DeviceCommands,
        p_create_info: *const SemaphoreCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateSemaphoreError!Semaphore {
        var p_semaphore: Semaphore = undefined;
        switch (self.fp_create_semaphore(self.handle, p_create_info, p_allocator, &p_semaphore)) {
            .success => return p_semaphore,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_semaphore(
        self: DeviceCommands,
        semaphore: Semaphore,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_semaphore(self.handle, semaphore, p_allocator);
    }
    pub const CreateEventError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_event(
        self: DeviceCommands,
        p_create_info: *const EventCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateEventError!Event {
        var p_event: Event = undefined;
        switch (self.fp_create_event(self.handle, p_create_info, p_allocator, &p_event)) {
            .success => return p_event,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_event(
        self: DeviceCommands,
        event: Event,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_event(self.handle, event, p_allocator);
    }
    pub const GetEventStatusResult = enum {
        event_set,
        event_reset,
    };
    pub const GetEventStatusError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_event_status(
        self: DeviceCommands,
        event: Event,
    ) GetEventStatusError!GetEventStatusResult {
        switch (self.fp_get_event_status(self.handle, event)) {
            .event_set => return .event_set,
            .event_reset => return .event_reset,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const SetEventError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn set_event(
        self: DeviceCommands,
        event: Event,
    ) SetEventError!void {
        switch (self.fp_set_event(self.handle, event)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const ResetEventError = error{
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn reset_event(
        self: DeviceCommands,
        event: Event,
    ) ResetEventError!void {
        switch (self.fp_reset_event(self.handle, event)) {
            .success => return,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateQueryPoolError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_query_pool(
        self: DeviceCommands,
        p_create_info: *const QueryPoolCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateQueryPoolError!QueryPool {
        var p_query_pool: QueryPool = undefined;
        switch (self.fp_create_query_pool(self.handle, p_create_info, p_allocator, &p_query_pool)) {
            .success => return p_query_pool,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_query_pool(
        self: DeviceCommands,
        query_pool: QueryPool,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_query_pool(self.handle, query_pool, p_allocator);
    }
    pub const GetQueryPoolResultsError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_query_pool_results(
        self: DeviceCommands,
        query_pool: QueryPool,
        first_query: u32,
        query_count: u32,
        p_data: []u8,
        stride: DeviceSize,
        flags: QueryResultFlags,
    ) GetQueryPoolResultsError!GetFenceStatusResult {
        const data_size: usize = @intCast(p_data.len);
        switch (self.fp_get_query_pool_results(self.handle, query_pool, first_query, query_count, data_size, p_data.ptr, stride, flags)) {
            .success => return .success,
            .not_ready => return .not_ready,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn reset_query_pool(
        self: DeviceCommands,
        query_pool: QueryPool,
        first_query: u32,
        query_count: u32,
    ) void {
        self.fp_reset_query_pool.?(self.handle, query_pool, first_query, query_count);
    }
    pub const CreateBufferError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InvalidOpaqueCaptureAddress,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_buffer(
        self: DeviceCommands,
        p_create_info: *const BufferCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateBufferError!Buffer {
        var p_buffer: Buffer = undefined;
        switch (self.fp_create_buffer(self.handle, p_create_info, p_allocator, &p_buffer)) {
            .success => return p_buffer,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_invalid_opaque_capture_address => return error.InvalidOpaqueCaptureAddress,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_buffer(
        self: DeviceCommands,
        buffer: Buffer,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_buffer(self.handle, buffer, p_allocator);
    }
    pub const CreateBufferViewError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_buffer_view(
        self: DeviceCommands,
        p_create_info: *const BufferViewCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateBufferViewError!BufferView {
        var p_view: BufferView = undefined;
        switch (self.fp_create_buffer_view(self.handle, p_create_info, p_allocator, &p_view)) {
            .success => return p_view,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_buffer_view(
        self: DeviceCommands,
        buffer_view: BufferView,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_buffer_view(self.handle, buffer_view, p_allocator);
    }
    pub const CreateImageError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        CompressionExhaustedExt,
        InvalidOpaqueCaptureAddress,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_image(
        self: DeviceCommands,
        p_create_info: *const ImageCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateImageError!Image {
        var p_image: Image = undefined;
        switch (self.fp_create_image(self.handle, p_create_info, p_allocator, &p_image)) {
            .success => return p_image,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_compression_exhausted_ext => return error.CompressionExhaustedExt,
            .error_invalid_opaque_capture_address => return error.InvalidOpaqueCaptureAddress,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_image(
        self: DeviceCommands,
        image: Image,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_image(self.handle, image, p_allocator);
    }
    pub fn get_image_subresource_layout(
        self: DeviceCommands,
        image: Image,
        p_subresource: *const ImageSubresource,
    ) SubresourceLayout {
        var p_layout: SubresourceLayout = undefined;
        self.fp_get_image_subresource_layout(self.handle, image, p_subresource, &p_layout);
        return p_layout;
    }
    pub const CreateImageViewError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InvalidOpaqueCaptureAddress,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_image_view(
        self: DeviceCommands,
        p_create_info: *const ImageViewCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateImageViewError!ImageView {
        var p_view: ImageView = undefined;
        switch (self.fp_create_image_view(self.handle, p_create_info, p_allocator, &p_view)) {
            .success => return p_view,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_invalid_opaque_capture_address => return error.InvalidOpaqueCaptureAddress,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_image_view(
        self: DeviceCommands,
        image_view: ImageView,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_image_view(self.handle, image_view, p_allocator);
    }
    pub const CreateShaderModuleError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InvalidShaderNv,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_shader_module(
        self: DeviceCommands,
        p_create_info: *const ShaderModuleCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateShaderModuleError!ShaderModule {
        var p_shader_module: ShaderModule = undefined;
        switch (self.fp_create_shader_module(self.handle, p_create_info, p_allocator, &p_shader_module)) {
            .success => return p_shader_module,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_invalid_shader_nv => return error.InvalidShaderNv,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_shader_module(
        self: DeviceCommands,
        shader_module: ShaderModule,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_shader_module(self.handle, shader_module, p_allocator);
    }
    pub const CreatePipelineCacheError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_pipeline_cache(
        self: DeviceCommands,
        p_create_info: *const PipelineCacheCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreatePipelineCacheError!PipelineCache {
        var p_pipeline_cache: PipelineCache = undefined;
        switch (self.fp_create_pipeline_cache(self.handle, p_create_info, p_allocator, &p_pipeline_cache)) {
            .success => return p_pipeline_cache,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_pipeline_cache(
        self: DeviceCommands,
        pipeline_cache: PipelineCache,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_pipeline_cache(self.handle, pipeline_cache, p_allocator);
    }
    pub const GetPipelineCacheDataError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_pipeline_cache_data(
        self: DeviceCommands,
        pipeline_cache: PipelineCache,
        p_data_size: *usize,
        p_data: ?*anyopaque,
    ) GetPipelineCacheDataError!EnumerateResult {
        switch (self.fp_get_pipeline_cache_data(self.handle, pipeline_cache, p_data_size, p_data)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const MergePipelineCachesError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn merge_pipeline_caches(
        self: DeviceCommands,
        dst_cache: PipelineCache,
        p_src_caches: []const PipelineCache,
    ) MergePipelineCachesError!void {
        const src_cache_count: u32 = @intCast(p_src_caches.len);
        switch (self.fp_merge_pipeline_caches(self.handle, dst_cache, src_cache_count, p_src_caches.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreatePipelineBinariesKHRResult = enum {
        success,
        incomplete,
        pipeline_binary_missing_khr,
    };
    pub const CreatePipelineBinariesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_pipeline_binaries_khr(
        self: DeviceCommands,
        p_create_info: *const PipelineBinaryCreateInfoKHR,
        p_allocator: ?*const AllocationCallbacks,
        p_binaries: *PipelineBinaryHandlesInfoKHR,
    ) CreatePipelineBinariesKHRError!CreatePipelineBinariesKHRResult {
        switch (self.fp_create_pipeline_binaries_khr.?(self.handle, p_create_info, p_allocator, p_binaries)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .pipeline_binary_missing_khr => return .pipeline_binary_missing_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_pipeline_binary_khr(
        self: DeviceCommands,
        pipeline_binary: PipelineBinaryKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_pipeline_binary_khr.?(self.handle, pipeline_binary, p_allocator);
    }
    pub const GetPipelineKeyKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_pipeline_key_khr(
        self: DeviceCommands,
        p_pipeline_create_info: ?*const PipelineCreateInfoKHR,
        p_pipeline_key: *PipelineBinaryKeyKHR,
    ) GetPipelineKeyKHRError!void {
        switch (self.fp_get_pipeline_key_khr.?(self.handle, p_pipeline_create_info, p_pipeline_key)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPipelineBinaryDataKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        NotEnoughSpaceKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_pipeline_binary_data_khr(
        self: DeviceCommands,
        p_info: *const PipelineBinaryDataInfoKHR,
        p_pipeline_binary_key: *PipelineBinaryKeyKHR,
        p_pipeline_binary_data_size: *usize,
        p_pipeline_binary_data: ?*anyopaque,
    ) GetPipelineBinaryDataKHRError!void {
        switch (self.fp_get_pipeline_binary_data_khr.?(self.handle, p_info, p_pipeline_binary_key, p_pipeline_binary_data_size, p_pipeline_binary_data)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_not_enough_space_khr => return error.NotEnoughSpaceKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const ReleaseCapturedPipelineDataKHRError = error{
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn release_captured_pipeline_data_khr(
        self: DeviceCommands,
        p_info: *const ReleaseCapturedPipelineDataInfoKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) ReleaseCapturedPipelineDataKHRError!void {
        switch (self.fp_release_captured_pipeline_data_khr.?(self.handle, p_info, p_allocator)) {
            .success => return,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateGraphicsPipelinesResult = enum {
        success,
        pipeline_compile_required,
    };
    pub const CreateGraphicsPipelinesError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InvalidShaderNv,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_graphics_pipelines(
        self: DeviceCommands,
        pipeline_cache: PipelineCache,
        p_create_infos: []const GraphicsPipelineCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
        p_pipelines: []Pipeline,
    ) CreateGraphicsPipelinesError!CreateGraphicsPipelinesResult {
        const create_info_count: u32 = @intCast(p_create_infos.len);
        assert(create_info_count == p_pipelines.len);
        switch (self.fp_create_graphics_pipelines(self.handle, pipeline_cache, create_info_count, p_create_infos.ptr, p_allocator, p_pipelines.ptr)) {
            .success => return .success,
            .pipeline_compile_required => return .pipeline_compile_required,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_invalid_shader_nv => return error.InvalidShaderNv,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateComputePipelinesError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InvalidShaderNv,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_compute_pipelines(
        self: DeviceCommands,
        pipeline_cache: PipelineCache,
        p_create_infos: []const ComputePipelineCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
        p_pipelines: []Pipeline,
    ) CreateComputePipelinesError!CreateGraphicsPipelinesResult {
        const create_info_count: u32 = @intCast(p_create_infos.len);
        assert(create_info_count == p_pipelines.len);
        switch (self.fp_create_compute_pipelines(self.handle, pipeline_cache, create_info_count, p_create_infos.ptr, p_allocator, p_pipelines.ptr)) {
            .success => return .success,
            .pipeline_compile_required => return .pipeline_compile_required,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_invalid_shader_nv => return error.InvalidShaderNv,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEIError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_device_subpass_shading_max_workgroup_size_huawei(
        self: DeviceCommands,
        renderpass: RenderPass,
    ) GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEIError!Extent2D {
        var p_max_workgroup_size: Extent2D = undefined;
        switch (self.fp_get_device_subpass_shading_max_workgroup_size_huawei.?(self.handle, renderpass, &p_max_workgroup_size)) {
            .success => return p_max_workgroup_size,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_pipeline(
        self: DeviceCommands,
        pipeline: Pipeline,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_pipeline(self.handle, pipeline, p_allocator);
    }
    pub const CreatePipelineLayoutError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_pipeline_layout(
        self: DeviceCommands,
        p_create_info: *const PipelineLayoutCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreatePipelineLayoutError!PipelineLayout {
        var p_pipeline_layout: PipelineLayout = undefined;
        switch (self.fp_create_pipeline_layout(self.handle, p_create_info, p_allocator, &p_pipeline_layout)) {
            .success => return p_pipeline_layout,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_pipeline_layout(
        self: DeviceCommands,
        pipeline_layout: PipelineLayout,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_pipeline_layout(self.handle, pipeline_layout, p_allocator);
    }
    pub const CreateSamplerError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InvalidOpaqueCaptureAddress,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_sampler(
        self: DeviceCommands,
        p_create_info: *const SamplerCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateSamplerError!Sampler {
        var p_sampler: Sampler = undefined;
        switch (self.fp_create_sampler(self.handle, p_create_info, p_allocator, &p_sampler)) {
            .success => return p_sampler,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_invalid_opaque_capture_address => return error.InvalidOpaqueCaptureAddress,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_sampler(
        self: DeviceCommands,
        sampler: Sampler,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_sampler(self.handle, sampler, p_allocator);
    }
    pub const CreateDescriptorSetLayoutError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_descriptor_set_layout(
        self: DeviceCommands,
        p_create_info: *const DescriptorSetLayoutCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateDescriptorSetLayoutError!DescriptorSetLayout {
        var p_set_layout: DescriptorSetLayout = undefined;
        switch (self.fp_create_descriptor_set_layout(self.handle, p_create_info, p_allocator, &p_set_layout)) {
            .success => return p_set_layout,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_descriptor_set_layout(
        self: DeviceCommands,
        descriptor_set_layout: DescriptorSetLayout,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_descriptor_set_layout(self.handle, descriptor_set_layout, p_allocator);
    }
    pub const CreateDescriptorPoolError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Fragmentation,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_descriptor_pool(
        self: DeviceCommands,
        p_create_info: *const DescriptorPoolCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateDescriptorPoolError!DescriptorPool {
        var p_descriptor_pool: DescriptorPool = undefined;
        switch (self.fp_create_descriptor_pool(self.handle, p_create_info, p_allocator, &p_descriptor_pool)) {
            .success => return p_descriptor_pool,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_fragmentation => return error.Fragmentation,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_descriptor_pool(
        self: DeviceCommands,
        descriptor_pool: DescriptorPool,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_descriptor_pool(self.handle, descriptor_pool, p_allocator);
    }
    pub const ResetDescriptorPoolError = error{
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn reset_descriptor_pool(
        self: DeviceCommands,
        descriptor_pool: DescriptorPool,
        flags: DescriptorPoolResetFlags,
    ) ResetDescriptorPoolError!void {
        switch (self.fp_reset_descriptor_pool(self.handle, descriptor_pool, flags)) {
            .success => return,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const AllocateDescriptorSetsError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        FragmentedPool,
        OutOfPoolMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn allocate_descriptor_sets(
        self: DeviceCommands,
        p_allocate_info: *const DescriptorSetAllocateInfo,
        p_descriptor_sets: []DescriptorSet,
    ) AllocateDescriptorSetsError!void {
        assert(p_descriptor_sets.len == p_allocate_info.descriptor_set_count);
        switch (self.fp_allocate_descriptor_sets(self.handle, p_allocate_info, p_descriptor_sets.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_fragmented_pool => return error.FragmentedPool,
            .error_out_of_pool_memory => return error.OutOfPoolMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const FreeDescriptorSetsError = error{
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn free_descriptor_sets(
        self: DeviceCommands,
        descriptor_pool: DescriptorPool,
        p_descriptor_sets: []const DescriptorSet,
    ) FreeDescriptorSetsError!void {
        const descriptor_set_count: u32 = @intCast(p_descriptor_sets.len);
        switch (self.fp_free_descriptor_sets(self.handle, descriptor_pool, descriptor_set_count, p_descriptor_sets.ptr)) {
            .success => return,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn update_descriptor_sets(
        self: DeviceCommands,
        p_descriptor_writes: []const WriteDescriptorSet,
        p_descriptor_copies: []const CopyDescriptorSet,
    ) void {
        const descriptor_write_count: u32 = @intCast(p_descriptor_writes.len);
        const descriptor_copy_count: u32 = @intCast(p_descriptor_copies.len);
        self.fp_update_descriptor_sets(self.handle, descriptor_write_count, p_descriptor_writes.ptr, descriptor_copy_count, p_descriptor_copies.ptr);
    }
    pub const CreateFramebufferError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_framebuffer(
        self: DeviceCommands,
        p_create_info: *const FramebufferCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateFramebufferError!Framebuffer {
        var p_framebuffer: Framebuffer = undefined;
        switch (self.fp_create_framebuffer(self.handle, p_create_info, p_allocator, &p_framebuffer)) {
            .success => return p_framebuffer,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_framebuffer(
        self: DeviceCommands,
        framebuffer: Framebuffer,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_framebuffer(self.handle, framebuffer, p_allocator);
    }
    pub const CreateRenderPassError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_render_pass(
        self: DeviceCommands,
        p_create_info: *const RenderPassCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateRenderPassError!RenderPass {
        var p_render_pass: RenderPass = undefined;
        switch (self.fp_create_render_pass(self.handle, p_create_info, p_allocator, &p_render_pass)) {
            .success => return p_render_pass,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_render_pass(
        self: DeviceCommands,
        render_pass: RenderPass,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_render_pass(self.handle, render_pass, p_allocator);
    }
    pub fn get_render_area_granularity(
        self: DeviceCommands,
        render_pass: RenderPass,
    ) Extent2D {
        var p_granularity: Extent2D = undefined;
        self.fp_get_render_area_granularity(self.handle, render_pass, &p_granularity);
        return p_granularity;
    }
    pub fn get_rendering_area_granularity(
        self: DeviceCommands,
        p_rendering_area_info: *const RenderingAreaInfo,
    ) Extent2D {
        var p_granularity: Extent2D = undefined;
        self.fp_get_rendering_area_granularity.?(self.handle, p_rendering_area_info, &p_granularity);
        return p_granularity;
    }
    pub const CreateCommandPoolError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_command_pool(
        self: DeviceCommands,
        p_create_info: *const CommandPoolCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateCommandPoolError!CommandPool {
        var p_command_pool: CommandPool = undefined;
        switch (self.fp_create_command_pool(self.handle, p_create_info, p_allocator, &p_command_pool)) {
            .success => return p_command_pool,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_command_pool(
        self: DeviceCommands,
        command_pool: CommandPool,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_command_pool(self.handle, command_pool, p_allocator);
    }
    pub const ResetCommandPoolError = error{
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn reset_command_pool(
        self: DeviceCommands,
        command_pool: CommandPool,
        flags: CommandPoolResetFlags,
    ) ResetCommandPoolError!void {
        switch (self.fp_reset_command_pool(self.handle, command_pool, flags)) {
            .success => return,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const AllocateCommandBuffersError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn allocate_command_buffers(
        self: DeviceCommands,
        p_allocate_info: *const CommandBufferAllocateInfo,
        p_command_buffers: []CommandBuffer,
    ) AllocateCommandBuffersError!void {
        assert(p_command_buffers.len == p_allocate_info.command_buffer_count);
        switch (self.fp_allocate_command_buffers(self.handle, p_allocate_info, p_command_buffers.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn free_command_buffers(
        self: DeviceCommands,
        command_pool: CommandPool,
        p_command_buffers: []const CommandBuffer,
    ) void {
        const command_buffer_count: u32 = @intCast(p_command_buffers.len);
        self.fp_free_command_buffers(self.handle, command_pool, command_buffer_count, p_command_buffers.ptr);
    }
    pub const BeginCommandBufferError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn begin_command_buffer(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_begin_info: *const CommandBufferBeginInfo,
    ) BeginCommandBufferError!void {
        switch (self.fp_begin_command_buffer(command_buffer, p_begin_info)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const EndCommandBufferError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn end_command_buffer(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
    ) EndCommandBufferError!void {
        switch (self.fp_end_command_buffer(command_buffer)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const ResetCommandBufferError = error{
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn reset_command_buffer(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        flags: CommandBufferResetFlags,
    ) ResetCommandBufferError!void {
        switch (self.fp_reset_command_buffer(command_buffer, flags)) {
            .success => return,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_bind_pipeline(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        pipeline_bind_point: PipelineBindPoint,
        pipeline: Pipeline,
    ) void {
        self.fp_cmd_bind_pipeline(command_buffer, pipeline_bind_point, pipeline);
    }
    pub fn cmd_set_attachment_feedback_loop_enable_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        aspect_mask: ImageAspectFlags,
    ) void {
        self.fp_cmd_set_attachment_feedback_loop_enable_ext.?(command_buffer, aspect_mask);
    }
    pub fn cmd_set_viewport(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_viewport: u32,
        p_viewports: []const Viewport,
    ) void {
        const viewport_count: u32 = @intCast(p_viewports.len);
        self.fp_cmd_set_viewport(command_buffer, first_viewport, viewport_count, p_viewports.ptr);
    }
    pub fn cmd_set_scissor(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_scissor: u32,
        p_scissors: []const Rect2D,
    ) void {
        const scissor_count: u32 = @intCast(p_scissors.len);
        self.fp_cmd_set_scissor(command_buffer, first_scissor, scissor_count, p_scissors.ptr);
    }
    pub fn cmd_set_line_width(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        line_width: f32,
    ) void {
        self.fp_cmd_set_line_width(command_buffer, line_width);
    }
    pub fn cmd_set_depth_bias(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        depth_bias_constant_factor: f32,
        depth_bias_clamp: f32,
        depth_bias_slope_factor: f32,
    ) void {
        self.fp_cmd_set_depth_bias(command_buffer, depth_bias_constant_factor, depth_bias_clamp, depth_bias_slope_factor);
    }
    pub fn cmd_set_blend_constants(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        blend_constants: [*]const f32,
    ) void {
        self.fp_cmd_set_blend_constants(command_buffer, blend_constants);
    }
    pub fn cmd_set_depth_bounds(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        min_depth_bounds: f32,
        max_depth_bounds: f32,
    ) void {
        self.fp_cmd_set_depth_bounds(command_buffer, min_depth_bounds, max_depth_bounds);
    }
    pub fn cmd_set_stencil_compare_mask(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        face_mask: StencilFaceFlags,
        compare_mask: u32,
    ) void {
        self.fp_cmd_set_stencil_compare_mask(command_buffer, face_mask, compare_mask);
    }
    pub fn cmd_set_stencil_write_mask(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        face_mask: StencilFaceFlags,
        write_mask: u32,
    ) void {
        self.fp_cmd_set_stencil_write_mask(command_buffer, face_mask, write_mask);
    }
    pub fn cmd_set_stencil_reference(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        face_mask: StencilFaceFlags,
        reference: u32,
    ) void {
        self.fp_cmd_set_stencil_reference(command_buffer, face_mask, reference);
    }
    pub fn cmd_bind_descriptor_sets(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        pipeline_bind_point: PipelineBindPoint,
        layout: PipelineLayout,
        first_set: u32,
        p_descriptor_sets: []const DescriptorSet,
        p_dynamic_offsets: []const u32,
    ) void {
        const descriptor_set_count: u32 = @intCast(p_descriptor_sets.len);
        const dynamic_offset_count: u32 = @intCast(p_dynamic_offsets.len);
        self.fp_cmd_bind_descriptor_sets(command_buffer, pipeline_bind_point, layout, first_set, descriptor_set_count, p_descriptor_sets.ptr, dynamic_offset_count, p_dynamic_offsets.ptr);
    }
    pub fn cmd_bind_index_buffer(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        index_type: IndexType,
    ) void {
        self.fp_cmd_bind_index_buffer(command_buffer, buffer, offset, index_type);
    }
    pub fn cmd_bind_vertex_buffers(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_binding: u32,
        p_buffers: []const Buffer,
        p_offsets: []const DeviceSize,
    ) void {
        const binding_count: u32 = @intCast(p_buffers.len);
        assert(binding_count == p_offsets.len);
        self.fp_cmd_bind_vertex_buffers(command_buffer, first_binding, binding_count, p_buffers.ptr, p_offsets.ptr);
    }
    pub fn cmd_draw(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        vertex_count: u32,
        instance_count: u32,
        first_vertex: u32,
        first_instance: u32,
    ) void {
        self.fp_cmd_draw(command_buffer, vertex_count, instance_count, first_vertex, first_instance);
    }
    pub fn cmd_draw_indexed(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        index_count: u32,
        instance_count: u32,
        first_index: u32,
        vertex_offset: i32,
        first_instance: u32,
    ) void {
        self.fp_cmd_draw_indexed(command_buffer, index_count, instance_count, first_index, vertex_offset, first_instance);
    }
    pub fn cmd_draw_multi_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_vertex_info: []const MultiDrawInfoEXT,
        instance_count: u32,
        first_instance: u32,
        stride: u32,
    ) void {
        const draw_count: u32 = @intCast(p_vertex_info.len);
        self.fp_cmd_draw_multi_ext.?(command_buffer, draw_count, p_vertex_info.ptr, instance_count, first_instance, stride);
    }
    pub fn cmd_draw_multi_indexed_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_index_info: []const MultiDrawIndexedInfoEXT,
        instance_count: u32,
        first_instance: u32,
        stride: u32,
        p_vertex_offset: ?*const i32,
    ) void {
        const draw_count: u32 = @intCast(p_index_info.len);
        self.fp_cmd_draw_multi_indexed_ext.?(command_buffer, draw_count, p_index_info.ptr, instance_count, first_instance, stride, p_vertex_offset);
    }
    pub fn cmd_draw_indirect(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        draw_count: u32,
        stride: u32,
    ) void {
        self.fp_cmd_draw_indirect(command_buffer, buffer, offset, draw_count, stride);
    }
    pub fn cmd_draw_indexed_indirect(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        draw_count: u32,
        stride: u32,
    ) void {
        self.fp_cmd_draw_indexed_indirect(command_buffer, buffer, offset, draw_count, stride);
    }
    pub fn cmd_dispatch(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        group_count_x: u32,
        group_count_y: u32,
        group_count_z: u32,
    ) void {
        self.fp_cmd_dispatch(command_buffer, group_count_x, group_count_y, group_count_z);
    }
    pub fn cmd_dispatch_indirect(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
    ) void {
        self.fp_cmd_dispatch_indirect(command_buffer, buffer, offset);
    }
    pub fn cmd_subpass_shading_huawei(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
    ) void {
        self.fp_cmd_subpass_shading_huawei.?(command_buffer);
    }
    pub fn cmd_draw_cluster_huawei(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        group_count_x: u32,
        group_count_y: u32,
        group_count_z: u32,
    ) void {
        self.fp_cmd_draw_cluster_huawei.?(command_buffer, group_count_x, group_count_y, group_count_z);
    }
    pub fn cmd_draw_cluster_indirect_huawei(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
    ) void {
        self.fp_cmd_draw_cluster_indirect_huawei.?(command_buffer, buffer, offset);
    }
    pub fn cmd_update_pipeline_indirect_buffer_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        pipeline_bind_point: PipelineBindPoint,
        pipeline: Pipeline,
    ) void {
        self.fp_cmd_update_pipeline_indirect_buffer_nv.?(command_buffer, pipeline_bind_point, pipeline);
    }
    pub fn cmd_copy_buffer(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        src_buffer: Buffer,
        dst_buffer: Buffer,
        p_regions: []const BufferCopy,
    ) void {
        const region_count: u32 = @intCast(p_regions.len);
        self.fp_cmd_copy_buffer(command_buffer, src_buffer, dst_buffer, region_count, p_regions.ptr);
    }
    pub fn cmd_copy_image(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        src_image: Image,
        src_image_layout: ImageLayout,
        dst_image: Image,
        dst_image_layout: ImageLayout,
        p_regions: []const ImageCopy,
    ) void {
        const region_count: u32 = @intCast(p_regions.len);
        self.fp_cmd_copy_image(command_buffer, src_image, src_image_layout, dst_image, dst_image_layout, region_count, p_regions.ptr);
    }
    pub fn cmd_blit_image(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        src_image: Image,
        src_image_layout: ImageLayout,
        dst_image: Image,
        dst_image_layout: ImageLayout,
        p_regions: []const ImageBlit,
        filter: Filter,
    ) void {
        const region_count: u32 = @intCast(p_regions.len);
        self.fp_cmd_blit_image(command_buffer, src_image, src_image_layout, dst_image, dst_image_layout, region_count, p_regions.ptr, filter);
    }
    pub fn cmd_copy_buffer_to_image(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        src_buffer: Buffer,
        dst_image: Image,
        dst_image_layout: ImageLayout,
        p_regions: []const BufferImageCopy,
    ) void {
        const region_count: u32 = @intCast(p_regions.len);
        self.fp_cmd_copy_buffer_to_image(command_buffer, src_buffer, dst_image, dst_image_layout, region_count, p_regions.ptr);
    }
    pub fn cmd_copy_image_to_buffer(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        src_image: Image,
        src_image_layout: ImageLayout,
        dst_buffer: Buffer,
        p_regions: []const BufferImageCopy,
    ) void {
        const region_count: u32 = @intCast(p_regions.len);
        self.fp_cmd_copy_image_to_buffer(command_buffer, src_image, src_image_layout, dst_buffer, region_count, p_regions.ptr);
    }
    pub fn cmd_copy_memory_indirect_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        copy_buffer_address: DeviceAddress,
        copy_count: u32,
        stride: u32,
    ) void {
        self.fp_cmd_copy_memory_indirect_nv.?(command_buffer, copy_buffer_address, copy_count, stride);
    }
    pub fn cmd_copy_memory_to_image_indirect_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        copy_buffer_address: DeviceAddress,
        stride: u32,
        dst_image: Image,
        dst_image_layout: ImageLayout,
        p_image_subresources: []const ImageSubresourceLayers,
    ) void {
        const copy_count: u32 = @intCast(p_image_subresources.len);
        self.fp_cmd_copy_memory_to_image_indirect_nv.?(command_buffer, copy_buffer_address, copy_count, stride, dst_image, dst_image_layout, p_image_subresources.ptr);
    }
    pub fn cmd_update_buffer(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        dst_buffer: Buffer,
        dst_offset: DeviceSize,
        p_data: []const u8,
    ) void {
        const data_size: DeviceSize = @intCast(p_data.len);
        self.fp_cmd_update_buffer(command_buffer, dst_buffer, dst_offset, data_size, p_data.ptr);
    }
    pub fn cmd_fill_buffer(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        dst_buffer: Buffer,
        dst_offset: DeviceSize,
        size: DeviceSize,
        data: u32,
    ) void {
        self.fp_cmd_fill_buffer(command_buffer, dst_buffer, dst_offset, size, data);
    }
    pub fn cmd_clear_color_image(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        image: Image,
        image_layout: ImageLayout,
        p_color: *const ClearColorValue,
        p_ranges: []const ImageSubresourceRange,
    ) void {
        const range_count: u32 = @intCast(p_ranges.len);
        self.fp_cmd_clear_color_image(command_buffer, image, image_layout, p_color, range_count, p_ranges.ptr);
    }
    pub fn cmd_clear_depth_stencil_image(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        image: Image,
        image_layout: ImageLayout,
        p_depth_stencil: *const ClearDepthStencilValue,
        p_ranges: []const ImageSubresourceRange,
    ) void {
        const range_count: u32 = @intCast(p_ranges.len);
        self.fp_cmd_clear_depth_stencil_image(command_buffer, image, image_layout, p_depth_stencil, range_count, p_ranges.ptr);
    }
    pub fn cmd_clear_attachments(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_attachments: []const ClearAttachment,
        p_rects: []const ClearRect,
    ) void {
        const attachment_count: u32 = @intCast(p_attachments.len);
        const rect_count: u32 = @intCast(p_rects.len);
        self.fp_cmd_clear_attachments(command_buffer, attachment_count, p_attachments.ptr, rect_count, p_rects.ptr);
    }
    pub fn cmd_resolve_image(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        src_image: Image,
        src_image_layout: ImageLayout,
        dst_image: Image,
        dst_image_layout: ImageLayout,
        p_regions: []const ImageResolve,
    ) void {
        const region_count: u32 = @intCast(p_regions.len);
        self.fp_cmd_resolve_image(command_buffer, src_image, src_image_layout, dst_image, dst_image_layout, region_count, p_regions.ptr);
    }
    pub fn cmd_set_event(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        event: Event,
        stage_mask: PipelineStageFlags,
    ) void {
        self.fp_cmd_set_event(command_buffer, event, stage_mask);
    }
    pub fn cmd_reset_event(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        event: Event,
        stage_mask: PipelineStageFlags,
    ) void {
        self.fp_cmd_reset_event(command_buffer, event, stage_mask);
    }
    pub fn cmd_wait_events(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_events: []const Event,
        src_stage_mask: PipelineStageFlags,
        dst_stage_mask: PipelineStageFlags,
        p_memory_barriers: []const MemoryBarrier,
        p_buffer_memory_barriers: []const BufferMemoryBarrier,
        p_image_memory_barriers: []const ImageMemoryBarrier,
    ) void {
        const event_count: u32 = @intCast(p_events.len);
        const memory_barrier_count: u32 = @intCast(p_memory_barriers.len);
        const buffer_memory_barrier_count: u32 = @intCast(p_buffer_memory_barriers.len);
        const image_memory_barrier_count: u32 = @intCast(p_image_memory_barriers.len);
        self.fp_cmd_wait_events(command_buffer, event_count, p_events.ptr, src_stage_mask, dst_stage_mask, memory_barrier_count, p_memory_barriers.ptr, buffer_memory_barrier_count, p_buffer_memory_barriers.ptr, image_memory_barrier_count, p_image_memory_barriers.ptr);
    }
    pub fn cmd_pipeline_barrier(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        src_stage_mask: PipelineStageFlags,
        dst_stage_mask: PipelineStageFlags,
        dependency_flags: DependencyFlags,
        p_memory_barriers: []const MemoryBarrier,
        p_buffer_memory_barriers: []const BufferMemoryBarrier,
        p_image_memory_barriers: []const ImageMemoryBarrier,
    ) void {
        const memory_barrier_count: u32 = @intCast(p_memory_barriers.len);
        const buffer_memory_barrier_count: u32 = @intCast(p_buffer_memory_barriers.len);
        const image_memory_barrier_count: u32 = @intCast(p_image_memory_barriers.len);
        self.fp_cmd_pipeline_barrier(command_buffer, src_stage_mask, dst_stage_mask, dependency_flags, memory_barrier_count, p_memory_barriers.ptr, buffer_memory_barrier_count, p_buffer_memory_barriers.ptr, image_memory_barrier_count, p_image_memory_barriers.ptr);
    }
    pub fn cmd_begin_query(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        query_pool: QueryPool,
        query: u32,
        flags: QueryControlFlags,
    ) void {
        self.fp_cmd_begin_query(command_buffer, query_pool, query, flags);
    }
    pub fn cmd_end_query(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        query_pool: QueryPool,
        query: u32,
    ) void {
        self.fp_cmd_end_query(command_buffer, query_pool, query);
    }
    pub fn cmd_begin_conditional_rendering_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_conditional_rendering_begin: *const ConditionalRenderingBeginInfoEXT,
    ) void {
        self.fp_cmd_begin_conditional_rendering_ext.?(command_buffer, p_conditional_rendering_begin);
    }
    pub fn cmd_end_conditional_rendering_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
    ) void {
        self.fp_cmd_end_conditional_rendering_ext.?(command_buffer);
    }
    pub fn cmd_reset_query_pool(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        query_pool: QueryPool,
        first_query: u32,
        query_count: u32,
    ) void {
        self.fp_cmd_reset_query_pool(command_buffer, query_pool, first_query, query_count);
    }
    pub fn cmd_write_timestamp(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        pipeline_stage: PipelineStageFlags,
        query_pool: QueryPool,
        query: u32,
    ) void {
        self.fp_cmd_write_timestamp(command_buffer, pipeline_stage, query_pool, query);
    }
    pub fn cmd_copy_query_pool_results(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        query_pool: QueryPool,
        first_query: u32,
        query_count: u32,
        dst_buffer: Buffer,
        dst_offset: DeviceSize,
        stride: DeviceSize,
        flags: QueryResultFlags,
    ) void {
        self.fp_cmd_copy_query_pool_results(command_buffer, query_pool, first_query, query_count, dst_buffer, dst_offset, stride, flags);
    }
    pub fn cmd_push_constants(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        layout: PipelineLayout,
        stage_flags: ShaderStageFlags,
        offset: u32,
        p_values: []const u8,
    ) void {
        const size: u32 = @intCast(p_values.len);
        self.fp_cmd_push_constants(command_buffer, layout, stage_flags, offset, size, p_values.ptr);
    }
    pub fn cmd_begin_render_pass(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_render_pass_begin: *const RenderPassBeginInfo,
        contents: SubpassContents,
    ) void {
        self.fp_cmd_begin_render_pass(command_buffer, p_render_pass_begin, contents);
    }
    pub fn cmd_next_subpass(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        contents: SubpassContents,
    ) void {
        self.fp_cmd_next_subpass(command_buffer, contents);
    }
    pub fn cmd_end_render_pass(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
    ) void {
        self.fp_cmd_end_render_pass(command_buffer);
    }
    pub fn cmd_execute_commands(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_command_buffers: []const CommandBuffer,
    ) void {
        const command_buffer_count: u32 = @intCast(p_command_buffers.len);
        self.fp_cmd_execute_commands(command_buffer, command_buffer_count, p_command_buffers.ptr);
    }
    pub const CreateSharedSwapchainsKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        IncompatibleDisplayKhr,
        DeviceLost,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_shared_swapchains_khr(
        self: DeviceCommands,
        p_create_infos: []const SwapchainCreateInfoKHR,
        p_allocator: ?*const AllocationCallbacks,
        p_swapchains: []SwapchainKHR,
    ) CreateSharedSwapchainsKHRError!void {
        const swapchain_count: u32 = @intCast(p_create_infos.len);
        assert(swapchain_count == p_swapchains.len);
        switch (self.fp_create_shared_swapchains_khr.?(self.handle, swapchain_count, p_create_infos.ptr, p_allocator, p_swapchains.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_incompatible_display_khr => return error.IncompatibleDisplayKhr,
            .error_device_lost => return error.DeviceLost,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateSwapchainKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        SurfaceLostKhr,
        NativeWindowInUseKhr,
        InitializationFailed,
        CompressionExhaustedExt,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_swapchain_khr(
        self: DeviceCommands,
        p_create_info: *const SwapchainCreateInfoKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateSwapchainKHRError!SwapchainKHR {
        var p_swapchain: SwapchainKHR = undefined;
        switch (self.fp_create_swapchain_khr.?(self.handle, p_create_info, p_allocator, &p_swapchain)) {
            .success => return p_swapchain,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_native_window_in_use_khr => return error.NativeWindowInUseKhr,
            .error_initialization_failed => return error.InitializationFailed,
            .error_compression_exhausted_ext => return error.CompressionExhaustedExt,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_swapchain_khr(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_swapchain_khr.?(self.handle, swapchain, p_allocator);
    }
    pub const GetSwapchainImagesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_swapchain_images_khr(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
        p_swapchain_image_count: *u32,
        p_swapchain_images: ?[*]Image,
    ) GetSwapchainImagesKHRError!EnumerateResult {
        switch (self.fp_get_swapchain_images_khr.?(self.handle, swapchain, p_swapchain_image_count, p_swapchain_images)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetSwapchainImagesKHROrAllocatorError = GetSwapchainImagesKHRError || Allocator.Error;
    pub fn get_swapchain_images_khr_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        swapchain: SwapchainKHR,
    ) GetSwapchainImagesKHROrAllocatorError![]Image {
        const enumerator = struct {
            self: *const DeviceCommands,
            swapchain: SwapchainKHR,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]Image) !EnumerateResult {
                return enumerator.self.get_swapchain_images_khr(
                    enumerator.swapchain,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .swapchain = swapchain,
        };
        return enumerate_generic_to_array(GetSwapchainImagesKHROrAllocatorError, Image, enumerator, allocator);
    }
    pub const AcquireNextImageKHRResult = enum {
        success,
        timeout,
        not_ready,
        suboptimal_khr,
    };
    pub const AcquireNextImageKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        OutOfDateKhr,
        SurfaceLostKhr,
        FullScreenExclusiveModeLostExt,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn acquire_next_image_khr(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
        timeout: u64,
        semaphore: Semaphore,
        fence: Fence,
        p_image_index: *u32,
    ) AcquireNextImageKHRError!AcquireNextImageKHRResult {
        switch (self.fp_acquire_next_image_khr.?(self.handle, swapchain, timeout, semaphore, fence, p_image_index)) {
            .success => return .success,
            .timeout => return .timeout,
            .not_ready => return .not_ready,
            .suboptimal_khr => return .suboptimal_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_out_of_date_khr => return error.OutOfDateKhr,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_full_screen_exclusive_mode_lost_ext => return error.FullScreenExclusiveModeLostExt,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const QueuePresentKHRResult = enum {
        success,
        suboptimal_khr,
    };
    pub const QueuePresentKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        OutOfDateKhr,
        SurfaceLostKhr,
        FullScreenExclusiveModeLostExt,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn queue_present_khr(
        self: DeviceCommands,
        queue: Queue,
        p_present_info: *const PresentInfoKHR,
    ) QueuePresentKHRError!QueuePresentKHRResult {
        switch (self.fp_queue_present_khr.?(queue, p_present_info)) {
            .success => return .success,
            .suboptimal_khr => return .suboptimal_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_out_of_date_khr => return error.OutOfDateKhr,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_full_screen_exclusive_mode_lost_ext => return error.FullScreenExclusiveModeLostExt,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const DebugMarkerSetObjectNameEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn debug_marker_set_object_name_ext(
        self: DeviceCommands,
        p_name_info: *const DebugMarkerObjectNameInfoEXT,
    ) DebugMarkerSetObjectNameEXTError!void {
        switch (self.fp_debug_marker_set_object_name_ext.?(self.handle, p_name_info)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const DebugMarkerSetObjectTagEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn debug_marker_set_object_tag_ext(
        self: DeviceCommands,
        p_tag_info: *const DebugMarkerObjectTagInfoEXT,
    ) DebugMarkerSetObjectTagEXTError!void {
        switch (self.fp_debug_marker_set_object_tag_ext.?(self.handle, p_tag_info)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_debug_marker_begin_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_marker_info: *const DebugMarkerMarkerInfoEXT,
    ) void {
        self.fp_cmd_debug_marker_begin_ext.?(command_buffer, p_marker_info);
    }
    pub fn cmd_debug_marker_end_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
    ) void {
        self.fp_cmd_debug_marker_end_ext.?(command_buffer);
    }
    pub fn cmd_debug_marker_insert_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_marker_info: *const DebugMarkerMarkerInfoEXT,
    ) void {
        self.fp_cmd_debug_marker_insert_ext.?(command_buffer, p_marker_info);
    }
    pub const GetMemoryWin32HandleNVError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_memory_win32_handle_nv(
        self: DeviceCommands,
        memory: DeviceMemory,
        handle_type: ExternalMemoryHandleTypeFlagsNV,
    ) GetMemoryWin32HandleNVError!HANDLE {
        var p_handle: HANDLE = undefined;
        switch (self.fp_get_memory_win32_handle_nv.?(self.handle, memory, handle_type, &p_handle)) {
            .success => return p_handle,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_execute_generated_commands_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        is_preprocessed: bool,
        p_generated_commands_info: *const GeneratedCommandsInfoNV,
    ) void {
        self.fp_cmd_execute_generated_commands_nv.?(command_buffer, Bool32.from_bool(is_preprocessed), p_generated_commands_info);
    }
    pub fn cmd_preprocess_generated_commands_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_generated_commands_info: *const GeneratedCommandsInfoNV,
    ) void {
        self.fp_cmd_preprocess_generated_commands_nv.?(command_buffer, p_generated_commands_info);
    }
    pub fn cmd_bind_pipeline_shader_group_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        pipeline_bind_point: PipelineBindPoint,
        pipeline: Pipeline,
        group_index: u32,
    ) void {
        self.fp_cmd_bind_pipeline_shader_group_nv.?(command_buffer, pipeline_bind_point, pipeline, group_index);
    }
    pub fn get_generated_commands_memory_requirements_nv(
        self: DeviceCommands,
        p_info: *const GeneratedCommandsMemoryRequirementsInfoNV,
        p_memory_requirements: *MemoryRequirements2,
    ) void {
        self.fp_get_generated_commands_memory_requirements_nv.?(self.handle, p_info, p_memory_requirements);
    }
    pub const CreateIndirectCommandsLayoutNVError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_indirect_commands_layout_nv(
        self: DeviceCommands,
        p_create_info: *const IndirectCommandsLayoutCreateInfoNV,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateIndirectCommandsLayoutNVError!IndirectCommandsLayoutNV {
        var p_indirect_commands_layout: IndirectCommandsLayoutNV = undefined;
        switch (self.fp_create_indirect_commands_layout_nv.?(self.handle, p_create_info, p_allocator, &p_indirect_commands_layout)) {
            .success => return p_indirect_commands_layout,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_indirect_commands_layout_nv(
        self: DeviceCommands,
        indirect_commands_layout: IndirectCommandsLayoutNV,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_indirect_commands_layout_nv.?(self.handle, indirect_commands_layout, p_allocator);
    }
    pub fn cmd_execute_generated_commands_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        is_preprocessed: bool,
        p_generated_commands_info: *const GeneratedCommandsInfoEXT,
    ) void {
        self.fp_cmd_execute_generated_commands_ext.?(command_buffer, Bool32.from_bool(is_preprocessed), p_generated_commands_info);
    }
    pub fn cmd_preprocess_generated_commands_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_generated_commands_info: *const GeneratedCommandsInfoEXT,
        state_command_buffer: CommandBuffer,
    ) void {
        self.fp_cmd_preprocess_generated_commands_ext.?(command_buffer, p_generated_commands_info, state_command_buffer);
    }
    pub fn get_generated_commands_memory_requirements_ext(
        self: DeviceCommands,
        p_info: *const GeneratedCommandsMemoryRequirementsInfoEXT,
        p_memory_requirements: *MemoryRequirements2,
    ) void {
        self.fp_get_generated_commands_memory_requirements_ext.?(self.handle, p_info, p_memory_requirements);
    }
    pub const CreateIndirectCommandsLayoutEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_indirect_commands_layout_ext(
        self: DeviceCommands,
        p_create_info: *const IndirectCommandsLayoutCreateInfoEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateIndirectCommandsLayoutEXTError!IndirectCommandsLayoutEXT {
        var p_indirect_commands_layout: IndirectCommandsLayoutEXT = undefined;
        switch (self.fp_create_indirect_commands_layout_ext.?(self.handle, p_create_info, p_allocator, &p_indirect_commands_layout)) {
            .success => return p_indirect_commands_layout,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_indirect_commands_layout_ext(
        self: DeviceCommands,
        indirect_commands_layout: IndirectCommandsLayoutEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_indirect_commands_layout_ext.?(self.handle, indirect_commands_layout, p_allocator);
    }
    pub const CreateIndirectExecutionSetEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_indirect_execution_set_ext(
        self: DeviceCommands,
        p_create_info: *const IndirectExecutionSetCreateInfoEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateIndirectExecutionSetEXTError!IndirectExecutionSetEXT {
        var p_indirect_execution_set: IndirectExecutionSetEXT = undefined;
        switch (self.fp_create_indirect_execution_set_ext.?(self.handle, p_create_info, p_allocator, &p_indirect_execution_set)) {
            .success => return p_indirect_execution_set,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_indirect_execution_set_ext(
        self: DeviceCommands,
        indirect_execution_set: IndirectExecutionSetEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_indirect_execution_set_ext.?(self.handle, indirect_execution_set, p_allocator);
    }
    pub fn update_indirect_execution_set_pipeline_ext(
        self: DeviceCommands,
        indirect_execution_set: IndirectExecutionSetEXT,
        p_execution_set_writes: []const WriteIndirectExecutionSetPipelineEXT,
    ) void {
        const execution_set_write_count: u32 = @intCast(p_execution_set_writes.len);
        self.fp_update_indirect_execution_set_pipeline_ext.?(self.handle, indirect_execution_set, execution_set_write_count, p_execution_set_writes.ptr);
    }
    pub fn update_indirect_execution_set_shader_ext(
        self: DeviceCommands,
        indirect_execution_set: IndirectExecutionSetEXT,
        p_execution_set_writes: []const WriteIndirectExecutionSetShaderEXT,
    ) void {
        const execution_set_write_count: u32 = @intCast(p_execution_set_writes.len);
        self.fp_update_indirect_execution_set_shader_ext.?(self.handle, indirect_execution_set, execution_set_write_count, p_execution_set_writes.ptr);
    }
    pub fn cmd_push_descriptor_set(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        pipeline_bind_point: PipelineBindPoint,
        layout: PipelineLayout,
        set: u32,
        p_descriptor_writes: []const WriteDescriptorSet,
    ) void {
        const descriptor_write_count: u32 = @intCast(p_descriptor_writes.len);
        self.fp_cmd_push_descriptor_set.?(command_buffer, pipeline_bind_point, layout, set, descriptor_write_count, p_descriptor_writes.ptr);
    }
    pub fn trim_command_pool(
        self: DeviceCommands,
        command_pool: CommandPool,
        flags: CommandPoolTrimFlags,
    ) void {
        self.fp_trim_command_pool.?(self.handle, command_pool, flags);
    }
    pub const GetMemoryWin32HandleKHRError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_memory_win32_handle_khr(
        self: DeviceCommands,
        p_get_win32_handle_info: *const MemoryGetWin32HandleInfoKHR,
    ) GetMemoryWin32HandleKHRError!HANDLE {
        var p_handle: HANDLE = undefined;
        switch (self.fp_get_memory_win32_handle_khr.?(self.handle, p_get_win32_handle_info, &p_handle)) {
            .success => return p_handle,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetMemoryWin32HandlePropertiesKHRError = error{
        OutOfHostMemory,
        InvalidExternalHandle,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_memory_win32_handle_properties_khr(
        self: DeviceCommands,
        handle_type: ExternalMemoryHandleTypeFlags,
        handle: HANDLE,
        p_memory_win32_handle_properties: *MemoryWin32HandlePropertiesKHR,
    ) GetMemoryWin32HandlePropertiesKHRError!void {
        switch (self.fp_get_memory_win32_handle_properties_khr.?(self.handle, handle_type, handle, p_memory_win32_handle_properties)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_invalid_external_handle => return error.InvalidExternalHandle,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetMemoryFdKHRError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_memory_fd_khr(
        self: DeviceCommands,
        p_get_fd_info: *const MemoryGetFdInfoKHR,
    ) GetMemoryFdKHRError!c_int {
        var p_fd: c_int = undefined;
        switch (self.fp_get_memory_fd_khr.?(self.handle, p_get_fd_info, &p_fd)) {
            .success => return p_fd,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetMemoryFdPropertiesKHRError = error{
        OutOfHostMemory,
        InvalidExternalHandle,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_memory_fd_properties_khr(
        self: DeviceCommands,
        handle_type: ExternalMemoryHandleTypeFlags,
        fd: c_int,
        p_memory_fd_properties: *MemoryFdPropertiesKHR,
    ) GetMemoryFdPropertiesKHRError!void {
        switch (self.fp_get_memory_fd_properties_khr.?(self.handle, handle_type, fd, p_memory_fd_properties)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_invalid_external_handle => return error.InvalidExternalHandle,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetMemoryZirconHandleFUCHSIAError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_memory_zircon_handle_fuchsia(
        self: DeviceCommands,
        p_get_zircon_handle_info: *const MemoryGetZirconHandleInfoFUCHSIA,
    ) GetMemoryZirconHandleFUCHSIAError!zx_handle_t {
        var p_zircon_handle: zx_handle_t = undefined;
        switch (self.fp_get_memory_zircon_handle_fuchsia.?(self.handle, p_get_zircon_handle_info, &p_zircon_handle)) {
            .success => return p_zircon_handle,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetMemoryZirconHandlePropertiesFUCHSIAError = error{
        InvalidExternalHandle,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_memory_zircon_handle_properties_fuchsia(
        self: DeviceCommands,
        handle_type: ExternalMemoryHandleTypeFlags,
        zircon_handle: zx_handle_t,
        p_memory_zircon_handle_properties: *MemoryZirconHandlePropertiesFUCHSIA,
    ) GetMemoryZirconHandlePropertiesFUCHSIAError!void {
        switch (self.fp_get_memory_zircon_handle_properties_fuchsia.?(self.handle, handle_type, zircon_handle, p_memory_zircon_handle_properties)) {
            .success => return,
            .error_invalid_external_handle => return error.InvalidExternalHandle,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetMemoryRemoteAddressNVError = error{
        InvalidExternalHandle,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_memory_remote_address_nv(
        self: DeviceCommands,
        p_memory_get_remote_address_info: *const MemoryGetRemoteAddressInfoNV,
    ) GetMemoryRemoteAddressNVError!RemoteAddressNV {
        var p_address: RemoteAddressNV = undefined;
        switch (self.fp_get_memory_remote_address_nv.?(self.handle, p_memory_get_remote_address_info, &p_address)) {
            .success => return p_address,
            .error_invalid_external_handle => return error.InvalidExternalHandle,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetSemaphoreWin32HandleKHRError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_semaphore_win32_handle_khr(
        self: DeviceCommands,
        p_get_win32_handle_info: *const SemaphoreGetWin32HandleInfoKHR,
    ) GetSemaphoreWin32HandleKHRError!HANDLE {
        var p_handle: HANDLE = undefined;
        switch (self.fp_get_semaphore_win32_handle_khr.?(self.handle, p_get_win32_handle_info, &p_handle)) {
            .success => return p_handle,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const ImportSemaphoreWin32HandleKHRError = error{
        OutOfHostMemory,
        InvalidExternalHandle,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn import_semaphore_win32_handle_khr(
        self: DeviceCommands,
        p_import_semaphore_win32_handle_info: *const ImportSemaphoreWin32HandleInfoKHR,
    ) ImportSemaphoreWin32HandleKHRError!void {
        switch (self.fp_import_semaphore_win32_handle_khr.?(self.handle, p_import_semaphore_win32_handle_info)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_invalid_external_handle => return error.InvalidExternalHandle,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetSemaphoreFdKHRError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_semaphore_fd_khr(
        self: DeviceCommands,
        p_get_fd_info: *const SemaphoreGetFdInfoKHR,
    ) GetSemaphoreFdKHRError!c_int {
        var p_fd: c_int = undefined;
        switch (self.fp_get_semaphore_fd_khr.?(self.handle, p_get_fd_info, &p_fd)) {
            .success => return p_fd,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const ImportSemaphoreFdKHRError = error{
        OutOfHostMemory,
        InvalidExternalHandle,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn import_semaphore_fd_khr(
        self: DeviceCommands,
        p_import_semaphore_fd_info: *const ImportSemaphoreFdInfoKHR,
    ) ImportSemaphoreFdKHRError!void {
        switch (self.fp_import_semaphore_fd_khr.?(self.handle, p_import_semaphore_fd_info)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_invalid_external_handle => return error.InvalidExternalHandle,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetSemaphoreZirconHandleFUCHSIAError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_semaphore_zircon_handle_fuchsia(
        self: DeviceCommands,
        p_get_zircon_handle_info: *const SemaphoreGetZirconHandleInfoFUCHSIA,
    ) GetSemaphoreZirconHandleFUCHSIAError!zx_handle_t {
        var p_zircon_handle: zx_handle_t = undefined;
        switch (self.fp_get_semaphore_zircon_handle_fuchsia.?(self.handle, p_get_zircon_handle_info, &p_zircon_handle)) {
            .success => return p_zircon_handle,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const ImportSemaphoreZirconHandleFUCHSIAError = error{
        OutOfHostMemory,
        InvalidExternalHandle,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn import_semaphore_zircon_handle_fuchsia(
        self: DeviceCommands,
        p_import_semaphore_zircon_handle_info: *const ImportSemaphoreZirconHandleInfoFUCHSIA,
    ) ImportSemaphoreZirconHandleFUCHSIAError!void {
        switch (self.fp_import_semaphore_zircon_handle_fuchsia.?(self.handle, p_import_semaphore_zircon_handle_info)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_invalid_external_handle => return error.InvalidExternalHandle,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetFenceWin32HandleKHRError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_fence_win32_handle_khr(
        self: DeviceCommands,
        p_get_win32_handle_info: *const FenceGetWin32HandleInfoKHR,
    ) GetFenceWin32HandleKHRError!HANDLE {
        var p_handle: HANDLE = undefined;
        switch (self.fp_get_fence_win32_handle_khr.?(self.handle, p_get_win32_handle_info, &p_handle)) {
            .success => return p_handle,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const ImportFenceWin32HandleKHRError = error{
        OutOfHostMemory,
        InvalidExternalHandle,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn import_fence_win32_handle_khr(
        self: DeviceCommands,
        p_import_fence_win32_handle_info: *const ImportFenceWin32HandleInfoKHR,
    ) ImportFenceWin32HandleKHRError!void {
        switch (self.fp_import_fence_win32_handle_khr.?(self.handle, p_import_fence_win32_handle_info)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_invalid_external_handle => return error.InvalidExternalHandle,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetFenceFdKHRError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_fence_fd_khr(
        self: DeviceCommands,
        p_get_fd_info: *const FenceGetFdInfoKHR,
    ) GetFenceFdKHRError!c_int {
        var p_fd: c_int = undefined;
        switch (self.fp_get_fence_fd_khr.?(self.handle, p_get_fd_info, &p_fd)) {
            .success => return p_fd,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const ImportFenceFdKHRError = error{
        OutOfHostMemory,
        InvalidExternalHandle,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn import_fence_fd_khr(
        self: DeviceCommands,
        p_import_fence_fd_info: *const ImportFenceFdInfoKHR,
    ) ImportFenceFdKHRError!void {
        switch (self.fp_import_fence_fd_khr.?(self.handle, p_import_fence_fd_info)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_invalid_external_handle => return error.InvalidExternalHandle,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const AcquireWinrtDisplayNVError = error{
        OutOfHostMemory,
        DeviceLost,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn acquire_winrt_display_nv(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        display: DisplayKHR,
    ) AcquireWinrtDisplayNVError!void {
        switch (self.fp_acquire_winrt_display_nv.?(physical_device, display)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_device_lost => return error.DeviceLost,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetWinrtDisplayNVError = error{
        OutOfHostMemory,
        DeviceLost,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_winrt_display_nv(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        device_relative_id: u32,
    ) GetWinrtDisplayNVError!DisplayKHR {
        var p_display: DisplayKHR = undefined;
        switch (self.fp_get_winrt_display_nv.?(physical_device, device_relative_id, &p_display)) {
            .success => return p_display,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_device_lost => return error.DeviceLost,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const DisplayPowerControlEXTError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn display_power_control_ext(
        self: DeviceCommands,
        display: DisplayKHR,
        p_display_power_info: *const DisplayPowerInfoEXT,
    ) DisplayPowerControlEXTError!void {
        switch (self.fp_display_power_control_ext.?(self.handle, display, p_display_power_info)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const RegisterDeviceEventEXTError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn register_device_event_ext(
        self: DeviceCommands,
        p_device_event_info: *const DeviceEventInfoEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) RegisterDeviceEventEXTError!Fence {
        var p_fence: Fence = undefined;
        switch (self.fp_register_device_event_ext.?(self.handle, p_device_event_info, p_allocator, &p_fence)) {
            .success => return p_fence,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const RegisterDisplayEventEXTError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn register_display_event_ext(
        self: DeviceCommands,
        display: DisplayKHR,
        p_display_event_info: *const DisplayEventInfoEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) RegisterDisplayEventEXTError!Fence {
        var p_fence: Fence = undefined;
        switch (self.fp_register_display_event_ext.?(self.handle, display, p_display_event_info, p_allocator, &p_fence)) {
            .success => return p_fence,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetSwapchainCounterEXTError = error{
        OutOfHostMemory,
        DeviceLost,
        OutOfDateKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_swapchain_counter_ext(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
        counter: SurfaceCounterFlagsEXT,
    ) GetSwapchainCounterEXTError!u64 {
        var p_counter_value: u64 = undefined;
        switch (self.fp_get_swapchain_counter_ext.?(self.handle, swapchain, counter, &p_counter_value)) {
            .success => return p_counter_value,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_device_lost => return error.DeviceLost,
            .error_out_of_date_khr => return error.OutOfDateKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_device_group_peer_memory_features(
        self: DeviceCommands,
        heap_index: u32,
        local_device_index: u32,
        remote_device_index: u32,
    ) PeerMemoryFeatureFlags {
        var p_peer_memory_features: PeerMemoryFeatureFlags = undefined;
        self.fp_get_device_group_peer_memory_features.?(self.handle, heap_index, local_device_index, remote_device_index, &p_peer_memory_features);
        return p_peer_memory_features;
    }
    pub const BindBufferMemory2Error = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InvalidOpaqueCaptureAddress,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn bind_buffer_memory2(
        self: DeviceCommands,
        p_bind_infos: []const BindBufferMemoryInfo,
    ) BindBufferMemory2Error!void {
        const bind_info_count: u32 = @intCast(p_bind_infos.len);
        switch (self.fp_bind_buffer_memory2.?(self.handle, bind_info_count, p_bind_infos.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_invalid_opaque_capture_address => return error.InvalidOpaqueCaptureAddress,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const BindImageMemory2Error = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn bind_image_memory2(
        self: DeviceCommands,
        p_bind_infos: []const BindImageMemoryInfo,
    ) BindImageMemory2Error!void {
        const bind_info_count: u32 = @intCast(p_bind_infos.len);
        switch (self.fp_bind_image_memory2.?(self.handle, bind_info_count, p_bind_infos.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_set_device_mask(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        device_mask: u32,
    ) void {
        self.fp_cmd_set_device_mask.?(command_buffer, device_mask);
    }
    pub const GetDeviceGroupPresentCapabilitiesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_device_group_present_capabilities_khr(
        self: DeviceCommands,
        p_device_group_present_capabilities: *DeviceGroupPresentCapabilitiesKHR,
    ) GetDeviceGroupPresentCapabilitiesKHRError!void {
        switch (self.fp_get_device_group_present_capabilities_khr.?(self.handle, p_device_group_present_capabilities)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetDeviceGroupSurfacePresentModesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_device_group_surface_present_modes_khr(
        self: DeviceCommands,
        surface: SurfaceKHR,
    ) GetDeviceGroupSurfacePresentModesKHRError!DeviceGroupPresentModeFlagsKHR {
        var p_modes: DeviceGroupPresentModeFlagsKHR = undefined;
        switch (self.fp_get_device_group_surface_present_modes_khr.?(self.handle, surface, &p_modes)) {
            .success => return p_modes,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const AcquireNextImage2KHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        OutOfDateKhr,
        SurfaceLostKhr,
        FullScreenExclusiveModeLostExt,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn acquire_next_image2_khr(
        self: DeviceCommands,
        p_acquire_info: *const AcquireNextImageInfoKHR,
        p_image_index: *u32,
    ) AcquireNextImage2KHRError!AcquireNextImageKHRResult {
        switch (self.fp_acquire_next_image2_khr.?(self.handle, p_acquire_info, p_image_index)) {
            .success => return .success,
            .timeout => return .timeout,
            .not_ready => return .not_ready,
            .suboptimal_khr => return .suboptimal_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_out_of_date_khr => return error.OutOfDateKhr,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_full_screen_exclusive_mode_lost_ext => return error.FullScreenExclusiveModeLostExt,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_dispatch_base(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        base_group_x: u32,
        base_group_y: u32,
        base_group_z: u32,
        group_count_x: u32,
        group_count_y: u32,
        group_count_z: u32,
    ) void {
        self.fp_cmd_dispatch_base.?(command_buffer, base_group_x, base_group_y, base_group_z, group_count_x, group_count_y, group_count_z);
    }
    pub const GetPhysicalDevicePresentRectanglesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_present_rectangles_khr(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        surface: SurfaceKHR,
        p_rect_count: *u32,
        p_rects: ?[*]Rect2D,
    ) GetPhysicalDevicePresentRectanglesKHRError!EnumerateResult {
        switch (self.fp_get_physical_device_present_rectangles_khr.?(physical_device, surface, p_rect_count, p_rects)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDevicePresentRectanglesKHROrAllocatorError = GetPhysicalDevicePresentRectanglesKHRError || Allocator.Error;
    pub fn get_physical_device_present_rectangles_khr_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
        surface: SurfaceKHR,
    ) GetPhysicalDevicePresentRectanglesKHROrAllocatorError![]Rect2D {
        const enumerator = struct {
            self: *const DeviceCommands,
            physical_device: PhysicalDevice,
            surface: SurfaceKHR,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]Rect2D) !EnumerateResult {
                return enumerator.self.get_physical_device_present_rectangles_khr(
                    enumerator.physical_device,
                    enumerator.surface,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
            .surface = surface,
        };
        return enumerate_generic_to_array(GetPhysicalDevicePresentRectanglesKHROrAllocatorError, Rect2D, enumerator, allocator);
    }
    pub const CreateDescriptorUpdateTemplateError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_descriptor_update_template(
        self: DeviceCommands,
        p_create_info: *const DescriptorUpdateTemplateCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateDescriptorUpdateTemplateError!DescriptorUpdateTemplate {
        var p_descriptor_update_template: DescriptorUpdateTemplate = undefined;
        switch (self.fp_create_descriptor_update_template.?(self.handle, p_create_info, p_allocator, &p_descriptor_update_template)) {
            .success => return p_descriptor_update_template,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_descriptor_update_template(
        self: DeviceCommands,
        descriptor_update_template: DescriptorUpdateTemplate,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_descriptor_update_template.?(self.handle, descriptor_update_template, p_allocator);
    }
    pub fn update_descriptor_set_with_template(
        self: DeviceCommands,
        descriptor_set: DescriptorSet,
        descriptor_update_template: DescriptorUpdateTemplate,
        p_data: *const anyopaque,
    ) void {
        self.fp_update_descriptor_set_with_template.?(self.handle, descriptor_set, descriptor_update_template, p_data);
    }
    pub fn cmd_push_descriptor_set_with_template(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        descriptor_update_template: DescriptorUpdateTemplate,
        layout: PipelineLayout,
        set: u32,
        p_data: *const anyopaque,
    ) void {
        self.fp_cmd_push_descriptor_set_with_template.?(command_buffer, descriptor_update_template, layout, set, p_data);
    }
    pub fn set_hdr_metadata_ext(
        self: DeviceCommands,
        p_swapchains: []const SwapchainKHR,
        p_metadata: []const HdrMetadataEXT,
    ) void {
        const swapchain_count: u32 = @intCast(p_swapchains.len);
        assert(swapchain_count == p_metadata.len);
        self.fp_set_hdr_metadata_ext.?(self.handle, swapchain_count, p_swapchains.ptr, p_metadata.ptr);
    }
    pub const GetSwapchainStatusKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        OutOfDateKhr,
        SurfaceLostKhr,
        FullScreenExclusiveModeLostExt,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_swapchain_status_khr(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
    ) GetSwapchainStatusKHRError!QueuePresentKHRResult {
        switch (self.fp_get_swapchain_status_khr.?(self.handle, swapchain)) {
            .success => return .success,
            .suboptimal_khr => return .suboptimal_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_out_of_date_khr => return error.OutOfDateKhr,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_full_screen_exclusive_mode_lost_ext => return error.FullScreenExclusiveModeLostExt,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetRefreshCycleDurationGOOGLEError = error{
        OutOfHostMemory,
        DeviceLost,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_refresh_cycle_duration_google(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
    ) GetRefreshCycleDurationGOOGLEError!RefreshCycleDurationGOOGLE {
        var p_display_timing_properties: RefreshCycleDurationGOOGLE = undefined;
        switch (self.fp_get_refresh_cycle_duration_google.?(self.handle, swapchain, &p_display_timing_properties)) {
            .success => return p_display_timing_properties,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_device_lost => return error.DeviceLost,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPastPresentationTimingGOOGLEError = error{
        OutOfHostMemory,
        DeviceLost,
        OutOfDateKhr,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_past_presentation_timing_google(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
        p_presentation_timing_count: *u32,
        p_presentation_timings: ?[*]PastPresentationTimingGOOGLE,
    ) GetPastPresentationTimingGOOGLEError!EnumerateResult {
        switch (self.fp_get_past_presentation_timing_google.?(self.handle, swapchain, p_presentation_timing_count, p_presentation_timings)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_device_lost => return error.DeviceLost,
            .error_out_of_date_khr => return error.OutOfDateKhr,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPastPresentationTimingGOOGLEOrAllocatorError = GetPastPresentationTimingGOOGLEError || Allocator.Error;
    pub fn get_past_presentation_timing_google_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        swapchain: SwapchainKHR,
    ) GetPastPresentationTimingGOOGLEOrAllocatorError![]PastPresentationTimingGOOGLE {
        const enumerator = struct {
            self: *const DeviceCommands,
            swapchain: SwapchainKHR,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]PastPresentationTimingGOOGLE) !EnumerateResult {
                return enumerator.self.get_past_presentation_timing_google(
                    enumerator.swapchain,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .swapchain = swapchain,
        };
        return enumerate_generic_to_array(GetPastPresentationTimingGOOGLEOrAllocatorError, PastPresentationTimingGOOGLE, enumerator, allocator);
    }
    pub fn cmd_set_viewport_w_scaling_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_viewport: u32,
        p_viewport_w_scalings: []const ViewportWScalingNV,
    ) void {
        const viewport_count: u32 = @intCast(p_viewport_w_scalings.len);
        self.fp_cmd_set_viewport_w_scaling_nv.?(command_buffer, first_viewport, viewport_count, p_viewport_w_scalings.ptr);
    }
    pub fn cmd_set_discard_rectangle_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_discard_rectangle: u32,
        p_discard_rectangles: []const Rect2D,
    ) void {
        const discard_rectangle_count: u32 = @intCast(p_discard_rectangles.len);
        self.fp_cmd_set_discard_rectangle_ext.?(command_buffer, first_discard_rectangle, discard_rectangle_count, p_discard_rectangles.ptr);
    }
    pub fn cmd_set_discard_rectangle_enable_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        discard_rectangle_enable: bool,
    ) void {
        self.fp_cmd_set_discard_rectangle_enable_ext.?(command_buffer, Bool32.from_bool(discard_rectangle_enable));
    }
    pub fn cmd_set_discard_rectangle_mode_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        discard_rectangle_mode: DiscardRectangleModeEXT,
    ) void {
        self.fp_cmd_set_discard_rectangle_mode_ext.?(command_buffer, discard_rectangle_mode);
    }
    pub fn cmd_set_sample_locations_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_sample_locations_info: *const SampleLocationsInfoEXT,
    ) void {
        self.fp_cmd_set_sample_locations_ext.?(command_buffer, p_sample_locations_info);
    }
    pub fn get_physical_device_multisample_properties_ext(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        samples: SampleCountFlags,
        p_multisample_properties: *MultisamplePropertiesEXT,
    ) void {
        self.fp_get_physical_device_multisample_properties_ext.?(physical_device, samples, p_multisample_properties);
    }
    pub fn get_buffer_memory_requirements2(
        self: DeviceCommands,
        p_info: *const BufferMemoryRequirementsInfo2,
        p_memory_requirements: *MemoryRequirements2,
    ) void {
        self.fp_get_buffer_memory_requirements2.?(self.handle, p_info, p_memory_requirements);
    }
    pub fn get_image_memory_requirements2(
        self: DeviceCommands,
        p_info: *const ImageMemoryRequirementsInfo2,
        p_memory_requirements: *MemoryRequirements2,
    ) void {
        self.fp_get_image_memory_requirements2.?(self.handle, p_info, p_memory_requirements);
    }
    pub fn get_image_sparse_memory_requirements2(
        self: DeviceCommands,
        p_info: *const ImageSparseMemoryRequirementsInfo2,
        p_sparse_memory_requirement_count: *u32,
        p_sparse_memory_requirements: ?[*]SparseImageMemoryRequirements2,
    ) void {
        self.fp_get_image_sparse_memory_requirements2.?(self.handle, p_info, p_sparse_memory_requirement_count, p_sparse_memory_requirements);
    }
    pub fn get_image_sparse_memory_requirements2_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        p_info: *const ImageSparseMemoryRequirementsInfo2,
    ) Allocator.Error![]SparseImageMemoryRequirements2 {
        const enumerator = struct {
            self: *const DeviceCommands,
            p_info: *const ImageSparseMemoryRequirementsInfo2,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]SparseImageMemoryRequirements2) void {
                return enumerator.self.get_image_sparse_memory_requirements2(
                    enumerator.p_info,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .p_info = p_info,
        };
        return enumerate_generic_unchecked_to_array(SparseImageMemoryRequirements2, enumerator, allocator);
    }
    pub fn get_device_buffer_memory_requirements(
        self: DeviceCommands,
        p_info: *const DeviceBufferMemoryRequirements,
        p_memory_requirements: *MemoryRequirements2,
    ) void {
        self.fp_get_device_buffer_memory_requirements.?(self.handle, p_info, p_memory_requirements);
    }
    pub fn get_device_image_memory_requirements(
        self: DeviceCommands,
        p_info: *const DeviceImageMemoryRequirements,
        p_memory_requirements: *MemoryRequirements2,
    ) void {
        self.fp_get_device_image_memory_requirements.?(self.handle, p_info, p_memory_requirements);
    }
    pub fn get_device_image_sparse_memory_requirements(
        self: DeviceCommands,
        p_info: *const DeviceImageMemoryRequirements,
        p_sparse_memory_requirement_count: *u32,
        p_sparse_memory_requirements: ?[*]SparseImageMemoryRequirements2,
    ) void {
        self.fp_get_device_image_sparse_memory_requirements.?(self.handle, p_info, p_sparse_memory_requirement_count, p_sparse_memory_requirements);
    }
    pub fn get_device_image_sparse_memory_requirements_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        p_info: *const DeviceImageMemoryRequirements,
    ) Allocator.Error![]SparseImageMemoryRequirements2 {
        const enumerator = struct {
            self: *const DeviceCommands,
            p_info: *const DeviceImageMemoryRequirements,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]SparseImageMemoryRequirements2) void {
                return enumerator.self.get_device_image_sparse_memory_requirements(
                    enumerator.p_info,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .p_info = p_info,
        };
        return enumerate_generic_unchecked_to_array(SparseImageMemoryRequirements2, enumerator, allocator);
    }
    pub const CreateSamplerYcbcrConversionError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_sampler_ycbcr_conversion(
        self: DeviceCommands,
        p_create_info: *const SamplerYcbcrConversionCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateSamplerYcbcrConversionError!SamplerYcbcrConversion {
        var p_ycbcr_conversion: SamplerYcbcrConversion = undefined;
        switch (self.fp_create_sampler_ycbcr_conversion.?(self.handle, p_create_info, p_allocator, &p_ycbcr_conversion)) {
            .success => return p_ycbcr_conversion,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_sampler_ycbcr_conversion(
        self: DeviceCommands,
        ycbcr_conversion: SamplerYcbcrConversion,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_sampler_ycbcr_conversion.?(self.handle, ycbcr_conversion, p_allocator);
    }
    pub fn get_device_queue2(
        self: DeviceCommands,
        p_queue_info: *const DeviceQueueInfo2,
    ) Queue {
        var p_queue: Queue = undefined;
        self.fp_get_device_queue2.?(self.handle, p_queue_info, &p_queue);
        return p_queue;
    }
    pub const CreateValidationCacheEXTError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_validation_cache_ext(
        self: DeviceCommands,
        p_create_info: *const ValidationCacheCreateInfoEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateValidationCacheEXTError!ValidationCacheEXT {
        var p_validation_cache: ValidationCacheEXT = undefined;
        switch (self.fp_create_validation_cache_ext.?(self.handle, p_create_info, p_allocator, &p_validation_cache)) {
            .success => return p_validation_cache,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_validation_cache_ext(
        self: DeviceCommands,
        validation_cache: ValidationCacheEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_validation_cache_ext.?(self.handle, validation_cache, p_allocator);
    }
    pub const GetValidationCacheDataEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_validation_cache_data_ext(
        self: DeviceCommands,
        validation_cache: ValidationCacheEXT,
        p_data_size: *usize,
        p_data: ?*anyopaque,
    ) GetValidationCacheDataEXTError!EnumerateResult {
        switch (self.fp_get_validation_cache_data_ext.?(self.handle, validation_cache, p_data_size, p_data)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const MergeValidationCachesEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn merge_validation_caches_ext(
        self: DeviceCommands,
        dst_cache: ValidationCacheEXT,
        p_src_caches: []const ValidationCacheEXT,
    ) MergeValidationCachesEXTError!void {
        const src_cache_count: u32 = @intCast(p_src_caches.len);
        switch (self.fp_merge_validation_caches_ext.?(self.handle, dst_cache, src_cache_count, p_src_caches.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_descriptor_set_layout_support(
        self: DeviceCommands,
        p_create_info: *const DescriptorSetLayoutCreateInfo,
        p_support: *DescriptorSetLayoutSupport,
    ) void {
        self.fp_get_descriptor_set_layout_support.?(self.handle, p_create_info, p_support);
    }
    pub const GetShaderInfoAMDError = error{
        FeatureNotPresent,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_shader_info_amd(
        self: DeviceCommands,
        pipeline: Pipeline,
        shader_stage: ShaderStageFlags,
        info_type: ShaderInfoTypeAMD,
        p_info_size: *usize,
        p_info: ?*anyopaque,
    ) GetShaderInfoAMDError!EnumerateResult {
        switch (self.fp_get_shader_info_amd.?(self.handle, pipeline, shader_stage, info_type, p_info_size, p_info)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_feature_not_present => return error.FeatureNotPresent,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn set_local_dimming_amd(
        self: DeviceCommands,
        swap_chain: SwapchainKHR,
        local_dimming_enable: bool,
    ) void {
        self.fp_set_local_dimming_amd.?(self.handle, swap_chain, Bool32.from_bool(local_dimming_enable));
    }
    pub const GetPhysicalDeviceCalibrateableTimeDomainsKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_calibrateable_time_domains_khr(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        p_time_domain_count: *u32,
        p_time_domains: ?[*]TimeDomainKHR,
    ) GetPhysicalDeviceCalibrateableTimeDomainsKHRError!EnumerateResult {
        switch (self.fp_get_physical_device_calibrateable_time_domains_khr.?(physical_device, p_time_domain_count, p_time_domains)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceCalibrateableTimeDomainsKHROrAllocatorError = GetPhysicalDeviceCalibrateableTimeDomainsKHRError || Allocator.Error;
    pub fn get_physical_device_calibrateable_time_domains_khr_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
    ) GetPhysicalDeviceCalibrateableTimeDomainsKHROrAllocatorError![]TimeDomainKHR {
        const enumerator = struct {
            self: *const DeviceCommands,
            physical_device: PhysicalDevice,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]TimeDomainKHR) !EnumerateResult {
                return enumerator.self.get_physical_device_calibrateable_time_domains_khr(
                    enumerator.physical_device,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceCalibrateableTimeDomainsKHROrAllocatorError, TimeDomainKHR, enumerator, allocator);
    }
    pub const GetCalibratedTimestampsKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_calibrated_timestamps_khr(
        self: DeviceCommands,
        p_timestamp_infos: []const CalibratedTimestampInfoKHR,
        p_timestamps: []u64,
    ) GetCalibratedTimestampsKHRError!u64 {
        const timestamp_count: u32 = @intCast(p_timestamp_infos.len);
        assert(timestamp_count == p_timestamps.len);
        var p_max_deviation: u64 = undefined;
        switch (self.fp_get_calibrated_timestamps_khr.?(self.handle, timestamp_count, p_timestamp_infos.ptr, p_timestamps.ptr, &p_max_deviation)) {
            .success => return p_max_deviation,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetMemoryHostPointerPropertiesEXTError = error{
        OutOfHostMemory,
        InvalidExternalHandle,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_memory_host_pointer_properties_ext(
        self: DeviceCommands,
        handle_type: ExternalMemoryHandleTypeFlags,
        p_host_pointer: *const anyopaque,
        p_memory_host_pointer_properties: *MemoryHostPointerPropertiesEXT,
    ) GetMemoryHostPointerPropertiesEXTError!void {
        switch (self.fp_get_memory_host_pointer_properties_ext.?(self.handle, handle_type, p_host_pointer, p_memory_host_pointer_properties)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_invalid_external_handle => return error.InvalidExternalHandle,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_write_buffer_marker_amd(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        pipeline_stage: PipelineStageFlags,
        dst_buffer: Buffer,
        dst_offset: DeviceSize,
        marker: u32,
    ) void {
        self.fp_cmd_write_buffer_marker_amd.?(command_buffer, pipeline_stage, dst_buffer, dst_offset, marker);
    }
    pub const CreateRenderPass2Error = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_render_pass2(
        self: DeviceCommands,
        p_create_info: *const RenderPassCreateInfo2,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateRenderPass2Error!RenderPass {
        var p_render_pass: RenderPass = undefined;
        switch (self.fp_create_render_pass2.?(self.handle, p_create_info, p_allocator, &p_render_pass)) {
            .success => return p_render_pass,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_begin_render_pass2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_render_pass_begin: *const RenderPassBeginInfo,
        p_subpass_begin_info: *const SubpassBeginInfo,
    ) void {
        self.fp_cmd_begin_render_pass2.?(command_buffer, p_render_pass_begin, p_subpass_begin_info);
    }
    pub fn cmd_next_subpass2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_subpass_begin_info: *const SubpassBeginInfo,
        p_subpass_end_info: *const SubpassEndInfo,
    ) void {
        self.fp_cmd_next_subpass2.?(command_buffer, p_subpass_begin_info, p_subpass_end_info);
    }
    pub fn cmd_end_render_pass2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_subpass_end_info: *const SubpassEndInfo,
    ) void {
        self.fp_cmd_end_render_pass2.?(command_buffer, p_subpass_end_info);
    }
    pub const GetSemaphoreCounterValueError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_semaphore_counter_value(
        self: DeviceCommands,
        semaphore: Semaphore,
    ) GetSemaphoreCounterValueError!u64 {
        var p_value: u64 = undefined;
        switch (self.fp_get_semaphore_counter_value.?(self.handle, semaphore, &p_value)) {
            .success => return p_value,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const WaitSemaphoresError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn wait_semaphores(
        self: DeviceCommands,
        p_wait_info: *const SemaphoreWaitInfo,
        timeout: u64,
    ) WaitSemaphoresError!WaitForFencesResult {
        switch (self.fp_wait_semaphores.?(self.handle, p_wait_info, timeout)) {
            .success => return .success,
            .timeout => return .timeout,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const SignalSemaphoreError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn signal_semaphore(
        self: DeviceCommands,
        p_signal_info: *const SemaphoreSignalInfo,
    ) SignalSemaphoreError!void {
        switch (self.fp_signal_semaphore.?(self.handle, p_signal_info)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetAndroidHardwareBufferPropertiesANDROIDError = error{
        OutOfHostMemory,
        InvalidExternalHandle,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_android_hardware_buffer_properties_android(
        self: DeviceCommands,
        buffer: *const AHardwareBuffer,
        p_properties: *AndroidHardwareBufferPropertiesANDROID,
    ) GetAndroidHardwareBufferPropertiesANDROIDError!void {
        switch (self.fp_get_android_hardware_buffer_properties_android.?(self.handle, buffer, p_properties)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_invalid_external_handle => return error.InvalidExternalHandle,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetMemoryAndroidHardwareBufferANDROIDError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_memory_android_hardware_buffer_android(
        self: DeviceCommands,
        p_info: *const MemoryGetAndroidHardwareBufferInfoANDROID,
    ) GetMemoryAndroidHardwareBufferANDROIDError!?*AHardwareBuffer {
        var p_buffer: ?*AHardwareBuffer = undefined;
        switch (self.fp_get_memory_android_hardware_buffer_android.?(self.handle, p_info, &p_buffer)) {
            .success => return p_buffer,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_draw_indirect_count(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        count_buffer: Buffer,
        count_buffer_offset: DeviceSize,
        max_draw_count: u32,
        stride: u32,
    ) void {
        self.fp_cmd_draw_indirect_count.?(command_buffer, buffer, offset, count_buffer, count_buffer_offset, max_draw_count, stride);
    }
    pub fn cmd_draw_indexed_indirect_count(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        count_buffer: Buffer,
        count_buffer_offset: DeviceSize,
        max_draw_count: u32,
        stride: u32,
    ) void {
        self.fp_cmd_draw_indexed_indirect_count.?(command_buffer, buffer, offset, count_buffer, count_buffer_offset, max_draw_count, stride);
    }
    pub fn cmd_set_checkpoint_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_checkpoint_marker: *const anyopaque,
    ) void {
        self.fp_cmd_set_checkpoint_nv.?(command_buffer, p_checkpoint_marker);
    }
    pub fn get_queue_checkpoint_data_nv(
        self: DeviceCommands,
        queue: Queue,
        p_checkpoint_data_count: *u32,
        p_checkpoint_data: ?[*]CheckpointDataNV,
    ) void {
        self.fp_get_queue_checkpoint_data_nv.?(queue, p_checkpoint_data_count, p_checkpoint_data);
    }
    pub fn get_queue_checkpoint_data_nv_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        queue: Queue,
    ) Allocator.Error![]CheckpointDataNV {
        const enumerator = struct {
            self: *const DeviceCommands,
            queue: Queue,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]CheckpointDataNV) void {
                return enumerator.self.get_queue_checkpoint_data_nv(
                    enumerator.queue,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .queue = queue,
        };
        return enumerate_generic_unchecked_to_array(CheckpointDataNV, enumerator, allocator);
    }
    pub fn cmd_bind_transform_feedback_buffers_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_binding: u32,
        p_buffers: []const Buffer,
        p_offsets: []const DeviceSize,
        p_sizes: ?[]const DeviceSize,
    ) void {
        const binding_count: u32 = @intCast(p_buffers.len);
        assert(binding_count == p_offsets.len);
        if (p_sizes) |s| {
            assert(binding_count == s.len);
        }
        self.fp_cmd_bind_transform_feedback_buffers_ext.?(command_buffer, first_binding, binding_count, p_buffers.ptr, p_offsets.ptr, if (p_sizes) |slice| slice.ptr orelse null);
    }
    pub fn cmd_begin_transform_feedback_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_counter_buffer: u32,
        p_counter_buffers: []const Buffer,
        p_counter_buffer_offsets: ?[]const DeviceSize,
    ) void {
        const counter_buffer_count: u32 = @intCast(p_counter_buffers.len);
        if (p_counter_buffer_offsets) |s| {
            assert(counter_buffer_count == s.len);
        }
        self.fp_cmd_begin_transform_feedback_ext.?(command_buffer, first_counter_buffer, counter_buffer_count, p_counter_buffers.ptr, if (p_counter_buffer_offsets) |slice| slice.ptr orelse null);
    }
    pub fn cmd_end_transform_feedback_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_counter_buffer: u32,
        p_counter_buffers: []const Buffer,
        p_counter_buffer_offsets: ?[]const DeviceSize,
    ) void {
        const counter_buffer_count: u32 = @intCast(p_counter_buffers.len);
        if (p_counter_buffer_offsets) |s| {
            assert(counter_buffer_count == s.len);
        }
        self.fp_cmd_end_transform_feedback_ext.?(command_buffer, first_counter_buffer, counter_buffer_count, p_counter_buffers.ptr, if (p_counter_buffer_offsets) |slice| slice.ptr orelse null);
    }
    pub fn cmd_begin_query_indexed_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        query_pool: QueryPool,
        query: u32,
        flags: QueryControlFlags,
        index: u32,
    ) void {
        self.fp_cmd_begin_query_indexed_ext.?(command_buffer, query_pool, query, flags, index);
    }
    pub fn cmd_end_query_indexed_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        query_pool: QueryPool,
        query: u32,
        index: u32,
    ) void {
        self.fp_cmd_end_query_indexed_ext.?(command_buffer, query_pool, query, index);
    }
    pub fn cmd_draw_indirect_byte_count_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        instance_count: u32,
        first_instance: u32,
        counter_buffer: Buffer,
        counter_buffer_offset: DeviceSize,
        counter_offset: u32,
        vertex_stride: u32,
    ) void {
        self.fp_cmd_draw_indirect_byte_count_ext.?(command_buffer, instance_count, first_instance, counter_buffer, counter_buffer_offset, counter_offset, vertex_stride);
    }
    pub fn cmd_set_exclusive_scissor_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_exclusive_scissor: u32,
        p_exclusive_scissors: []const Rect2D,
    ) void {
        const exclusive_scissor_count: u32 = @intCast(p_exclusive_scissors.len);
        self.fp_cmd_set_exclusive_scissor_nv.?(command_buffer, first_exclusive_scissor, exclusive_scissor_count, p_exclusive_scissors.ptr);
    }
    pub fn cmd_set_exclusive_scissor_enable_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_exclusive_scissor: u32,
        p_exclusive_scissor_enables: []const Bool32,
    ) void {
        const exclusive_scissor_count: u32 = @intCast(p_exclusive_scissor_enables.len);
        self.fp_cmd_set_exclusive_scissor_enable_nv.?(command_buffer, first_exclusive_scissor, exclusive_scissor_count, p_exclusive_scissor_enables.ptr);
    }
    pub fn cmd_bind_shading_rate_image_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        image_view: ImageView,
        image_layout: ImageLayout,
    ) void {
        self.fp_cmd_bind_shading_rate_image_nv.?(command_buffer, image_view, image_layout);
    }
    pub fn cmd_set_viewport_shading_rate_palette_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_viewport: u32,
        p_shading_rate_palettes: []const ShadingRatePaletteNV,
    ) void {
        const viewport_count: u32 = @intCast(p_shading_rate_palettes.len);
        self.fp_cmd_set_viewport_shading_rate_palette_nv.?(command_buffer, first_viewport, viewport_count, p_shading_rate_palettes.ptr);
    }
    pub fn cmd_set_coarse_sample_order_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        sample_order_type: CoarseSampleOrderTypeNV,
        p_custom_sample_orders: []const CoarseSampleOrderCustomNV,
    ) void {
        const custom_sample_order_count: u32 = @intCast(p_custom_sample_orders.len);
        self.fp_cmd_set_coarse_sample_order_nv.?(command_buffer, sample_order_type, custom_sample_order_count, p_custom_sample_orders.ptr);
    }
    pub fn cmd_draw_mesh_tasks_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        task_count: u32,
        first_task: u32,
    ) void {
        self.fp_cmd_draw_mesh_tasks_nv.?(command_buffer, task_count, first_task);
    }
    pub fn cmd_draw_mesh_tasks_indirect_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        draw_count: u32,
        stride: u32,
    ) void {
        self.fp_cmd_draw_mesh_tasks_indirect_nv.?(command_buffer, buffer, offset, draw_count, stride);
    }
    pub fn cmd_draw_mesh_tasks_indirect_count_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        count_buffer: Buffer,
        count_buffer_offset: DeviceSize,
        max_draw_count: u32,
        stride: u32,
    ) void {
        self.fp_cmd_draw_mesh_tasks_indirect_count_nv.?(command_buffer, buffer, offset, count_buffer, count_buffer_offset, max_draw_count, stride);
    }
    pub fn cmd_draw_mesh_tasks_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        group_count_x: u32,
        group_count_y: u32,
        group_count_z: u32,
    ) void {
        self.fp_cmd_draw_mesh_tasks_ext.?(command_buffer, group_count_x, group_count_y, group_count_z);
    }
    pub fn cmd_draw_mesh_tasks_indirect_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        draw_count: u32,
        stride: u32,
    ) void {
        self.fp_cmd_draw_mesh_tasks_indirect_ext.?(command_buffer, buffer, offset, draw_count, stride);
    }
    pub fn cmd_draw_mesh_tasks_indirect_count_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        count_buffer: Buffer,
        count_buffer_offset: DeviceSize,
        max_draw_count: u32,
        stride: u32,
    ) void {
        self.fp_cmd_draw_mesh_tasks_indirect_count_ext.?(command_buffer, buffer, offset, count_buffer, count_buffer_offset, max_draw_count, stride);
    }
    pub const CompileDeferredNVError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn compile_deferred_nv(
        self: DeviceCommands,
        pipeline: Pipeline,
        shader: u32,
    ) CompileDeferredNVError!void {
        switch (self.fp_compile_deferred_nv.?(self.handle, pipeline, shader)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateAccelerationStructureNVError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_acceleration_structure_nv(
        self: DeviceCommands,
        p_create_info: *const AccelerationStructureCreateInfoNV,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateAccelerationStructureNVError!AccelerationStructureNV {
        var p_acceleration_structure: AccelerationStructureNV = undefined;
        switch (self.fp_create_acceleration_structure_nv.?(self.handle, p_create_info, p_allocator, &p_acceleration_structure)) {
            .success => return p_acceleration_structure,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_bind_invocation_mask_huawei(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        image_view: ImageView,
        image_layout: ImageLayout,
    ) void {
        self.fp_cmd_bind_invocation_mask_huawei.?(command_buffer, image_view, image_layout);
    }
    pub fn destroy_acceleration_structure_khr(
        self: DeviceCommands,
        acceleration_structure: AccelerationStructureKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_acceleration_structure_khr.?(self.handle, acceleration_structure, p_allocator);
    }
    pub fn destroy_acceleration_structure_nv(
        self: DeviceCommands,
        acceleration_structure: AccelerationStructureNV,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_acceleration_structure_nv.?(self.handle, acceleration_structure, p_allocator);
    }
    pub fn get_acceleration_structure_memory_requirements_nv(
        self: DeviceCommands,
        p_info: *const AccelerationStructureMemoryRequirementsInfoNV,
    ) MemoryRequirements2KHR {
        var p_memory_requirements: MemoryRequirements2KHR = undefined;
        self.fp_get_acceleration_structure_memory_requirements_nv.?(self.handle, p_info, &p_memory_requirements);
        return p_memory_requirements;
    }
    pub const BindAccelerationStructureMemoryNVError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn bind_acceleration_structure_memory_nv(
        self: DeviceCommands,
        p_bind_infos: []const BindAccelerationStructureMemoryInfoNV,
    ) BindAccelerationStructureMemoryNVError!void {
        const bind_info_count: u32 = @intCast(p_bind_infos.len);
        switch (self.fp_bind_acceleration_structure_memory_nv.?(self.handle, bind_info_count, p_bind_infos.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_copy_acceleration_structure_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        dst: AccelerationStructureNV,
        src: AccelerationStructureNV,
        mode: CopyAccelerationStructureModeKHR,
    ) void {
        self.fp_cmd_copy_acceleration_structure_nv.?(command_buffer, dst, src, mode);
    }
    pub fn cmd_copy_acceleration_structure_khr(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_info: *const CopyAccelerationStructureInfoKHR,
    ) void {
        self.fp_cmd_copy_acceleration_structure_khr.?(command_buffer, p_info);
    }
    pub const CopyAccelerationStructureKHRResult = enum {
        success,
        operation_deferred_khr,
        operation_not_deferred_khr,
    };
    pub const CopyAccelerationStructureKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn copy_acceleration_structure_khr(
        self: DeviceCommands,
        deferred_operation: DeferredOperationKHR,
        p_info: *const CopyAccelerationStructureInfoKHR,
    ) CopyAccelerationStructureKHRError!CopyAccelerationStructureKHRResult {
        switch (self.fp_copy_acceleration_structure_khr.?(self.handle, deferred_operation, p_info)) {
            .success => return .success,
            .operation_deferred_khr => return .operation_deferred_khr,
            .operation_not_deferred_khr => return .operation_not_deferred_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_copy_acceleration_structure_to_memory_khr(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_info: *const CopyAccelerationStructureToMemoryInfoKHR,
    ) void {
        self.fp_cmd_copy_acceleration_structure_to_memory_khr.?(command_buffer, p_info);
    }
    pub const CopyAccelerationStructureToMemoryKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn copy_acceleration_structure_to_memory_khr(
        self: DeviceCommands,
        deferred_operation: DeferredOperationKHR,
        p_info: *const CopyAccelerationStructureToMemoryInfoKHR,
    ) CopyAccelerationStructureToMemoryKHRError!CopyAccelerationStructureKHRResult {
        switch (self.fp_copy_acceleration_structure_to_memory_khr.?(self.handle, deferred_operation, p_info)) {
            .success => return .success,
            .operation_deferred_khr => return .operation_deferred_khr,
            .operation_not_deferred_khr => return .operation_not_deferred_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_copy_memory_to_acceleration_structure_khr(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_info: *const CopyMemoryToAccelerationStructureInfoKHR,
    ) void {
        self.fp_cmd_copy_memory_to_acceleration_structure_khr.?(command_buffer, p_info);
    }
    pub const CopyMemoryToAccelerationStructureKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn copy_memory_to_acceleration_structure_khr(
        self: DeviceCommands,
        deferred_operation: DeferredOperationKHR,
        p_info: *const CopyMemoryToAccelerationStructureInfoKHR,
    ) CopyMemoryToAccelerationStructureKHRError!CopyAccelerationStructureKHRResult {
        switch (self.fp_copy_memory_to_acceleration_structure_khr.?(self.handle, deferred_operation, p_info)) {
            .success => return .success,
            .operation_deferred_khr => return .operation_deferred_khr,
            .operation_not_deferred_khr => return .operation_not_deferred_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_write_acceleration_structures_properties_khr(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_acceleration_structures: []const AccelerationStructureKHR,
        query_type: QueryType,
        query_pool: QueryPool,
        first_query: u32,
    ) void {
        const acceleration_structure_count: u32 = @intCast(p_acceleration_structures.len);
        self.fp_cmd_write_acceleration_structures_properties_khr.?(command_buffer, acceleration_structure_count, p_acceleration_structures.ptr, query_type, query_pool, first_query);
    }
    pub fn cmd_write_acceleration_structures_properties_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_acceleration_structures: []const AccelerationStructureNV,
        query_type: QueryType,
        query_pool: QueryPool,
        first_query: u32,
    ) void {
        const acceleration_structure_count: u32 = @intCast(p_acceleration_structures.len);
        self.fp_cmd_write_acceleration_structures_properties_nv.?(command_buffer, acceleration_structure_count, p_acceleration_structures.ptr, query_type, query_pool, first_query);
    }
    pub fn cmd_build_acceleration_structure_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_info: *const AccelerationStructureInfoNV,
        instance_data: Buffer,
        instance_offset: DeviceSize,
        update: bool,
        dst: AccelerationStructureNV,
        src: AccelerationStructureNV,
        scratch: Buffer,
        scratch_offset: DeviceSize,
    ) void {
        self.fp_cmd_build_acceleration_structure_nv.?(command_buffer, p_info, instance_data, instance_offset, Bool32.from_bool(update), dst, src, scratch, scratch_offset);
    }
    pub const WriteAccelerationStructuresPropertiesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn write_acceleration_structures_properties_khr(
        self: DeviceCommands,
        p_acceleration_structures: []const AccelerationStructureKHR,
        query_type: QueryType,
        p_data: []u8,
        stride: usize,
    ) WriteAccelerationStructuresPropertiesKHRError!void {
        const acceleration_structure_count: u32 = @intCast(p_acceleration_structures.len);
        const data_size: usize = @intCast(p_data.len);
        switch (self.fp_write_acceleration_structures_properties_khr.?(self.handle, acceleration_structure_count, p_acceleration_structures.ptr, query_type, data_size, p_data.ptr, stride)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_trace_rays_khr(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_raygen_shader_binding_table: *const StridedDeviceAddressRegionKHR,
        p_miss_shader_binding_table: *const StridedDeviceAddressRegionKHR,
        p_hit_shader_binding_table: *const StridedDeviceAddressRegionKHR,
        p_callable_shader_binding_table: *const StridedDeviceAddressRegionKHR,
        width: u32,
        height: u32,
        depth: u32,
    ) void {
        self.fp_cmd_trace_rays_khr.?(command_buffer, p_raygen_shader_binding_table, p_miss_shader_binding_table, p_hit_shader_binding_table, p_callable_shader_binding_table, width, height, depth);
    }
    pub fn cmd_trace_rays_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        raygen_shader_binding_table_buffer: Buffer,
        raygen_shader_binding_offset: DeviceSize,
        miss_shader_binding_table_buffer: Buffer,
        miss_shader_binding_offset: DeviceSize,
        miss_shader_binding_stride: DeviceSize,
        hit_shader_binding_table_buffer: Buffer,
        hit_shader_binding_offset: DeviceSize,
        hit_shader_binding_stride: DeviceSize,
        callable_shader_binding_table_buffer: Buffer,
        callable_shader_binding_offset: DeviceSize,
        callable_shader_binding_stride: DeviceSize,
        width: u32,
        height: u32,
        depth: u32,
    ) void {
        self.fp_cmd_trace_rays_nv.?(command_buffer, raygen_shader_binding_table_buffer, raygen_shader_binding_offset, miss_shader_binding_table_buffer, miss_shader_binding_offset, miss_shader_binding_stride, hit_shader_binding_table_buffer, hit_shader_binding_offset, hit_shader_binding_stride, callable_shader_binding_table_buffer, callable_shader_binding_offset, callable_shader_binding_stride, width, height, depth);
    }
    pub const GetRayTracingShaderGroupHandlesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_ray_tracing_shader_group_handles_khr(
        self: DeviceCommands,
        pipeline: Pipeline,
        first_group: u32,
        group_count: u32,
        p_data: []u8,
    ) GetRayTracingShaderGroupHandlesKHRError!void {
        const data_size: usize = @intCast(p_data.len);
        switch (self.fp_get_ray_tracing_shader_group_handles_khr.?(self.handle, pipeline, first_group, group_count, data_size, p_data.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetRayTracingCaptureReplayShaderGroupHandlesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_ray_tracing_capture_replay_shader_group_handles_khr(
        self: DeviceCommands,
        pipeline: Pipeline,
        first_group: u32,
        group_count: u32,
        p_data: []u8,
    ) GetRayTracingCaptureReplayShaderGroupHandlesKHRError!void {
        const data_size: usize = @intCast(p_data.len);
        switch (self.fp_get_ray_tracing_capture_replay_shader_group_handles_khr.?(self.handle, pipeline, first_group, group_count, data_size, p_data.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetAccelerationStructureHandleNVError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_acceleration_structure_handle_nv(
        self: DeviceCommands,
        acceleration_structure: AccelerationStructureNV,
        p_data: []u8,
    ) GetAccelerationStructureHandleNVError!void {
        const data_size: usize = @intCast(p_data.len);
        switch (self.fp_get_acceleration_structure_handle_nv.?(self.handle, acceleration_structure, data_size, p_data.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateRayTracingPipelinesNVError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InvalidShaderNv,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_ray_tracing_pipelines_nv(
        self: DeviceCommands,
        pipeline_cache: PipelineCache,
        p_create_infos: []const RayTracingPipelineCreateInfoNV,
        p_allocator: ?*const AllocationCallbacks,
        p_pipelines: []Pipeline,
    ) CreateRayTracingPipelinesNVError!CreateGraphicsPipelinesResult {
        const create_info_count: u32 = @intCast(p_create_infos.len);
        assert(create_info_count == p_pipelines.len);
        switch (self.fp_create_ray_tracing_pipelines_nv.?(self.handle, pipeline_cache, create_info_count, p_create_infos.ptr, p_allocator, p_pipelines.ptr)) {
            .success => return .success,
            .pipeline_compile_required => return .pipeline_compile_required,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_invalid_shader_nv => return error.InvalidShaderNv,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateRayTracingPipelinesKHRResult = enum {
        success,
        operation_deferred_khr,
        operation_not_deferred_khr,
        pipeline_compile_required,
    };
    pub const CreateRayTracingPipelinesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InvalidOpaqueCaptureAddress,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_ray_tracing_pipelines_khr(
        self: DeviceCommands,
        deferred_operation: DeferredOperationKHR,
        pipeline_cache: PipelineCache,
        p_create_infos: []const RayTracingPipelineCreateInfoKHR,
        p_allocator: ?*const AllocationCallbacks,
        p_pipelines: []Pipeline,
    ) CreateRayTracingPipelinesKHRError!CreateRayTracingPipelinesKHRResult {
        const create_info_count: u32 = @intCast(p_create_infos.len);
        assert(create_info_count == p_pipelines.len);
        switch (self.fp_create_ray_tracing_pipelines_khr.?(self.handle, deferred_operation, pipeline_cache, create_info_count, p_create_infos.ptr, p_allocator, p_pipelines.ptr)) {
            .success => return .success,
            .operation_deferred_khr => return .operation_deferred_khr,
            .operation_not_deferred_khr => return .operation_not_deferred_khr,
            .pipeline_compile_required => return .pipeline_compile_required,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_invalid_opaque_capture_address => return error.InvalidOpaqueCaptureAddress,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceCooperativeMatrixPropertiesNVError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_cooperative_matrix_properties_nv(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        p_property_count: *u32,
        p_properties: ?[*]CooperativeMatrixPropertiesNV,
    ) GetPhysicalDeviceCooperativeMatrixPropertiesNVError!EnumerateResult {
        switch (self.fp_get_physical_device_cooperative_matrix_properties_nv.?(physical_device, p_property_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceCooperativeMatrixPropertiesNVOrAllocatorError = GetPhysicalDeviceCooperativeMatrixPropertiesNVError || Allocator.Error;
    pub fn get_physical_device_cooperative_matrix_properties_nv_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
    ) GetPhysicalDeviceCooperativeMatrixPropertiesNVOrAllocatorError![]CooperativeMatrixPropertiesNV {
        const enumerator = struct {
            self: *const DeviceCommands,
            physical_device: PhysicalDevice,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]CooperativeMatrixPropertiesNV) !EnumerateResult {
                return enumerator.self.get_physical_device_cooperative_matrix_properties_nv(
                    enumerator.physical_device,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceCooperativeMatrixPropertiesNVOrAllocatorError, CooperativeMatrixPropertiesNV, enumerator, allocator);
    }
    pub fn cmd_trace_rays_indirect_khr(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_raygen_shader_binding_table: *const StridedDeviceAddressRegionKHR,
        p_miss_shader_binding_table: *const StridedDeviceAddressRegionKHR,
        p_hit_shader_binding_table: *const StridedDeviceAddressRegionKHR,
        p_callable_shader_binding_table: *const StridedDeviceAddressRegionKHR,
        indirect_device_address: DeviceAddress,
    ) void {
        self.fp_cmd_trace_rays_indirect_khr.?(command_buffer, p_raygen_shader_binding_table, p_miss_shader_binding_table, p_hit_shader_binding_table, p_callable_shader_binding_table, indirect_device_address);
    }
    pub fn cmd_trace_rays_indirect2_khr(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        indirect_device_address: DeviceAddress,
    ) void {
        self.fp_cmd_trace_rays_indirect2_khr.?(command_buffer, indirect_device_address);
    }
    pub fn get_cluster_acceleration_structure_build_sizes_nv(
        self: DeviceCommands,
        p_info: *const ClusterAccelerationStructureInputInfoNV,
        p_size_info: *AccelerationStructureBuildSizesInfoKHR,
    ) void {
        self.fp_get_cluster_acceleration_structure_build_sizes_nv.?(self.handle, p_info, p_size_info);
    }
    pub fn cmd_build_cluster_acceleration_structure_indirect_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_command_infos: *const ClusterAccelerationStructureCommandsInfoNV,
    ) void {
        self.fp_cmd_build_cluster_acceleration_structure_indirect_nv.?(command_buffer, p_command_infos);
    }
    pub fn get_device_acceleration_structure_compatibility_khr(
        self: DeviceCommands,
        p_version_info: *const AccelerationStructureVersionInfoKHR,
    ) AccelerationStructureCompatibilityKHR {
        var p_compatibility: AccelerationStructureCompatibilityKHR = undefined;
        self.fp_get_device_acceleration_structure_compatibility_khr.?(self.handle, p_version_info, &p_compatibility);
        return p_compatibility;
    }
    pub fn get_ray_tracing_shader_group_stack_size_khr(
        self: DeviceCommands,
        pipeline: Pipeline,
        group: u32,
        group_shader: ShaderGroupShaderKHR,
    ) DeviceSize {
        self.fp_get_ray_tracing_shader_group_stack_size_khr.?(self.handle, pipeline, group, group_shader);
    }
    pub fn cmd_set_ray_tracing_pipeline_stack_size_khr(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        pipeline_stack_size: u32,
    ) void {
        self.fp_cmd_set_ray_tracing_pipeline_stack_size_khr.?(command_buffer, pipeline_stack_size);
    }
    pub fn get_image_view_handle_nvx(
        self: DeviceCommands,
        p_info: *const ImageViewHandleInfoNVX,
    ) u32 {
        self.fp_get_image_view_handle_nvx.?(self.handle, p_info);
    }
    pub fn get_image_view_handle64_nvx(
        self: DeviceCommands,
        p_info: *const ImageViewHandleInfoNVX,
    ) u64 {
        self.fp_get_image_view_handle64_nvx.?(self.handle, p_info);
    }
    pub const GetImageViewAddressNVXError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_image_view_address_nvx(
        self: DeviceCommands,
        image_view: ImageView,
        p_properties: *ImageViewAddressPropertiesNVX,
    ) GetImageViewAddressNVXError!void {
        switch (self.fp_get_image_view_address_nvx.?(self.handle, image_view, p_properties)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceSurfacePresentModes2EXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_surface_present_modes2_ext(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
        p_present_mode_count: *u32,
        p_present_modes: ?[*]PresentModeKHR,
    ) GetPhysicalDeviceSurfacePresentModes2EXTError!EnumerateResult {
        switch (self.fp_get_physical_device_surface_present_modes2_ext.?(physical_device, p_surface_info, p_present_mode_count, p_present_modes)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceSurfacePresentModes2EXTOrAllocatorError = GetPhysicalDeviceSurfacePresentModes2EXTError || Allocator.Error;
    pub fn get_physical_device_surface_present_modes2_ext_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
        p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    ) GetPhysicalDeviceSurfacePresentModes2EXTOrAllocatorError![]PresentModeKHR {
        const enumerator = struct {
            self: *const DeviceCommands,
            physical_device: PhysicalDevice,
            p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]PresentModeKHR) !EnumerateResult {
                return enumerator.self.get_physical_device_surface_present_modes2_ext(
                    enumerator.physical_device,
                    enumerator.p_surface_info,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
            .p_surface_info = p_surface_info,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceSurfacePresentModes2EXTOrAllocatorError, PresentModeKHR, enumerator, allocator);
    }
    pub const GetDeviceGroupSurfacePresentModes2EXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_device_group_surface_present_modes2_ext(
        self: DeviceCommands,
        p_surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
    ) GetDeviceGroupSurfacePresentModes2EXTError!DeviceGroupPresentModeFlagsKHR {
        var p_modes: DeviceGroupPresentModeFlagsKHR = undefined;
        switch (self.fp_get_device_group_surface_present_modes2_ext.?(self.handle, p_surface_info, &p_modes)) {
            .success => return p_modes,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const AcquireFullScreenExclusiveModeEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InitializationFailed,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn acquire_full_screen_exclusive_mode_ext(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
    ) AcquireFullScreenExclusiveModeEXTError!void {
        switch (self.fp_acquire_full_screen_exclusive_mode_ext.?(self.handle, swapchain)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const ReleaseFullScreenExclusiveModeEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn release_full_screen_exclusive_mode_ext(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
    ) ReleaseFullScreenExclusiveModeEXTError!void {
        switch (self.fp_release_full_screen_exclusive_mode_ext.?(self.handle, swapchain)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn enumerate_physical_device_queue_family_performance_query_counters_khr(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
        p_counter_count: *u32,
        p_counters: ?[*]PerformanceCounterKHR,
        p_counter_descriptions: ?[*]PerformanceCounterDescriptionKHR,
    ) EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHRError!EnumerateResult {
        switch (self.fp_enumerate_physical_device_queue_family_performance_query_counters_khr.?(physical_device, queue_family_index, p_counter_count, p_counters, p_counter_descriptions)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_physical_device_queue_family_performance_query_passes_khr(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        p_performance_query_create_info: *const QueryPoolPerformanceCreateInfoKHR,
    ) u32 {
        var p_num_passes: u32 = undefined;
        self.fp_get_physical_device_queue_family_performance_query_passes_khr.?(physical_device, p_performance_query_create_info, &p_num_passes);
        return p_num_passes;
    }
    pub const AcquireProfilingLockKHRError = error{
        OutOfHostMemory,
        Timeout,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn acquire_profiling_lock_khr(
        self: DeviceCommands,
        p_info: *const AcquireProfilingLockInfoKHR,
    ) AcquireProfilingLockKHRError!void {
        switch (self.fp_acquire_profiling_lock_khr.?(self.handle, p_info)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .timeout => return error.Timeout,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn release_profiling_lock_khr(
        self: DeviceCommands,
    ) void {
        self.fp_release_profiling_lock_khr.?(self.handle);
    }
    pub const GetImageDrmFormatModifierPropertiesEXTError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_image_drm_format_modifier_properties_ext(
        self: DeviceCommands,
        image: Image,
        p_properties: *ImageDrmFormatModifierPropertiesEXT,
    ) GetImageDrmFormatModifierPropertiesEXTError!void {
        switch (self.fp_get_image_drm_format_modifier_properties_ext.?(self.handle, image, p_properties)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_buffer_opaque_capture_address(
        self: DeviceCommands,
        p_info: *const BufferDeviceAddressInfo,
    ) u64 {
        self.fp_get_buffer_opaque_capture_address.?(self.handle, p_info);
    }
    pub fn get_buffer_device_address(
        self: DeviceCommands,
        p_info: *const BufferDeviceAddressInfo,
    ) DeviceAddress {
        self.fp_get_buffer_device_address.?(self.handle, p_info);
    }
    pub const GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNVError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_supported_framebuffer_mixed_samples_combinations_nv(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        p_combination_count: *u32,
        p_combinations: ?[*]FramebufferMixedSamplesCombinationNV,
    ) GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNVError!EnumerateResult {
        switch (self.fp_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv.?(physical_device, p_combination_count, p_combinations)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNVOrAllocatorError = GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNVError || Allocator.Error;
    pub fn get_physical_device_supported_framebuffer_mixed_samples_combinations_nv_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
    ) GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNVOrAllocatorError![]FramebufferMixedSamplesCombinationNV {
        const enumerator = struct {
            self: *const DeviceCommands,
            physical_device: PhysicalDevice,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]FramebufferMixedSamplesCombinationNV) !EnumerateResult {
                return enumerator.self.get_physical_device_supported_framebuffer_mixed_samples_combinations_nv(
                    enumerator.physical_device,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNVOrAllocatorError, FramebufferMixedSamplesCombinationNV, enumerator, allocator);
    }
    pub const InitializePerformanceApiINTELError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn initialize_performance_api_intel(
        self: DeviceCommands,
        p_initialize_info: *const InitializePerformanceApiInfoINTEL,
    ) InitializePerformanceApiINTELError!void {
        switch (self.fp_initialize_performance_api_intel.?(self.handle, p_initialize_info)) {
            .success => return,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn uninitialize_performance_api_intel(
        self: DeviceCommands,
    ) void {
        self.fp_uninitialize_performance_api_intel.?(self.handle);
    }
    pub const CmdSetPerformanceMarkerINTELError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn cmd_set_performance_marker_intel(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_marker_info: *const PerformanceMarkerInfoINTEL,
    ) CmdSetPerformanceMarkerINTELError!void {
        switch (self.fp_cmd_set_performance_marker_intel.?(command_buffer, p_marker_info)) {
            .success => return,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CmdSetPerformanceStreamMarkerINTELError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn cmd_set_performance_stream_marker_intel(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_marker_info: *const PerformanceStreamMarkerInfoINTEL,
    ) CmdSetPerformanceStreamMarkerINTELError!void {
        switch (self.fp_cmd_set_performance_stream_marker_intel.?(command_buffer, p_marker_info)) {
            .success => return,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CmdSetPerformanceOverrideINTELError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn cmd_set_performance_override_intel(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_override_info: *const PerformanceOverrideInfoINTEL,
    ) CmdSetPerformanceOverrideINTELError!void {
        switch (self.fp_cmd_set_performance_override_intel.?(command_buffer, p_override_info)) {
            .success => return,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const AcquirePerformanceConfigurationINTELError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn acquire_performance_configuration_intel(
        self: DeviceCommands,
        p_acquire_info: *const PerformanceConfigurationAcquireInfoINTEL,
    ) AcquirePerformanceConfigurationINTELError!PerformanceConfigurationINTEL {
        var p_configuration: PerformanceConfigurationINTEL = undefined;
        switch (self.fp_acquire_performance_configuration_intel.?(self.handle, p_acquire_info, &p_configuration)) {
            .success => return p_configuration,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const ReleasePerformanceConfigurationINTELError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn release_performance_configuration_intel(
        self: DeviceCommands,
        configuration: PerformanceConfigurationINTEL,
    ) ReleasePerformanceConfigurationINTELError!void {
        switch (self.fp_release_performance_configuration_intel.?(self.handle, configuration)) {
            .success => return,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const QueueSetPerformanceConfigurationINTELError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn queue_set_performance_configuration_intel(
        self: DeviceCommands,
        queue: Queue,
        configuration: PerformanceConfigurationINTEL,
    ) QueueSetPerformanceConfigurationINTELError!void {
        switch (self.fp_queue_set_performance_configuration_intel.?(queue, configuration)) {
            .success => return,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPerformanceParameterINTELError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_performance_parameter_intel(
        self: DeviceCommands,
        parameter: PerformanceParameterTypeINTEL,
    ) GetPerformanceParameterINTELError!PerformanceValueINTEL {
        var p_value: PerformanceValueINTEL = undefined;
        switch (self.fp_get_performance_parameter_intel.?(self.handle, parameter, &p_value)) {
            .success => return p_value,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_device_memory_opaque_capture_address(
        self: DeviceCommands,
        p_info: *const DeviceMemoryOpaqueCaptureAddressInfo,
    ) u64 {
        self.fp_get_device_memory_opaque_capture_address.?(self.handle, p_info);
    }
    pub const GetPipelineExecutablePropertiesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_pipeline_executable_properties_khr(
        self: DeviceCommands,
        p_pipeline_info: *const PipelineInfoKHR,
        p_executable_count: *u32,
        p_properties: ?[*]PipelineExecutablePropertiesKHR,
    ) GetPipelineExecutablePropertiesKHRError!EnumerateResult {
        switch (self.fp_get_pipeline_executable_properties_khr.?(self.handle, p_pipeline_info, p_executable_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPipelineExecutablePropertiesKHROrAllocatorError = GetPipelineExecutablePropertiesKHRError || Allocator.Error;
    pub fn get_pipeline_executable_properties_khr_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        p_pipeline_info: *const PipelineInfoKHR,
    ) GetPipelineExecutablePropertiesKHROrAllocatorError![]PipelineExecutablePropertiesKHR {
        const enumerator = struct {
            self: *const DeviceCommands,
            p_pipeline_info: *const PipelineInfoKHR,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]PipelineExecutablePropertiesKHR) !EnumerateResult {
                return enumerator.self.get_pipeline_executable_properties_khr(
                    enumerator.p_pipeline_info,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .p_pipeline_info = p_pipeline_info,
        };
        return enumerate_generic_to_array(GetPipelineExecutablePropertiesKHROrAllocatorError, PipelineExecutablePropertiesKHR, enumerator, allocator);
    }
    pub const GetPipelineExecutableStatisticsKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_pipeline_executable_statistics_khr(
        self: DeviceCommands,
        p_executable_info: *const PipelineExecutableInfoKHR,
        p_statistic_count: *u32,
        p_statistics: ?[*]PipelineExecutableStatisticKHR,
    ) GetPipelineExecutableStatisticsKHRError!EnumerateResult {
        switch (self.fp_get_pipeline_executable_statistics_khr.?(self.handle, p_executable_info, p_statistic_count, p_statistics)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPipelineExecutableStatisticsKHROrAllocatorError = GetPipelineExecutableStatisticsKHRError || Allocator.Error;
    pub fn get_pipeline_executable_statistics_khr_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        p_executable_info: *const PipelineExecutableInfoKHR,
    ) GetPipelineExecutableStatisticsKHROrAllocatorError![]PipelineExecutableStatisticKHR {
        const enumerator = struct {
            self: *const DeviceCommands,
            p_executable_info: *const PipelineExecutableInfoKHR,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]PipelineExecutableStatisticKHR) !EnumerateResult {
                return enumerator.self.get_pipeline_executable_statistics_khr(
                    enumerator.p_executable_info,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .p_executable_info = p_executable_info,
        };
        return enumerate_generic_to_array(GetPipelineExecutableStatisticsKHROrAllocatorError, PipelineExecutableStatisticKHR, enumerator, allocator);
    }
    pub const GetPipelineExecutableInternalRepresentationsKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_pipeline_executable_internal_representations_khr(
        self: DeviceCommands,
        p_executable_info: *const PipelineExecutableInfoKHR,
        p_internal_representation_count: *u32,
        p_internal_representations: ?[*]PipelineExecutableInternalRepresentationKHR,
    ) GetPipelineExecutableInternalRepresentationsKHRError!EnumerateResult {
        switch (self.fp_get_pipeline_executable_internal_representations_khr.?(self.handle, p_executable_info, p_internal_representation_count, p_internal_representations)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPipelineExecutableInternalRepresentationsKHROrAllocatorError = GetPipelineExecutableInternalRepresentationsKHRError || Allocator.Error;
    pub fn get_pipeline_executable_internal_representations_khr_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        p_executable_info: *const PipelineExecutableInfoKHR,
    ) GetPipelineExecutableInternalRepresentationsKHROrAllocatorError![]PipelineExecutableInternalRepresentationKHR {
        const enumerator = struct {
            self: *const DeviceCommands,
            p_executable_info: *const PipelineExecutableInfoKHR,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]PipelineExecutableInternalRepresentationKHR) !EnumerateResult {
                return enumerator.self.get_pipeline_executable_internal_representations_khr(
                    enumerator.p_executable_info,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .p_executable_info = p_executable_info,
        };
        return enumerate_generic_to_array(GetPipelineExecutableInternalRepresentationsKHROrAllocatorError, PipelineExecutableInternalRepresentationKHR, enumerator, allocator);
    }
    pub fn cmd_set_line_stipple(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        line_stipple_factor: u32,
        line_stipple_pattern: u16,
    ) void {
        self.fp_cmd_set_line_stipple.?(command_buffer, line_stipple_factor, line_stipple_pattern);
    }
    pub const GetPhysicalDeviceToolPropertiesError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_tool_properties(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        p_tool_count: *u32,
        p_tool_properties: ?[*]PhysicalDeviceToolProperties,
    ) GetPhysicalDeviceToolPropertiesError!EnumerateResult {
        switch (self.fp_get_physical_device_tool_properties.?(physical_device, p_tool_count, p_tool_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceToolPropertiesOrAllocatorError = GetPhysicalDeviceToolPropertiesError || Allocator.Error;
    pub fn get_physical_device_tool_properties_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
    ) GetPhysicalDeviceToolPropertiesOrAllocatorError![]PhysicalDeviceToolProperties {
        const enumerator = struct {
            self: *const DeviceCommands,
            physical_device: PhysicalDevice,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]PhysicalDeviceToolProperties) !EnumerateResult {
                return enumerator.self.get_physical_device_tool_properties(
                    enumerator.physical_device,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceToolPropertiesOrAllocatorError, PhysicalDeviceToolProperties, enumerator, allocator);
    }
    pub const CreateAccelerationStructureKHRError = error{
        OutOfHostMemory,
        InvalidOpaqueCaptureAddress,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_acceleration_structure_khr(
        self: DeviceCommands,
        p_create_info: *const AccelerationStructureCreateInfoKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateAccelerationStructureKHRError!AccelerationStructureKHR {
        var p_acceleration_structure: AccelerationStructureKHR = undefined;
        switch (self.fp_create_acceleration_structure_khr.?(self.handle, p_create_info, p_allocator, &p_acceleration_structure)) {
            .success => return p_acceleration_structure,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_invalid_opaque_capture_address => return error.InvalidOpaqueCaptureAddress,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_build_acceleration_structures_khr(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_infos: []const AccelerationStructureBuildGeometryInfoKHR,
        pp_build_range_infos: []const ?*const AccelerationStructureBuildRangeInfoKHR,
    ) void {
        const info_count: u32 = @intCast(p_infos.len);
        assert(info_count == pp_build_range_infos.len);
        self.fp_cmd_build_acceleration_structures_khr.?(command_buffer, info_count, p_infos.ptr, pp_build_range_infos.ptr);
    }
    pub fn cmd_build_acceleration_structures_indirect_khr(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_infos: []const AccelerationStructureBuildGeometryInfoKHR,
        p_indirect_device_addresses: []const DeviceAddress,
        p_indirect_strides: []const u32,
        pp_max_primitive_counts: []const ?*const u32,
    ) void {
        const info_count: u32 = @intCast(p_infos.len);
        assert(info_count == p_indirect_device_addresses.len);
        assert(info_count == p_indirect_strides.len);
        assert(info_count == pp_max_primitive_counts.len);
        self.fp_cmd_build_acceleration_structures_indirect_khr.?(command_buffer, info_count, p_infos.ptr, p_indirect_device_addresses.ptr, p_indirect_strides.ptr, pp_max_primitive_counts.ptr);
    }
    pub const BuildAccelerationStructuresKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn build_acceleration_structures_khr(
        self: DeviceCommands,
        deferred_operation: DeferredOperationKHR,
        p_infos: []const AccelerationStructureBuildGeometryInfoKHR,
        pp_build_range_infos: []const ?*const AccelerationStructureBuildRangeInfoKHR,
    ) BuildAccelerationStructuresKHRError!CopyAccelerationStructureKHRResult {
        const info_count: u32 = @intCast(p_infos.len);
        assert(info_count == pp_build_range_infos.len);
        switch (self.fp_build_acceleration_structures_khr.?(self.handle, deferred_operation, info_count, p_infos.ptr, pp_build_range_infos.ptr)) {
            .success => return .success,
            .operation_deferred_khr => return .operation_deferred_khr,
            .operation_not_deferred_khr => return .operation_not_deferred_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_acceleration_structure_device_address_khr(
        self: DeviceCommands,
        p_info: *const AccelerationStructureDeviceAddressInfoKHR,
    ) DeviceAddress {
        self.fp_get_acceleration_structure_device_address_khr.?(self.handle, p_info);
    }
    pub const CreateDeferredOperationKHRError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_deferred_operation_khr(
        self: DeviceCommands,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateDeferredOperationKHRError!DeferredOperationKHR {
        var p_deferred_operation: DeferredOperationKHR = undefined;
        switch (self.fp_create_deferred_operation_khr.?(self.handle, p_allocator, &p_deferred_operation)) {
            .success => return p_deferred_operation,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_deferred_operation_khr(
        self: DeviceCommands,
        operation: DeferredOperationKHR,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_deferred_operation_khr.?(self.handle, operation, p_allocator);
    }
    pub fn get_deferred_operation_max_concurrency_khr(
        self: DeviceCommands,
        operation: DeferredOperationKHR,
    ) u32 {
        self.fp_get_deferred_operation_max_concurrency_khr.?(self.handle, operation);
    }
    pub const GetDeferredOperationResultKHRError = error{
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_deferred_operation_result_khr(
        self: DeviceCommands,
        operation: DeferredOperationKHR,
    ) GetDeferredOperationResultKHRError!GetFenceStatusResult {
        switch (self.fp_get_deferred_operation_result_khr.?(self.handle, operation)) {
            .success => return .success,
            .not_ready => return .not_ready,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const DeferredOperationJoinKHRResult = enum {
        success,
        thread_done_khr,
        thread_idle_khr,
    };
    pub const DeferredOperationJoinKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn deferred_operation_join_khr(
        self: DeviceCommands,
        operation: DeferredOperationKHR,
    ) DeferredOperationJoinKHRError!DeferredOperationJoinKHRResult {
        switch (self.fp_deferred_operation_join_khr.?(self.handle, operation)) {
            .success => return .success,
            .thread_done_khr => return .thread_done_khr,
            .thread_idle_khr => return .thread_idle_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_pipeline_indirect_memory_requirements_nv(
        self: DeviceCommands,
        p_create_info: *const ComputePipelineCreateInfo,
        p_memory_requirements: *MemoryRequirements2,
    ) void {
        self.fp_get_pipeline_indirect_memory_requirements_nv.?(self.handle, p_create_info, p_memory_requirements);
    }
    pub fn get_pipeline_indirect_device_address_nv(
        self: DeviceCommands,
        p_info: *const PipelineIndirectDeviceAddressInfoNV,
    ) DeviceAddress {
        self.fp_get_pipeline_indirect_device_address_nv.?(self.handle, p_info);
    }
    pub fn anti_lag_update_amd(
        self: DeviceCommands,
        p_data: *const AntiLagDataAMD,
    ) void {
        self.fp_anti_lag_update_amd.?(self.handle, p_data);
    }
    pub fn cmd_set_cull_mode(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        cull_mode: CullModeFlags,
    ) void {
        self.fp_cmd_set_cull_mode.?(command_buffer, cull_mode);
    }
    pub fn cmd_set_front_face(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        front_face: FrontFace,
    ) void {
        self.fp_cmd_set_front_face.?(command_buffer, front_face);
    }
    pub fn cmd_set_primitive_topology(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        primitive_topology: PrimitiveTopology,
    ) void {
        self.fp_cmd_set_primitive_topology.?(command_buffer, primitive_topology);
    }
    pub fn cmd_set_viewport_with_count(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_viewports: []const Viewport,
    ) void {
        const viewport_count: u32 = @intCast(p_viewports.len);
        self.fp_cmd_set_viewport_with_count.?(command_buffer, viewport_count, p_viewports.ptr);
    }
    pub fn cmd_set_scissor_with_count(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_scissors: []const Rect2D,
    ) void {
        const scissor_count: u32 = @intCast(p_scissors.len);
        self.fp_cmd_set_scissor_with_count.?(command_buffer, scissor_count, p_scissors.ptr);
    }
    pub fn cmd_bind_index_buffer2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        size: DeviceSize,
        index_type: IndexType,
    ) void {
        self.fp_cmd_bind_index_buffer2.?(command_buffer, buffer, offset, size, index_type);
    }
    pub fn cmd_bind_vertex_buffers2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_binding: u32,
        p_buffers: []const Buffer,
        p_offsets: []const DeviceSize,
        p_sizes: ?[]const DeviceSize,
        p_strides: ?[]const DeviceSize,
    ) void {
        const binding_count: u32 = @intCast(p_buffers.len);
        assert(binding_count == p_offsets.len);
        if (p_sizes) |s| {
            assert(binding_count == s.len);
        }
        if (p_strides) |s| {
            assert(binding_count == s.len);
        }
        self.fp_cmd_bind_vertex_buffers2.?(command_buffer, first_binding, binding_count, p_buffers.ptr, p_offsets.ptr, if (p_sizes) |slice| slice.ptr orelse null, if (p_strides) |slice| slice.ptr orelse null);
    }
    pub fn cmd_set_depth_test_enable(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        depth_test_enable: bool,
    ) void {
        self.fp_cmd_set_depth_test_enable.?(command_buffer, Bool32.from_bool(depth_test_enable));
    }
    pub fn cmd_set_depth_write_enable(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        depth_write_enable: bool,
    ) void {
        self.fp_cmd_set_depth_write_enable.?(command_buffer, Bool32.from_bool(depth_write_enable));
    }
    pub fn cmd_set_depth_compare_op(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        depth_compare_op: CompareOp,
    ) void {
        self.fp_cmd_set_depth_compare_op.?(command_buffer, depth_compare_op);
    }
    pub fn cmd_set_depth_bounds_test_enable(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        depth_bounds_test_enable: bool,
    ) void {
        self.fp_cmd_set_depth_bounds_test_enable.?(command_buffer, Bool32.from_bool(depth_bounds_test_enable));
    }
    pub fn cmd_set_stencil_test_enable(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        stencil_test_enable: bool,
    ) void {
        self.fp_cmd_set_stencil_test_enable.?(command_buffer, Bool32.from_bool(stencil_test_enable));
    }
    pub fn cmd_set_stencil_op(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        face_mask: StencilFaceFlags,
        fail_op: StencilOp,
        pass_op: StencilOp,
        depth_fail_op: StencilOp,
        compare_op: CompareOp,
    ) void {
        self.fp_cmd_set_stencil_op.?(command_buffer, face_mask, fail_op, pass_op, depth_fail_op, compare_op);
    }
    pub fn cmd_set_patch_control_points_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        patch_control_points: u32,
    ) void {
        self.fp_cmd_set_patch_control_points_ext.?(command_buffer, patch_control_points);
    }
    pub fn cmd_set_rasterizer_discard_enable(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        rasterizer_discard_enable: bool,
    ) void {
        self.fp_cmd_set_rasterizer_discard_enable.?(command_buffer, Bool32.from_bool(rasterizer_discard_enable));
    }
    pub fn cmd_set_depth_bias_enable(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        depth_bias_enable: bool,
    ) void {
        self.fp_cmd_set_depth_bias_enable.?(command_buffer, Bool32.from_bool(depth_bias_enable));
    }
    pub fn cmd_set_logic_op_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        logic_op: LogicOp,
    ) void {
        self.fp_cmd_set_logic_op_ext.?(command_buffer, logic_op);
    }
    pub fn cmd_set_primitive_restart_enable(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        primitive_restart_enable: bool,
    ) void {
        self.fp_cmd_set_primitive_restart_enable.?(command_buffer, Bool32.from_bool(primitive_restart_enable));
    }
    pub fn cmd_set_tessellation_domain_origin_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        domain_origin: TessellationDomainOrigin,
    ) void {
        self.fp_cmd_set_tessellation_domain_origin_ext.?(command_buffer, domain_origin);
    }
    pub fn cmd_set_depth_clamp_enable_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        depth_clamp_enable: bool,
    ) void {
        self.fp_cmd_set_depth_clamp_enable_ext.?(command_buffer, Bool32.from_bool(depth_clamp_enable));
    }
    pub fn cmd_set_polygon_mode_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        polygon_mode: PolygonMode,
    ) void {
        self.fp_cmd_set_polygon_mode_ext.?(command_buffer, polygon_mode);
    }
    pub fn cmd_set_rasterization_samples_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        rasterization_samples: SampleCountFlags,
    ) void {
        self.fp_cmd_set_rasterization_samples_ext.?(command_buffer, rasterization_samples);
    }
    pub fn cmd_set_sample_mask_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        samples: SampleCountFlags,
        p_sample_mask: [*]const SampleMask,
    ) void {
        self.fp_cmd_set_sample_mask_ext.?(command_buffer, samples, p_sample_mask);
    }
    pub fn cmd_set_alpha_to_coverage_enable_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        alpha_to_coverage_enable: bool,
    ) void {
        self.fp_cmd_set_alpha_to_coverage_enable_ext.?(command_buffer, Bool32.from_bool(alpha_to_coverage_enable));
    }
    pub fn cmd_set_alpha_to_one_enable_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        alpha_to_one_enable: bool,
    ) void {
        self.fp_cmd_set_alpha_to_one_enable_ext.?(command_buffer, Bool32.from_bool(alpha_to_one_enable));
    }
    pub fn cmd_set_logic_op_enable_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        logic_op_enable: bool,
    ) void {
        self.fp_cmd_set_logic_op_enable_ext.?(command_buffer, Bool32.from_bool(logic_op_enable));
    }
    pub fn cmd_set_color_blend_enable_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_attachment: u32,
        p_color_blend_enables: []const Bool32,
    ) void {
        const attachment_count: u32 = @intCast(p_color_blend_enables.len);
        self.fp_cmd_set_color_blend_enable_ext.?(command_buffer, first_attachment, attachment_count, p_color_blend_enables.ptr);
    }
    pub fn cmd_set_color_blend_equation_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_attachment: u32,
        p_color_blend_equations: []const ColorBlendEquationEXT,
    ) void {
        const attachment_count: u32 = @intCast(p_color_blend_equations.len);
        self.fp_cmd_set_color_blend_equation_ext.?(command_buffer, first_attachment, attachment_count, p_color_blend_equations.ptr);
    }
    pub fn cmd_set_color_write_mask_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_attachment: u32,
        p_color_write_masks: []const ColorComponentFlags,
    ) void {
        const attachment_count: u32 = @intCast(p_color_write_masks.len);
        self.fp_cmd_set_color_write_mask_ext.?(command_buffer, first_attachment, attachment_count, p_color_write_masks.ptr);
    }
    pub fn cmd_set_rasterization_stream_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        rasterization_stream: u32,
    ) void {
        self.fp_cmd_set_rasterization_stream_ext.?(command_buffer, rasterization_stream);
    }
    pub fn cmd_set_conservative_rasterization_mode_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        conservative_rasterization_mode: ConservativeRasterizationModeEXT,
    ) void {
        self.fp_cmd_set_conservative_rasterization_mode_ext.?(command_buffer, conservative_rasterization_mode);
    }
    pub fn cmd_set_extra_primitive_overestimation_size_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        extra_primitive_overestimation_size: f32,
    ) void {
        self.fp_cmd_set_extra_primitive_overestimation_size_ext.?(command_buffer, extra_primitive_overestimation_size);
    }
    pub fn cmd_set_depth_clip_enable_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        depth_clip_enable: bool,
    ) void {
        self.fp_cmd_set_depth_clip_enable_ext.?(command_buffer, Bool32.from_bool(depth_clip_enable));
    }
    pub fn cmd_set_sample_locations_enable_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        sample_locations_enable: bool,
    ) void {
        self.fp_cmd_set_sample_locations_enable_ext.?(command_buffer, Bool32.from_bool(sample_locations_enable));
    }
    pub fn cmd_set_color_blend_advanced_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_attachment: u32,
        p_color_blend_advanced: []const ColorBlendAdvancedEXT,
    ) void {
        const attachment_count: u32 = @intCast(p_color_blend_advanced.len);
        self.fp_cmd_set_color_blend_advanced_ext.?(command_buffer, first_attachment, attachment_count, p_color_blend_advanced.ptr);
    }
    pub fn cmd_set_provoking_vertex_mode_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        provoking_vertex_mode: ProvokingVertexModeEXT,
    ) void {
        self.fp_cmd_set_provoking_vertex_mode_ext.?(command_buffer, provoking_vertex_mode);
    }
    pub fn cmd_set_line_rasterization_mode_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        line_rasterization_mode: LineRasterizationModeEXT,
    ) void {
        self.fp_cmd_set_line_rasterization_mode_ext.?(command_buffer, line_rasterization_mode);
    }
    pub fn cmd_set_line_stipple_enable_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        stippled_line_enable: bool,
    ) void {
        self.fp_cmd_set_line_stipple_enable_ext.?(command_buffer, Bool32.from_bool(stippled_line_enable));
    }
    pub fn cmd_set_depth_clip_negative_one_to_one_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        negative_one_to_one: bool,
    ) void {
        self.fp_cmd_set_depth_clip_negative_one_to_one_ext.?(command_buffer, Bool32.from_bool(negative_one_to_one));
    }
    pub fn cmd_set_viewport_w_scaling_enable_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        viewport_w_scaling_enable: bool,
    ) void {
        self.fp_cmd_set_viewport_w_scaling_enable_nv.?(command_buffer, Bool32.from_bool(viewport_w_scaling_enable));
    }
    pub fn cmd_set_viewport_swizzle_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        first_viewport: u32,
        p_viewport_swizzles: []const ViewportSwizzleNV,
    ) void {
        const viewport_count: u32 = @intCast(p_viewport_swizzles.len);
        self.fp_cmd_set_viewport_swizzle_nv.?(command_buffer, first_viewport, viewport_count, p_viewport_swizzles.ptr);
    }
    pub fn cmd_set_coverage_to_color_enable_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        coverage_to_color_enable: bool,
    ) void {
        self.fp_cmd_set_coverage_to_color_enable_nv.?(command_buffer, Bool32.from_bool(coverage_to_color_enable));
    }
    pub fn cmd_set_coverage_to_color_location_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        coverage_to_color_location: u32,
    ) void {
        self.fp_cmd_set_coverage_to_color_location_nv.?(command_buffer, coverage_to_color_location);
    }
    pub fn cmd_set_coverage_modulation_mode_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        coverage_modulation_mode: CoverageModulationModeNV,
    ) void {
        self.fp_cmd_set_coverage_modulation_mode_nv.?(command_buffer, coverage_modulation_mode);
    }
    pub fn cmd_set_coverage_modulation_table_enable_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        coverage_modulation_table_enable: bool,
    ) void {
        self.fp_cmd_set_coverage_modulation_table_enable_nv.?(command_buffer, Bool32.from_bool(coverage_modulation_table_enable));
    }
    pub fn cmd_set_coverage_modulation_table_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_coverage_modulation_table: []const f32,
    ) void {
        const coverage_modulation_table_count: u32 = @intCast(p_coverage_modulation_table.len);
        self.fp_cmd_set_coverage_modulation_table_nv.?(command_buffer, coverage_modulation_table_count, p_coverage_modulation_table.ptr);
    }
    pub fn cmd_set_shading_rate_image_enable_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        shading_rate_image_enable: bool,
    ) void {
        self.fp_cmd_set_shading_rate_image_enable_nv.?(command_buffer, Bool32.from_bool(shading_rate_image_enable));
    }
    pub fn cmd_set_coverage_reduction_mode_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        coverage_reduction_mode: CoverageReductionModeNV,
    ) void {
        self.fp_cmd_set_coverage_reduction_mode_nv.?(command_buffer, coverage_reduction_mode);
    }
    pub fn cmd_set_representative_fragment_test_enable_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        representative_fragment_test_enable: bool,
    ) void {
        self.fp_cmd_set_representative_fragment_test_enable_nv.?(command_buffer, Bool32.from_bool(representative_fragment_test_enable));
    }
    pub const CreatePrivateDataSlotError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_private_data_slot(
        self: DeviceCommands,
        p_create_info: *const PrivateDataSlotCreateInfo,
        p_allocator: ?*const AllocationCallbacks,
    ) CreatePrivateDataSlotError!PrivateDataSlot {
        var p_private_data_slot: PrivateDataSlot = undefined;
        switch (self.fp_create_private_data_slot.?(self.handle, p_create_info, p_allocator, &p_private_data_slot)) {
            .success => return p_private_data_slot,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_private_data_slot(
        self: DeviceCommands,
        private_data_slot: PrivateDataSlot,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_private_data_slot.?(self.handle, private_data_slot, p_allocator);
    }
    pub const SetPrivateDataError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn set_private_data(
        self: DeviceCommands,
        object_type: ObjectType,
        object_handle: u64,
        private_data_slot: PrivateDataSlot,
        data: u64,
    ) SetPrivateDataError!void {
        switch (self.fp_set_private_data.?(self.handle, object_type, object_handle, private_data_slot, data)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_private_data(
        self: DeviceCommands,
        object_type: ObjectType,
        object_handle: u64,
        private_data_slot: PrivateDataSlot,
    ) u64 {
        var p_data: u64 = undefined;
        self.fp_get_private_data.?(self.handle, object_type, object_handle, private_data_slot, &p_data);
        return p_data;
    }
    pub fn cmd_copy_buffer2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_copy_buffer_info: *const CopyBufferInfo2,
    ) void {
        self.fp_cmd_copy_buffer2.?(command_buffer, p_copy_buffer_info);
    }
    pub fn cmd_copy_image2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_copy_image_info: *const CopyImageInfo2,
    ) void {
        self.fp_cmd_copy_image2.?(command_buffer, p_copy_image_info);
    }
    pub fn cmd_blit_image2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_blit_image_info: *const BlitImageInfo2,
    ) void {
        self.fp_cmd_blit_image2.?(command_buffer, p_blit_image_info);
    }
    pub fn cmd_copy_buffer_to_image2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_copy_buffer_to_image_info: *const CopyBufferToImageInfo2,
    ) void {
        self.fp_cmd_copy_buffer_to_image2.?(command_buffer, p_copy_buffer_to_image_info);
    }
    pub fn cmd_copy_image_to_buffer2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_copy_image_to_buffer_info: *const CopyImageToBufferInfo2,
    ) void {
        self.fp_cmd_copy_image_to_buffer2.?(command_buffer, p_copy_image_to_buffer_info);
    }
    pub fn cmd_resolve_image2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_resolve_image_info: *const ResolveImageInfo2,
    ) void {
        self.fp_cmd_resolve_image2.?(command_buffer, p_resolve_image_info);
    }
    pub fn cmd_set_fragment_shading_rate_khr(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_fragment_size: *const Extent2D,
        combiner_ops: [*]const FragmentShadingRateCombinerOpKHR,
    ) void {
        self.fp_cmd_set_fragment_shading_rate_khr.?(command_buffer, p_fragment_size, combiner_ops);
    }
    pub const GetPhysicalDeviceFragmentShadingRatesKHRError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_fragment_shading_rates_khr(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        p_fragment_shading_rate_count: *u32,
        p_fragment_shading_rates: ?[*]PhysicalDeviceFragmentShadingRateKHR,
    ) GetPhysicalDeviceFragmentShadingRatesKHRError!EnumerateResult {
        switch (self.fp_get_physical_device_fragment_shading_rates_khr.?(physical_device, p_fragment_shading_rate_count, p_fragment_shading_rates)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceFragmentShadingRatesKHROrAllocatorError = GetPhysicalDeviceFragmentShadingRatesKHRError || Allocator.Error;
    pub fn get_physical_device_fragment_shading_rates_khr_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
    ) GetPhysicalDeviceFragmentShadingRatesKHROrAllocatorError![]PhysicalDeviceFragmentShadingRateKHR {
        const enumerator = struct {
            self: *const DeviceCommands,
            physical_device: PhysicalDevice,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]PhysicalDeviceFragmentShadingRateKHR) !EnumerateResult {
                return enumerator.self.get_physical_device_fragment_shading_rates_khr(
                    enumerator.physical_device,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceFragmentShadingRatesKHROrAllocatorError, PhysicalDeviceFragmentShadingRateKHR, enumerator, allocator);
    }
    pub fn cmd_set_fragment_shading_rate_enum_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        shading_rate: FragmentShadingRateNV,
        combiner_ops: [*]const FragmentShadingRateCombinerOpKHR,
    ) void {
        self.fp_cmd_set_fragment_shading_rate_enum_nv.?(command_buffer, shading_rate, combiner_ops);
    }
    pub fn get_acceleration_structure_build_sizes_khr(
        self: DeviceCommands,
        build_type: AccelerationStructureBuildTypeKHR,
        p_build_info: *const AccelerationStructureBuildGeometryInfoKHR,
        p_max_primitive_counts: ?[]const u32,
        p_size_info: *AccelerationStructureBuildSizesInfoKHR,
    ) void {
        if (p_max_primitive_counts) |s| {
            assert(s.len == p_build_info.geometry_count);
        }
        self.fp_get_acceleration_structure_build_sizes_khr.?(self.handle, build_type, p_build_info, if (p_max_primitive_counts) |slice| slice.ptr orelse null, p_size_info);
    }
    pub fn cmd_set_vertex_input_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_vertex_binding_descriptions: []const VertexInputBindingDescription2EXT,
        p_vertex_attribute_descriptions: []const VertexInputAttributeDescription2EXT,
    ) void {
        const vertex_binding_description_count: u32 = @intCast(p_vertex_binding_descriptions.len);
        const vertex_attribute_description_count: u32 = @intCast(p_vertex_attribute_descriptions.len);
        self.fp_cmd_set_vertex_input_ext.?(command_buffer, vertex_binding_description_count, p_vertex_binding_descriptions.ptr, vertex_attribute_description_count, p_vertex_attribute_descriptions.ptr);
    }
    pub fn cmd_set_color_write_enable_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_color_write_enables: []const Bool32,
    ) void {
        const attachment_count: u32 = @intCast(p_color_write_enables.len);
        self.fp_cmd_set_color_write_enable_ext.?(command_buffer, attachment_count, p_color_write_enables.ptr);
    }
    pub fn cmd_set_event2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        event: Event,
        p_dependency_info: *const DependencyInfo,
    ) void {
        self.fp_cmd_set_event2.?(command_buffer, event, p_dependency_info);
    }
    pub fn cmd_reset_event2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        event: Event,
        stage_mask: PipelineStageFlags2,
    ) void {
        self.fp_cmd_reset_event2.?(command_buffer, event, stage_mask);
    }
    pub fn cmd_wait_events2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_events: []const Event,
        p_dependency_infos: []const DependencyInfo,
    ) void {
        const event_count: u32 = @intCast(p_events.len);
        assert(event_count == p_dependency_infos.len);
        self.fp_cmd_wait_events2.?(command_buffer, event_count, p_events.ptr, p_dependency_infos.ptr);
    }
    pub fn cmd_pipeline_barrier2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_dependency_info: *const DependencyInfo,
    ) void {
        self.fp_cmd_pipeline_barrier2.?(command_buffer, p_dependency_info);
    }
    pub const QueueSubmit2Error = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn queue_submit2(
        self: DeviceCommands,
        queue: Queue,
        p_submits: []const SubmitInfo2,
        fence: Fence,
    ) QueueSubmit2Error!void {
        const submit_count: u32 = @intCast(p_submits.len);
        switch (self.fp_queue_submit2.?(queue, submit_count, p_submits.ptr, fence)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_write_timestamp2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        stage: PipelineStageFlags2,
        query_pool: QueryPool,
        query: u32,
    ) void {
        self.fp_cmd_write_timestamp2.?(command_buffer, stage, query_pool, query);
    }
    pub fn cmd_write_buffer_marker2_amd(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        stage: PipelineStageFlags2,
        dst_buffer: Buffer,
        dst_offset: DeviceSize,
        marker: u32,
    ) void {
        self.fp_cmd_write_buffer_marker2_amd.?(command_buffer, stage, dst_buffer, dst_offset, marker);
    }
    pub fn get_queue_checkpoint_data2_nv(
        self: DeviceCommands,
        queue: Queue,
        p_checkpoint_data_count: *u32,
        p_checkpoint_data: ?[*]CheckpointData2NV,
    ) void {
        self.fp_get_queue_checkpoint_data2_nv.?(queue, p_checkpoint_data_count, p_checkpoint_data);
    }
    pub fn get_queue_checkpoint_data2_nv_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        queue: Queue,
    ) Allocator.Error![]CheckpointData2NV {
        const enumerator = struct {
            self: *const DeviceCommands,
            queue: Queue,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]CheckpointData2NV) void {
                return enumerator.self.get_queue_checkpoint_data2_nv(
                    enumerator.queue,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .queue = queue,
        };
        return enumerate_generic_unchecked_to_array(CheckpointData2NV, enumerator, allocator);
    }
    pub const CopyMemoryToImageError = error{
        InitializationFailed,
        OutOfHostMemory,
        OutOfDeviceMemory,
        MemoryMapFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn copy_memory_to_image(
        self: DeviceCommands,
        p_copy_memory_to_image_info: *const CopyMemoryToImageInfo,
    ) CopyMemoryToImageError!void {
        switch (self.fp_copy_memory_to_image.?(self.handle, p_copy_memory_to_image_info)) {
            .success => return,
            .error_initialization_failed => return error.InitializationFailed,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_memory_map_failed => return error.MemoryMapFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CopyImageToMemoryError = error{
        InitializationFailed,
        OutOfHostMemory,
        OutOfDeviceMemory,
        MemoryMapFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn copy_image_to_memory(
        self: DeviceCommands,
        p_copy_image_to_memory_info: *const CopyImageToMemoryInfo,
    ) CopyImageToMemoryError!void {
        switch (self.fp_copy_image_to_memory.?(self.handle, p_copy_image_to_memory_info)) {
            .success => return,
            .error_initialization_failed => return error.InitializationFailed,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_memory_map_failed => return error.MemoryMapFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CopyImageToImageError = error{
        InitializationFailed,
        OutOfHostMemory,
        OutOfDeviceMemory,
        MemoryMapFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn copy_image_to_image(
        self: DeviceCommands,
        p_copy_image_to_image_info: *const CopyImageToImageInfo,
    ) CopyImageToImageError!void {
        switch (self.fp_copy_image_to_image.?(self.handle, p_copy_image_to_image_info)) {
            .success => return,
            .error_initialization_failed => return error.InitializationFailed,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_memory_map_failed => return error.MemoryMapFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const TransitionImageLayoutError = error{
        InitializationFailed,
        OutOfHostMemory,
        OutOfDeviceMemory,
        MemoryMapFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn transition_image_layout(
        self: DeviceCommands,
        p_transitions: []const HostImageLayoutTransitionInfo,
    ) TransitionImageLayoutError!void {
        const transition_count: u32 = @intCast(p_transitions.len);
        switch (self.fp_transition_image_layout.?(self.handle, transition_count, p_transitions.ptr)) {
            .success => return,
            .error_initialization_failed => return error.InitializationFailed,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_memory_map_failed => return error.MemoryMapFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_decompress_memory_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_decompress_memory_regions: []const DecompressMemoryRegionNV,
    ) void {
        const decompress_region_count: u32 = @intCast(p_decompress_memory_regions.len);
        self.fp_cmd_decompress_memory_nv.?(command_buffer, decompress_region_count, p_decompress_memory_regions.ptr);
    }
    pub fn cmd_decompress_memory_indirect_count_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        indirect_commands_address: DeviceAddress,
        indirect_commands_count_address: DeviceAddress,
        stride: u32,
    ) void {
        self.fp_cmd_decompress_memory_indirect_count_nv.?(command_buffer, indirect_commands_address, indirect_commands_count_address, stride);
    }
    pub fn get_partitioned_acceleration_structures_build_sizes_nv(
        self: DeviceCommands,
        p_info: *const PartitionedAccelerationStructureInstancesInputNV,
        p_size_info: *AccelerationStructureBuildSizesInfoKHR,
    ) void {
        self.fp_get_partitioned_acceleration_structures_build_sizes_nv.?(self.handle, p_info, p_size_info);
    }
    pub fn cmd_build_partitioned_acceleration_structures_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_build_info: *const BuildPartitionedAccelerationStructureInfoNV,
    ) void {
        self.fp_cmd_build_partitioned_acceleration_structures_nv.?(command_buffer, p_build_info);
    }
    pub const CreateCuModuleNVXError = error{
        OutOfHostMemory,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_cu_module_nvx(
        self: DeviceCommands,
        p_create_info: *const CuModuleCreateInfoNVX,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateCuModuleNVXError!CuModuleNVX {
        var p_module: CuModuleNVX = undefined;
        switch (self.fp_create_cu_module_nvx.?(self.handle, p_create_info, p_allocator, &p_module)) {
            .success => return p_module,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateCuFunctionNVXError = error{
        OutOfHostMemory,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_cu_function_nvx(
        self: DeviceCommands,
        p_create_info: *const CuFunctionCreateInfoNVX,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateCuFunctionNVXError!CuFunctionNVX {
        var p_function: CuFunctionNVX = undefined;
        switch (self.fp_create_cu_function_nvx.?(self.handle, p_create_info, p_allocator, &p_function)) {
            .success => return p_function,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_cu_module_nvx(
        self: DeviceCommands,
        module: CuModuleNVX,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_cu_module_nvx.?(self.handle, module, p_allocator);
    }
    pub fn destroy_cu_function_nvx(
        self: DeviceCommands,
        function: CuFunctionNVX,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_cu_function_nvx.?(self.handle, function, p_allocator);
    }
    pub fn cmd_cu_launch_kernel_nvx(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_launch_info: *const CuLaunchInfoNVX,
    ) void {
        self.fp_cmd_cu_launch_kernel_nvx.?(command_buffer, p_launch_info);
    }
    pub fn get_descriptor_set_layout_size_ext(
        self: DeviceCommands,
        layout: DescriptorSetLayout,
    ) DeviceSize {
        var p_layout_size_in_bytes: DeviceSize = undefined;
        self.fp_get_descriptor_set_layout_size_ext.?(self.handle, layout, &p_layout_size_in_bytes);
        return p_layout_size_in_bytes;
    }
    pub fn get_descriptor_set_layout_binding_offset_ext(
        self: DeviceCommands,
        layout: DescriptorSetLayout,
        binding: u32,
    ) DeviceSize {
        var p_offset: DeviceSize = undefined;
        self.fp_get_descriptor_set_layout_binding_offset_ext.?(self.handle, layout, binding, &p_offset);
        return p_offset;
    }
    pub fn get_descriptor_ext(
        self: DeviceCommands,
        p_descriptor_info: *const DescriptorGetInfoEXT,
        p_descriptor: []u8,
    ) void {
        const data_size: usize = @intCast(p_descriptor.len);
        self.fp_get_descriptor_ext.?(self.handle, p_descriptor_info, data_size, p_descriptor.ptr);
    }
    pub fn cmd_bind_descriptor_buffers_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_binding_infos: []const DescriptorBufferBindingInfoEXT,
    ) void {
        const buffer_count: u32 = @intCast(p_binding_infos.len);
        self.fp_cmd_bind_descriptor_buffers_ext.?(command_buffer, buffer_count, p_binding_infos.ptr);
    }
    pub fn cmd_set_descriptor_buffer_offsets_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        pipeline_bind_point: PipelineBindPoint,
        layout: PipelineLayout,
        first_set: u32,
        p_buffer_indices: []const u32,
        p_offsets: []const DeviceSize,
    ) void {
        const set_count: u32 = @intCast(p_buffer_indices.len);
        assert(set_count == p_offsets.len);
        self.fp_cmd_set_descriptor_buffer_offsets_ext.?(command_buffer, pipeline_bind_point, layout, first_set, set_count, p_buffer_indices.ptr, p_offsets.ptr);
    }
    pub fn cmd_bind_descriptor_buffer_embedded_samplers_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        pipeline_bind_point: PipelineBindPoint,
        layout: PipelineLayout,
        set: u32,
    ) void {
        self.fp_cmd_bind_descriptor_buffer_embedded_samplers_ext.?(command_buffer, pipeline_bind_point, layout, set);
    }
    pub const GetBufferOpaqueCaptureDescriptorDataEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_buffer_opaque_capture_descriptor_data_ext(
        self: DeviceCommands,
        p_info: *const BufferCaptureDescriptorDataInfoEXT,
        p_data: *anyopaque,
    ) GetBufferOpaqueCaptureDescriptorDataEXTError!void {
        switch (self.fp_get_buffer_opaque_capture_descriptor_data_ext.?(self.handle, p_info, p_data)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetImageOpaqueCaptureDescriptorDataEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_image_opaque_capture_descriptor_data_ext(
        self: DeviceCommands,
        p_info: *const ImageCaptureDescriptorDataInfoEXT,
        p_data: *anyopaque,
    ) GetImageOpaqueCaptureDescriptorDataEXTError!void {
        switch (self.fp_get_image_opaque_capture_descriptor_data_ext.?(self.handle, p_info, p_data)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetImageViewOpaqueCaptureDescriptorDataEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_image_view_opaque_capture_descriptor_data_ext(
        self: DeviceCommands,
        p_info: *const ImageViewCaptureDescriptorDataInfoEXT,
        p_data: *anyopaque,
    ) GetImageViewOpaqueCaptureDescriptorDataEXTError!void {
        switch (self.fp_get_image_view_opaque_capture_descriptor_data_ext.?(self.handle, p_info, p_data)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetSamplerOpaqueCaptureDescriptorDataEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_sampler_opaque_capture_descriptor_data_ext(
        self: DeviceCommands,
        p_info: *const SamplerCaptureDescriptorDataInfoEXT,
        p_data: *anyopaque,
    ) GetSamplerOpaqueCaptureDescriptorDataEXTError!void {
        switch (self.fp_get_sampler_opaque_capture_descriptor_data_ext.?(self.handle, p_info, p_data)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetAccelerationStructureOpaqueCaptureDescriptorDataEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_acceleration_structure_opaque_capture_descriptor_data_ext(
        self: DeviceCommands,
        p_info: *const AccelerationStructureCaptureDescriptorDataInfoEXT,
        p_data: *anyopaque,
    ) GetAccelerationStructureOpaqueCaptureDescriptorDataEXTError!void {
        switch (self.fp_get_acceleration_structure_opaque_capture_descriptor_data_ext.?(self.handle, p_info, p_data)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn set_device_memory_priority_ext(
        self: DeviceCommands,
        memory: DeviceMemory,
        priority: f32,
    ) void {
        self.fp_set_device_memory_priority_ext.?(self.handle, memory, priority);
    }
    pub const WaitForPresent2KHRResult = enum {
        success,
        timeout,
        suboptimal_khr,
    };
    pub const WaitForPresent2KHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        OutOfDateKhr,
        SurfaceLostKhr,
        FullScreenExclusiveModeLostExt,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn wait_for_present2_khr(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
        p_present_wait2_info: *const PresentWait2InfoKHR,
    ) WaitForPresent2KHRError!WaitForPresent2KHRResult {
        switch (self.fp_wait_for_present2_khr.?(self.handle, swapchain, p_present_wait2_info)) {
            .success => return .success,
            .timeout => return .timeout,
            .suboptimal_khr => return .suboptimal_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_out_of_date_khr => return error.OutOfDateKhr,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_full_screen_exclusive_mode_lost_ext => return error.FullScreenExclusiveModeLostExt,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const WaitForPresentKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        DeviceLost,
        OutOfDateKhr,
        SurfaceLostKhr,
        FullScreenExclusiveModeLostExt,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn wait_for_present_khr(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
        present_id: u64,
        timeout: u64,
    ) WaitForPresentKHRError!WaitForPresent2KHRResult {
        switch (self.fp_wait_for_present_khr.?(self.handle, swapchain, present_id, timeout)) {
            .success => return .success,
            .timeout => return .timeout,
            .suboptimal_khr => return .suboptimal_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_device_lost => return error.DeviceLost,
            .error_out_of_date_khr => return error.OutOfDateKhr,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_full_screen_exclusive_mode_lost_ext => return error.FullScreenExclusiveModeLostExt,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateBufferCollectionFUCHSIAError = error{
        OutOfHostMemory,
        InvalidExternalHandle,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_buffer_collection_fuchsia(
        self: DeviceCommands,
        p_create_info: *const BufferCollectionCreateInfoFUCHSIA,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateBufferCollectionFUCHSIAError!BufferCollectionFUCHSIA {
        var p_collection: BufferCollectionFUCHSIA = undefined;
        switch (self.fp_create_buffer_collection_fuchsia.?(self.handle, p_create_info, p_allocator, &p_collection)) {
            .success => return p_collection,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_invalid_external_handle => return error.InvalidExternalHandle,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const SetBufferCollectionBufferConstraintsFUCHSIAError = error{
        InitializationFailed,
        OutOfHostMemory,
        FormatNotSupported,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn set_buffer_collection_buffer_constraints_fuchsia(
        self: DeviceCommands,
        collection: BufferCollectionFUCHSIA,
        p_buffer_constraints_info: *const BufferConstraintsInfoFUCHSIA,
    ) SetBufferCollectionBufferConstraintsFUCHSIAError!void {
        switch (self.fp_set_buffer_collection_buffer_constraints_fuchsia.?(self.handle, collection, p_buffer_constraints_info)) {
            .success => return,
            .error_initialization_failed => return error.InitializationFailed,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_format_not_supported => return error.FormatNotSupported,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const SetBufferCollectionImageConstraintsFUCHSIAError = error{
        InitializationFailed,
        OutOfHostMemory,
        FormatNotSupported,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn set_buffer_collection_image_constraints_fuchsia(
        self: DeviceCommands,
        collection: BufferCollectionFUCHSIA,
        p_image_constraints_info: *const ImageConstraintsInfoFUCHSIA,
    ) SetBufferCollectionImageConstraintsFUCHSIAError!void {
        switch (self.fp_set_buffer_collection_image_constraints_fuchsia.?(self.handle, collection, p_image_constraints_info)) {
            .success => return,
            .error_initialization_failed => return error.InitializationFailed,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_format_not_supported => return error.FormatNotSupported,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_buffer_collection_fuchsia(
        self: DeviceCommands,
        collection: BufferCollectionFUCHSIA,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_buffer_collection_fuchsia.?(self.handle, collection, p_allocator);
    }
    pub const GetBufferCollectionPropertiesFUCHSIAError = error{
        OutOfHostMemory,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_buffer_collection_properties_fuchsia(
        self: DeviceCommands,
        collection: BufferCollectionFUCHSIA,
        p_properties: *BufferCollectionPropertiesFUCHSIA,
    ) GetBufferCollectionPropertiesFUCHSIAError!void {
        switch (self.fp_get_buffer_collection_properties_fuchsia.?(self.handle, collection, p_properties)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateCudaModuleNVError = error{
        InitializationFailed,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_cuda_module_nv(
        self: DeviceCommands,
        p_create_info: *const CudaModuleCreateInfoNV,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateCudaModuleNVError!CudaModuleNV {
        var p_module: CudaModuleNV = undefined;
        switch (self.fp_create_cuda_module_nv.?(self.handle, p_create_info, p_allocator, &p_module)) {
            .success => return p_module,
            .error_initialization_failed => return error.InitializationFailed,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetCudaModuleCacheNVError = error{
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_cuda_module_cache_nv(
        self: DeviceCommands,
        module: CudaModuleNV,
        p_cache_size: *usize,
        p_cache_data: ?*anyopaque,
    ) GetCudaModuleCacheNVError!EnumerateResult {
        switch (self.fp_get_cuda_module_cache_nv.?(self.handle, module, p_cache_size, p_cache_data)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateCudaFunctionNVError = error{
        InitializationFailed,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_cuda_function_nv(
        self: DeviceCommands,
        p_create_info: *const CudaFunctionCreateInfoNV,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateCudaFunctionNVError!CudaFunctionNV {
        var p_function: CudaFunctionNV = undefined;
        switch (self.fp_create_cuda_function_nv.?(self.handle, p_create_info, p_allocator, &p_function)) {
            .success => return p_function,
            .error_initialization_failed => return error.InitializationFailed,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_cuda_module_nv(
        self: DeviceCommands,
        module: CudaModuleNV,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_cuda_module_nv.?(self.handle, module, p_allocator);
    }
    pub fn destroy_cuda_function_nv(
        self: DeviceCommands,
        function: CudaFunctionNV,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_cuda_function_nv.?(self.handle, function, p_allocator);
    }
    pub fn cmd_cuda_launch_kernel_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_launch_info: *const CudaLaunchInfoNV,
    ) void {
        self.fp_cmd_cuda_launch_kernel_nv.?(command_buffer, p_launch_info);
    }
    pub fn cmd_begin_rendering(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_rendering_info: *const RenderingInfo,
    ) void {
        self.fp_cmd_begin_rendering.?(command_buffer, p_rendering_info);
    }
    pub fn cmd_end_rendering(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
    ) void {
        self.fp_cmd_end_rendering.?(command_buffer);
    }
    pub fn cmd_end_rendering2_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_rendering_end_info: ?*const RenderingEndInfoEXT,
    ) void {
        self.fp_cmd_end_rendering2_ext.?(command_buffer, p_rendering_end_info);
    }
    pub fn get_descriptor_set_layout_host_mapping_info_valve(
        self: DeviceCommands,
        p_binding_reference: *const DescriptorSetBindingReferenceVALVE,
        p_host_mapping: *DescriptorSetLayoutHostMappingInfoVALVE,
    ) void {
        self.fp_get_descriptor_set_layout_host_mapping_info_valve.?(self.handle, p_binding_reference, p_host_mapping);
    }
    pub fn get_descriptor_set_host_mapping_valve(
        self: DeviceCommands,
        descriptor_set: DescriptorSet,
    ) ?*anyopaque {
        var pp_data: ?*anyopaque = undefined;
        self.fp_get_descriptor_set_host_mapping_valve.?(self.handle, descriptor_set, &pp_data);
        return pp_data;
    }
    pub const CreateMicromapEXTError = error{
        OutOfHostMemory,
        InvalidOpaqueCaptureAddress,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_micromap_ext(
        self: DeviceCommands,
        p_create_info: *const MicromapCreateInfoEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateMicromapEXTError!MicromapEXT {
        var p_micromap: MicromapEXT = undefined;
        switch (self.fp_create_micromap_ext.?(self.handle, p_create_info, p_allocator, &p_micromap)) {
            .success => return p_micromap,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_invalid_opaque_capture_address => return error.InvalidOpaqueCaptureAddress,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_build_micromaps_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_infos: []const MicromapBuildInfoEXT,
    ) void {
        const info_count: u32 = @intCast(p_infos.len);
        self.fp_cmd_build_micromaps_ext.?(command_buffer, info_count, p_infos.ptr);
    }
    pub const BuildMicromapsEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn build_micromaps_ext(
        self: DeviceCommands,
        deferred_operation: DeferredOperationKHR,
        p_infos: []const MicromapBuildInfoEXT,
    ) BuildMicromapsEXTError!CopyAccelerationStructureKHRResult {
        const info_count: u32 = @intCast(p_infos.len);
        switch (self.fp_build_micromaps_ext.?(self.handle, deferred_operation, info_count, p_infos.ptr)) {
            .success => return .success,
            .operation_deferred_khr => return .operation_deferred_khr,
            .operation_not_deferred_khr => return .operation_not_deferred_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_micromap_ext(
        self: DeviceCommands,
        micromap: MicromapEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_micromap_ext.?(self.handle, micromap, p_allocator);
    }
    pub fn cmd_copy_micromap_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_info: *const CopyMicromapInfoEXT,
    ) void {
        self.fp_cmd_copy_micromap_ext.?(command_buffer, p_info);
    }
    pub const CopyMicromapEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn copy_micromap_ext(
        self: DeviceCommands,
        deferred_operation: DeferredOperationKHR,
        p_info: *const CopyMicromapInfoEXT,
    ) CopyMicromapEXTError!CopyAccelerationStructureKHRResult {
        switch (self.fp_copy_micromap_ext.?(self.handle, deferred_operation, p_info)) {
            .success => return .success,
            .operation_deferred_khr => return .operation_deferred_khr,
            .operation_not_deferred_khr => return .operation_not_deferred_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_copy_micromap_to_memory_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_info: *const CopyMicromapToMemoryInfoEXT,
    ) void {
        self.fp_cmd_copy_micromap_to_memory_ext.?(command_buffer, p_info);
    }
    pub const CopyMicromapToMemoryEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn copy_micromap_to_memory_ext(
        self: DeviceCommands,
        deferred_operation: DeferredOperationKHR,
        p_info: *const CopyMicromapToMemoryInfoEXT,
    ) CopyMicromapToMemoryEXTError!CopyAccelerationStructureKHRResult {
        switch (self.fp_copy_micromap_to_memory_ext.?(self.handle, deferred_operation, p_info)) {
            .success => return .success,
            .operation_deferred_khr => return .operation_deferred_khr,
            .operation_not_deferred_khr => return .operation_not_deferred_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_copy_memory_to_micromap_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_info: *const CopyMemoryToMicromapInfoEXT,
    ) void {
        self.fp_cmd_copy_memory_to_micromap_ext.?(command_buffer, p_info);
    }
    pub const CopyMemoryToMicromapEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn copy_memory_to_micromap_ext(
        self: DeviceCommands,
        deferred_operation: DeferredOperationKHR,
        p_info: *const CopyMemoryToMicromapInfoEXT,
    ) CopyMemoryToMicromapEXTError!CopyAccelerationStructureKHRResult {
        switch (self.fp_copy_memory_to_micromap_ext.?(self.handle, deferred_operation, p_info)) {
            .success => return .success,
            .operation_deferred_khr => return .operation_deferred_khr,
            .operation_not_deferred_khr => return .operation_not_deferred_khr,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_write_micromaps_properties_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_micromaps: []const MicromapEXT,
        query_type: QueryType,
        query_pool: QueryPool,
        first_query: u32,
    ) void {
        const micromap_count: u32 = @intCast(p_micromaps.len);
        self.fp_cmd_write_micromaps_properties_ext.?(command_buffer, micromap_count, p_micromaps.ptr, query_type, query_pool, first_query);
    }
    pub const WriteMicromapsPropertiesEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn write_micromaps_properties_ext(
        self: DeviceCommands,
        p_micromaps: []const MicromapEXT,
        query_type: QueryType,
        p_data: []u8,
        stride: usize,
    ) WriteMicromapsPropertiesEXTError!void {
        const micromap_count: u32 = @intCast(p_micromaps.len);
        const data_size: usize = @intCast(p_data.len);
        switch (self.fp_write_micromaps_properties_ext.?(self.handle, micromap_count, p_micromaps.ptr, query_type, data_size, p_data.ptr, stride)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_device_micromap_compatibility_ext(
        self: DeviceCommands,
        p_version_info: *const MicromapVersionInfoEXT,
    ) AccelerationStructureCompatibilityKHR {
        var p_compatibility: AccelerationStructureCompatibilityKHR = undefined;
        self.fp_get_device_micromap_compatibility_ext.?(self.handle, p_version_info, &p_compatibility);
        return p_compatibility;
    }
    pub fn get_micromap_build_sizes_ext(
        self: DeviceCommands,
        build_type: AccelerationStructureBuildTypeKHR,
        p_build_info: *const MicromapBuildInfoEXT,
        p_size_info: *MicromapBuildSizesInfoEXT,
    ) void {
        self.fp_get_micromap_build_sizes_ext.?(self.handle, build_type, p_build_info, p_size_info);
    }
    pub fn get_shader_module_identifier_ext(
        self: DeviceCommands,
        shader_module: ShaderModule,
        p_identifier: *ShaderModuleIdentifierEXT,
    ) void {
        self.fp_get_shader_module_identifier_ext.?(self.handle, shader_module, p_identifier);
    }
    pub fn get_shader_module_create_info_identifier_ext(
        self: DeviceCommands,
        p_create_info: *const ShaderModuleCreateInfo,
        p_identifier: *ShaderModuleIdentifierEXT,
    ) void {
        self.fp_get_shader_module_create_info_identifier_ext.?(self.handle, p_create_info, p_identifier);
    }
    pub fn get_image_subresource_layout2(
        self: DeviceCommands,
        image: Image,
        p_subresource: *const ImageSubresource2,
        p_layout: *SubresourceLayout2,
    ) void {
        self.fp_get_image_subresource_layout2.?(self.handle, image, p_subresource, p_layout);
    }
    pub const GetPipelinePropertiesEXTError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_pipeline_properties_ext(
        self: DeviceCommands,
        p_pipeline_info: *const PipelineInfoEXT,
    ) GetPipelinePropertiesEXTError!BaseOutStructure {
        var p_pipeline_properties: BaseOutStructure = undefined;
        switch (self.fp_get_pipeline_properties_ext.?(self.handle, p_pipeline_info, &p_pipeline_properties)) {
            .success => return p_pipeline_properties,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn export_metal_objects_ext(
        self: DeviceCommands,
        p_metal_objects_info: *ExportMetalObjectsInfoEXT,
    ) void {
        self.fp_export_metal_objects_ext.?(self.handle, p_metal_objects_info);
    }
    pub fn cmd_bind_tile_memory_qcom(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_tile_memory_bind_info: ?*const TileMemoryBindInfoQCOM,
    ) void {
        self.fp_cmd_bind_tile_memory_qcom.?(command_buffer, p_tile_memory_bind_info);
    }
    pub const GetFramebufferTilePropertiesQCOMError = error{
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_framebuffer_tile_properties_qcom(
        self: DeviceCommands,
        framebuffer: Framebuffer,
        p_properties_count: *u32,
        p_properties: ?[*]TilePropertiesQCOM,
    ) GetFramebufferTilePropertiesQCOMError!EnumerateResult {
        switch (self.fp_get_framebuffer_tile_properties_qcom.?(self.handle, framebuffer, p_properties_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetDynamicRenderingTilePropertiesQCOMError = error{
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_dynamic_rendering_tile_properties_qcom(
        self: DeviceCommands,
        p_rendering_info: *const RenderingInfo,
        p_properties: *TilePropertiesQCOM,
    ) GetDynamicRenderingTilePropertiesQCOMError!void {
        switch (self.fp_get_dynamic_rendering_tile_properties_qcom.?(self.handle, p_rendering_info, p_properties)) {
            .success => return,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceOpticalFlowImageFormatsNVError = error{
        ExtensionNotPresent,
        InitializationFailed,
        FormatNotSupported,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_optical_flow_image_formats_nv(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        p_optical_flow_image_format_info: *const OpticalFlowImageFormatInfoNV,
        p_format_count: *u32,
        p_image_format_properties: ?[*]OpticalFlowImageFormatPropertiesNV,
    ) GetPhysicalDeviceOpticalFlowImageFormatsNVError!EnumerateResult {
        switch (self.fp_get_physical_device_optical_flow_image_formats_nv.?(physical_device, p_optical_flow_image_format_info, p_format_count, p_image_format_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_extension_not_present => return error.ExtensionNotPresent,
            .error_initialization_failed => return error.InitializationFailed,
            .error_format_not_supported => return error.FormatNotSupported,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceOpticalFlowImageFormatsNVOrAllocatorError = GetPhysicalDeviceOpticalFlowImageFormatsNVError || Allocator.Error;
    pub fn get_physical_device_optical_flow_image_formats_nv_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
        p_optical_flow_image_format_info: *const OpticalFlowImageFormatInfoNV,
    ) GetPhysicalDeviceOpticalFlowImageFormatsNVOrAllocatorError![]OpticalFlowImageFormatPropertiesNV {
        const enumerator = struct {
            self: *const DeviceCommands,
            physical_device: PhysicalDevice,
            p_optical_flow_image_format_info: *const OpticalFlowImageFormatInfoNV,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]OpticalFlowImageFormatPropertiesNV) !EnumerateResult {
                return enumerator.self.get_physical_device_optical_flow_image_formats_nv(
                    enumerator.physical_device,
                    enumerator.p_optical_flow_image_format_info,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
            .p_optical_flow_image_format_info = p_optical_flow_image_format_info,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceOpticalFlowImageFormatsNVOrAllocatorError, OpticalFlowImageFormatPropertiesNV, enumerator, allocator);
    }
    pub const CreateOpticalFlowSessionNVError = error{
        OutOfHostMemory,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_optical_flow_session_nv(
        self: DeviceCommands,
        p_create_info: *const OpticalFlowSessionCreateInfoNV,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateOpticalFlowSessionNVError!OpticalFlowSessionNV {
        var p_session: OpticalFlowSessionNV = undefined;
        switch (self.fp_create_optical_flow_session_nv.?(self.handle, p_create_info, p_allocator, &p_session)) {
            .success => return p_session,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_optical_flow_session_nv(
        self: DeviceCommands,
        session: OpticalFlowSessionNV,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_optical_flow_session_nv.?(self.handle, session, p_allocator);
    }
    pub const BindOpticalFlowSessionImageNVError = error{
        OutOfHostMemory,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn bind_optical_flow_session_image_nv(
        self: DeviceCommands,
        session: OpticalFlowSessionNV,
        binding_point: OpticalFlowSessionBindingPointNV,
        view: ImageView,
        layout: ImageLayout,
    ) BindOpticalFlowSessionImageNVError!void {
        switch (self.fp_bind_optical_flow_session_image_nv.?(self.handle, session, binding_point, view, layout)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_optical_flow_execute_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        session: OpticalFlowSessionNV,
        p_execute_info: *const OpticalFlowExecuteInfoNV,
    ) void {
        self.fp_cmd_optical_flow_execute_nv.?(command_buffer, session, p_execute_info);
    }
    pub const GetDeviceFaultInfoEXTError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_device_fault_info_ext(
        self: DeviceCommands,
        p_fault_counts: *DeviceFaultCountsEXT,
        p_fault_info: ?*DeviceFaultInfoEXT,
    ) GetDeviceFaultInfoEXTError!EnumerateResult {
        switch (self.fp_get_device_fault_info_ext.?(self.handle, p_fault_counts, p_fault_info)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_set_depth_bias2_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_depth_bias_info: *const DepthBiasInfoEXT,
    ) void {
        self.fp_cmd_set_depth_bias2_ext.?(command_buffer, p_depth_bias_info);
    }
    pub const ReleaseSwapchainImagesKHRError = error{
        SurfaceLostKhr,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn release_swapchain_images_khr(
        self: DeviceCommands,
        p_release_info: *const ReleaseSwapchainImagesInfoKHR,
    ) ReleaseSwapchainImagesKHRError!void {
        switch (self.fp_release_swapchain_images_khr.?(self.handle, p_release_info)) {
            .success => return,
            .error_surface_lost_khr => return error.SurfaceLostKhr,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_device_image_subresource_layout(
        self: DeviceCommands,
        p_info: *const DeviceImageSubresourceInfo,
        p_layout: *SubresourceLayout2,
    ) void {
        self.fp_get_device_image_subresource_layout.?(self.handle, p_info, p_layout);
    }
    pub const MapMemory2Error = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        MemoryMapFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn map_memory2(
        self: DeviceCommands,
        p_memory_map_info: *const MemoryMapInfo,
    ) MapMemory2Error!?*anyopaque {
        var pp_data: ?*anyopaque = undefined;
        switch (self.fp_map_memory2.?(self.handle, p_memory_map_info, &pp_data)) {
            .success => return pp_data,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_memory_map_failed => return error.MemoryMapFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const UnmapMemory2Error = error{
        MemoryMapFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn unmap_memory2(
        self: DeviceCommands,
        p_memory_unmap_info: *const MemoryUnmapInfo,
    ) UnmapMemory2Error!void {
        switch (self.fp_unmap_memory2.?(self.handle, p_memory_unmap_info)) {
            .success => return,
            .error_memory_map_failed => return error.MemoryMapFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateShadersEXTResult = enum {
        success,
        incompatible_shader_binary_ext,
    };
    pub const CreateShadersEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_shaders_ext(
        self: DeviceCommands,
        p_create_infos: []const ShaderCreateInfoEXT,
        p_allocator: ?*const AllocationCallbacks,
        p_shaders: []ShaderEXT,
    ) CreateShadersEXTError!CreateShadersEXTResult {
        const create_info_count: u32 = @intCast(p_create_infos.len);
        assert(create_info_count == p_shaders.len);
        switch (self.fp_create_shaders_ext.?(self.handle, create_info_count, p_create_infos.ptr, p_allocator, p_shaders.ptr)) {
            .success => return .success,
            .incompatible_shader_binary_ext => return .incompatible_shader_binary_ext,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_shader_ext(
        self: DeviceCommands,
        shader: ShaderEXT,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_shader_ext.?(self.handle, shader, p_allocator);
    }
    pub const GetShaderBinaryDataEXTError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_shader_binary_data_ext(
        self: DeviceCommands,
        shader: ShaderEXT,
        p_data_size: *usize,
        p_data: ?*anyopaque,
    ) GetShaderBinaryDataEXTError!EnumerateResult {
        switch (self.fp_get_shader_binary_data_ext.?(self.handle, shader, p_data_size, p_data)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_bind_shaders_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_stages: []const ShaderStageFlags,
        p_shaders: ?[]const ShaderEXT,
    ) void {
        const stage_count: u32 = @intCast(p_stages.len);
        if (p_shaders) |s| {
            assert(stage_count == s.len);
        }
        self.fp_cmd_bind_shaders_ext.?(command_buffer, stage_count, p_stages.ptr, if (p_shaders) |slice| slice.ptr orelse null);
    }
    pub const GetPhysicalDeviceCooperativeMatrixPropertiesKHRError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_cooperative_matrix_properties_khr(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        p_property_count: *u32,
        p_properties: ?[*]CooperativeMatrixPropertiesKHR,
    ) GetPhysicalDeviceCooperativeMatrixPropertiesKHRError!EnumerateResult {
        switch (self.fp_get_physical_device_cooperative_matrix_properties_khr.?(physical_device, p_property_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceCooperativeMatrixPropertiesKHROrAllocatorError = GetPhysicalDeviceCooperativeMatrixPropertiesKHRError || Allocator.Error;
    pub fn get_physical_device_cooperative_matrix_properties_khr_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
    ) GetPhysicalDeviceCooperativeMatrixPropertiesKHROrAllocatorError![]CooperativeMatrixPropertiesKHR {
        const enumerator = struct {
            self: *const DeviceCommands,
            physical_device: PhysicalDevice,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]CooperativeMatrixPropertiesKHR) !EnumerateResult {
                return enumerator.self.get_physical_device_cooperative_matrix_properties_khr(
                    enumerator.physical_device,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceCooperativeMatrixPropertiesKHROrAllocatorError, CooperativeMatrixPropertiesKHR, enumerator, allocator);
    }
    pub const GetExecutionGraphPipelineScratchSizeAMDXError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_execution_graph_pipeline_scratch_size_amdx(
        self: DeviceCommands,
        execution_graph: Pipeline,
        p_size_info: *ExecutionGraphPipelineScratchSizeAMDX,
    ) GetExecutionGraphPipelineScratchSizeAMDXError!void {
        switch (self.fp_get_execution_graph_pipeline_scratch_size_amdx.?(self.handle, execution_graph, p_size_info)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetExecutionGraphPipelineNodeIndexAMDXError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_execution_graph_pipeline_node_index_amdx(
        self: DeviceCommands,
        execution_graph: Pipeline,
        p_node_info: *const PipelineShaderStageNodeCreateInfoAMDX,
    ) GetExecutionGraphPipelineNodeIndexAMDXError!u32 {
        var p_node_index: u32 = undefined;
        switch (self.fp_get_execution_graph_pipeline_node_index_amdx.?(self.handle, execution_graph, p_node_info, &p_node_index)) {
            .success => return p_node_index,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateExecutionGraphPipelinesAMDXError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_execution_graph_pipelines_amdx(
        self: DeviceCommands,
        pipeline_cache: PipelineCache,
        p_create_infos: []const ExecutionGraphPipelineCreateInfoAMDX,
        p_allocator: ?*const AllocationCallbacks,
        p_pipelines: []Pipeline,
    ) CreateExecutionGraphPipelinesAMDXError!CreateGraphicsPipelinesResult {
        const create_info_count: u32 = @intCast(p_create_infos.len);
        assert(create_info_count == p_pipelines.len);
        switch (self.fp_create_execution_graph_pipelines_amdx.?(self.handle, pipeline_cache, create_info_count, p_create_infos.ptr, p_allocator, p_pipelines.ptr)) {
            .success => return .success,
            .pipeline_compile_required => return .pipeline_compile_required,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_initialize_graph_scratch_memory_amdx(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        execution_graph: Pipeline,
        scratch: DeviceAddress,
        scratch_size: DeviceSize,
    ) void {
        self.fp_cmd_initialize_graph_scratch_memory_amdx.?(command_buffer, execution_graph, scratch, scratch_size);
    }
    pub fn cmd_dispatch_graph_amdx(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        scratch: DeviceAddress,
        scratch_size: DeviceSize,
        p_count_info: *const DispatchGraphCountInfoAMDX,
    ) void {
        self.fp_cmd_dispatch_graph_amdx.?(command_buffer, scratch, scratch_size, p_count_info);
    }
    pub fn cmd_dispatch_graph_indirect_amdx(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        scratch: DeviceAddress,
        scratch_size: DeviceSize,
        p_count_info: *const DispatchGraphCountInfoAMDX,
    ) void {
        self.fp_cmd_dispatch_graph_indirect_amdx.?(command_buffer, scratch, scratch_size, p_count_info);
    }
    pub fn cmd_dispatch_graph_indirect_count_amdx(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        scratch: DeviceAddress,
        scratch_size: DeviceSize,
        count_info: DeviceAddress,
    ) void {
        self.fp_cmd_dispatch_graph_indirect_count_amdx.?(command_buffer, scratch, scratch_size, count_info);
    }
    pub fn cmd_bind_descriptor_sets2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_bind_descriptor_sets_info: *const BindDescriptorSetsInfo,
    ) void {
        self.fp_cmd_bind_descriptor_sets2.?(command_buffer, p_bind_descriptor_sets_info);
    }
    pub fn cmd_push_constants2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_push_constants_info: *const PushConstantsInfo,
    ) void {
        self.fp_cmd_push_constants2.?(command_buffer, p_push_constants_info);
    }
    pub fn cmd_push_descriptor_set2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_push_descriptor_set_info: *const PushDescriptorSetInfo,
    ) void {
        self.fp_cmd_push_descriptor_set2.?(command_buffer, p_push_descriptor_set_info);
    }
    pub fn cmd_push_descriptor_set_with_template2(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_push_descriptor_set_with_template_info: *const PushDescriptorSetWithTemplateInfo,
    ) void {
        self.fp_cmd_push_descriptor_set_with_template2.?(command_buffer, p_push_descriptor_set_with_template_info);
    }
    pub fn cmd_set_descriptor_buffer_offsets2_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_set_descriptor_buffer_offsets_info: *const SetDescriptorBufferOffsetsInfoEXT,
    ) void {
        self.fp_cmd_set_descriptor_buffer_offsets2_ext.?(command_buffer, p_set_descriptor_buffer_offsets_info);
    }
    pub fn cmd_bind_descriptor_buffer_embedded_samplers2_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_bind_descriptor_buffer_embedded_samplers_info: *const BindDescriptorBufferEmbeddedSamplersInfoEXT,
    ) void {
        self.fp_cmd_bind_descriptor_buffer_embedded_samplers2_ext.?(command_buffer, p_bind_descriptor_buffer_embedded_samplers_info);
    }
    pub const SetLatencySleepModeNVError = error{
        InitializationFailed,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn set_latency_sleep_mode_nv(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
        p_sleep_mode_info: *const LatencySleepModeInfoNV,
    ) SetLatencySleepModeNVError!void {
        switch (self.fp_set_latency_sleep_mode_nv.?(self.handle, swapchain, p_sleep_mode_info)) {
            .success => return,
            .error_initialization_failed => return error.InitializationFailed,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const LatencySleepNVError = error{
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn latency_sleep_nv(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
        p_sleep_info: *const LatencySleepInfoNV,
    ) LatencySleepNVError!void {
        switch (self.fp_latency_sleep_nv.?(self.handle, swapchain, p_sleep_info)) {
            .success => return,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn set_latency_marker_nv(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
        p_latency_marker_info: *const SetLatencyMarkerInfoNV,
    ) void {
        self.fp_set_latency_marker_nv.?(self.handle, swapchain, p_latency_marker_info);
    }
    pub fn get_latency_timings_nv(
        self: DeviceCommands,
        swapchain: SwapchainKHR,
        p_latency_marker_info: *GetLatencyMarkerInfoNV,
    ) void {
        self.fp_get_latency_timings_nv.?(self.handle, swapchain, p_latency_marker_info);
    }
    pub fn queue_notify_out_of_band_nv(
        self: DeviceCommands,
        queue: Queue,
        p_queue_type_info: *const OutOfBandQueueTypeInfoNV,
    ) void {
        self.fp_queue_notify_out_of_band_nv.?(queue, p_queue_type_info);
    }
    pub fn cmd_set_rendering_attachment_locations(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_location_info: *const RenderingAttachmentLocationInfo,
    ) void {
        self.fp_cmd_set_rendering_attachment_locations.?(command_buffer, p_location_info);
    }
    pub fn cmd_set_rendering_input_attachment_indices(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_input_attachment_index_info: *const RenderingInputAttachmentIndexInfo,
    ) void {
        self.fp_cmd_set_rendering_input_attachment_indices.?(command_buffer, p_input_attachment_index_info);
    }
    pub fn cmd_set_depth_clamp_range_ext(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        depth_clamp_mode: DepthClampModeEXT,
        p_depth_clamp_range: ?*const DepthClampRangeEXT,
    ) void {
        self.fp_cmd_set_depth_clamp_range_ext.?(command_buffer, depth_clamp_mode, p_depth_clamp_range);
    }
    pub const GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNVError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        p_property_count: *u32,
        p_properties: ?[*]CooperativeMatrixFlexibleDimensionsPropertiesNV,
    ) GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNVError!EnumerateResult {
        switch (self.fp_get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv.?(physical_device, p_property_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNVOrAllocatorError = GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNVError || Allocator.Error;
    pub fn get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        physical_device: PhysicalDevice,
    ) GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNVOrAllocatorError![]CooperativeMatrixFlexibleDimensionsPropertiesNV {
        const enumerator = struct {
            self: *const DeviceCommands,
            physical_device: PhysicalDevice,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]CooperativeMatrixFlexibleDimensionsPropertiesNV) !EnumerateResult {
                return enumerator.self.get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv(
                    enumerator.physical_device,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .physical_device = physical_device,
        };
        return enumerate_generic_to_array(GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNVOrAllocatorError, CooperativeMatrixFlexibleDimensionsPropertiesNV, enumerator, allocator);
    }
    pub const GetMemoryMetalHandleEXTError = error{
        TooManyObjects,
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_memory_metal_handle_ext(
        self: DeviceCommands,
        p_get_metal_handle_info: *const MemoryGetMetalHandleInfoEXT,
    ) GetMemoryMetalHandleEXTError!?*anyopaque {
        var p_handle: ?*anyopaque = undefined;
        switch (self.fp_get_memory_metal_handle_ext.?(self.handle, p_get_metal_handle_info, &p_handle)) {
            .success => return p_handle,
            .error_too_many_objects => return error.TooManyObjects,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetMemoryMetalHandlePropertiesEXTError = error{
        OutOfHostMemory,
        InvalidExternalHandle,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_memory_metal_handle_properties_ext(
        self: DeviceCommands,
        handle_type: ExternalMemoryHandleTypeFlags,
        p_handle: *const anyopaque,
        p_memory_metal_handle_properties: *MemoryMetalHandlePropertiesEXT,
    ) GetMemoryMetalHandlePropertiesEXTError!void {
        switch (self.fp_get_memory_metal_handle_properties_ext.?(self.handle, handle_type, p_handle, p_memory_metal_handle_properties)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_invalid_external_handle => return error.InvalidExternalHandle,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceCooperativeVectorPropertiesNVError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_cooperative_vector_properties_nv(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        p_property_count: *u32,
        p_properties: ?[*]CooperativeVectorPropertiesNV,
    ) GetPhysicalDeviceCooperativeVectorPropertiesNVError!EnumerateResult {
        switch (self.fp_get_physical_device_cooperative_vector_properties_nv.?(physical_device, p_property_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const ConvertCooperativeVectorMatrixNVError = error{
        OutOfHostMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn convert_cooperative_vector_matrix_nv(
        self: DeviceCommands,
        p_info: *const ConvertCooperativeVectorMatrixInfoNV,
    ) ConvertCooperativeVectorMatrixNVError!EnumerateResult {
        switch (self.fp_convert_cooperative_vector_matrix_nv.?(self.handle, p_info)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn cmd_convert_cooperative_vector_matrix_nv(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_infos: []const ConvertCooperativeVectorMatrixInfoNV,
    ) void {
        const info_count: u32 = @intCast(p_infos.len);
        self.fp_cmd_convert_cooperative_vector_matrix_nv.?(command_buffer, info_count, p_infos.ptr);
    }
    pub fn cmd_dispatch_tile_qcom(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_dispatch_tile_info: *const DispatchTileInfoQCOM,
    ) void {
        self.fp_cmd_dispatch_tile_qcom.?(command_buffer, p_dispatch_tile_info);
    }
    pub fn cmd_begin_per_tile_execution_qcom(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_per_tile_begin_info: *const PerTileBeginInfoQCOM,
    ) void {
        self.fp_cmd_begin_per_tile_execution_qcom.?(command_buffer, p_per_tile_begin_info);
    }
    pub fn cmd_end_per_tile_execution_qcom(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_per_tile_end_info: *const PerTileEndInfoQCOM,
    ) void {
        self.fp_cmd_end_per_tile_execution_qcom.?(command_buffer, p_per_tile_end_info);
    }
    pub const CreateExternalComputeQueueNVError = error{
        OutOfHostMemory,
        TooManyObjects,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_external_compute_queue_nv(
        self: DeviceCommands,
        p_create_info: *const ExternalComputeQueueCreateInfoNV,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateExternalComputeQueueNVError!ExternalComputeQueueNV {
        var p_external_queue: ExternalComputeQueueNV = undefined;
        switch (self.fp_create_external_compute_queue_nv.?(self.handle, p_create_info, p_allocator, &p_external_queue)) {
            .success => return p_external_queue,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_too_many_objects => return error.TooManyObjects,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_external_compute_queue_nv(
        self: DeviceCommands,
        external_queue: ExternalComputeQueueNV,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_external_compute_queue_nv.?(self.handle, external_queue, p_allocator);
    }
    pub fn get_external_compute_queue_data_nv(
        self: DeviceCommands,
        external_queue: ExternalComputeQueueNV,
        params: *ExternalComputeQueueDataParamsNV,
        p_data: *anyopaque,
    ) void {
        self.fp_get_external_compute_queue_data_nv.?(external_queue, params, p_data);
    }
    pub const CreateTensorARMError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_tensor_arm(
        self: DeviceCommands,
        p_create_info: *const TensorCreateInfoARM,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateTensorARMError!TensorARM {
        var p_tensor: TensorARM = undefined;
        switch (self.fp_create_tensor_arm.?(self.handle, p_create_info, p_allocator, &p_tensor)) {
            .success => return p_tensor,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_tensor_arm(
        self: DeviceCommands,
        tensor: TensorARM,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_tensor_arm.?(self.handle, tensor, p_allocator);
    }
    pub const CreateTensorViewARMError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_tensor_view_arm(
        self: DeviceCommands,
        p_create_info: *const TensorViewCreateInfoARM,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateTensorViewARMError!TensorViewARM {
        var p_view: TensorViewARM = undefined;
        switch (self.fp_create_tensor_view_arm.?(self.handle, p_create_info, p_allocator, &p_view)) {
            .success => return p_view,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_tensor_view_arm(
        self: DeviceCommands,
        tensor_view: TensorViewARM,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_tensor_view_arm.?(self.handle, tensor_view, p_allocator);
    }
    pub fn get_tensor_memory_requirements_arm(
        self: DeviceCommands,
        p_info: *const TensorMemoryRequirementsInfoARM,
        p_memory_requirements: *MemoryRequirements2,
    ) void {
        self.fp_get_tensor_memory_requirements_arm.?(self.handle, p_info, p_memory_requirements);
    }
    pub const BindTensorMemoryARMError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn bind_tensor_memory_arm(
        self: DeviceCommands,
        p_bind_infos: []const BindTensorMemoryInfoARM,
    ) BindTensorMemoryARMError!void {
        const bind_info_count: u32 = @intCast(p_bind_infos.len);
        switch (self.fp_bind_tensor_memory_arm.?(self.handle, bind_info_count, p_bind_infos.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_device_tensor_memory_requirements_arm(
        self: DeviceCommands,
        p_info: *const DeviceTensorMemoryRequirementsARM,
        p_memory_requirements: *MemoryRequirements2,
    ) void {
        self.fp_get_device_tensor_memory_requirements_arm.?(self.handle, p_info, p_memory_requirements);
    }
    pub fn cmd_copy_tensor_arm(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        p_copy_tensor_info: *const CopyTensorInfoARM,
    ) void {
        self.fp_cmd_copy_tensor_arm.?(command_buffer, p_copy_tensor_info);
    }
    pub const GetTensorOpaqueCaptureDescriptorDataARMError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_tensor_opaque_capture_descriptor_data_arm(
        self: DeviceCommands,
        p_info: *const TensorCaptureDescriptorDataInfoARM,
        p_data: *anyopaque,
    ) GetTensorOpaqueCaptureDescriptorDataARMError!void {
        switch (self.fp_get_tensor_opaque_capture_descriptor_data_arm.?(self.handle, p_info, p_data)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetTensorViewOpaqueCaptureDescriptorDataARMError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_tensor_view_opaque_capture_descriptor_data_arm(
        self: DeviceCommands,
        p_info: *const TensorViewCaptureDescriptorDataInfoARM,
        p_data: *anyopaque,
    ) GetTensorViewOpaqueCaptureDescriptorDataARMError!void {
        switch (self.fp_get_tensor_view_opaque_capture_descriptor_data_arm.?(self.handle, p_info, p_data)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_physical_device_external_tensor_properties_arm(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        p_external_tensor_info: *const PhysicalDeviceExternalTensorInfoARM,
        p_external_tensor_properties: *ExternalTensorPropertiesARM,
    ) void {
        self.fp_get_physical_device_external_tensor_properties_arm.?(physical_device, p_external_tensor_info, p_external_tensor_properties);
    }
    pub const CreateDataGraphPipelinesARMError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_data_graph_pipelines_arm(
        self: DeviceCommands,
        deferred_operation: DeferredOperationKHR,
        pipeline_cache: PipelineCache,
        p_create_infos: []const DataGraphPipelineCreateInfoARM,
        p_allocator: ?*const AllocationCallbacks,
        p_pipelines: []Pipeline,
    ) CreateDataGraphPipelinesARMError!CreateGraphicsPipelinesResult {
        const create_info_count: u32 = @intCast(p_create_infos.len);
        assert(create_info_count == p_pipelines.len);
        switch (self.fp_create_data_graph_pipelines_arm.?(self.handle, deferred_operation, pipeline_cache, create_info_count, p_create_infos.ptr, p_allocator, p_pipelines.ptr)) {
            .success => return .success,
            .pipeline_compile_required => return .pipeline_compile_required,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const CreateDataGraphPipelineSessionARMError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn create_data_graph_pipeline_session_arm(
        self: DeviceCommands,
        p_create_info: *const DataGraphPipelineSessionCreateInfoARM,
        p_allocator: ?*const AllocationCallbacks,
    ) CreateDataGraphPipelineSessionARMError!DataGraphPipelineSessionARM {
        var p_session: DataGraphPipelineSessionARM = undefined;
        switch (self.fp_create_data_graph_pipeline_session_arm.?(self.handle, p_create_info, p_allocator, &p_session)) {
            .success => return p_session,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetDataGraphPipelineSessionBindPointRequirementsARMError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_data_graph_pipeline_session_bind_point_requirements_arm(
        self: DeviceCommands,
        p_info: *const DataGraphPipelineSessionBindPointRequirementsInfoARM,
        p_bind_point_requirement_count: *u32,
        p_bind_point_requirements: ?[*]DataGraphPipelineSessionBindPointRequirementARM,
    ) GetDataGraphPipelineSessionBindPointRequirementsARMError!EnumerateResult {
        switch (self.fp_get_data_graph_pipeline_session_bind_point_requirements_arm.?(self.handle, p_info, p_bind_point_requirement_count, p_bind_point_requirements)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_data_graph_pipeline_session_memory_requirements_arm(
        self: DeviceCommands,
        p_info: *const DataGraphPipelineSessionMemoryRequirementsInfoARM,
        p_memory_requirements: *MemoryRequirements2,
    ) void {
        self.fp_get_data_graph_pipeline_session_memory_requirements_arm.?(self.handle, p_info, p_memory_requirements);
    }
    pub const BindDataGraphPipelineSessionMemoryARMError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn bind_data_graph_pipeline_session_memory_arm(
        self: DeviceCommands,
        p_bind_infos: []const BindDataGraphPipelineSessionMemoryInfoARM,
    ) BindDataGraphPipelineSessionMemoryARMError!void {
        const bind_info_count: u32 = @intCast(p_bind_infos.len);
        switch (self.fp_bind_data_graph_pipeline_session_memory_arm.?(self.handle, bind_info_count, p_bind_infos.ptr)) {
            .success => return,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn destroy_data_graph_pipeline_session_arm(
        self: DeviceCommands,
        session: DataGraphPipelineSessionARM,
        p_allocator: ?*const AllocationCallbacks,
    ) void {
        self.fp_destroy_data_graph_pipeline_session_arm.?(self.handle, session, p_allocator);
    }
    pub fn cmd_dispatch_data_graph_arm(
        self: DeviceCommands,
        command_buffer: CommandBuffer,
        session: DataGraphPipelineSessionARM,
        p_info: ?*const DataGraphPipelineDispatchInfoARM,
    ) void {
        self.fp_cmd_dispatch_data_graph_arm.?(command_buffer, session, p_info);
    }
    pub const GetDataGraphPipelineAvailablePropertiesARMError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_data_graph_pipeline_available_properties_arm(
        self: DeviceCommands,
        p_pipeline_info: *const DataGraphPipelineInfoARM,
        p_properties_count: *u32,
        p_properties: ?[*]DataGraphPipelinePropertyARM,
    ) GetDataGraphPipelineAvailablePropertiesARMError!EnumerateResult {
        switch (self.fp_get_data_graph_pipeline_available_properties_arm.?(self.handle, p_pipeline_info, p_properties_count, p_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetDataGraphPipelineAvailablePropertiesARMOrAllocatorError = GetDataGraphPipelineAvailablePropertiesARMError || Allocator.Error;
    pub fn get_data_graph_pipeline_available_properties_arm_to_array(
        self: DeviceCommands,
        allocator: Allocator,
        p_pipeline_info: *const DataGraphPipelineInfoARM,
    ) GetDataGraphPipelineAvailablePropertiesARMOrAllocatorError![]DataGraphPipelinePropertyARM {
        const enumerator = struct {
            self: *const DeviceCommands,
            p_pipeline_info: *const DataGraphPipelineInfoARM,
            pub fn enumerate(enumerator: @This(), len: *u32, elements: ?[*]DataGraphPipelinePropertyARM) !EnumerateResult {
                return enumerator.self.get_data_graph_pipeline_available_properties_arm(
                    enumerator.p_pipeline_info,
                    len,
                    elements,
                );
            }
        }{
            .self = &self,
            .p_pipeline_info = p_pipeline_info,
        };
        return enumerate_generic_to_array(GetDataGraphPipelineAvailablePropertiesARMOrAllocatorError, DataGraphPipelinePropertyARM, enumerator, allocator);
    }
    pub const GetDataGraphPipelinePropertiesARMError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_data_graph_pipeline_properties_arm(
        self: DeviceCommands,
        p_pipeline_info: *const DataGraphPipelineInfoARM,
        p_properties: []DataGraphPipelinePropertyQueryResultARM,
    ) GetDataGraphPipelinePropertiesARMError!EnumerateResult {
        const properties_count: u32 = @intCast(p_properties.len);
        switch (self.fp_get_data_graph_pipeline_properties_arm.?(self.handle, p_pipeline_info, properties_count, p_properties.ptr)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub const GetPhysicalDeviceQueueFamilyDataGraphPropertiesARMError = error{
        OutOfHostMemory,
        OutOfDeviceMemory,
        Unknown,
        ValidationFailed,
        Unexpected,
    };
    pub fn get_physical_device_queue_family_data_graph_properties_arm(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
        p_queue_family_data_graph_property_count: *u32,
        p_queue_family_data_graph_properties: ?[*]QueueFamilyDataGraphPropertiesARM,
    ) GetPhysicalDeviceQueueFamilyDataGraphPropertiesARMError!EnumerateResult {
        switch (self.fp_get_physical_device_queue_family_data_graph_properties_arm.?(physical_device, queue_family_index, p_queue_family_data_graph_property_count, p_queue_family_data_graph_properties)) {
            .success => return .success,
            .incomplete => return .incomplete,
            .error_out_of_host_memory => return error.OutOfHostMemory,
            .error_out_of_device_memory => return error.OutOfDeviceMemory,
            .error_unknown => return error.Unknown,
            .error_validation_failed => return error.ValidationFailed,
            else => return error.Unexpected,
        }
    }
    pub fn get_physical_device_queue_family_data_graph_processing_engine_properties_arm(
        self: DeviceCommands,
        physical_device: PhysicalDevice,
        p_queue_family_data_graph_processing_engine_info: *const PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM,
        p_queue_family_data_graph_processing_engine_properties: *QueueFamilyDataGraphProcessingEnginePropertiesARM,
    ) void {
        self.fp_get_physical_device_queue_family_data_graph_processing_engine_properties_arm.?(physical_device, p_queue_family_data_graph_processing_engine_info, p_queue_family_data_graph_processing_engine_properties);
    }
};

const std = @import("std");

const assert = std.debug.assert;
const Allocator = std.mem.Allocator;
